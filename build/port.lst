ARM GAS  /tmp/ccsuQooq.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 6
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"port.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c"
  25              		.section	.data.ulCriticalNesting,"aw"
  26              		.align	2
  29              	ulCriticalNesting:
  30 0000 AAAAAAAA 		.word	-1431655766
  31              		.section	.bss.ucMaxSysCallPriority,"aw",%nobits
  34              	ucMaxSysCallPriority:
  35 0000 00       		.space	1
  36              		.section	.bss.ulMaxPRIGROUPValue,"aw",%nobits
  37              		.align	2
  40              	ulMaxPRIGROUPValue:
  41 0000 00000000 		.space	4
  42              		.section	.rodata.pcInterruptPriorityRegisters,"a"
  43              		.align	2
  46              	pcInterruptPriorityRegisters:
  47 0000 F0E300E0 		.word	-536812560
  48              		.section	.text.vPortSetupTimerInterrupt,"ax",%progbits
  49              		.align	1
  50              		.weak	vPortSetupTimerInterrupt
  51              		.syntax unified
  52              		.thumb
  53              		.thumb_func
  55              	vPortSetupTimerInterrupt:
  56              	.LFB0:
   1:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*
   2:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FreeRTOS Kernel V10.6.2
   3:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
   5:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * SPDX-License-Identifier: MIT
   6:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
   7:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * the Software without restriction, including without limitation the rights to
  10:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
ARM GAS  /tmp/ccsuQooq.s 			page 2


  11:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * subject to the following conditions:
  13:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  14:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The above copyright notice and this permission notice shall be included in all
  15:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * copies or substantial portions of the Software.
  16:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  17:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  24:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * https://www.FreeRTOS.org
  25:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * https://github.com/FreeRTOS
  26:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  27:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  28:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  29:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  30:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * all the API functions to use the MPU wrappers. That should only be done when
  31:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * task.h is included from an application file. */
  32:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  33:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  34:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Scheduler includes. */
  35:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "FreeRTOS.h"
  36:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "task.h"
  37:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  38:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* MPU includes. */
  39:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "mpu_wrappers.h"
  40:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "mpu_syscall_numbers.h"
  41:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  42:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Portasm includes. */
  43:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #include "portasm.h"
  44:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  45:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_TRUSTZONE == 1 )
  46:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Secure components includes. */
  47:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #include "secure_context.h"
  48:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #include "secure_init.h"
  49:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_TRUSTZONE */
  50:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  51:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  52:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  53:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  54:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The FreeRTOS Cortex M33 port can be configured to run on the Secure Side only
  55:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * i.e. the processor boots as secure and never jumps to the non-secure side.
  56:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The Trust Zone support in the port must be disabled in order to run FreeRTOS
  57:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * on the secure side. The following are the valid configuration seetings:
  58:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  59:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1. Run FreeRTOS on the Secure Side:
  60:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 1 and configENABLE_TRUSTZONE = 0
  61:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  62:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 2. Run FreeRTOS on the Non-Secure Side with Secure Side function call support:
  63:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 1
  64:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
  65:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 3. Run FreeRTOS on the Non-Secure Side only i.e. no Secure Side function call support:
  66:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *    configRUN_FREERTOS_SECURE_ONLY = 0 and configENABLE_TRUSTZONE = 0
  67:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
ARM GAS  /tmp/ccsuQooq.s 			page 3


  68:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configRUN_FREERTOS_SECURE_ONLY == 1 ) && ( configENABLE_TRUSTZONE == 1 ) )
  69:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #error TrustZone needs to be disabled in order to run FreeRTOS on the Secure Side.
  70:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
  71:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  72:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  73:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  74:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the NVIC.
  75:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  76:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CTRL_REG             ( *( ( volatile uint32_t * ) 0xe000e010 ) )
  77:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_LOAD_REG             ( *( ( volatile uint32_t * ) 0xe000e014 ) )
  78:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CURRENT_VALUE_REG    ( *( ( volatile uint32_t * ) 0xe000e018 ) )
  79:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SHPR3_REG                    ( *( ( volatile uint32_t * ) 0xe000ed20 ) )
  80:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_ENABLE_BIT           ( 1UL << 0UL )
  81:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_INT_BIT              ( 1UL << 1UL )
  82:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_CLK_BIT              ( 1UL << 2UL )
  83:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_COUNT_FLAG_BIT       ( 1UL << 16UL )
  84:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PEND_SYSTICK_CLEAR_BIT       ( 1UL << 25UL )
  85:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PEND_SYSTICK_SET_BIT         ( 1UL << 26UL )
  86:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMIN_INTERRUPT_PRIORITY            ( 255UL )
  87:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_PENDSV_PRI                   ( portMIN_INTERRUPT_PRIORITY << 16UL )
  88:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SYSTICK_PRI                  ( portMIN_INTERRUPT_PRIORITY << 24UL )
  89:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  90:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  91:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  92:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the SCB.
  93:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
  94:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portSCB_SYS_HANDLER_CTRL_STATE_REG    ( *( volatile uint32_t * ) 0xe000ed24 )
  95:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portSCB_MEM_FAULT_ENABLE_BIT          ( 1UL << 16UL )
  96:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
  97:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
  98:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
  99:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to check the validity of an interrupt priority.
 100:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_SHPR2_REG                 ( *( ( volatile uint32_t * ) 0xE000ED1C ) )
 102:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFIRST_USER_INTERRUPT_NUMBER    ( 16 )
 103:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNVIC_IP_REGISTERS_OFFSET_16    ( 0xE000E3F0 )
 104:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portAIRCR_REG                      ( *( ( volatile uint32_t * ) 0xE000ED0C ) )
 105:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portTOP_BIT_OF_BYTE                ( ( uint8_t ) 0x80 )
 106:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMAX_PRIGROUP_BITS              ( ( uint8_t ) 7 )
 107:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRIORITY_GROUP_MASK            ( 0x07UL << 8UL )
 108:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRIGROUP_SHIFT                 ( 8UL )
 109:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 110:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 111:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 112:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants used during system call enter and exit.
 113:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 114:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPSR_STACK_PADDING_MASK                ( 1UL << 9UL )
 115:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXC_RETURN_STACK_FRAME_TYPE_MASK      ( 1UL << 4UL )
 116:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 117:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 118:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 119:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the FPU.
 120:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 121:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR               ( ( volatile uint32_t * ) 0xe000ed88 )              /* Coprocessor 
 122:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP10_VALUE    ( 3UL )
 123:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP11_VALUE    portCPACR_CP10_VALUE
 124:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP10_POS      ( 20UL )
ARM GAS  /tmp/ccsuQooq.s 			page 4


 125:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCPACR_CP11_POS      ( 22UL )
 126:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 127:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR               ( ( volatile uint32_t * ) 0xe000ef34 )              /* Floating Poi
 128:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_ASPEN_POS     ( 31UL )
 129:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_ASPEN_MASK    ( 1UL << portFPCCR_ASPEN_POS )
 130:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_LSPEN_POS     ( 30UL )
 131:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portFPCCR_LSPEN_MASK    ( 1UL << portFPCCR_LSPEN_POS )
 132:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 133:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 134:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 135:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Offsets in the stack to the parameters when inside the SVC handler.
 136:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 137:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_LR                    ( 5 )
 138:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_PC                    ( 6 )
 139:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portOFFSET_TO_PSR                   ( 7 )
 140:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 141:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 142:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 143:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to manipulate the MPU.
 144:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 145:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_TYPE_REG                      ( *( ( volatile uint32_t * ) 0xe000ed90 ) )
 146:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_CTRL_REG                      ( *( ( volatile uint32_t * ) 0xe000ed94 ) )
 147:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RNR_REG                       ( *( ( volatile uint32_t * ) 0xe000ed98 ) )
 148:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 149:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_REG                      ( *( ( volatile uint32_t * ) 0xe000ed9c ) )
 150:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_REG                      ( *( ( volatile uint32_t * ) 0xe000eda0 ) )
 151:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 152:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A1_REG                   ( *( ( volatile uint32_t * ) 0xe000eda4 ) )
 153:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A1_REG                   ( *( ( volatile uint32_t * ) 0xe000eda8 ) )
 154:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 155:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A2_REG                   ( *( ( volatile uint32_t * ) 0xe000edac ) )
 156:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A2_REG                   ( *( ( volatile uint32_t * ) 0xe000edb0 ) )
 157:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 158:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_A3_REG                   ( *( ( volatile uint32_t * ) 0xe000edb4 ) )
 159:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_A3_REG                   ( *( ( volatile uint32_t * ) 0xe000edb8 ) )
 160:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 161:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR0_REG                     ( *( ( volatile uint32_t * ) 0xe000edc0 ) )
 162:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR1_REG                     ( *( ( volatile uint32_t * ) 0xe000edc4 ) )
 163:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 164:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_ADDRESS_MASK             ( 0xffffffe0 ) /* Must be 32-byte aligned. */
 165:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ADDRESS_MASK             ( 0xffffffe0 ) /* Must be 32-byte aligned. */
 166:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 167:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RBAR_ACCESS_PERMISSIONS_MASK  ( 3UL << 1UL )
 168:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 169:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR0_POS                ( 0UL )
 170:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR0_MASK               ( 0x000000ff )
 171:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 172:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR1_POS                ( 8UL )
 173:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR1_MASK               ( 0x0000ff00 )
 174:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 175:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR2_POS                ( 16UL )
 176:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR2_MASK               ( 0x00ff0000 )
 177:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 178:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR3_POS                ( 24UL )
 179:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR3_MASK               ( 0xff000000 )
 180:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 181:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR4_POS                ( 0UL )
ARM GAS  /tmp/ccsuQooq.s 			page 5


 182:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR4_MASK               ( 0x000000ff )
 183:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 184:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR5_POS                ( 8UL )
 185:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR5_MASK               ( 0x0000ff00 )
 186:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 187:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR6_POS                ( 16UL )
 188:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR6_MASK               ( 0x00ff0000 )
 189:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 190:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR7_POS                ( 24UL )
 191:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_MAIR_ATTR7_MASK               ( 0xff000000 )
 192:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 193:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX0              ( 0UL << 1UL )
 194:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX1              ( 1UL << 1UL )
 195:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX2              ( 2UL << 1UL )
 196:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX3              ( 3UL << 1UL )
 197:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX4              ( 4UL << 1UL )
 198:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX5              ( 5UL << 1UL )
 199:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX6              ( 6UL << 1UL )
 200:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_ATTR_INDEX7              ( 7UL << 1UL )
 201:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 202:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_RLAR_REGION_ENABLE            ( 1UL )
 203:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 204:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Enable privileged access to unmapped region. */
 205:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_PRIV_BACKGROUND_ENABLE_BIT    ( 1UL << 2UL )
 206:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 207:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Enable MPU. */
 208:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMPU_ENABLE_BIT                    ( 1UL << 0UL )
 209:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 210:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Expected value of the portMPU_TYPE register. */
 211:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXPECTED_MPU_TYPE_VALUE           ( configTOTAL_MPU_REGIONS << 8UL )
 212:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 213:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Extract first address of the MPU region as encoded in the
 214:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * RBAR (Region Base Address Register) value. */
 215:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXTRACT_FIRST_ADDRESS_FROM_RBAR( rbar ) \
 216:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( rbar ) & portMPU_RBAR_ADDRESS_MASK )
 217:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 218:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Extract last address of the MPU region as encoded in the
 219:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * RLAR (Region Limit Address Register) value. */
 220:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portEXTRACT_LAST_ADDRESS_FROM_RLAR( rlar ) \
 221:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( rlar ) & portMPU_RLAR_ADDRESS_MASK ) | ~portMPU_RLAR_ADDRESS_MASK )
 222:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 223:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Does addr lies within [start, end] address range? */
 224:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portIS_ADDRESS_WITHIN_RANGE( addr, start, end ) \
 225:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( addr ) >= ( start ) ) && ( ( addr ) <= ( end ) ) )
 226:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 227:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Is the access request satisfied by the available permissions? */
 228:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portIS_AUTHORIZED( accessRequest, permissions ) \
 229:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ( ( ( permissions ) & ( accessRequest ) ) == accessRequest )
 230:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 231:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Max value that fits in a uint32_t type. */
 232:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portUINT32_MAX    ( ~( ( uint32_t ) 0 ) )
 233:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 234:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /* Check if adding a and b will result in overflow. */
 235:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portADD_UINT32_WILL_OVERFLOW( a, b )    ( ( a ) > ( portUINT32_MAX - ( b ) ) )
 236:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 237:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 238:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
ARM GAS  /tmp/ccsuQooq.s 			page 6


 239:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The maximum 24-bit number.
 240:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 241:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * It is needed because the systick is a 24-bit counter.
 242:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 243:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMAX_24_BIT_NUMBER       ( 0xffffffUL )
 244:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 245:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 246:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief A fiddle factor to estimate the number of SysTick counts that would
 247:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * have occurred while the SysTick counter is stopped during tickless idle
 248:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * calculations.
 249:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 250:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portMISSED_COUNTS_FACTOR    ( 94UL )
 251:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 252:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 253:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 254:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Constants required to set up the initial stack.
 255:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 256:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_XPSR    ( 0x01000000 )
 257:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 258:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configRUN_FREERTOS_SECURE_ONLY == 1 )
 259:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 260:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 261:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial EXC_RETURN value.
 262:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 263:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *     FF         FF         FF         FD
 264:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1111 1111  1111 1111  1111 1111  1111 1101
 265:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 266:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[6] - 1 --> The exception was taken from the Secure state.
 267:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[5] - 1 --> Do not skip stacking of additional state context.
 268:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
 269:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[3] - 1 --> Return to the Thread mode.
 270:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[2] - 1 --> Restore registers from the process stack.
 271:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[1] - 0 --> Reserved, 0.
 272:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] - 1 --> The exception was taken to the Secure state.
 273:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 274:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portINITIAL_EXC_RETURN    ( 0xfffffffd )
 275:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 276:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 277:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 278:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial EXC_RETURN value.
 279:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 280:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *     FF         FF         FF         BC
 281:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * 1111 1111  1111 1111  1111 1111  1011 1100
 282:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 283:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[6] - 0 --> The exception was taken from the Non-Secure state.
 284:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[5] - 1 --> Do not skip stacking of additional state context.
 285:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[4] - 1 --> The PE did not allocate space on the stack for FP context.
 286:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[3] - 1 --> Return to the Thread mode.
 287:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[2] - 1 --> Restore registers from the process stack.
 288:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[1] - 0 --> Reserved, 0.
 289:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] - 0 --> The exception was taken to the Non-Secure state.
 290:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 291:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portINITIAL_EXC_RETURN    ( 0xffffffbc )
 292:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configRUN_FREERTOS_SECURE_ONLY */
 293:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 294:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 295:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief CONTROL register privileged bit mask.
ARM GAS  /tmp/ccsuQooq.s 			page 7


 296:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 297:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Bit[0] in CONTROL register tells the privilege:
 298:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *  Bit[0] = 0 ==> The task is privileged.
 299:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *  Bit[0] = 1 ==> The task is not privileged.
 300:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 301:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portCONTROL_PRIVILEGED_MASK         ( 1UL << 0UL )
 302:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 303:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 304:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Initial CONTROL register values.
 305:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 306:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_CONTROL_UNPRIVILEGED    ( 0x3 )
 307:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portINITIAL_CONTROL_PRIVILEGED      ( 0x2 )
 308:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 309:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 310:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Let the user override the default SysTick clock rate.  If defined by the
 311:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * user, this symbol must equal the SysTick clock rate when the CLK bit is 0 in the
 312:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * configuration register.
 313:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 314:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #ifndef configSYSTICK_CLOCK_HZ
 315:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define configSYSTICK_CLOCK_HZ             ( configCPU_CLOCK_HZ )
 316:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Ensure the SysTick is clocked at the same frequency as the core. */
 317:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portNVIC_SYSTICK_CLK_BIT_CONFIG    ( portNVIC_SYSTICK_CLK_BIT )
 318:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 319:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Select the option to clock SysTick not at the same frequency as the core. */
 320:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portNVIC_SYSTICK_CLK_BIT_CONFIG    ( 0 )
 321:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 322:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 323:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 324:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Let the user override the pre-loading of the initial LR with the
 325:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * address of prvTaskExitError() in case it messes up unwinding of the stack
 326:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * in the debugger.
 327:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 328:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #ifdef configTASK_RETURN_ADDRESS
 329:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portTASK_RETURN_ADDRESS    configTASK_RETURN_ADDRESS
 330:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else
 331:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #define portTASK_RETURN_ADDRESS    prvTaskExitError
 332:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 333:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 334:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 335:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief If portPRELOAD_REGISTERS then registers will be given an initial value
 336:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * when a task is created. This helps in debugging at the cost of code size.
 337:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 338:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portPRELOAD_REGISTERS    1
 339:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 340:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 341:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief A task is created without a secure context, and must call
 342:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * portALLOCATE_SECURE_CONTEXT() to give itself a secure context before it makes
 343:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * any secure calls.
 344:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 345:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #define portNO_SECURE_CONTEXT    0
 346:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 347:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 348:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 349:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Used to catch tasks that attempt to return from their implementing
 350:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * function.
 351:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 352:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** static void prvTaskExitError( void );
ARM GAS  /tmp/ccsuQooq.s 			page 8


 353:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 354:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 355:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 356:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 357:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Extract MPU region's access permissions from the Region Base Address
 358:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * Register (RBAR) value.
 359:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 360:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ulRBARValue RBAR value for the MPU region.
 361:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 362:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @return uint32_t Access permissions.
 363:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 364:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t prvGetRegionAccessPermissions( uint32_t ulRBARValue ) PRIVILEGED_FUNCTION;
 365:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 366:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 367:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 368:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 369:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 370:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the Memory Protection Unit (MPU).
 371:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 372:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupMPU( void ) PRIVILEGED_FUNCTION;
 373:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 374:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 375:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_FPU == 1 )
 376:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 377:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 378:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the Floating Point Unit (FPU).
 379:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 380:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupFPU( void ) PRIVILEGED_FUNCTION;
 381:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_FPU */
 382:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 383:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 384:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Setup the timer to generate the tick interrupts.
 385:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 386:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * The implementation in this file is weak to allow application writers to
 387:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * change the timer used to generate the tick interrupt.
 388:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 389:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortSetupTimerInterrupt( void ) PRIVILEGED_FUNCTION;
 390:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 391:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 392:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Checks whether the current execution context is interrupt.
 393:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 394:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @return pdTRUE if the current execution context is interrupt, pdFALSE
 395:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * otherwise.
 396:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 397:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortIsInsideInterrupt( void );
 398:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 399:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 400:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Yield the processor.
 401:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 402:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortYield( void ) PRIVILEGED_FUNCTION;
 403:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 404:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 405:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Enter critical section.
 406:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 407:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEnterCritical( void ) PRIVILEGED_FUNCTION;
 408:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 409:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
ARM GAS  /tmp/ccsuQooq.s 			page 9


 410:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Exit from critical section.
 411:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 412:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortExitCritical( void ) PRIVILEGED_FUNCTION;
 413:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 414:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 415:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief SysTick handler.
 416:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 417:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void SysTick_Handler( void ) PRIVILEGED_FUNCTION;
 418:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 419:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 420:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief C part of SVC handler.
 421:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 422:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** portDONT_DISCARD void vPortSVCHandler_C( uint32_t * pulCallerStackAddress ) PRIVILEGED_FUNCTION;
 423:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 424:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 425:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 426:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 427:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Sets up the system call stack so that upon returning from
 428:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * SVC, the system call stack is used.
 429:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  *
 430:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param pulTaskStack The current SP when the SVC was raised.
 431:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ulLR The value of Link Register (EXC_RETURN) in the SVC handler.
 432:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @param ucSystemCallNumber The system call number of the system call.
 433:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 434:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallEnter( uint32_t * pulTaskStack,
 435:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint32_t ulLR,
 436:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint8_t ucSystemCallNumber ) PRIVILEGED_FUNCTION;
 437:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 438:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 439:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 440:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 441:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 442:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 443:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Raise SVC for exiting from a system call.
 444:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 445:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vRequestSystemCallExit( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION;
 446:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 447:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 448:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 449:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
 450:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 451:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /**
 452:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @brief Sets up the task stack so that upon returning from
 453:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * SVC, the task stack is used again.
 454:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      *
 455:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @param pulSystemCallStack The current SP when the SVC was raised.
 456:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @param ulLR The value of Link Register (EXC_RETURN) in the SVC handler.
 457:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      */
 458:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallExit( uint32_t * pulSystemCallStack,
 459:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                           uint32_t ulLR ) PRIVILEGED_FUNCTION;
 460:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 461:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
 462:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 463:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 464:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 465:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /**
 466:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @brief Checks whether or not the calling task is privileged.
ARM GAS  /tmp/ccsuQooq.s 			page 10


 467:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      *
 468:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * @return pdTRUE if the calling task is privileged, pdFALSE otherwise.
 469:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      */
 470:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsTaskPrivileged( void ) PRIVILEGED_FUNCTION;
 471:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 472:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU == 1 */
 473:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 474:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 475:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_CONT
 476:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 477:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 478:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief This variable is set to pdTRUE when the scheduler is started.
 479:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 480:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static BaseType_t xSchedulerRunning = pdFALSE;
 481:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 482:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif
 483:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 484:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 485:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Each task maintains its own interrupt status in the critical nesting
 486:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * variable.
 487:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 488:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** PRIVILEGED_DATA static volatile uint32_t ulCriticalNesting = 0xaaaaaaaaUL;
 489:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 490:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_TRUSTZONE == 1 )
 491:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 492:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 493:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Saved as part of the task context to indicate which context the
 494:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * task is using on the secure side.
 495:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 496:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA portDONT_DISCARD volatile SecureContextHandle_t xSecureContext = portNO_SECURE_
 497:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_TRUSTZONE */
 498:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 499:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 500:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Used by the portASSERT_IF_INTERRUPT_PRIORITY_INVALID() macro to ensure
 501:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * FreeRTOS API functions are not called from interrupts that have been assigned
 502:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * a priority above configMAX_SYSCALL_INTERRUPT_PRIORITY.
 503:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 504:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
 505:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 506:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint8_t ucMaxSysCallPriority = 0;
 507:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t ulMaxPRIGROUPValue = 0;
 508:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static const volatile uint8_t * const pcInterruptPriorityRegisters = ( const volatile uint8_t *
 509:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 510:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) ) */
 511:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 512:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configUSE_TICKLESS_IDLE == 1 )
 513:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 514:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 515:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The number of SysTick increments that make up one tick period.
 516:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 517:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t ulTimerCountsForOneTick = 0;
 518:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 519:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 520:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief The maximum number of tick periods that can be suppressed is
 521:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * limited by the 24 bit resolution of the SysTick timer.
 522:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 523:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t xMaximumPossibleSuppressedTicks = 0;
ARM GAS  /tmp/ccsuQooq.s 			page 11


 524:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 525:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /**
 526:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * @brief Compensate for the CPU cycles that pass while the SysTick is
 527:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  * stopped (low power functionality only).
 528:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****  */
 529:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     PRIVILEGED_DATA static uint32_t ulStoppedTimerCompensation = 0;
 530:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 531:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 532:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 533:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configUSE_TICKLESS_IDLE == 1 )
 534:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __attribute__( ( weak ) ) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
 535:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 536:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements, ulSysTickDecre
 537:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         TickType_t xModifiableIdleTime;
 538:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 539:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Make sure the SysTick reload value does not overflow the counter. */
 540:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
 541:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 542:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
 543:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 544:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 545:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Enter a critical section but don't use the taskENTER_CRITICAL()
 546:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * method as that will mask interrupts that should exit sleep mode. */
 547:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "cpsid i" ::: "memory" );
 548:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "dsb" );
 549:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "isb" );
 550:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 551:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* If a context switch is pending or a task is waiting for the scheduler
 552:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * to be unsuspended then abandon the low power entry. */
 553:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( eTaskConfirmSleepModeStatus() == eAbortSleep )
 554:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 555:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Re-enable interrupts - see comments above the cpsid instruction
 556:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * above. */
 557:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 558:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 559:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
 560:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 561:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Stop the SysTick momentarily.  The time the SysTick is stopped for
 562:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * is accounted for as best it can be, but using the tickless mode will
 563:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * inevitably result in some tiny drift of the time maintained by the
 564:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * kernel with respect to calendar time. */
 565:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BI
 566:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 567:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the SysTick current-value register to determine the number of
 568:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SysTick decrements remaining until the next tick interrupt.  If the
 569:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * current-value register is zero, then there are actually
 570:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * ulTimerCountsForOneTick decrements remaining, not zero, because the
 571:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SysTick requests the interrupt when decrementing from 1 to 0. */
 572:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulSysTickDecrementsLeft = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 573:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 574:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ulSysTickDecrementsLeft == 0 )
 575:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 576:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulSysTickDecrementsLeft = ulTimerCountsForOneTick;
 577:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 578:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 579:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Calculate the reload value required to wait xExpectedIdleTime
 580:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * tick periods.  -1 is used because this code normally executes part
ARM GAS  /tmp/ccsuQooq.s 			page 12


 581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * way through the first tick period.  But if the SysTick IRQ is now
 582:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * pending, then clear the IRQ, suppressing the first tick, and correct
 583:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the reload value to reflect that the second tick period is already
 584:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * underway.  The expected idle time is always at least two ticks. */
 585:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulReloadValue = ulSysTickDecrementsLeft + ( ulTimerCountsForOneTick * ( xExpectedIdleTi
 586:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 587:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( portNVIC_INT_CTRL_REG & portNVIC_PEND_SYSTICK_SET_BIT ) != 0 )
 588:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 589:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_INT_CTRL_REG = portNVIC_PEND_SYSTICK_CLEAR_BIT;
 590:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulReloadValue -= ulTimerCountsForOneTick;
 591:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 592:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 593:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ulReloadValue > ulStoppedTimerCompensation )
 594:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 595:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulReloadValue -= ulStoppedTimerCompensation;
 596:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 597:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 598:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Set the new reload value. */
 599:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
 600:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Clear the SysTick count flag and set the count value back to
 602:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * zero. */
 603:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 604:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 605:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restart SysTick. */
 606:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
 607:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 608:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
 609:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * set its parameter to 0 to indicate that its implementation contains
 610:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * its own wait for interrupt or wait for event instruction, and so wfi
 611:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * should not be executed again.  However, the original expected idle
 612:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time variable must remain unmodified, so a copy is taken. */
 613:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xModifiableIdleTime = xExpectedIdleTime;
 614:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
 615:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 616:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( xModifiableIdleTime > 0 )
 617:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 618:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "dsb" ::: "memory" );
 619:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "wfi" );
 620:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 __asm volatile ( "isb" );
 621:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 622:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 623:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
 624:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 625:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Re-enable interrupts to allow the interrupt that brought the MCU
 626:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * out of sleep mode to execute immediately.  See comments above
 627:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the cpsid instruction above. */
 628:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 629:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "dsb" );
 630:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "isb" );
 631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 632:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Disable interrupts again because the clock is about to be stopped
 633:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and interrupts that execute while the clock is stopped will increase
 634:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * any slippage between the time maintained by the RTOS and calendar
 635:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time. */
 636:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsid i" ::: "memory" );
 637:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "dsb" );
ARM GAS  /tmp/ccsuQooq.s 			page 13


 638:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "isb" );
 639:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 640:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Disable the SysTick clock without reading the
 641:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * portNVIC_SYSTICK_CTRL_REG register to ensure the
 642:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
 643:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the time the SysTick is stopped for is accounted for as best it can
 644:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * be, but using the tickless mode will inevitably result in some tiny
 645:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * drift of the time maintained by the kernel with respect to calendar
 646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * time*/
 647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BI
 648:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 649:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Determine whether the SysTick has already counted to zero. */
 650:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 651:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 652:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 uint32_t ulCalculatedLoadValue;
 653:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 654:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The tick interrupt ended the sleep (or is now pending), and
 655:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * a new tick period has started.  Reset portNVIC_SYSTICK_LOAD_REG
 656:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * with whatever remains of the new tick period. */
 657:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portN
 658:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 659:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Don't allow a tiny value, or values that have somehow
 660:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * underflowed because the post sleep hook did something
 661:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * that took too long or because the SysTick current-value register
 662:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * is zero. */
 663:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulCalculatedLoadValue <= ulStoppedTimerCompensation ) || ( ulCalculatedLoadVa
 664:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 665:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
 666:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
 667:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 668:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
 669:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 670:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* As the pending tick will be processed as soon as this
 671:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * function exits, the tick value maintained by the tick is stepped
 672:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * forward by one less than the time spent waiting. */
 673:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
 674:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 675:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
 676:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 677:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Something other than the tick interrupt ended the sleep. */
 678:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 679:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Use the SysTick current-value register to determine the
 680:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * number of SysTick decrements remaining until the expected idle
 681:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * time would have ended. */
 682:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulSysTickDecrementsLeft = portNVIC_SYSTICK_CURRENT_VALUE_REG;
 683:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #if ( portNVIC_SYSTICK_CLK_BIT_CONFIG != portNVIC_SYSTICK_CLK_BIT )
 684:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 685:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* If the SysTick is not using the core clock, the current-
 686:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * value register might still be zero here.  In that case, the
 687:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * SysTick didn't load from the reload register, and there are
 688:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * ulReloadValue decrements remaining in the expected idle
 689:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * time, not zero. */
 690:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     if( ulSysTickDecrementsLeft == 0 )
 691:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     {
 692:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ulSysTickDecrementsLeft = ulReloadValue;
 693:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     }
 694:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
ARM GAS  /tmp/ccsuQooq.s 			page 14


 695:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #endif /* portNVIC_SYSTICK_CLK_BIT_CONFIG */
 696:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 697:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Work out how long the sleep lasted rounded to complete tick
 698:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * periods (not the ulReload value which accounted for part
 699:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * ticks). */
 700:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - ul
 701:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 702:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* How many complete tick periods passed while the processor
 703:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * was waiting? */
 704:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
 705:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 706:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The reload value is set to whatever fraction of a single tick
 707:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * period remains. */
 708:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOne
 709:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 710:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 711:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG again,
 712:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * then set portNVIC_SYSTICK_LOAD_REG back to its standard value.  If
 713:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the SysTick is not using the core clock, temporarily configure it to
 714:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * use the core clock.  This configuration forces the SysTick to load
 715:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * from portNVIC_SYSTICK_LOAD_REG immediately instead of at the next
 716:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * cycle of the other clock.  Then portNVIC_SYSTICK_LOAD_REG is ready
 717:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to receive the standard value immediately. */
 718:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 719:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portN
 720:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( portNVIC_SYSTICK_CLK_BIT_CONFIG == portNVIC_SYSTICK_CLK_BIT )
 721:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 722:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 723:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 724:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else
 725:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
 726:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* The temporary usage of the core clock has served its purpose,
 727:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * as described above.  Resume usage of the other clock. */
 728:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT;
 729:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 730:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
 731:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
 732:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* The partial tick period already ended.  Be sure the SysTick
 733:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * counts it only once. */
 734:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0;
 735:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
 736:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 737:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
 738:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_
 739:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
 740:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* portNVIC_SYSTICK_CLK_BIT_CONFIG */
 741:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 742:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Step the tick to account for any tick periods that elapsed. */
 743:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             vTaskStepTick( ulCompleteTickPeriods );
 744:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 745:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Exit with interrupts enabled. */
 746:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "cpsie i" ::: "memory" );
 747:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 748:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 749:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configUSE_TICKLESS_IDLE */
 750:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 751:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/ccsuQooq.s 			page 15


 752:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** __attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void ) /* PRIVILEGED_FUNCTION */
 753:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
  57              		.loc 1 753 1
  58              		.cfi_startproc
  59              		@ args = 0, pretend = 0, frame = 0
  60              		@ frame_needed = 1, uses_anonymous_args = 0
  61              		@ link register save eliminated.
  62 0000 80B4     		push	{r7}
  63              		.cfi_def_cfa_offset 4
  64              		.cfi_offset 7, -4
  65 0002 00AF     		add	r7, sp, #0
  66              		.cfi_def_cfa_register 7
 754:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Calculate the constants required to configure the tick interrupt. */
 755:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configUSE_TICKLESS_IDLE == 1 )
 756:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 757:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
 758:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
 759:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTIC
 760:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 761:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configUSE_TICKLESS_IDLE */
 762:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 763:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Stop and reset the SysTick. */
 764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = 0UL;
  67              		.loc 1 764 5
  68 0004 0B4B     		ldr	r3, .L2
  69              		.loc 1 764 31
  70 0006 0022     		movs	r2, #0
  71 0008 1A60     		str	r2, [r3]
 765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  72              		.loc 1 765 5
  73 000a 0B4B     		ldr	r3, .L2+4
  74              		.loc 1 765 40
  75 000c 0022     		movs	r2, #0
  76 000e 1A60     		str	r2, [r3]
 766:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 767:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Configure SysTick to interrupt at the requested rate. */
 768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  77              		.loc 1 768 58
  78 0010 0A4B     		ldr	r3, .L2+8
  79 0012 1B68     		ldr	r3, [r3]
  80 0014 0A4A     		ldr	r2, .L2+12
  81 0016 A2FB0323 		umull	r2, r3, r2, r3
  82 001a 9B09     		lsrs	r3, r3, #6
  83              		.loc 1 768 5
  84 001c 094A     		ldr	r2, .L2+16
  85              		.loc 1 768 81
  86 001e 013B     		subs	r3, r3, #1
  87              		.loc 1 768 31
  88 0020 1360     		str	r3, [r2]
 769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNV
  89              		.loc 1 769 5
  90 0022 044B     		ldr	r3, .L2
  91              		.loc 1 769 31
  92 0024 0722     		movs	r2, #7
  93 0026 1A60     		str	r2, [r3]
 770:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
  94              		.loc 1 770 1
ARM GAS  /tmp/ccsuQooq.s 			page 16


  95 0028 00BF     		nop
  96 002a BD46     		mov	sp, r7
  97              		.cfi_def_cfa_register 13
  98              		@ sp needed
  99 002c 5DF8047B 		ldr	r7, [sp], #4
 100              		.cfi_restore 7
 101              		.cfi_def_cfa_offset 0
 102 0030 7047     		bx	lr
 103              	.L3:
 104 0032 00BF     		.align	2
 105              	.L2:
 106 0034 10E000E0 		.word	-536813552
 107 0038 18E000E0 		.word	-536813544
 108 003c 00000000 		.word	SystemCoreClock
 109 0040 D34D6210 		.word	274877907
 110 0044 14E000E0 		.word	-536813548
 111              		.cfi_endproc
 112              	.LFE0:
 114              		.section	.rodata
 115              		.align	2
 116              	.LC0:
 117 0000 3000     		.ascii	"0\000"
 118 0002 0000     		.align	2
 119              	.LC1:
 120 0004 4C69622F 		.ascii	"Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_s"
 120      46726565 
 120      52544F53 
 120      2F536F75 
 120      7263652F 
 121 0037 65637572 		.ascii	"ecure/port.c\000"
 121      652F706F 
 121      72742E63 
 121      00
 122              		.section	.text.prvTaskExitError,"ax",%progbits
 123              		.align	1
 124              		.syntax unified
 125              		.thumb
 126              		.thumb_func
 128              	prvTaskExitError:
 129              	.LFB1:
 771:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 772:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 773:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** static void prvTaskExitError( void )
 774:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 130              		.loc 1 774 1
 131              		.cfi_startproc
 132              		@ args = 0, pretend = 0, frame = 8
 133              		@ frame_needed = 1, uses_anonymous_args = 0
 134 0000 80B5     		push	{r7, lr}
 135              		.cfi_def_cfa_offset 8
 136              		.cfi_offset 7, -8
 137              		.cfi_offset 14, -4
 138 0002 82B0     		sub	sp, sp, #8
 139              		.cfi_def_cfa_offset 16
 140 0004 00AF     		add	r7, sp, #0
 141              		.cfi_def_cfa_register 7
 775:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     volatile uint32_t ulDummy = 0UL;
ARM GAS  /tmp/ccsuQooq.s 			page 17


 142              		.loc 1 775 23
 143 0006 0023     		movs	r3, #0
 144 0008 7B60     		str	r3, [r7, #4]
 776:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 777:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* A function that implements a task must not exit or attempt to return to
 778:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * its caller as there is nothing to return to. If a task wants to exit it
 779:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * should instead call vTaskDelete( NULL ). Artificially force an assert()
 780:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * to be triggered if configASSERT() is defined, then stop here so
 781:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * application writers can catch the error. */
 782:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting == ~0UL );
 145              		.loc 1 782 5
 146 000a 0C4B     		ldr	r3, .L7
 147 000c 1B68     		ldr	r3, [r3]
 148 000e B3F1FF3F 		cmp	r3, #-1
 149 0012 08D0     		beq	.L5
 150              		.loc 1 782 5 is_stmt 0 discriminator 1
 151 0014 FFF7FEFF 		bl	ulSetInterruptMask
 152 0018 094B     		ldr	r3, .L7+4
 153 001a 0A4A     		ldr	r2, .L7+8
 154 001c 40F20E31 		movw	r1, #782
 155 0020 0948     		ldr	r0, .L7+12
 156 0022 FFF7FEFF 		bl	__assert_func
 157              	.L5:
 783:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portDISABLE_INTERRUPTS();
 158              		.loc 1 783 5 is_stmt 1
 159 0026 FFF7FEFF 		bl	ulSetInterruptMask
 784:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 785:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     while( ulDummy == 0 )
 160              		.loc 1 785 10
 161 002a 00BF     		nop
 162              	.L6:
 163              		.loc 1 785 20 discriminator 1
 164 002c 7B68     		ldr	r3, [r7, #4]
 165 002e 002B     		cmp	r3, #0
 166 0030 FCD0     		beq	.L6
 786:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 787:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* This file calls prvTaskExitError() after the scheduler has been
 788:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * started to remove a compiler warning about the function being
 789:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * defined but never called.  ulDummy is used purely to quieten other
 790:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * warnings about code appearing after this function is called - making
 791:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * ulDummy volatile makes the compiler think the function could return
 792:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * and therefore not output an 'unreachable code' warning for code that
 793:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * appears after it. */
 794:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 795:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 167              		.loc 1 795 1
 168 0032 00BF     		nop
 169 0034 00BF     		nop
 170 0036 0837     		adds	r7, r7, #8
 171              		.cfi_def_cfa_offset 8
 172 0038 BD46     		mov	sp, r7
 173              		.cfi_def_cfa_register 13
 174              		@ sp needed
 175 003a 80BD     		pop	{r7, pc}
 176              	.L8:
 177              		.align	2
 178              	.L7:
ARM GAS  /tmp/ccsuQooq.s 			page 18


 179 003c 00000000 		.word	ulCriticalNesting
 180 0040 00000000 		.word	.LC0
 181 0044 00000000 		.word	__func__.5
 182 0048 04000000 		.word	.LC1
 183              		.cfi_endproc
 184              	.LFE1:
 186              		.section	.text.prvSetupFPU,"ax",%progbits
 187              		.align	1
 188              		.syntax unified
 189              		.thumb
 190              		.thumb_func
 192              	prvSetupFPU:
 193              	.LFB2:
 796:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 797:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 798:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 799:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static uint32_t prvGetRegionAccessPermissions( uint32_t ulRBARValue ) /* PRIVILEGED_FUNCTION */
 800:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 801:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulAccessPermissions = 0;
 802:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 803:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_ONLY )
 804:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 805:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulAccessPermissions = tskMPU_READ_PERMISSION;
 806:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 807:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 808:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulRBARValue & portMPU_RBAR_ACCESS_PERMISSIONS_MASK ) == portMPU_REGION_READ_WRITE )
 809:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 810:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulAccessPermissions = ( tskMPU_READ_PERMISSION | tskMPU_WRITE_PERMISSION );
 811:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 812:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 813:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return ulAccessPermissions;
 814:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 815:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 816:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 817:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 818:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
 819:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupMPU( void ) /* PRIVILEGED_FUNCTION */
 820:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 821:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
 822:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
 823:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
 824:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_start__;
 825:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_end__;
 826:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
 827:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
 828:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __unprivileged_flash_start__;
 829:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __unprivileged_flash_end__;
 830:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_start__;
 831:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_end__;
 832:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else /* if defined( __ARMCC_VERSION ) */
 833:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
 834:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_start__[];
 835:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_end__[];
 836:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
 837:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
 838:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __unprivileged_flash_start__[];
 839:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __unprivileged_flash_end__[];
ARM GAS  /tmp/ccsuQooq.s 			page 19


 840:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_start__[];
 841:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_end__[];
 842:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
 843:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 844:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* The only permitted number of regions are 8 or 16. */
 845:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( configTOTAL_MPU_REGIONS == 8 ) || ( configTOTAL_MPU_REGIONS == 16 ) );
 846:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 847:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Ensure that the configTOTAL_MPU_REGIONS is configured correctly. */
 848:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE );
 849:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 850:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the MPU is present. */
 851:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( portMPU_TYPE_REG == portEXPECTED_MPU_TYPE_VALUE )
 852:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 853:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* MAIR0 - Index 0. */
 854:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_MAIR0_REG |= ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATT
 855:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* MAIR0 - Index 1. */
 856:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_MAIR0_REG |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & port
 857:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 858:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup privileged flash as Read Only so that privileged tasks can
 859:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * read it but not modify. */
 860:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portPRIVILEGED_FLASH_REGION;
 861:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_functions_start__ ) & portMPU_RBAR_ADD
 862:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 863:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_PRIVILEGED_READ_ONLY );
 864:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_functions_end__ ) & portMPU_RLAR_ADDRE
 865:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 866:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 867:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 868:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup unprivileged flash as Read Only by both privileged and
 869:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * unprivileged tasks. All tasks can read it but no-one can modify. */
 870:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portUNPRIVILEGED_FLASH_REGION;
 871:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __unprivileged_flash_start__ ) & portMPU_RBAR_ADDRE
 872:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 873:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_READ_ONLY );
 874:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __unprivileged_flash_end__ ) & portMPU_RLAR_ADDRESS
 875:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 876:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 877:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 878:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup unprivileged syscalls flash as Read Only by both privileged
 879:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and unprivileged tasks. All tasks can read it but no-one can modify. */
 880:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portUNPRIVILEGED_SYSCALLS_REGION;
 881:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __syscalls_flash_start__ ) & portMPU_RBAR_ADDRESS_M
 882:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 883:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_READ_ONLY );
 884:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __syscalls_flash_end__ ) & portMPU_RLAR_ADDRESS_MAS
 885:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 886:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
 887:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 888:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup RAM containing kernel data for privileged access only. */
 889:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RNR_REG = portPRIVILEGED_RAM_REGION;
 890:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RBAR_REG = ( ( ( uint32_t ) __privileged_sram_start__ ) & portMPU_RBAR_ADDRESS_
 891:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_NON_SHAREABLE ) |
 892:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_PRIVILEGED_READ_WRITE ) |
 893:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_REGION_EXECUTE_NEVER );
 894:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_RLAR_REG = ( ( ( uint32_t ) __privileged_sram_end__ ) & portMPU_RLAR_ADDRESS_MA
 895:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_ATTR_INDEX0 ) |
 896:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                ( portMPU_RLAR_REGION_ENABLE );
ARM GAS  /tmp/ccsuQooq.s 			page 20


 897:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 898:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable mem fault. */
 899:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portSCB_SYS_HANDLER_CTRL_STATE_REG |= portSCB_MEM_FAULT_ENABLE_BIT;
 900:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 901:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable MPU with privileged background access i.e. unmapped
 902:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * regions have privileged access. */
 903:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portMPU_CTRL_REG |= ( portMPU_PRIV_BACKGROUND_ENABLE_BIT | portMPU_ENABLE_BIT );
 904:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 905:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 906:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
 907:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 908:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 909:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_FPU == 1 )
 910:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     static void prvSetupFPU( void ) /* PRIVILEGED_FUNCTION */
 911:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 194              		.loc 1 911 5
 195              		.cfi_startproc
 196              		@ args = 0, pretend = 0, frame = 0
 197              		@ frame_needed = 1, uses_anonymous_args = 0
 198              		@ link register save eliminated.
 199 0000 80B4     		push	{r7}
 200              		.cfi_def_cfa_offset 4
 201              		.cfi_offset 7, -4
 202 0002 00AF     		add	r7, sp, #0
 203              		.cfi_def_cfa_register 7
 912:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
 913:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 914:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Enable non-secure access to the FPU. */
 915:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             SecureInit_EnableNSFPUAccess();
 916:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 917:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
 918:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 919:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* CP10 = 11 ==> Full access to FPU i.e. both privileged and
 920:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * unprivileged code should be able to access FPU. CP11 should be
 921:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * programmed to the same value as CP10. */
 922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         *( portCPACR ) |= ( ( portCPACR_CP10_VALUE << portCPACR_CP10_POS ) |
 204              		.loc 1 922 9
 205 0004 084B     		ldr	r3, .L10
 206 0006 1B68     		ldr	r3, [r3]
 207 0008 074A     		ldr	r2, .L10
 208              		.loc 1 922 24
 209 000a 43F47003 		orr	r3, r3, #15728640
 210 000e 1360     		str	r3, [r2]
 923:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             ( portCPACR_CP11_VALUE << portCPACR_CP11_POS )
 924:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             );
 925:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 926:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* ASPEN = 1 ==> Hardware should automatically preserve floating point
 927:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * context on exception entry and restore on exception return.
 928:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * LSPEN = 1 ==> Enable lazy context save of FP state. */
 929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         *( portFPCCR ) |= ( portFPCCR_ASPEN_MASK | portFPCCR_LSPEN_MASK );
 211              		.loc 1 929 9
 212 0010 064B     		ldr	r3, .L10+4
 213 0012 1B68     		ldr	r3, [r3]
 214 0014 054A     		ldr	r2, .L10+4
 215              		.loc 1 929 24
 216 0016 43F04043 		orr	r3, r3, #-1073741824
 217 001a 1360     		str	r3, [r2]
ARM GAS  /tmp/ccsuQooq.s 			page 21


 930:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 218              		.loc 1 930 5
 219 001c 00BF     		nop
 220 001e BD46     		mov	sp, r7
 221              		.cfi_def_cfa_register 13
 222              		@ sp needed
 223 0020 5DF8047B 		ldr	r7, [sp], #4
 224              		.cfi_restore 7
 225              		.cfi_def_cfa_offset 0
 226 0024 7047     		bx	lr
 227              	.L11:
 228 0026 00BF     		.align	2
 229              	.L10:
 230 0028 88ED00E0 		.word	-536810104
 231 002c 34EF00E0 		.word	-536809676
 232              		.cfi_endproc
 233              	.LFE2:
 235              		.section	.text.vPortYield,"ax",%progbits
 236              		.align	1
 237              		.global	vPortYield
 238              		.syntax unified
 239              		.thumb
 240              		.thumb_func
 242              	vPortYield:
 243              	.LFB3:
 931:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_FPU */
 932:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 933:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 934:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortYield( void ) /* PRIVILEGED_FUNCTION */
 935:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 244              		.loc 1 935 1
 245              		.cfi_startproc
 246              		@ args = 0, pretend = 0, frame = 0
 247              		@ frame_needed = 1, uses_anonymous_args = 0
 248              		@ link register save eliminated.
 249 0000 80B4     		push	{r7}
 250              		.cfi_def_cfa_offset 4
 251              		.cfi_offset 7, -4
 252 0002 00AF     		add	r7, sp, #0
 253              		.cfi_def_cfa_register 7
 936:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Set a PendSV to request a context switch. */
 937:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 254              		.loc 1 937 5
 255 0004 064B     		ldr	r3, .L13
 256              		.loc 1 937 27
 257 0006 4FF08052 		mov	r2, #268435456
 258 000a 1A60     		str	r2, [r3]
 938:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 939:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Barriers are normally not required but do ensure the code is
 940:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * completely within the specified behaviour for the architecture. */
 941:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "dsb" ::: "memory" );
 259              		.loc 1 941 5
 260              		.syntax unified
 261              	@ 941 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 262 000c BFF34F8F 		dsb
 263              	@ 0 "" 2
 942:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "isb" );
ARM GAS  /tmp/ccsuQooq.s 			page 22


 264              		.loc 1 942 5
 265              	@ 942 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 266 0010 BFF36F8F 		isb
 267              	@ 0 "" 2
 943:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 268              		.loc 1 943 1
 269              		.thumb
 270              		.syntax unified
 271 0014 00BF     		nop
 272 0016 BD46     		mov	sp, r7
 273              		.cfi_def_cfa_register 13
 274              		@ sp needed
 275 0018 5DF8047B 		ldr	r7, [sp], #4
 276              		.cfi_restore 7
 277              		.cfi_def_cfa_offset 0
 278 001c 7047     		bx	lr
 279              	.L14:
 280 001e 00BF     		.align	2
 281              	.L13:
 282 0020 04ED00E0 		.word	-536810236
 283              		.cfi_endproc
 284              	.LFE3:
 286              		.section	.text.vPortEnterCritical,"ax",%progbits
 287              		.align	1
 288              		.global	vPortEnterCritical
 289              		.syntax unified
 290              		.thumb
 291              		.thumb_func
 293              	vPortEnterCritical:
 294              	.LFB4:
 944:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 945:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 946:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEnterCritical( void ) /* PRIVILEGED_FUNCTION */
 947:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 295              		.loc 1 947 1
 296              		.cfi_startproc
 297              		@ args = 0, pretend = 0, frame = 0
 298              		@ frame_needed = 1, uses_anonymous_args = 0
 299 0000 80B5     		push	{r7, lr}
 300              		.cfi_def_cfa_offset 8
 301              		.cfi_offset 7, -8
 302              		.cfi_offset 14, -4
 303 0002 00AF     		add	r7, sp, #0
 304              		.cfi_def_cfa_register 7
 948:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portDISABLE_INTERRUPTS();
 305              		.loc 1 948 5
 306 0004 FFF7FEFF 		bl	ulSetInterruptMask
 949:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting++;
 307              		.loc 1 949 22
 308 0008 054B     		ldr	r3, .L16
 309 000a 1B68     		ldr	r3, [r3]
 310 000c 0133     		adds	r3, r3, #1
 311 000e 044A     		ldr	r2, .L16
 312 0010 1360     		str	r3, [r2]
 950:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 951:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Barriers are normally not required but do ensure the code is
 952:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * completely within the specified behaviour for the architecture. */
ARM GAS  /tmp/ccsuQooq.s 			page 23


 953:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "dsb" ::: "memory" );
 313              		.loc 1 953 5
 314              		.syntax unified
 315              	@ 953 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 316 0012 BFF34F8F 		dsb
 317              	@ 0 "" 2
 954:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "isb" );
 318              		.loc 1 954 5
 319              	@ 954 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 320 0016 BFF36F8F 		isb
 321              	@ 0 "" 2
 955:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 322              		.loc 1 955 1
 323              		.thumb
 324              		.syntax unified
 325 001a 00BF     		nop
 326 001c 80BD     		pop	{r7, pc}
 327              	.L17:
 328 001e 00BF     		.align	2
 329              	.L16:
 330 0020 00000000 		.word	ulCriticalNesting
 331              		.cfi_endproc
 332              	.LFE4:
 334              		.section	.text.vPortExitCritical,"ax",%progbits
 335              		.align	1
 336              		.global	vPortExitCritical
 337              		.syntax unified
 338              		.thumb
 339              		.thumb_func
 341              	vPortExitCritical:
 342              	.LFB5:
 956:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 957:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 958:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortExitCritical( void ) /* PRIVILEGED_FUNCTION */
 959:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 343              		.loc 1 959 1
 344              		.cfi_startproc
 345              		@ args = 0, pretend = 0, frame = 0
 346              		@ frame_needed = 1, uses_anonymous_args = 0
 347 0000 80B5     		push	{r7, lr}
 348              		.cfi_def_cfa_offset 8
 349              		.cfi_offset 7, -8
 350              		.cfi_offset 14, -4
 351 0002 00AF     		add	r7, sp, #0
 352              		.cfi_def_cfa_register 7
 960:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting );
 353              		.loc 1 960 5
 354 0004 0D4B     		ldr	r3, .L22
 355 0006 1B68     		ldr	r3, [r3]
 356 0008 002B     		cmp	r3, #0
 357 000a 08D1     		bne	.L19
 358              		.loc 1 960 5 is_stmt 0 discriminator 1
 359 000c FFF7FEFF 		bl	ulSetInterruptMask
 360 0010 0B4B     		ldr	r3, .L22+4
 361 0012 0C4A     		ldr	r2, .L22+8
 362 0014 4FF47071 		mov	r1, #960
 363 0018 0B48     		ldr	r0, .L22+12
ARM GAS  /tmp/ccsuQooq.s 			page 24


 364 001a FFF7FEFF 		bl	__assert_func
 365              	.L19:
 961:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting--;
 366              		.loc 1 961 22 is_stmt 1
 367 001e 074B     		ldr	r3, .L22
 368 0020 1B68     		ldr	r3, [r3]
 369 0022 013B     		subs	r3, r3, #1
 370 0024 054A     		ldr	r2, .L22
 371 0026 1360     		str	r3, [r2]
 962:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 963:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     if( ulCriticalNesting == 0 )
 372              		.loc 1 963 27
 373 0028 044B     		ldr	r3, .L22
 374 002a 1B68     		ldr	r3, [r3]
 375              		.loc 1 963 7
 376 002c 002B     		cmp	r3, #0
 377 002e 02D1     		bne	.L21
 964:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 965:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portENABLE_INTERRUPTS();
 378              		.loc 1 965 9
 379 0030 0020     		movs	r0, #0
 380 0032 FFF7FEFF 		bl	vClearInterruptMask
 381              	.L21:
 966:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 967:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 382              		.loc 1 967 1
 383 0036 00BF     		nop
 384 0038 80BD     		pop	{r7, pc}
 385              	.L23:
 386 003a 00BF     		.align	2
 387              	.L22:
 388 003c 00000000 		.word	ulCriticalNesting
 389 0040 00000000 		.word	.LC0
 390 0044 00000000 		.word	__func__.4
 391 0048 04000000 		.word	.LC1
 392              		.cfi_endproc
 393              	.LFE5:
 395              		.section	.text.SysTick_Handler,"ax",%progbits
 396              		.align	1
 397              		.global	SysTick_Handler
 398              		.syntax unified
 399              		.thumb
 400              		.thumb_func
 402              	SysTick_Handler:
 403              	.LFB6:
 968:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 969:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 970:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void SysTick_Handler( void ) /* PRIVILEGED_FUNCTION */
 971:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 404              		.loc 1 971 1
 405              		.cfi_startproc
 406              		@ args = 0, pretend = 0, frame = 8
 407              		@ frame_needed = 1, uses_anonymous_args = 0
 408 0000 80B5     		push	{r7, lr}
 409              		.cfi_def_cfa_offset 8
 410              		.cfi_offset 7, -8
 411              		.cfi_offset 14, -4
ARM GAS  /tmp/ccsuQooq.s 			page 25


 412 0002 82B0     		sub	sp, sp, #8
 413              		.cfi_def_cfa_offset 16
 414 0004 00AF     		add	r7, sp, #0
 415              		.cfi_def_cfa_register 7
 972:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulPreviousMask;
 973:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 974:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
 416              		.loc 1 974 22
 417 0006 FFF7FEFF 		bl	ulSetInterruptMask
 418 000a 7860     		str	r0, [r7, #4]
 975:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 976:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Increment the RTOS tick. */
 977:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xTaskIncrementTick() != pdFALSE )
 419              		.loc 1 977 13
 420 000c FFF7FEFF 		bl	xTaskIncrementTick
 421 0010 0346     		mov	r3, r0
 422              		.loc 1 977 11 discriminator 1
 423 0012 002B     		cmp	r3, #0
 424 0014 03D0     		beq	.L25
 978:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 979:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Pend a context switch. */
 980:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 425              		.loc 1 980 13
 426 0016 054B     		ldr	r3, .L26
 427              		.loc 1 980 35
 428 0018 4FF08052 		mov	r2, #268435456
 429 001c 1A60     		str	r2, [r3]
 430              	.L25:
 981:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
 982:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 983:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
 431              		.loc 1 983 5
 432 001e 7868     		ldr	r0, [r7, #4]
 433 0020 FFF7FEFF 		bl	vClearInterruptMask
 984:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 434              		.loc 1 984 1
 435 0024 00BF     		nop
 436 0026 0837     		adds	r7, r7, #8
 437              		.cfi_def_cfa_offset 8
 438 0028 BD46     		mov	sp, r7
 439              		.cfi_def_cfa_register 13
 440              		@ sp needed
 441 002a 80BD     		pop	{r7, pc}
 442              	.L27:
 443              		.align	2
 444              	.L26:
 445 002c 04ED00E0 		.word	-536810236
 446              		.cfi_endproc
 447              	.LFE6:
 449              		.section	.text.vPortSVCHandler_C,"ax",%progbits
 450              		.align	1
 451              		.global	vPortSVCHandler_C
 452              		.syntax unified
 453              		.thumb
 454              		.thumb_func
 456              	vPortSVCHandler_C:
 457              	.LFB7:
ARM GAS  /tmp/ccsuQooq.s 			page 26


 985:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
 986:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
 987:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortSVCHandler_C( uint32_t * pulCallerStackAddress ) /* PRIVILEGED_FUNCTION portDONT_DISCARD 
 988:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 458              		.loc 1 988 1
 459              		.cfi_startproc
 460              		@ args = 0, pretend = 0, frame = 16
 461              		@ frame_needed = 1, uses_anonymous_args = 0
 462 0000 80B5     		push	{r7, lr}
 463              		.cfi_def_cfa_offset 8
 464              		.cfi_offset 7, -8
 465              		.cfi_offset 14, -4
 466 0002 84B0     		sub	sp, sp, #16
 467              		.cfi_def_cfa_offset 24
 468 0004 00AF     		add	r7, sp, #0
 469              		.cfi_def_cfa_register 7
 470 0006 7860     		str	r0, [r7, #4]
 989:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) )
 990:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
 991:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
 992:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
 993:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
 994:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
 995:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
 996:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
 997:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
 998:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
 999:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
1000:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) */
1001:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1002:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulPC;
1003:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1004:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configENABLE_TRUSTZONE == 1 )
1005:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulR0, ulR1;
1006:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1007:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_MPU == 1 )
1008:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             uint32_t ulControl, ulIsTaskPrivileged;
1009:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_MPU */
1010:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configENABLE_TRUSTZONE */
1011:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint8_t ucSVCNumber;
1012:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1013:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Register are stored on the stack in the following order - R0, R1, R2, R3,
1014:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * R12, LR, PC, xPSR. */
1015:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulPC = pulCallerStackAddress[ portOFFSET_TO_PC ];
 471              		.loc 1 1015 10
 472 0008 7B68     		ldr	r3, [r7, #4]
 473 000a 9B69     		ldr	r3, [r3, #24]
 474 000c FB60     		str	r3, [r7, #12]
1016:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ucSVCNumber = ( ( uint8_t * ) ulPC )[ -2 ];
 475              		.loc 1 1016 41
 476 000e FB68     		ldr	r3, [r7, #12]
 477 0010 023B     		subs	r3, r3, #2
 478              		.loc 1 1016 17
 479 0012 1B78     		ldrb	r3, [r3]
 480 0014 FB72     		strb	r3, [r7, #11]
1017:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1018:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     switch( ucSVCNumber )
ARM GAS  /tmp/ccsuQooq.s 			page 27


 481              		.loc 1 1018 5
 482 0016 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 483 0018 662B     		cmp	r3, #102
 484 001a 04D1     		bne	.L31
1019:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1020:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
1021:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_ALLOCATE_SECURE_CONTEXT:
1022:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1023:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* R0 contains the stack size passed as parameter to the
1024:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * vPortAllocateSecureContext function. */
1025:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR0 = pulCallerStackAddress[ 0 ];
1026:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1027:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #if ( configENABLE_MPU == 1 )
1028:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1029:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Read the CONTROL register value. */
1030:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile ( "mrs %0, control"  : "=r" ( ulControl ) );
1031:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1032:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* The task that raised the SVC is privileged if Bit[0]
1033:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                      * in the CONTROL register is 0. */
1034:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulIsTaskPrivileged = ( ( ulControl & portCONTROL_PRIVILEGED_MASK ) == 0 );
1035:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1036:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Allocate and load a context for the secure task. */
1037:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xSecureContext = SecureContext_AllocateContext( ulR0, ulIsTaskPrivileged, pxCur
1038:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1039:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #else /* if ( configENABLE_MPU == 1 ) */
1040:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1041:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Allocate and load a context for the secure task. */
1042:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xSecureContext = SecureContext_AllocateContext( ulR0, pxCurrentTCB );
1043:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1044:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 #endif /* configENABLE_MPU */
1045:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1046:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 configASSERT( xSecureContext != securecontextINVALID_CONTEXT_ID );
1047:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_LoadContext( xSecureContext, pxCurrentTCB );
1048:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1049:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1050:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_FREE_SECURE_CONTEXT:
1051:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1052:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* R0 contains TCB being freed and R1 contains the secure
1053:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * context handle to be freed. */
1054:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR0 = pulCallerStackAddress[ 0 ];
1055:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulR1 = pulCallerStackAddress[ 1 ];
1056:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1057:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Free the secure context. */
1058:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_FreeContext( ( SecureContextHandle_t ) ulR1, ( void * ) ulR0 );
1059:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1060:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
1061:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1062:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         case portSVC_START_SCHEDULER:
1063:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1064:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1065:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* De-prioritize the non-secure exceptions so that the
1066:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * non-secure pendSV runs at the lowest priority. */
1067:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureInit_DePrioritizeNSExceptions();
1068:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1069:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Initialize the secure context management system. */
1070:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 SecureContext_Init();
1071:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
ARM GAS  /tmp/ccsuQooq.s 			page 28


1072:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1073:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1074:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_FPU == 1 )
1075:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1076:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Setup the Floating Point Unit (FPU). */
1077:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 prvSetupFPU();
 485              		.loc 1 1077 17
 486 001c FFF7FEFF 		bl	prvSetupFPU
1078:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1079:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_FPU */
1080:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1081:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Setup the context of the first task so that the first task starts
1082:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * executing. */
1083:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             vRestoreContextOfFirstTask();
 487              		.loc 1 1083 13
 488 0020 FFF7FEFF 		bl	vRestoreContextOfFirstTask
1084:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             break;
 489              		.loc 1 1084 13
 490 0024 08E0     		b	.L32
 491              	.L31:
1085:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1086:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) )
1087:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             case portSVC_RAISE_PRIVILEGE:
1088:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1089:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Only raise the privilege, if the svc was raised from any of
1090:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * the system calls. */
1091:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulPC >= ( uint32_t ) __syscalls_flash_start__ ) &&
1092:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ( ulPC <= ( uint32_t ) __syscalls_flash_end__ ) )
1093:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1094:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     vRaisePrivilege();
1095:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1096:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 break;
1097:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 1 ) */
1098:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1099:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         default:
1100:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Incorrect SVC call. */
1101:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( pdFALSE );
 492              		.loc 1 1101 13 discriminator 1
 493 0026 FFF7FEFF 		bl	ulSetInterruptMask
 494 002a 054B     		ldr	r3, .L33
 495 002c 054A     		ldr	r2, .L33+4
 496 002e 40F24D41 		movw	r1, #1101
 497 0032 0548     		ldr	r0, .L33+8
 498 0034 FFF7FEFF 		bl	__assert_func
 499              	.L32:
1102:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1103:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 500              		.loc 1 1103 1
 501 0038 00BF     		nop
 502 003a 1037     		adds	r7, r7, #16
 503              		.cfi_def_cfa_offset 8
 504 003c BD46     		mov	sp, r7
 505              		.cfi_def_cfa_register 13
 506              		@ sp needed
 507 003e 80BD     		pop	{r7, pc}
 508              	.L34:
 509              		.align	2
ARM GAS  /tmp/ccsuQooq.s 			page 29


 510              	.L33:
 511 0040 00000000 		.word	.LC0
 512 0044 00000000 		.word	__func__.3
 513 0048 04000000 		.word	.LC1
 514              		.cfi_endproc
 515              	.LFE7:
 517              		.section	.text.pxPortInitialiseStack,"ax",%progbits
 518              		.align	1
 519              		.global	pxPortInitialiseStack
 520              		.syntax unified
 521              		.thumb
 522              		.thumb_func
 524              	pxPortInitialiseStack:
 525              	.LFB8:
1104:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1105:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1106:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1107:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1108:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallEnter( uint32_t * pulTaskStack,
1109:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint32_t ulLR,
1110:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                            uint8_t ucSystemCallNumber ) /* PRIVILEGED_FUNCTION */
1111:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1112:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1113:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern UBaseType_t uxSystemCallImplementations[ NUM_SYSTEM_CALLS ];
1114:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPU_SETTINGS * pxMpuSettings;
1115:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t * pulSystemCallStack;
1116:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulStackFrameSize, ulSystemCallLocation, i;
1117:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1118:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1119:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1120:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1121:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_start__;
1122:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __syscalls_flash_end__;
1123:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1124:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1125:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_start__[];
1126:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __syscalls_flash_end__[];
1127:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* #if defined( __ARMCC_VERSION ) */
1128:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1129:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulSystemCallLocation = pulTaskStack[ portOFFSET_TO_PC ];
1130:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         pxMpuSettings = xTaskGetMPUSettings( pxCurrentTCB );
1131:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1132:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Checks:
1133:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 1. SVC is raised from the system call section (i.e. application is
1134:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    not raising SVC directly).
1135:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 2. pxMpuSettings->xSystemCallStackInfo.pulTaskStack must be NULL as
1136:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    it is non-NULL only during the execution of a system call (i.e.
1137:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    between system call enter and exit).
1138:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 3. System call is not for a kernel API disabled by the configuration
1139:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    in FreeRTOSConfig.h.
1140:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 4. We do not need to check that ucSystemCallNumber is within range
1141:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    because the assembly SVC handler checks that before calling
1142:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    this function.
1143:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          */
1144:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulSystemCallLocation >= ( uint32_t ) __syscalls_flash_start__ ) &&
1145:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( ulSystemCallLocation <= ( uint32_t ) __syscalls_flash_end__ ) &&
1146:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( pxMpuSettings->xSystemCallStackInfo.pulTaskStack == NULL ) &&
ARM GAS  /tmp/ccsuQooq.s 			page 30


1147:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( uxSystemCallImplementations[ ucSystemCallNumber ] != ( UBaseType_t ) 0 ) )
1148:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1149:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack = pxMpuSettings->xSystemCallStackInfo.pulSystemCallStack;
1150:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1151:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) )
1152:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1153:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulLR & portEXC_RETURN_STACK_FRAME_TYPE_MASK ) == 0UL )
1154:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1155:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Extended frame i.e. FPU in use. */
1156:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 26;
1157:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile
1158:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     (
1159:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpush {s0}         \n" /* Trigger lazy stacking. */
1160:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpop  {s0}         \n" /* Nullify the affect of the above instruction. */
1161:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ::: "memory"
1162:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     );
1163:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1164:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1165:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1166:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Standard frame i.e. FPU not in use. */
1167:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 8;
1168:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1169:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1170:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1171:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1172:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulStackFrameSize = 8;
1173:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1174:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1175:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1176:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Make space on the system call stack for the stack frame. */
1177:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack = pulSystemCallStack - ulStackFrameSize;
1178:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1179:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Copy the stack frame. */
1180:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             for( i = 0; i < ulStackFrameSize; i++ )
1181:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1182:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulSystemCallStack[ i ] = pulTaskStack[ i ];
1183:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1184:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1185:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Store the value of the Link Register before the SVC was raised.
1186:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * It contains the address of the caller of the System Call entry
1187:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * point (i.e. the caller of the MPU_<API>). We need to restore it
1188:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * when we exit from the system call. */
1189:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAtSystemCallEntry = pulTaskStack[ por
1190:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1191:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Store the value of the PSPLIM register before the SVC was raised.
1192:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * We need to restore it when we exit from the system call. */
1193:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "mrs %0, psplim" : "=r" ( pxMpuSettings->xSystemCallStackInfo.ulStackL
1194:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1195:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the pulSystemCallStack in thread mode. */
1196:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psp, %0" : : "r" ( pulSystemCallStack ) );
1197:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psplim, %0" : : "r" ( pxMpuSettings->xSystemCallStackInfo.pulSyst
1198:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1199:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Start executing the system call upon returning from this handler. */
1200:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_PC ] = uxSystemCallImplementations[ ucSystemCallNumbe
1201:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1202:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Raise a request to exit from the system call upon finishing the
1203:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * system call. */
ARM GAS  /tmp/ccsuQooq.s 			page 31


1204:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_LR ] = ( uint32_t ) vRequestSystemCallExit;
1205:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1206:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Remember the location where we should copy the stack frame when we exit from
1207:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the system call. */
1208:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.pulTaskStack = pulTaskStack + ulStackFrameSize;
1209:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1210:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Record if the hardware used padding to force the stack pointer
1211:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to be double word aligned. */
1212:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( pulTaskStack[ portOFFSET_TO_PSR ] & portPSR_STACK_PADDING_MASK ) == portPSR_STACK
1213:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1214:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxMpuSettings->ulTaskFlags |= portSTACK_FRAME_HAS_PADDING_FLAG;
1215:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1216:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1217:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1218:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxMpuSettings->ulTaskFlags &= ( ~portSTACK_FRAME_HAS_PADDING_FLAG );
1219:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1220:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1221:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* We ensure in pxPortInitialiseStack that the system call stack is
1222:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * double word aligned and therefore, there is no need of padding.
1223:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Clear the bit[9] of stacked xPSR. */
1224:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulSystemCallStack[ portOFFSET_TO_PSR ] &= ( ~portPSR_STACK_PADDING_MASK );
1225:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1226:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Raise the privilege for the duration of the system call. */
1227:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile
1228:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             (
1229:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " mrs r0, control     \n" /* Obtain current control value. */
1230:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " movs r1, #1         \n" /* r1 = 1. */
1231:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " bics r0, r1         \n" /* Clear nPRIV bit. */
1232:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " msr control, r0     \n" /* Write back new control value. */
1233:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ::: "r0", "r1", "memory"
1234:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             );
1235:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1236:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1237:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1238:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1239:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1240:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1241:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1242:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1243:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vRequestSystemCallExit( void ) /* __attribute__( ( naked ) ) PRIVILEGED_FUNCTION */
1244:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1245:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "svc %0 \n" ::"i" ( portSVC_SYSTEM_CALL_EXIT ) : "memory" );
1246:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1247:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1248:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1249:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1250:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1251:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) )
1252:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1253:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vSystemCallExit( uint32_t * pulSystemCallStack,
1254:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                           uint32_t ulLR ) /* PRIVILEGED_FUNCTION */
1255:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1256:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         extern TaskHandle_t pxCurrentTCB;
1257:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPU_SETTINGS * pxMpuSettings;
1258:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t * pulTaskStack;
1259:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulStackFrameSize, ulSystemCallLocation, i;
1260:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/ccsuQooq.s 			page 32


1261:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1262:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1263:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1264:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_start__;
1265:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_functions_end__;
1266:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1267:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1268:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_start__[];
1269:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_functions_end__[];
1270:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* #if defined( __ARMCC_VERSION ) */
1271:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1272:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulSystemCallLocation = pulSystemCallStack[ portOFFSET_TO_PC ];
1273:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         pxMpuSettings = xTaskGetMPUSettings( pxCurrentTCB );
1274:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1275:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Checks:
1276:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 1. SVC is raised from the privileged code (i.e. application is not
1277:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    raising SVC directly). This SVC is only raised from
1278:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    vRequestSystemCallExit which is in the privileged code section.
1279:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * 2. pxMpuSettings->xSystemCallStackInfo.pulTaskStack must not be NULL -
1280:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    this means that we previously entered a system call and the
1281:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    application is not attempting to exit without entering a system
1282:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *    call.
1283:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          */
1284:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( ulSystemCallLocation >= ( uint32_t ) __privileged_functions_start__ ) &&
1285:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( ulSystemCallLocation <= ( uint32_t ) __privileged_functions_end__ ) &&
1286:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ( pxMpuSettings->xSystemCallStackInfo.pulTaskStack != NULL ) )
1287:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1288:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack = pxMpuSettings->xSystemCallStackInfo.pulTaskStack;
1289:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1290:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) )
1291:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1292:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( ulLR & portEXC_RETURN_STACK_FRAME_TYPE_MASK ) == 0UL )
1293:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1294:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Extended frame i.e. FPU in use. */
1295:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 26;
1296:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     __asm volatile
1297:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     (
1298:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpush {s0}         \n" /* Trigger lazy stacking. */
1299:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         " vpop  {s0}         \n" /* Nullify the affect of the above instruction. */
1300:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         ::: "memory"
1301:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     );
1302:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1303:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1304:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1305:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Standard frame i.e. FPU not in use. */
1306:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     ulStackFrameSize = 8;
1307:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1308:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1309:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #else /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1310:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1311:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulStackFrameSize = 8;
1312:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1313:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* if ( ( configENABLE_FPU == 1 ) || ( configENABLE_MVE == 1 ) ) */
1314:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1315:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Make space on the task stack for the stack frame. */
1316:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack = pulTaskStack - ulStackFrameSize;
1317:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/ccsuQooq.s 			page 33


1318:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Copy the stack frame. */
1319:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             for( i = 0; i < ulStackFrameSize; i++ )
1320:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1321:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ i ] = pulSystemCallStack[ i ];
1322:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1323:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1324:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Use the pulTaskStack in thread mode. */
1325:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psp, %0" : : "r" ( pulTaskStack ) );
1326:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1327:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Return to the caller of the System Call entry point (i.e. the
1328:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * caller of the MPU_<API>). */
1329:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack[ portOFFSET_TO_PC ] = pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAt
1330:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Ensure that LR has a valid value.*/
1331:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pulTaskStack[ portOFFSET_TO_LR ] = pxMpuSettings->xSystemCallStackInfo.ulLinkRegisterAt
1332:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1333:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Restore the PSPLIM register to what it was at the time of
1334:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * system call entry. */
1335:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile ( "msr psplim, %0" : : "r" ( pxMpuSettings->xSystemCallStackInfo.ulStack
1336:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1337:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If the hardware used padding to force the stack pointer
1338:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to be double word aligned, set the stacked xPSR bit[9],
1339:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * otherwise clear it. */
1340:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( pxMpuSettings->ulTaskFlags & portSTACK_FRAME_HAS_PADDING_FLAG ) == portSTACK_FRAM
1341:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1342:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ portOFFSET_TO_PSR ] |= portPSR_STACK_PADDING_MASK;
1343:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1344:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1345:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1346:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pulTaskStack[ portOFFSET_TO_PSR ] &= ( ~portPSR_STACK_PADDING_MASK );
1347:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1348:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1349:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* This is not NULL only for the duration of the system call. */
1350:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxMpuSettings->xSystemCallStackInfo.pulTaskStack = NULL;
1351:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1352:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Drop the privilege before returning to the thread mode. */
1353:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             __asm volatile
1354:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             (
1355:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " mrs r0, control     \n" /* Obtain current control value. */
1356:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " movs r1, #1         \n" /* r1 = 1. */
1357:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " orrs r0, r1         \n" /* Set nPRIV bit. */
1358:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 " msr control, r0     \n" /* Write back new control value. */
1359:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ::: "r0", "r1", "memory"
1360:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             );
1361:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1362:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1363:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1364:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) */
1365:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1366:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1367:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1368:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1369:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsTaskPrivileged( void ) /* PRIVILEGED_FUNCTION */
1370:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1371:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         BaseType_t xTaskIsPrivileged = pdFALSE;
1372:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU
1373:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1374:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEG
ARM GAS  /tmp/ccsuQooq.s 			page 34


1375:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1376:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xTaskIsPrivileged = pdTRUE;
1377:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1378:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1379:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return xTaskIsPrivileged;
1380:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1381:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1382:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU == 1 */
1383:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1384:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1385:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1386:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1387:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
1388:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          StackType_t * pxEndOfStack,
1389:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          TaskFunction_t pxCode,
1390:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          void * pvParameters,
1391:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          BaseType_t xRunPrivileged,
1392:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          xMPU_SETTINGS * xMPUSettings ) /* PRIVILEGED_FUNCTION */
1393:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1394:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulIndex = 0;
1395:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1396:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x04040404; /* r4. */
1397:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1398:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x05050505; /* r5. */
1399:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1400:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x06060606; /* r6. */
1401:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1402:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x07070707; /* r7. */
1403:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1404:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x08080808; /* r8. */
1405:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1406:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x09090909; /* r9. */
1407:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1408:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x10101010; /* r10. */
1409:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1410:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x11111111; /* r11. */
1411:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1412:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1413:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pvParameters; /* r0. */
1414:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1415:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x01010101; /* r1. */
1416:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1417:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x02020202; /* r2. */
1418:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1419:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x03030303; /* r3. */
1420:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1421:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = 0x12121212; /* r12. */
1422:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1423:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portTASK_RETURN_ADDRESS; /* LR. */
1424:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1425:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxCode; /* PC. */
1426:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1427:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_XPSR; /* xPSR. */
1428:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1429:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1430:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configENABLE_TRUSTZONE == 1 )
1431:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
ARM GAS  /tmp/ccsuQooq.s 			page 35


1432:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = portNO_SECURE_CONTEXT; /* xSecureContext. */
1433:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1434:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1435:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configENABLE_TRUSTZONE */
1436:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) ( pxTopOfStack - 8 ); /* PSP with the har
1437:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1438:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) pxEndOfStack; /* PSPLIM. */
1439:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1440:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( xRunPrivileged == pdTRUE )
1441:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1442:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
1443:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_PRIVILEGED; /* CO
1444:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1445:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1446:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1447:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1448:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulTaskFlags &= ( ~portTASK_IS_PRIVILEGED_FLAG );
1449:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->ulContext[ ulIndex ] = ( uint32_t ) portINITIAL_CONTROL_UNPRIVILEGED; /* 
1450:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulIndex++;
1451:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1452:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulContext[ ulIndex ] = portINITIAL_EXC_RETURN; /* LR (EXC_RETURN). */
1453:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulIndex++;
1454:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1455:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( configUSE_MPU_WRAPPERS_V1 == 0 )
1456:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1457:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Ensure that the system call stack is double word aligned. */
1458:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStack = &( xMPUSettings->xSystemCallSta
1459:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStack = ( uint32_t * ) ( ( uint32_t ) (
1460:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                      ( uint32_t ) (
1461:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1462:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStackLimit = &( xMPUSettings->xSystemCa
1463:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulSystemCallStackLimit = ( uint32_t * ) ( ( ( uint3
1464:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                             ( uint3
1465:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                                           ( uint32_
1466:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1467:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* This is not NULL only for the duration of a system call. */
1468:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xMPUSettings->xSystemCallStackInfo.pulTaskStack = NULL;
1469:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1470:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* configUSE_MPU_WRAPPERS_V1 == 0 */
1471:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1472:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return &( xMPUSettings->ulContext[ ulIndex ] );
1473:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1474:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1475:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #else /* configENABLE_MPU */
1476:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1477:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
1478:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          StackType_t * pxEndOfStack,
1479:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          TaskFunction_t pxCode,
1480:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                          void * pvParameters ) /* PRIVILEGED_FUNCTION */
1481:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 526              		.loc 1 1481 5
 527              		.cfi_startproc
 528              		@ args = 0, pretend = 0, frame = 16
 529              		@ frame_needed = 1, uses_anonymous_args = 0
 530              		@ link register save eliminated.
 531 0000 80B4     		push	{r7}
 532              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/ccsuQooq.s 			page 36


 533              		.cfi_offset 7, -4
 534 0002 85B0     		sub	sp, sp, #20
 535              		.cfi_def_cfa_offset 24
 536 0004 00AF     		add	r7, sp, #0
 537              		.cfi_def_cfa_register 7
 538 0006 F860     		str	r0, [r7, #12]
 539 0008 B960     		str	r1, [r7, #8]
 540 000a 7A60     		str	r2, [r7, #4]
 541 000c 3B60     		str	r3, [r7]
1482:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Simulate the stack frame as it would be created by a context switch
1483:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * interrupt. */
1484:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if ( portPRELOAD_REGISTERS == 0 )
1485:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1486:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/
1487:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR. */
1488:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1489:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC. */
1490:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1491:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
1492:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack -= 5;                                       /* R12, R3, R2 and R1. */
1493:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0. */
1494:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack -= 9;                                       /* R11..R4, EXC_RETURN. */
1495:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_EXC_RETURN;
1496:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
1497:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxEndOfStack; /* Slot used to hold this task's PSPLIM v
1498:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1499:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1500:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1501:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxTopOfStack--;
1502:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 *pxTopOfStack = portNO_SECURE_CONTEXT; /* Slot used to hold this task's xSecureCont
1503:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1504:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1505:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1506:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else /* portPRELOAD_REGISTERS */
1507:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1508:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/
 542              		.loc 1 1508 25
 543 000e FB68     		ldr	r3, [r7, #12]
 544 0010 043B     		subs	r3, r3, #4
 545 0012 FB60     		str	r3, [r7, #12]
1509:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_XPSR;                        /* xPSR. */
 546              		.loc 1 1509 27
 547 0014 FB68     		ldr	r3, [r7, #12]
 548 0016 4FF08072 		mov	r2, #16777216
 549 001a 1A60     		str	r2, [r3]
1510:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 550              		.loc 1 1510 25
 551 001c FB68     		ldr	r3, [r7, #12]
 552 001e 043B     		subs	r3, r3, #4
 553 0020 FB60     		str	r3, [r7, #12]
1511:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxCode;                  /* PC. */
 554              		.loc 1 1511 29
 555 0022 7A68     		ldr	r2, [r7, #4]
 556              		.loc 1 1511 27
 557 0024 FB68     		ldr	r3, [r7, #12]
 558 0026 1A60     		str	r2, [r3]
1512:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
ARM GAS  /tmp/ccsuQooq.s 			page 37


 559              		.loc 1 1512 25
 560 0028 FB68     		ldr	r3, [r7, #12]
 561 002a 043B     		subs	r3, r3, #4
 562 002c FB60     		str	r3, [r7, #12]
1513:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
 563              		.loc 1 1513 29
 564 002e 384A     		ldr	r2, .L37
 565              		.loc 1 1513 27
 566 0030 FB68     		ldr	r3, [r7, #12]
 567 0032 1A60     		str	r2, [r3]
1514:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 568              		.loc 1 1514 25
 569 0034 FB68     		ldr	r3, [r7, #12]
 570 0036 043B     		subs	r3, r3, #4
 571 0038 FB60     		str	r3, [r7, #12]
1515:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x12121212UL;            /* R12. */
 572              		.loc 1 1515 27
 573 003a FB68     		ldr	r3, [r7, #12]
 574 003c 4FF01232 		mov	r2, #303174162
 575 0040 1A60     		str	r2, [r3]
1516:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 576              		.loc 1 1516 25
 577 0042 FB68     		ldr	r3, [r7, #12]
 578 0044 043B     		subs	r3, r3, #4
 579 0046 FB60     		str	r3, [r7, #12]
1517:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x03030303UL;            /* R3. */
 580              		.loc 1 1517 27
 581 0048 FB68     		ldr	r3, [r7, #12]
 582 004a 4FF00332 		mov	r2, #50529027
 583 004e 1A60     		str	r2, [r3]
1518:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 584              		.loc 1 1518 25
 585 0050 FB68     		ldr	r3, [r7, #12]
 586 0052 043B     		subs	r3, r3, #4
 587 0054 FB60     		str	r3, [r7, #12]
1519:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x02020202UL;            /* R2. */
 588              		.loc 1 1519 27
 589 0056 FB68     		ldr	r3, [r7, #12]
 590 0058 4FF00232 		mov	r2, #33686018
 591 005c 1A60     		str	r2, [r3]
1520:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 592              		.loc 1 1520 25
 593 005e FB68     		ldr	r3, [r7, #12]
 594 0060 043B     		subs	r3, r3, #4
 595 0062 FB60     		str	r3, [r7, #12]
1521:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x01010101UL;            /* R1. */
 596              		.loc 1 1521 27
 597 0064 FB68     		ldr	r3, [r7, #12]
 598 0066 4FF00132 		mov	r2, #16843009
 599 006a 1A60     		str	r2, [r3]
1522:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 600              		.loc 1 1522 25
 601 006c FB68     		ldr	r3, [r7, #12]
 602 006e 043B     		subs	r3, r3, #4
 603 0070 FB60     		str	r3, [r7, #12]
1523:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pvParameters;            /* R0. */
 604              		.loc 1 1523 29
ARM GAS  /tmp/ccsuQooq.s 			page 38


 605 0072 3A68     		ldr	r2, [r7]
 606              		.loc 1 1523 27
 607 0074 FB68     		ldr	r3, [r7, #12]
 608 0076 1A60     		str	r2, [r3]
1524:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 609              		.loc 1 1524 25
 610 0078 FB68     		ldr	r3, [r7, #12]
 611 007a 043B     		subs	r3, r3, #4
 612 007c FB60     		str	r3, [r7, #12]
1525:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x11111111UL;            /* R11. */
 613              		.loc 1 1525 27
 614 007e FB68     		ldr	r3, [r7, #12]
 615 0080 4FF01132 		mov	r2, #286331153
 616 0084 1A60     		str	r2, [r3]
1526:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 617              		.loc 1 1526 25
 618 0086 FB68     		ldr	r3, [r7, #12]
 619 0088 043B     		subs	r3, r3, #4
 620 008a FB60     		str	r3, [r7, #12]
1527:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x10101010UL;            /* R10. */
 621              		.loc 1 1527 27
 622 008c FB68     		ldr	r3, [r7, #12]
 623 008e 4FF01032 		mov	r2, #269488144
 624 0092 1A60     		str	r2, [r3]
1528:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 625              		.loc 1 1528 25
 626 0094 FB68     		ldr	r3, [r7, #12]
 627 0096 043B     		subs	r3, r3, #4
 628 0098 FB60     		str	r3, [r7, #12]
1529:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x09090909UL;            /* R09. */
 629              		.loc 1 1529 27
 630 009a FB68     		ldr	r3, [r7, #12]
 631 009c 4FF00932 		mov	r2, #151587081
 632 00a0 1A60     		str	r2, [r3]
1530:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 633              		.loc 1 1530 25
 634 00a2 FB68     		ldr	r3, [r7, #12]
 635 00a4 043B     		subs	r3, r3, #4
 636 00a6 FB60     		str	r3, [r7, #12]
1531:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x08080808UL;            /* R08. */
 637              		.loc 1 1531 27
 638 00a8 FB68     		ldr	r3, [r7, #12]
 639 00aa 4FF00832 		mov	r2, #134744072
 640 00ae 1A60     		str	r2, [r3]
1532:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 641              		.loc 1 1532 25
 642 00b0 FB68     		ldr	r3, [r7, #12]
 643 00b2 043B     		subs	r3, r3, #4
 644 00b4 FB60     		str	r3, [r7, #12]
1533:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x07070707UL;            /* R07. */
 645              		.loc 1 1533 27
 646 00b6 FB68     		ldr	r3, [r7, #12]
 647 00b8 4FF00732 		mov	r2, #117901063
 648 00bc 1A60     		str	r2, [r3]
1534:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 649              		.loc 1 1534 25
 650 00be FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccsuQooq.s 			page 39


 651 00c0 043B     		subs	r3, r3, #4
 652 00c2 FB60     		str	r3, [r7, #12]
1535:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x06060606UL;            /* R06. */
 653              		.loc 1 1535 27
 654 00c4 FB68     		ldr	r3, [r7, #12]
 655 00c6 4FF00632 		mov	r2, #101058054
 656 00ca 1A60     		str	r2, [r3]
1536:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 657              		.loc 1 1536 25
 658 00cc FB68     		ldr	r3, [r7, #12]
 659 00ce 043B     		subs	r3, r3, #4
 660 00d0 FB60     		str	r3, [r7, #12]
1537:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x05050505UL;            /* R05. */
 661              		.loc 1 1537 27
 662 00d2 FB68     		ldr	r3, [r7, #12]
 663 00d4 4FF00532 		mov	r2, #84215045
 664 00d8 1A60     		str	r2, [r3]
1538:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 665              		.loc 1 1538 25
 666 00da FB68     		ldr	r3, [r7, #12]
 667 00dc 043B     		subs	r3, r3, #4
 668 00de FB60     		str	r3, [r7, #12]
1539:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) 0x04040404UL;            /* R04. */
 669              		.loc 1 1539 27
 670 00e0 FB68     		ldr	r3, [r7, #12]
 671 00e2 4FF00432 		mov	r2, #67372036
 672 00e6 1A60     		str	r2, [r3]
1540:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 673              		.loc 1 1540 25
 674 00e8 FB68     		ldr	r3, [r7, #12]
 675 00ea 043B     		subs	r3, r3, #4
 676 00ec FB60     		str	r3, [r7, #12]
1541:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = portINITIAL_EXC_RETURN;                  /* EXC_RETURN. */
 677              		.loc 1 1541 27
 678 00ee FB68     		ldr	r3, [r7, #12]
 679 00f0 6FF00202 		mvn	r2, #2
 680 00f4 1A60     		str	r2, [r3]
1542:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             pxTopOfStack--;
 681              		.loc 1 1542 25
 682 00f6 FB68     		ldr	r3, [r7, #12]
 683 00f8 043B     		subs	r3, r3, #4
 684 00fa FB60     		str	r3, [r7, #12]
1543:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             *pxTopOfStack = ( StackType_t ) pxEndOfStack; /* Slot used to hold this task's PSPLIM v
 685              		.loc 1 1543 29
 686 00fc BA68     		ldr	r2, [r7, #8]
 687              		.loc 1 1543 27
 688 00fe FB68     		ldr	r3, [r7, #12]
 689 0100 1A60     		str	r2, [r3]
1544:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1545:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #if ( configENABLE_TRUSTZONE == 1 )
1546:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1547:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 pxTopOfStack--;
1548:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 *pxTopOfStack = portNO_SECURE_CONTEXT; /* Slot used to hold this task's xSecureCont
1549:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1550:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             #endif /* configENABLE_TRUSTZONE */
1551:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1552:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* portPRELOAD_REGISTERS */
ARM GAS  /tmp/ccsuQooq.s 			page 40


1553:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1554:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return pxTopOfStack;
 690              		.loc 1 1554 16
 691 0102 FB68     		ldr	r3, [r7, #12]
1555:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 692              		.loc 1 1555 5
 693 0104 1846     		mov	r0, r3
 694 0106 1437     		adds	r7, r7, #20
 695              		.cfi_def_cfa_offset 4
 696 0108 BD46     		mov	sp, r7
 697              		.cfi_def_cfa_register 13
 698              		@ sp needed
 699 010a 5DF8047B 		ldr	r7, [sp], #4
 700              		.cfi_restore 7
 701              		.cfi_def_cfa_offset 0
 702 010e 7047     		bx	lr
 703              	.L38:
 704              		.align	2
 705              	.L37:
 706 0110 00000000 		.word	prvTaskExitError
 707              		.cfi_endproc
 708              	.LFE8:
 710              		.section	.text.xPortStartScheduler,"ax",%progbits
 711              		.align	1
 712              		.global	xPortStartScheduler
 713              		.syntax unified
 714              		.thumb
 715              		.thumb_func
 717              	xPortStartScheduler:
 718              	.LFB9:
1556:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1557:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1558:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1559:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1560:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortStartScheduler( void ) /* PRIVILEGED_FUNCTION */
1561:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 719              		.loc 1 1561 1
 720              		.cfi_startproc
 721              		@ args = 0, pretend = 0, frame = 16
 722              		@ frame_needed = 1, uses_anonymous_args = 0
 723 0000 80B5     		push	{r7, lr}
 724              		.cfi_def_cfa_offset 8
 725              		.cfi_offset 7, -8
 726              		.cfi_offset 14, -4
 727 0002 84B0     		sub	sp, sp, #16
 728              		.cfi_def_cfa_offset 24
 729 0004 00AF     		add	r7, sp, #0
 730              		.cfi_def_cfa_register 7
 731              	.LBB2:
1562:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
1563:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1564:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint32_t ulOriginalPriority;
1565:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint32_t ulImplementedPrioBits = 0;
 732              		.loc 1 1565 27
 733 0006 0023     		movs	r3, #0
 734 0008 BB60     		str	r3, [r7, #8]
1566:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         volatile uint8_t ucMaxPriorityValue;
ARM GAS  /tmp/ccsuQooq.s 			page 41


1567:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1568:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Determine the maximum priority from which ISR safe FreeRTOS API
1569:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * functions can be called.  ISR safe functions are those that end in
1570:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
1571:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * ensure interrupt entry is as fast and simple as possible.
1572:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *
1573:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * Save the interrupt priority value that is about to be clobbered. */
1574:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulOriginalPriority = portNVIC_SHPR2_REG;
 735              		.loc 1 1574 30
 736 000a 3A4B     		ldr	r3, .L47
 737 000c 1B68     		ldr	r3, [r3]
 738              		.loc 1 1574 28
 739 000e FB60     		str	r3, [r7, #12]
1575:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1576:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Determine the number of priority bits available.  First write to all
1577:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * possible bits. */
1578:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portNVIC_SHPR2_REG = 0xFF000000;
 740              		.loc 1 1578 9
 741 0010 384B     		ldr	r3, .L47
 742              		.loc 1 1578 28
 743 0012 4FF07F42 		mov	r2, #-16777216
 744 0016 1A60     		str	r2, [r3]
1579:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1580:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Read the value back to see how many bits stuck. */
1581:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ucMaxPriorityValue = ( uint8_t ) ( ( portNVIC_SHPR2_REG & 0xFF000000 ) >> 24 );
 745              		.loc 1 1581 46
 746 0018 364B     		ldr	r3, .L47
 747 001a 1B68     		ldr	r3, [r3]
 748              		.loc 1 1581 80
 749 001c 1B0E     		lsrs	r3, r3, #24
 750              		.loc 1 1581 30
 751 001e DBB2     		uxtb	r3, r3
 752              		.loc 1 1581 28
 753 0020 FB71     		strb	r3, [r7, #7]
1582:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1583:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Use the same mask on the maximum system call priority. */
1584:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 754              		.loc 1 1584 69
 755 0022 FB79     		ldrb	r3, [r7, #7]
 756 0024 DBB2     		uxtb	r3, r3
 757 0026 03F05003 		and	r3, r3, #80
 758 002a DAB2     		uxtb	r2, r3
 759              		.loc 1 1584 30
 760 002c 324B     		ldr	r3, .L47+4
 761 002e 1A70     		strb	r2, [r3]
1585:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1586:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the maximum system call priority is nonzero after
1587:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * accounting for the number of priority bits supported by the
1588:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * hardware. A priority of 0 is invalid because setting the BASEPRI
1589:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * register to 0 unmasks all interrupts, and interrupts with priority 0
1590:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * cannot be masked using BASEPRI.
1591:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * See https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1592:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ucMaxSysCallPriority );
 762              		.loc 1 1592 9
 763 0030 314B     		ldr	r3, .L47+4
 764 0032 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 765 0034 002B     		cmp	r3, #0
ARM GAS  /tmp/ccsuQooq.s 			page 42


 766 0036 08D1     		bne	.L40
 767              		.loc 1 1592 9 is_stmt 0 discriminator 1
 768 0038 FFF7FEFF 		bl	ulSetInterruptMask
 769 003c 2F4B     		ldr	r3, .L47+8
 770 003e 304A     		ldr	r2, .L47+12
 771 0040 4FF4C761 		mov	r1, #1592
 772 0044 2F48     		ldr	r0, .L47+16
 773 0046 FFF7FEFF 		bl	__assert_func
 774              	.L40:
1593:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1594:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Check that the bits not implemented in hardware are zero in
1595:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * configMAX_SYSCALL_INTERRUPT_PRIORITY. */
1596:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & ( ~ucMaxPriorityValue ) ) == 0U );
 775              		.loc 1 1596 9 is_stmt 1
 776 004a FB79     		ldrb	r3, [r7, #7]
 777 004c DBB2     		uxtb	r3, r3
 778 004e DB43     		mvns	r3, r3
 779 0050 03F05003 		and	r3, r3, #80
 780 0054 002B     		cmp	r3, #0
 781 0056 10D0     		beq	.L42
 782              		.loc 1 1596 9 is_stmt 0 discriminator 1
 783 0058 FFF7FEFF 		bl	ulSetInterruptMask
 784 005c 274B     		ldr	r3, .L47+8
 785 005e 284A     		ldr	r2, .L47+12
 786 0060 40F23C61 		movw	r1, #1596
 787 0064 2748     		ldr	r0, .L47+16
 788 0066 FFF7FEFF 		bl	__assert_func
 789              	.L43:
1597:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1598:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Calculate the maximum acceptable priority group value for the number
1599:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * of bits read back. */
1600:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
1602:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1603:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulImplementedPrioBits++;
 790              		.loc 1 1603 34 is_stmt 1
 791 006a BB68     		ldr	r3, [r7, #8]
 792 006c 0133     		adds	r3, r3, #1
 793 006e BB60     		str	r3, [r7, #8]
1604:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 794              		.loc 1 1604 32
 795 0070 FB79     		ldrb	r3, [r7, #7]
 796 0072 DBB2     		uxtb	r3, r3
 797 0074 5B00     		lsls	r3, r3, #1
 798 0076 DBB2     		uxtb	r3, r3
 799 0078 FB71     		strb	r3, [r7, #7]
 800              	.L42:
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 801              		.loc 1 1601 37
 802 007a FB79     		ldrb	r3, [r7, #7]
 803 007c DBB2     		uxtb	r3, r3
 804 007e 03F08003 		and	r3, r3, #128
1601:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
 805              		.loc 1 1601 61
 806 0082 802B     		cmp	r3, #128
 807 0084 F1D0     		beq	.L43
1605:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
ARM GAS  /tmp/ccsuQooq.s 			page 43


1606:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1607:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulImplementedPrioBits == 8 )
 808              		.loc 1 1607 35
 809 0086 BB68     		ldr	r3, [r7, #8]
 810              		.loc 1 1607 11
 811 0088 082B     		cmp	r3, #8
 812 008a 03D1     		bne	.L44
1608:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1609:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* When the hardware implements 8 priority bits, there is no way for
1610:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * the software to configure PRIGROUP to not have sub-priorities. As
1611:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * a result, the least significant bit is always used for sub-priority
1612:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and there are 128 preemption priorities and 2 sub-priorities.
1613:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1614:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * This may cause some confusion in some cases - for example, if
1615:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY is set to 5, both 5 and 4
1616:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * priority interrupts will be masked in Critical Sections as those
1617:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * are at the same preemption priority. This may appear confusing as
1618:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * 4 is higher (numerically lower) priority than
1619:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY and therefore, should not
1620:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * have been masked. Instead, if we set configMAX_SYSCALL_INTERRUPT_PRIORITY
1621:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * to 4, this confusion does not happen and the behaviour remains the same.
1622:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1623:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * The following assert ensures that the sub-priority bit in the
1624:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY is clear to avoid the above mentioned
1625:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * confusion. */
1626:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( ( configMAX_SYSCALL_INTERRUPT_PRIORITY & 0x1U ) == 0U );
1627:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulMaxPRIGROUPValue = 0;
 813              		.loc 1 1627 32
 814 008c 1E4B     		ldr	r3, .L47+20
 815 008e 0022     		movs	r2, #0
 816 0090 1A60     		str	r2, [r3]
 817 0092 04E0     		b	.L45
 818              	.L44:
1628:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1629:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1630:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1631:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS - ulImplementedPrioBits;
 819              		.loc 1 1631 56
 820 0094 BB68     		ldr	r3, [r7, #8]
 821 0096 C3F10703 		rsb	r3, r3, #7
 822              		.loc 1 1631 32
 823 009a 1B4A     		ldr	r2, .L47+20
 824 009c 1360     		str	r3, [r2]
 825              	.L45:
1632:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1633:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1634:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Shift the priority group value back to its position within the AIRCR
1635:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * register. */
1636:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 826              		.loc 1 1636 28
 827 009e 1A4B     		ldr	r3, .L47+20
 828 00a0 1B68     		ldr	r3, [r3]
 829 00a2 1B02     		lsls	r3, r3, #8
 830 00a4 184A     		ldr	r2, .L47+20
 831 00a6 1360     		str	r3, [r2]
1637:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 832              		.loc 1 1637 28
ARM GAS  /tmp/ccsuQooq.s 			page 44


 833 00a8 174B     		ldr	r3, .L47+20
 834 00aa 1B68     		ldr	r3, [r3]
 835 00ac 03F4E063 		and	r3, r3, #1792
 836 00b0 154A     		ldr	r2, .L47+20
 837 00b2 1360     		str	r3, [r2]
1638:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1639:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Restore the clobbered interrupt priority register to its original
1640:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * value. */
1641:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         portNVIC_SHPR2_REG = ulOriginalPriority;
 838              		.loc 1 1641 9
 839 00b4 0F4A     		ldr	r2, .L47
 840              		.loc 1 1641 28
 841 00b6 FB68     		ldr	r3, [r7, #12]
 842 00b8 1360     		str	r3, [r2]
 843              	.LBE2:
1642:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1643:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) ) */
1644:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1645:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Make PendSV, CallSV and SysTick the same priority as the kernel. */
1646:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 844              		.loc 1 1646 5
 845 00ba 144B     		ldr	r3, .L47+24
 846 00bc 1B68     		ldr	r3, [r3]
 847 00be 134A     		ldr	r2, .L47+24
 848              		.loc 1 1646 24
 849 00c0 43F47F03 		orr	r3, r3, #16711680
 850 00c4 1360     		str	r3, [r2]
1647:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 851              		.loc 1 1647 5
 852 00c6 114B     		ldr	r3, .L47+24
 853 00c8 1B68     		ldr	r3, [r3]
 854 00ca 104A     		ldr	r2, .L47+24
 855              		.loc 1 1647 24
 856 00cc 43F07F43 		orr	r3, r3, #-16777216
 857 00d0 1360     		str	r3, [r2]
1648:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1649:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( configENABLE_MPU == 1 )
1650:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1651:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Setup the Memory Protection Unit (MPU). */
1652:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         prvSetupMPU();
1653:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1654:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif /* configENABLE_MPU */
1655:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1656:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Start the timer that generates the tick ISR. Interrupts are disabled
1657:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * here already. */
1658:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vPortSetupTimerInterrupt();
 858              		.loc 1 1658 5
 859 00d2 FFF7FEFF 		bl	vPortSetupTimerInterrupt
1659:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1660:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Initialize the critical nesting count ready for the first task. */
1661:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     ulCriticalNesting = 0;
 860              		.loc 1 1661 23
 861 00d6 0E4B     		ldr	r3, .L47+28
 862 00d8 0022     		movs	r2, #0
 863 00da 1A60     		str	r2, [r3]
1662:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1663:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #if ( ( configENABLE_MPU == 1 ) && ( configUSE_MPU_WRAPPERS_V1 == 0 ) && ( configENABLE_ACCESS_
ARM GAS  /tmp/ccsuQooq.s 			page 45


1664:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1665:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xSchedulerRunning = pdTRUE;
1666:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1667:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     #endif
1668:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1669:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Start the first task. */
1670:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vStartFirstTask();
 864              		.loc 1 1670 5
 865 00dc FFF7FEFF 		bl	vStartFirstTask
1671:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1672:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Should never get here as the tasks will now be executing. Call the task
1673:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * exit error function to prevent compiler warnings about a static function
1674:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * not being called in the case that the application writer overrides this
1675:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * functionality by defining configTASK_RETURN_ADDRESS. Call
1676:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * vTaskSwitchContext() so link time optimization does not remove the
1677:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * symbol. */
1678:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     vTaskSwitchContext();
 866              		.loc 1 1678 5
 867 00e0 FFF7FEFF 		bl	vTaskSwitchContext
1679:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     prvTaskExitError();
 868              		.loc 1 1679 5
 869 00e4 FFF7FEFF 		bl	prvTaskExitError
1680:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1681:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Should not get here. */
1682:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     return 0;
 870              		.loc 1 1682 12
 871 00e8 0023     		movs	r3, #0
1683:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 872              		.loc 1 1683 1
 873 00ea 1846     		mov	r0, r3
 874 00ec 1037     		adds	r7, r7, #16
 875              		.cfi_def_cfa_offset 8
 876 00ee BD46     		mov	sp, r7
 877              		.cfi_def_cfa_register 13
 878              		@ sp needed
 879 00f0 80BD     		pop	{r7, pc}
 880              	.L48:
 881 00f2 00BF     		.align	2
 882              	.L47:
 883 00f4 1CED00E0 		.word	-536810212
 884 00f8 00000000 		.word	ucMaxSysCallPriority
 885 00fc 00000000 		.word	.LC0
 886 0100 00000000 		.word	__func__.2
 887 0104 04000000 		.word	.LC1
 888 0108 00000000 		.word	ulMaxPRIGROUPValue
 889 010c 20ED00E0 		.word	-536810208
 890 0110 00000000 		.word	ulCriticalNesting
 891              		.cfi_endproc
 892              	.LFE9:
 894              		.section	.text.vPortEndScheduler,"ax",%progbits
 895              		.align	1
 896              		.global	vPortEndScheduler
 897              		.syntax unified
 898              		.thumb
 899              		.thumb_func
 901              	vPortEndScheduler:
 902              	.LFB10:
ARM GAS  /tmp/ccsuQooq.s 			page 46


1684:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1685:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1686:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** void vPortEndScheduler( void ) /* PRIVILEGED_FUNCTION */
1687:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 903              		.loc 1 1687 1
 904              		.cfi_startproc
 905              		@ args = 0, pretend = 0, frame = 0
 906              		@ frame_needed = 1, uses_anonymous_args = 0
 907 0000 80B5     		push	{r7, lr}
 908              		.cfi_def_cfa_offset 8
 909              		.cfi_offset 7, -8
 910              		.cfi_offset 14, -4
 911 0002 00AF     		add	r7, sp, #0
 912              		.cfi_def_cfa_register 7
1688:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Not implemented in ports where there is nothing to return to.
1689:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * Artificially force an assert. */
1690:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     configASSERT( ulCriticalNesting == 1000UL );
 913              		.loc 1 1690 5
 914 0004 074B     		ldr	r3, .L52
 915 0006 1B68     		ldr	r3, [r3]
 916 0008 B3F57A7F 		cmp	r3, #1000
 917 000c 08D0     		beq	.L51
 918              		.loc 1 1690 5 is_stmt 0 discriminator 1
 919 000e FFF7FEFF 		bl	ulSetInterruptMask
 920 0012 054B     		ldr	r3, .L52+4
 921 0014 054A     		ldr	r2, .L52+8
 922 0016 40F29A61 		movw	r1, #1690
 923 001a 0548     		ldr	r0, .L52+12
 924 001c FFF7FEFF 		bl	__assert_func
 925              	.L51:
1691:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 926              		.loc 1 1691 1 is_stmt 1
 927 0020 00BF     		nop
 928 0022 80BD     		pop	{r7, pc}
 929              	.L53:
 930              		.align	2
 931              	.L52:
 932 0024 00000000 		.word	ulCriticalNesting
 933 0028 00000000 		.word	.LC0
 934 002c 00000000 		.word	__func__.1
 935 0030 04000000 		.word	.LC1
 936              		.cfi_endproc
 937              	.LFE10:
 939              		.section	.text.xPortIsInsideInterrupt,"ax",%progbits
 940              		.align	1
 941              		.global	xPortIsInsideInterrupt
 942              		.syntax unified
 943              		.thumb
 944              		.thumb_func
 946              	xPortIsInsideInterrupt:
 947              	.LFB11:
1692:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1693:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1694:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1695:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vPortStoreTaskMPUSettings( xMPU_SETTINGS * xMPUSettings,
1696:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     const struct xMEMORY_REGION * const xRegions,
1697:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     StackType_t * pxBottomOfStack,
ARM GAS  /tmp/ccsuQooq.s 			page 47


1698:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                     uint32_t ulStackDepth )
1699:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1700:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulRegionStartAddress, ulRegionEndAddress, ulRegionNumber;
1701:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         int32_t lIndex = 0;
1702:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1703:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #if defined( __ARMCC_VERSION )
1704:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are defined in code instead of being
1705:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * exported from linker scripts. */
1706:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_start__;
1707:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t * __privileged_sram_end__;
1708:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #else
1709:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Declaration when these variable are exported from linker scripts. */
1710:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_start__[];
1711:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             extern uint32_t __privileged_sram_end__[];
1712:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         #endif /* defined( __ARMCC_VERSION ) */
1713:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1714:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Setup MAIR0. */
1715:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulMAIR0 = ( ( portMPU_NORMAL_MEMORY_BUFFERABLE_CACHEABLE << portMPU_MAIR_ATTR
1716:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xMPUSettings->ulMAIR0 |= ( ( portMPU_DEVICE_MEMORY_nGnRE << portMPU_MAIR_ATTR1_POS ) & port
1717:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1718:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* This function is called automatically when the task is created - in
1719:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * which case the stack region parameters will be valid.  At all other
1720:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * times the stack parameters will not be valid and it is assumed that
1721:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * the stack region has already been configured. */
1722:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulStackDepth > 0 )
1723:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1724:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulRegionStartAddress = ( uint32_t ) pxBottomOfStack;
1725:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ulRegionEndAddress = ( uint32_t ) pxBottomOfStack + ( ulStackDepth * ( uint32_t ) sizeo
1726:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1727:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If the stack is within the privileged SRAM, do not protect it
1728:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * using a separate MPU region. This is needed because privileged
1729:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * SRAM is already protected using an MPU region and ARMv8-M does
1730:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * not allow overlapping MPU regions. */
1731:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( ulRegionStartAddress >= ( uint32_t ) __privileged_sram_start__ ) &&
1732:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ( ulRegionEndAddress <= ( uint32_t ) __privileged_sram_end__ ) )
1733:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1734:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = 0;
1735:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = 0;
1736:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1737:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1738:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1739:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Define the region that allows access to the stack. */
1740:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionStartAddress &= portMPU_RBAR_ADDRESS_MASK;
1741:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
1742:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1743:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRBAR = ( ulRegionStartAddress ) |
1744:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_NON_SHAREABLE ) |
1745:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_READ_WRITE ) |
1746:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_REGION_EXECUTE_NEVER );
1747:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1748:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ 0 ].ulRLAR = ( ulRegionEndAddress ) |
1749:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_RLAR_ATTR_INDEX0 ) |
1750:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                              ( portMPU_RLAR_REGION_ENABLE );
1751:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1752:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1753:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1754:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* User supplied configurable regions. */
ARM GAS  /tmp/ccsuQooq.s 			page 48


1755:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         for( ulRegionNumber = 1; ulRegionNumber <= portNUM_CONFIGURABLE_REGIONS; ulRegionNumber++ )
1756:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1757:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* If xRegions is NULL i.e. the task has not specified any MPU
1758:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * region, the else part ensures that all the configurable MPU
1759:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * regions are invalidated. */
1760:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( ( xRegions != NULL ) && ( xRegions[ lIndex ].ulLengthInBytes > 0UL ) )
1761:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1762:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Translate the generic region definition contained in xRegions
1763:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * into the ARMv8 specific MPU settings that are then stored in
1764:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                  * xMPUSettings. */
1765:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionStartAddress = ( ( uint32_t ) xRegions[ lIndex ].pvBaseAddress ) & portMPU_
1766:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress = ( uint32_t ) xRegions[ lIndex ].pvBaseAddress + xRegions[ lInd
1767:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulRegionEndAddress &= portMPU_RLAR_ADDRESS_MASK;
1768:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1769:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Start address. */
1770:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = ( ulRegionStartAddress ) 
1771:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                           ( portMPU_REGION_NON_SHAR
1772:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1773:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* RO/RW. */
1774:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_READ_ONLY ) != 0 )
1775:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1776:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_REA
1777:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1778:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1779:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1780:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_REA
1781:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1782:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1783:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* XN. */
1784:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_EXECUTE_NEVER ) != 0 )
1785:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1786:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR |= ( portMPU_REGION_EXE
1787:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1788:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1789:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* End Address. */
1790:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = ( ulRegionEndAddress ) |
1791:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                                           ( portMPU_RLAR_REGION_ENA
1792:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1793:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Normal memory/ Device memory. */
1794:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 if( ( xRegions[ lIndex ].ulParameters & tskMPU_REGION_DEVICE_MEMORY ) != 0 )
1795:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1796:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Attr1 in MAIR0 is configured as device memory. */
1797:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_IN
1798:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1799:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 else
1800:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1801:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Attr0 in MAIR0 is configured as normal memory. */
1802:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR |= portMPU_RLAR_ATTR_IN
1803:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1804:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1805:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             else
1806:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1807:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 /* Invalidate the region. */
1808:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRBAR = 0UL;
1809:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 xMPUSettings->xRegionsSettings[ ulRegionNumber ].ulRLAR = 0UL;
1810:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1811:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
ARM GAS  /tmp/ccsuQooq.s 			page 49


1812:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             lIndex++;
1813:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1814:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1815:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1816:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1817:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1818:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( configENABLE_MPU == 1 )
1819:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xPortIsAuthorizedToAccessBuffer( const void * pvBuffer,
1820:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                 uint32_t ulBufferLength,
1821:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                 uint32_t ulAccessRequested ) /* PRIVILEGED_FUNCTION
1822:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1823:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1824:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t i, ulBufferStartAddress, ulBufferEndAddress;
1825:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         BaseType_t xAccessGranted = pdFALSE;
1826:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL ); /* Calling task's MPU
1827:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1828:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEG
1829:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1830:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             xAccessGranted = pdTRUE;
1831:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1832:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         else
1833:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1834:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             if( portADD_UINT32_WILL_OVERFLOW( ( ( uint32_t ) pvBuffer ), ( ulBufferLength - 1UL ) )
1835:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             {
1836:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulBufferStartAddress = ( uint32_t ) pvBuffer;
1837:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 ulBufferEndAddress = ( ( ( uint32_t ) pvBuffer ) + ulBufferLength - 1UL );
1838:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1839:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 for( i = 0; i < portTOTAL_NUM_REGIONS; i++ )
1840:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 {
1841:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     /* Is the MPU region enabled? */
1842:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     if( ( xTaskMpuSettings->xRegionsSettings[ i ].ulRLAR & portMPU_RLAR_REGION_ENAB
1843:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     {
1844:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         if( portIS_ADDRESS_WITHIN_RANGE( ulBufferStartAddress,
1845:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_FIRST_ADDRESS_FROM_RBAR( xTask
1846:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskM
1847:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             portIS_ADDRESS_WITHIN_RANGE( ulBufferEndAddress,
1848:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_FIRST_ADDRESS_FROM_RBAR( xTask
1849:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                          portEXTRACT_LAST_ADDRESS_FROM_RLAR( xTaskM
1850:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             portIS_AUTHORIZED( ulAccessRequested,
1851:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                                                prvGetRegionAccessPermissions( xTaskMpuSettings->xRe
1852:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         {
1853:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             xAccessGranted = pdTRUE;
1854:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                             break;
1855:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                         }
1856:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                     }
1857:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****                 }
1858:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             }
1859:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1860:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1861:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         return xAccessGranted;
1862:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1863:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #endif /* configENABLE_MPU */
1864:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1865:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1866:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** BaseType_t xPortIsInsideInterrupt( void )
1867:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** {
 948              		.loc 1 1867 1
ARM GAS  /tmp/ccsuQooq.s 			page 50


 949              		.cfi_startproc
 950              		@ args = 0, pretend = 0, frame = 8
 951              		@ frame_needed = 1, uses_anonymous_args = 0
 952              		@ link register save eliminated.
 953 0000 80B4     		push	{r7}
 954              		.cfi_def_cfa_offset 4
 955              		.cfi_offset 7, -4
 956 0002 83B0     		sub	sp, sp, #12
 957              		.cfi_def_cfa_offset 16
 958 0004 00AF     		add	r7, sp, #0
 959              		.cfi_def_cfa_register 7
1868:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     uint32_t ulCurrentInterrupt;
1869:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     BaseType_t xReturn;
1870:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1871:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     /* Obtain the number of the currently executing interrupt. Interrupt Program
1872:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * Status Register (IPSR) holds the exception number of the currently-executing
1873:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****      * exception or zero for Thread mode.*/
1874:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 960              		.loc 1 1874 5
 961              		.syntax unified
 962              	@ 1874 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 963 0006 EFF30583 		mrs r3, ipsr
 964              	@ 0 "" 2
 965              		.thumb
 966              		.syntax unified
 967 000a 3B60     		str	r3, [r7]
1875:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1876:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     if( ulCurrentInterrupt == 0 )
 968              		.loc 1 1876 7
 969 000c 3B68     		ldr	r3, [r7]
 970 000e 002B     		cmp	r3, #0
 971 0010 02D1     		bne	.L55
1877:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1878:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xReturn = pdFALSE;
 972              		.loc 1 1878 17
 973 0012 0023     		movs	r3, #0
 974 0014 7B60     		str	r3, [r7, #4]
 975 0016 01E0     		b	.L56
 976              	.L55:
1879:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1880:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     else
1881:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
1882:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         xReturn = pdTRUE;
 977              		.loc 1 1882 17
 978 0018 0123     		movs	r3, #1
 979 001a 7B60     		str	r3, [r7, #4]
 980              	.L56:
1883:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
1884:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1885:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     return xReturn;
 981              		.loc 1 1885 12
 982 001c 7B68     		ldr	r3, [r7, #4]
1886:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** }
 983              		.loc 1 1886 1
 984 001e 1846     		mov	r0, r3
 985 0020 0C37     		adds	r7, r7, #12
 986              		.cfi_def_cfa_offset 4
ARM GAS  /tmp/ccsuQooq.s 			page 51


 987 0022 BD46     		mov	sp, r7
 988              		.cfi_def_cfa_register 13
 989              		@ sp needed
 990 0024 5DF8047B 		ldr	r7, [sp], #4
 991              		.cfi_restore 7
 992              		.cfi_def_cfa_offset 0
 993 0028 7047     		bx	lr
 994              		.cfi_endproc
 995              	.LFE11:
 997              		.section	.text.vPortValidateInterruptPriority,"ax",%progbits
 998              		.align	1
 999              		.global	vPortValidateInterruptPriority
 1000              		.syntax unified
 1001              		.thumb
 1002              		.thumb_func
 1004              	vPortValidateInterruptPriority:
 1005              	.LFB12:
1887:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** /*-----------------------------------------------------------*/
1888:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1889:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** #if ( ( configASSERT_DEFINED == 1 ) && ( portHAS_BASEPRI == 1 ) )
1890:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1891:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     void vPortValidateInterruptPriority( void )
1892:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     {
 1006              		.loc 1 1892 5
 1007              		.cfi_startproc
 1008              		@ args = 0, pretend = 0, frame = 8
 1009              		@ frame_needed = 1, uses_anonymous_args = 0
 1010 0000 80B5     		push	{r7, lr}
 1011              		.cfi_def_cfa_offset 8
 1012              		.cfi_offset 7, -8
 1013              		.cfi_offset 14, -4
 1014 0002 82B0     		sub	sp, sp, #8
 1015              		.cfi_def_cfa_offset 16
 1016 0004 00AF     		add	r7, sp, #0
 1017              		.cfi_def_cfa_register 7
1893:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint32_t ulCurrentInterrupt;
1894:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         uint8_t ucCurrentPriority;
1895:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1896:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Obtain the number of the currently executing interrupt. */
1897:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         __asm volatile ( "mrs %0, ipsr" : "=r" ( ulCurrentInterrupt )::"memory" );
 1018              		.loc 1 1897 9
 1019              		.syntax unified
 1020              	@ 1897 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c" 1
 1021 0006 EFF30583 		mrs r3, ipsr
 1022              	@ 0 "" 2
 1023              		.thumb
 1024              		.syntax unified
 1025 000a 7B60     		str	r3, [r7, #4]
1898:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1899:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Is the interrupt number a user defined interrupt? */
1900:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 1026              		.loc 1 1900 11
 1027 000c 7B68     		ldr	r3, [r7, #4]
 1028 000e 0F2B     		cmp	r3, #15
 1029 0010 12D9     		bls	.L59
1901:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         {
1902:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* Look up the interrupt's priority. */
ARM GAS  /tmp/ccsuQooq.s 			page 52


1903:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 1030              		.loc 1 1903 61
 1031 0012 144A     		ldr	r2, .L62
 1032 0014 7B68     		ldr	r3, [r7, #4]
 1033 0016 1344     		add	r3, r3, r2
 1034              		.loc 1 1903 31
 1035 0018 1B78     		ldrb	r3, [r3]
 1036 001a FB70     		strb	r3, [r7, #3]
1904:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1905:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             /* The following assertion will fail if a service routine (ISR) for
1906:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * an interrupt that has been assigned a priority above
1907:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
1908:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * function.  ISR safe FreeRTOS API functions must *only* be called
1909:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * from interrupts that have been assigned a priority at or below
1910:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY.
1911:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1912:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Numerically low interrupt priority numbers represent logically high
1913:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * interrupt priorities, therefore the priority of the interrupt must
1914:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * be set to a value equal to or numerically *higher* than
1915:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * configMAX_SYSCALL_INTERRUPT_PRIORITY.
1916:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1917:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * Interrupts that  use the FreeRTOS API must not be left at their
1918:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * default priority of  zero as that is the highest possible priority,
1919:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
1920:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * and  therefore also guaranteed to be invalid.
1921:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1922:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * FreeRTOS maintains separate thread and ISR API functions to ensure
1923:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * interrupt entry is as fast and simple as possible.
1924:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              *
1925:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * The following links provide detailed information:
1926:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html
1927:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****              * https://www.FreeRTOS.org/FAQHelp.html */
1928:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****             configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 1037              		.loc 1 1928 13
 1038 001c 124B     		ldr	r3, .L62+4
 1039 001e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1040 0020 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1041 0022 9A42     		cmp	r2, r3
 1042 0024 08D2     		bcs	.L59
 1043              		.loc 1 1928 13 is_stmt 0 discriminator 1
 1044 0026 FFF7FEFF 		bl	ulSetInterruptMask
 1045 002a 104B     		ldr	r3, .L62+8
 1046 002c 104A     		ldr	r2, .L62+12
 1047 002e 4FF4F161 		mov	r1, #1928
 1048 0032 1048     		ldr	r0, .L62+16
 1049 0034 FFF7FEFF 		bl	__assert_func
 1050              	.L59:
1929:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         }
1930:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c **** 
1931:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         /* Priority grouping:  The interrupt controller (NVIC) allows the bits
1932:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * that define each interrupt's priority to be split between bits that
1933:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * define the interrupt's pre-emption priority bits and bits that define
1934:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * the interrupt's sub-priority.  For simplicity all bits must be defined
1935:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * to be pre-emption priority bits.  The following assertion will fail if
1936:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * this is not the case (if some bits represent a sub-priority).
1937:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          *
1938:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * If the application only uses CMSIS libraries for interrupt
ARM GAS  /tmp/ccsuQooq.s 			page 53


1939:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * configuration then the correct setting can be achieved on all Cortex-M
1940:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
1941:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * scheduler.  Note however that some vendor specific peripheral libraries
1942:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * assume a non-zero priority group setting, in which cases using a value
1943:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****          * of zero will result in unpredictable behaviour. */
1944:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****         configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 1051              		.loc 1 1944 9 is_stmt 1
 1052 0038 0F4B     		ldr	r3, .L62+20
 1053 003a 1B68     		ldr	r3, [r3]
 1054 003c 03F4E062 		and	r2, r3, #1792
 1055 0040 0E4B     		ldr	r3, .L62+24
 1056 0042 1B68     		ldr	r3, [r3]
 1057 0044 9A42     		cmp	r2, r3
 1058 0046 08D9     		bls	.L61
 1059              		.loc 1 1944 9 is_stmt 0 discriminator 1
 1060 0048 FFF7FEFF 		bl	ulSetInterruptMask
 1061 004c 074B     		ldr	r3, .L62+8
 1062 004e 084A     		ldr	r2, .L62+12
 1063 0050 4FF4F361 		mov	r1, #1944
 1064 0054 0748     		ldr	r0, .L62+16
 1065 0056 FFF7FEFF 		bl	__assert_func
 1066              	.L61:
1945:Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/port.c ****     }
 1067              		.loc 1 1945 5 is_stmt 1
 1068 005a 00BF     		nop
 1069 005c 0837     		adds	r7, r7, #8
 1070              		.cfi_def_cfa_offset 8
 1071 005e BD46     		mov	sp, r7
 1072              		.cfi_def_cfa_register 13
 1073              		@ sp needed
 1074 0060 80BD     		pop	{r7, pc}
 1075              	.L63:
 1076 0062 00BF     		.align	2
 1077              	.L62:
 1078 0064 F0E300E0 		.word	-536812560
 1079 0068 00000000 		.word	ucMaxSysCallPriority
 1080 006c 00000000 		.word	.LC0
 1081 0070 00000000 		.word	__func__.0
 1082 0074 04000000 		.word	.LC1
 1083 0078 0CED00E0 		.word	-536810228
 1084 007c 00000000 		.word	ulMaxPRIGROUPValue
 1085              		.cfi_endproc
 1086              	.LFE12:
 1088              		.section	.rodata.__func__.5,"a"
 1089              		.align	2
 1092              	__func__.5:
 1093 0000 70727654 		.ascii	"prvTaskExitError\000"
 1093      61736B45 
 1093      78697445 
 1093      72726F72 
 1093      00
 1094              		.section	.rodata.__func__.4,"a"
 1095              		.align	2
 1098              	__func__.4:
 1099 0000 76506F72 		.ascii	"vPortExitCritical\000"
 1099      74457869 
 1099      74437269 
ARM GAS  /tmp/ccsuQooq.s 			page 54


 1099      74696361 
 1099      6C00
 1100              		.section	.rodata.__func__.3,"a"
 1101              		.align	2
 1104              	__func__.3:
 1105 0000 76506F72 		.ascii	"vPortSVCHandler_C\000"
 1105      74535643 
 1105      48616E64 
 1105      6C65725F 
 1105      4300
 1106              		.section	.rodata.__func__.2,"a"
 1107              		.align	2
 1110              	__func__.2:
 1111 0000 78506F72 		.ascii	"xPortStartScheduler\000"
 1111      74537461 
 1111      72745363 
 1111      68656475 
 1111      6C657200 
 1112              		.section	.rodata.__func__.1,"a"
 1113              		.align	2
 1116              	__func__.1:
 1117 0000 76506F72 		.ascii	"vPortEndScheduler\000"
 1117      74456E64 
 1117      53636865 
 1117      64756C65 
 1117      7200
 1118              		.section	.rodata.__func__.0,"a"
 1119              		.align	2
 1122              	__func__.0:
 1123 0000 76506F72 		.ascii	"vPortValidateInterruptPriority\000"
 1123      7456616C 
 1123      69646174 
 1123      65496E74 
 1123      65727275 
 1124              		.text
 1125              	.Letext0:
 1126              		.file 2 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 1127              		.file 3 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 1128              		.file 4 "Lib/FreeRTOS/Source/include/projdefs.h"
 1129              		.file 5 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 1130              		.file 6 "Lib/FreeRTOS/Source/include/task.h"
 1131              		.file 7 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portasm.h"
 1132              		.file 8 "Inc/FreeRTOSConfig.h"
 1133              		.file 9 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
ARM GAS  /tmp/ccsuQooq.s 			page 55


DEFINED SYMBOLS
                            *ABS*:00000000 port.c
     /tmp/ccsuQooq.s:26     .data.ulCriticalNesting:00000000 $d
     /tmp/ccsuQooq.s:29     .data.ulCriticalNesting:00000000 ulCriticalNesting
     /tmp/ccsuQooq.s:34     .bss.ucMaxSysCallPriority:00000000 ucMaxSysCallPriority
     /tmp/ccsuQooq.s:35     .bss.ucMaxSysCallPriority:00000000 $d
     /tmp/ccsuQooq.s:37     .bss.ulMaxPRIGROUPValue:00000000 $d
     /tmp/ccsuQooq.s:40     .bss.ulMaxPRIGROUPValue:00000000 ulMaxPRIGROUPValue
     /tmp/ccsuQooq.s:43     .rodata.pcInterruptPriorityRegisters:00000000 $d
     /tmp/ccsuQooq.s:46     .rodata.pcInterruptPriorityRegisters:00000000 pcInterruptPriorityRegisters
     /tmp/ccsuQooq.s:49     .text.vPortSetupTimerInterrupt:00000000 $t
     /tmp/ccsuQooq.s:55     .text.vPortSetupTimerInterrupt:00000000 vPortSetupTimerInterrupt
     /tmp/ccsuQooq.s:106    .text.vPortSetupTimerInterrupt:00000034 $d
     /tmp/ccsuQooq.s:115    .rodata:00000000 $d
     /tmp/ccsuQooq.s:123    .text.prvTaskExitError:00000000 $t
     /tmp/ccsuQooq.s:128    .text.prvTaskExitError:00000000 prvTaskExitError
     /tmp/ccsuQooq.s:179    .text.prvTaskExitError:0000003c $d
     /tmp/ccsuQooq.s:1092   .rodata.__func__.5:00000000 __func__.5
     /tmp/ccsuQooq.s:187    .text.prvSetupFPU:00000000 $t
     /tmp/ccsuQooq.s:192    .text.prvSetupFPU:00000000 prvSetupFPU
     /tmp/ccsuQooq.s:230    .text.prvSetupFPU:00000028 $d
     /tmp/ccsuQooq.s:236    .text.vPortYield:00000000 $t
     /tmp/ccsuQooq.s:242    .text.vPortYield:00000000 vPortYield
     /tmp/ccsuQooq.s:282    .text.vPortYield:00000020 $d
     /tmp/ccsuQooq.s:287    .text.vPortEnterCritical:00000000 $t
     /tmp/ccsuQooq.s:293    .text.vPortEnterCritical:00000000 vPortEnterCritical
     /tmp/ccsuQooq.s:330    .text.vPortEnterCritical:00000020 $d
     /tmp/ccsuQooq.s:335    .text.vPortExitCritical:00000000 $t
     /tmp/ccsuQooq.s:341    .text.vPortExitCritical:00000000 vPortExitCritical
     /tmp/ccsuQooq.s:388    .text.vPortExitCritical:0000003c $d
     /tmp/ccsuQooq.s:1098   .rodata.__func__.4:00000000 __func__.4
     /tmp/ccsuQooq.s:396    .text.SysTick_Handler:00000000 $t
     /tmp/ccsuQooq.s:402    .text.SysTick_Handler:00000000 SysTick_Handler
     /tmp/ccsuQooq.s:445    .text.SysTick_Handler:0000002c $d
     /tmp/ccsuQooq.s:450    .text.vPortSVCHandler_C:00000000 $t
     /tmp/ccsuQooq.s:456    .text.vPortSVCHandler_C:00000000 vPortSVCHandler_C
     /tmp/ccsuQooq.s:511    .text.vPortSVCHandler_C:00000040 $d
     /tmp/ccsuQooq.s:1104   .rodata.__func__.3:00000000 __func__.3
     /tmp/ccsuQooq.s:518    .text.pxPortInitialiseStack:00000000 $t
     /tmp/ccsuQooq.s:524    .text.pxPortInitialiseStack:00000000 pxPortInitialiseStack
     /tmp/ccsuQooq.s:706    .text.pxPortInitialiseStack:00000110 $d
     /tmp/ccsuQooq.s:711    .text.xPortStartScheduler:00000000 $t
     /tmp/ccsuQooq.s:717    .text.xPortStartScheduler:00000000 xPortStartScheduler
     /tmp/ccsuQooq.s:883    .text.xPortStartScheduler:000000f4 $d
     /tmp/ccsuQooq.s:1110   .rodata.__func__.2:00000000 __func__.2
     /tmp/ccsuQooq.s:895    .text.vPortEndScheduler:00000000 $t
     /tmp/ccsuQooq.s:901    .text.vPortEndScheduler:00000000 vPortEndScheduler
     /tmp/ccsuQooq.s:932    .text.vPortEndScheduler:00000024 $d
     /tmp/ccsuQooq.s:1116   .rodata.__func__.1:00000000 __func__.1
     /tmp/ccsuQooq.s:940    .text.xPortIsInsideInterrupt:00000000 $t
     /tmp/ccsuQooq.s:946    .text.xPortIsInsideInterrupt:00000000 xPortIsInsideInterrupt
     /tmp/ccsuQooq.s:998    .text.vPortValidateInterruptPriority:00000000 $t
     /tmp/ccsuQooq.s:1004   .text.vPortValidateInterruptPriority:00000000 vPortValidateInterruptPriority
     /tmp/ccsuQooq.s:1078   .text.vPortValidateInterruptPriority:00000064 $d
     /tmp/ccsuQooq.s:1122   .rodata.__func__.0:00000000 __func__.0
     /tmp/ccsuQooq.s:1089   .rodata.__func__.5:00000000 $d
     /tmp/ccsuQooq.s:1095   .rodata.__func__.4:00000000 $d
ARM GAS  /tmp/ccsuQooq.s 			page 56


     /tmp/ccsuQooq.s:1101   .rodata.__func__.3:00000000 $d
     /tmp/ccsuQooq.s:1107   .rodata.__func__.2:00000000 $d
     /tmp/ccsuQooq.s:1113   .rodata.__func__.1:00000000 $d
     /tmp/ccsuQooq.s:1119   .rodata.__func__.0:00000000 $d
                           .group:00000000 wm4.0.2a10773746a5c5ebb5552f50e466f80b
                           .group:00000000 wm4.stddef.h.39.0dc9006b34572d4d9cae4c8b422c4971
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.features.h.33.e0c9f337c65cb9f22ed5f23d082bc78b
                           .group:00000000 wm4._default_types.h.15.247e5cd201eca3442cbf5404108c4935
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.newlib.h.7.591ac1bd65c1f5b34864757667a05252
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.FreeRTOSConfig.h.59.2629c72cff9e6dbe880a2dc225eae516
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.mpu_syscall_numbers.h.30.0a27a9934a6f5d596ea064151c3c3bfa

UNDEFINED SYMBOLS
SystemCoreClock
ulSetInterruptMask
__assert_func
vClearInterruptMask
xTaskIncrementTick
vRestoreContextOfFirstTask
vStartFirstTask
vTaskSwitchContext
