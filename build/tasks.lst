ARM GAS  /tmp/ccTFOe4z.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 6
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"tasks.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Lib/FreeRTOS/Source/tasks.c"
  25              		.global	pxCurrentTCB
  26              		.section	.bss.pxCurrentTCB,"aw",%nobits
  27              		.align	2
  30              	pxCurrentTCB:
  31 0000 00000000 		.space	4
  32              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  33              		.align	2
  36              	pxReadyTasksLists:
  37 0000 00000000 		.space	1120
  37      00000000 
  37      00000000 
  37      00000000 
  37      00000000 
  38              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  39              		.align	2
  42              	xDelayedTaskList1:
  43 0000 00000000 		.space	20
  43      00000000 
  43      00000000 
  43      00000000 
  43      00000000 
  44              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  45              		.align	2
  48              	xDelayedTaskList2:
  49 0000 00000000 		.space	20
  49      00000000 
  49      00000000 
  49      00000000 
  49      00000000 
  50              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  51              		.align	2
  54              	pxDelayedTaskList:
  55 0000 00000000 		.space	4
ARM GAS  /tmp/ccTFOe4z.s 			page 2


  56              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  57              		.align	2
  60              	pxOverflowDelayedTaskList:
  61 0000 00000000 		.space	4
  62              		.section	.bss.xPendingReadyList,"aw",%nobits
  63              		.align	2
  66              	xPendingReadyList:
  67 0000 00000000 		.space	20
  67      00000000 
  67      00000000 
  67      00000000 
  67      00000000 
  68              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  69              		.align	2
  72              	xTasksWaitingTermination:
  73 0000 00000000 		.space	20
  73      00000000 
  73      00000000 
  73      00000000 
  73      00000000 
  74              		.section	.bss.uxDeletedTasksWaitingCleanUp,"aw",%nobits
  75              		.align	2
  78              	uxDeletedTasksWaitingCleanUp:
  79 0000 00000000 		.space	4
  80              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  81              		.align	2
  84              	xSuspendedTaskList:
  85 0000 00000000 		.space	20
  85      00000000 
  85      00000000 
  85      00000000 
  85      00000000 
  86              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  87              		.align	2
  90              	uxCurrentNumberOfTasks:
  91 0000 00000000 		.space	4
  92              		.section	.bss.xTickCount,"aw",%nobits
  93              		.align	2
  96              	xTickCount:
  97 0000 00000000 		.space	4
  98              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  99              		.align	2
 102              	uxTopReadyPriority:
 103 0000 00000000 		.space	4
 104              		.section	.bss.xSchedulerRunning,"aw",%nobits
 105              		.align	2
 108              	xSchedulerRunning:
 109 0000 00000000 		.space	4
 110              		.section	.bss.xPendedTicks,"aw",%nobits
 111              		.align	2
 114              	xPendedTicks:
 115 0000 00000000 		.space	4
 116              		.section	.bss.xYieldPending,"aw",%nobits
 117              		.align	2
 120              	xYieldPending:
 121 0000 00000000 		.space	4
 122              		.section	.bss.xNumOfOverflows,"aw",%nobits
ARM GAS  /tmp/ccTFOe4z.s 			page 3


 123              		.align	2
 126              	xNumOfOverflows:
 127 0000 00000000 		.space	4
 128              		.section	.bss.uxTaskNumber,"aw",%nobits
 129              		.align	2
 132              	uxTaskNumber:
 133 0000 00000000 		.space	4
 134              		.section	.bss.xNextTaskUnblockTime,"aw",%nobits
 135              		.align	2
 138              	xNextTaskUnblockTime:
 139 0000 00000000 		.space	4
 140              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 141              		.align	2
 144              	xIdleTaskHandle:
 145 0000 00000000 		.space	4
 146              		.global	uxTopUsedPriority
 147              		.section	.rodata.uxTopUsedPriority,"a"
 148              		.align	2
 151              	uxTopUsedPriority:
 152 0000 37000000 		.word	55
 153              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 154              		.align	2
 157              	uxSchedulerSuspended:
 158 0000 00000000 		.space	4
 159              		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 160              		.align	2
 163              	ulTaskSwitchedInTime:
 164 0000 00000000 		.space	4
 165              		.section	.bss.ulTotalRunTime,"aw",%nobits
 166              		.align	2
 169              	ulTotalRunTime:
 170 0000 00000000 		.space	4
 171              		.section	.rodata
 172              		.align	2
 173              	.LC0:
 174 0000 3000     		.ascii	"0\000"
 175 0002 0000     		.align	2
 176              	.LC1:
 177 0004 4C69622F 		.ascii	"Lib/FreeRTOS/Source/tasks.c\000"
 177      46726565 
 177      52544F53 
 177      2F536F75 
 177      7263652F 
 178              		.section	.text.xTaskCreateStatic,"ax",%progbits
 179              		.align	1
 180              		.global	xTaskCreateStatic
 181              		.syntax unified
 182              		.thumb
 183              		.thumb_func
 185              	xTaskCreateStatic:
 186              	.LFB0:
   1:Lib/FreeRTOS/Source/tasks.c **** /*
   2:Lib/FreeRTOS/Source/tasks.c ****  * FreeRTOS Kernel V10.6.2
   3:Lib/FreeRTOS/Source/tasks.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Lib/FreeRTOS/Source/tasks.c ****  *
   5:Lib/FreeRTOS/Source/tasks.c ****  * SPDX-License-Identifier: MIT
   6:Lib/FreeRTOS/Source/tasks.c ****  *
ARM GAS  /tmp/ccTFOe4z.s 			page 4


   7:Lib/FreeRTOS/Source/tasks.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:Lib/FreeRTOS/Source/tasks.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:Lib/FreeRTOS/Source/tasks.c ****  * the Software without restriction, including without limitation the rights to
  10:Lib/FreeRTOS/Source/tasks.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:Lib/FreeRTOS/Source/tasks.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:Lib/FreeRTOS/Source/tasks.c ****  * subject to the following conditions:
  13:Lib/FreeRTOS/Source/tasks.c ****  *
  14:Lib/FreeRTOS/Source/tasks.c ****  * The above copyright notice and this permission notice shall be included in all
  15:Lib/FreeRTOS/Source/tasks.c ****  * copies or substantial portions of the Software.
  16:Lib/FreeRTOS/Source/tasks.c ****  *
  17:Lib/FreeRTOS/Source/tasks.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:Lib/FreeRTOS/Source/tasks.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:Lib/FreeRTOS/Source/tasks.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:Lib/FreeRTOS/Source/tasks.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:Lib/FreeRTOS/Source/tasks.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:Lib/FreeRTOS/Source/tasks.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:Lib/FreeRTOS/Source/tasks.c ****  *
  24:Lib/FreeRTOS/Source/tasks.c ****  * https://www.FreeRTOS.org
  25:Lib/FreeRTOS/Source/tasks.c ****  * https://github.com/FreeRTOS
  26:Lib/FreeRTOS/Source/tasks.c ****  *
  27:Lib/FreeRTOS/Source/tasks.c ****  */
  28:Lib/FreeRTOS/Source/tasks.c **** 
  29:Lib/FreeRTOS/Source/tasks.c **** /* Standard includes. */
  30:Lib/FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  31:Lib/FreeRTOS/Source/tasks.c **** #include <string.h>
  32:Lib/FreeRTOS/Source/tasks.c **** 
  33:Lib/FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  34:Lib/FreeRTOS/Source/tasks.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  35:Lib/FreeRTOS/Source/tasks.c ****  * task.h is included from an application file. */
  36:Lib/FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  37:Lib/FreeRTOS/Source/tasks.c **** 
  38:Lib/FreeRTOS/Source/tasks.c **** /* FreeRTOS includes. */
  39:Lib/FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  40:Lib/FreeRTOS/Source/tasks.c **** #include "task.h"
  41:Lib/FreeRTOS/Source/tasks.c **** #include "timers.h"
  42:Lib/FreeRTOS/Source/tasks.c **** #include "stack_macros.h"
  43:Lib/FreeRTOS/Source/tasks.c **** 
  44:Lib/FreeRTOS/Source/tasks.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  45:Lib/FreeRTOS/Source/tasks.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  46:Lib/FreeRTOS/Source/tasks.c ****  * for the header files above, but not in this file, in order to generate the
  47:Lib/FreeRTOS/Source/tasks.c ****  * correct privileged Vs unprivileged linkage and placement. */
  48:Lib/FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  49:Lib/FreeRTOS/Source/tasks.c **** 
  50:Lib/FreeRTOS/Source/tasks.c **** /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
  51:Lib/FreeRTOS/Source/tasks.c ****  * functions but without including stdio.h here. */
  52:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
  53:Lib/FreeRTOS/Source/tasks.c **** 
  54:Lib/FreeRTOS/Source/tasks.c **** /* At the bottom of this file are two optional functions that can be used
  55:Lib/FreeRTOS/Source/tasks.c ****  * to generate human readable text from the raw data generated by the
  56:Lib/FreeRTOS/Source/tasks.c ****  * uxTaskGetSystemState() function.  Note the formatting functions are provided
  57:Lib/FreeRTOS/Source/tasks.c ****  * for convenience only, and are NOT considered part of the kernel. */
  58:Lib/FreeRTOS/Source/tasks.c ****     #include <stdio.h>
  59:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
  60:Lib/FreeRTOS/Source/tasks.c **** 
  61:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_PREEMPTION == 0 )
  62:Lib/FreeRTOS/Source/tasks.c **** 
  63:Lib/FreeRTOS/Source/tasks.c **** /* If the cooperative scheduler is being used then a yield should not be
ARM GAS  /tmp/ccTFOe4z.s 			page 5


  64:Lib/FreeRTOS/Source/tasks.c ****  * performed just because a higher priority task has been woken. */
  65:Lib/FreeRTOS/Source/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()
  66:Lib/FreeRTOS/Source/tasks.c **** #else
  67:Lib/FreeRTOS/Source/tasks.c ****     #define taskYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  68:Lib/FreeRTOS/Source/tasks.c **** #endif
  69:Lib/FreeRTOS/Source/tasks.c **** 
  70:Lib/FreeRTOS/Source/tasks.c **** /* Values that can be assigned to the ucNotifyState member of the TCB. */
  71:Lib/FreeRTOS/Source/tasks.c **** #define taskNOT_WAITING_NOTIFICATION              ( ( uint8_t ) 0 ) /* Must be zero as it is the in
  72:Lib/FreeRTOS/Source/tasks.c **** #define taskWAITING_NOTIFICATION                  ( ( uint8_t ) 1 )
  73:Lib/FreeRTOS/Source/tasks.c **** #define taskNOTIFICATION_RECEIVED                 ( ( uint8_t ) 2 )
  74:Lib/FreeRTOS/Source/tasks.c **** 
  75:Lib/FreeRTOS/Source/tasks.c **** /*
  76:Lib/FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
  77:Lib/FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
  78:Lib/FreeRTOS/Source/tasks.c ****  */
  79:Lib/FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE                        ( 0xa5U )
  80:Lib/FreeRTOS/Source/tasks.c **** 
  81:Lib/FreeRTOS/Source/tasks.c **** /* Bits used to record how a task's stack and TCB were allocated. */
  82:Lib/FreeRTOS/Source/tasks.c **** #define tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB    ( ( uint8_t ) 0 )
  83:Lib/FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_ONLY        ( ( uint8_t ) 1 )
  84:Lib/FreeRTOS/Source/tasks.c **** #define tskSTATICALLY_ALLOCATED_STACK_AND_TCB     ( ( uint8_t ) 2 )
  85:Lib/FreeRTOS/Source/tasks.c **** 
  86:Lib/FreeRTOS/Source/tasks.c **** /* If any of the following are set then task stacks are filled with a known
  87:Lib/FreeRTOS/Source/tasks.c ****  * value so the high water mark can be determined.  If none of the following are
  88:Lib/FreeRTOS/Source/tasks.c ****  * set then don't fill the stack so there is no unnecessary dependency on memset. */
  89:Lib/FreeRTOS/Source/tasks.c **** #if ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTa
  90:Lib/FreeRTOS/Source/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    1
  91:Lib/FreeRTOS/Source/tasks.c **** #else
  92:Lib/FreeRTOS/Source/tasks.c ****     #define tskSET_NEW_STACKS_TO_KNOWN_VALUE    0
  93:Lib/FreeRTOS/Source/tasks.c **** #endif
  94:Lib/FreeRTOS/Source/tasks.c **** 
  95:Lib/FreeRTOS/Source/tasks.c **** /*
  96:Lib/FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
  97:Lib/FreeRTOS/Source/tasks.c ****  */
  98:Lib/FreeRTOS/Source/tasks.c **** #define tskRUNNING_CHAR      ( 'X' )
  99:Lib/FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR      ( 'B' )
 100:Lib/FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR        ( 'R' )
 101:Lib/FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR      ( 'D' )
 102:Lib/FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR    ( 'S' )
 103:Lib/FreeRTOS/Source/tasks.c **** 
 104:Lib/FreeRTOS/Source/tasks.c **** /*
 105:Lib/FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require the data the debugger needs access to to
 106:Lib/FreeRTOS/Source/tasks.c ****  * be global, rather than file scope.
 107:Lib/FreeRTOS/Source/tasks.c ****  */
 108:Lib/FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 109:Lib/FreeRTOS/Source/tasks.c ****     #define static
 110:Lib/FreeRTOS/Source/tasks.c **** #endif
 111:Lib/FreeRTOS/Source/tasks.c **** 
 112:Lib/FreeRTOS/Source/tasks.c **** /* The name allocated to the Idle task.  This can be overridden by defining
 113:Lib/FreeRTOS/Source/tasks.c ****  * configIDLE_TASK_NAME in FreeRTOSConfig.h. */
 114:Lib/FreeRTOS/Source/tasks.c **** #ifndef configIDLE_TASK_NAME
 115:Lib/FreeRTOS/Source/tasks.c ****     #define configIDLE_TASK_NAME    "IDLE"
 116:Lib/FreeRTOS/Source/tasks.c **** #endif
 117:Lib/FreeRTOS/Source/tasks.c **** 
 118:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
 119:Lib/FreeRTOS/Source/tasks.c **** 
 120:Lib/FreeRTOS/Source/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
ARM GAS  /tmp/ccTFOe4z.s 			page 6


 121:Lib/FreeRTOS/Source/tasks.c ****  * performed in a generic way that is not optimised to any particular
 122:Lib/FreeRTOS/Source/tasks.c ****  * microcontroller architecture. */
 123:Lib/FreeRTOS/Source/tasks.c **** 
 124:Lib/FreeRTOS/Source/tasks.c **** /* uxTopReadyPriority holds the priority of the highest priority ready
 125:Lib/FreeRTOS/Source/tasks.c ****  * state task. */
 126:Lib/FreeRTOS/Source/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority ) \
 127:Lib/FreeRTOS/Source/tasks.c ****     do {                                            \
 128:Lib/FreeRTOS/Source/tasks.c ****         if( ( uxPriority ) > uxTopReadyPriority )   \
 129:Lib/FreeRTOS/Source/tasks.c ****         {                                           \
 130:Lib/FreeRTOS/Source/tasks.c ****             uxTopReadyPriority = ( uxPriority );    \
 131:Lib/FreeRTOS/Source/tasks.c ****         }                                           \
 132:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 ) /* taskRECORD_READY_PRIORITY */
 133:Lib/FreeRTOS/Source/tasks.c **** 
 134:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 135:Lib/FreeRTOS/Source/tasks.c **** 
 136:Lib/FreeRTOS/Source/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                \
 137:Lib/FreeRTOS/Source/tasks.c ****     do {                                                                      \
 138:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTopPriority = uxTopReadyPriority;                       \
 139:Lib/FreeRTOS/Source/tasks.c ****                                                                               \
 140:Lib/FreeRTOS/Source/tasks.c ****         /* Find the highest priority queue that contains ready tasks. */      \
 141:Lib/FreeRTOS/Source/tasks.c ****         while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) ) \
 142:Lib/FreeRTOS/Source/tasks.c ****         {                                                                     \
 143:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( uxTopPriority );                                    \
 144:Lib/FreeRTOS/Source/tasks.c ****             --uxTopPriority;                                                  \
 145:Lib/FreeRTOS/Source/tasks.c ****         }                                                                     \
 146:Lib/FreeRTOS/Source/tasks.c ****                                                                               \
 147:Lib/FreeRTOS/Source/tasks.c ****         /* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of \
 148:Lib/FreeRTOS/Source/tasks.c ****          * the  same priority get an equal share of the processor time. */                    \
 149:Lib/FreeRTOS/Source/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) ); \
 150:Lib/FreeRTOS/Source/tasks.c ****         uxTopReadyPriority = uxTopPriority;                                                   \
 151:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 ) /* taskSELECT_HIGHEST_PRIORITY_TASK */
 152:Lib/FreeRTOS/Source/tasks.c **** 
 153:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 154:Lib/FreeRTOS/Source/tasks.c **** 
 155:Lib/FreeRTOS/Source/tasks.c **** /* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
 156:Lib/FreeRTOS/Source/tasks.c ****  * they are only required when a port optimised method of task selection is
 157:Lib/FreeRTOS/Source/tasks.c ****  * being used. */
 158:Lib/FreeRTOS/Source/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )
 159:Lib/FreeRTOS/Source/tasks.c ****     #define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
 160:Lib/FreeRTOS/Source/tasks.c **** 
 161:Lib/FreeRTOS/Source/tasks.c **** #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 162:Lib/FreeRTOS/Source/tasks.c **** 
 163:Lib/FreeRTOS/Source/tasks.c **** /* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
 164:Lib/FreeRTOS/Source/tasks.c ****  * performed in a way that is tailored to the particular microcontroller
 165:Lib/FreeRTOS/Source/tasks.c ****  * architecture being used. */
 166:Lib/FreeRTOS/Source/tasks.c **** 
 167:Lib/FreeRTOS/Source/tasks.c **** /* A port optimised version is provided.  Call the port defined macros. */
 168:Lib/FreeRTOS/Source/tasks.c ****     #define taskRECORD_READY_PRIORITY( uxPriority )    portRECORD_READY_PRIORITY( ( uxPriority ), u
 169:Lib/FreeRTOS/Source/tasks.c **** 
 170:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 171:Lib/FreeRTOS/Source/tasks.c **** 
 172:Lib/FreeRTOS/Source/tasks.c ****     #define taskSELECT_HIGHEST_PRIORITY_TASK()                                                  \
 173:Lib/FreeRTOS/Source/tasks.c ****     do {                                                                                        \
 174:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTopPriority;                                                              \
 175:Lib/FreeRTOS/Source/tasks.c ****                                                                                                 \
 176:Lib/FreeRTOS/Source/tasks.c ****         /* Find the highest priority list that contains ready tasks. */                         \
 177:Lib/FreeRTOS/Source/tasks.c ****         portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );                          \
ARM GAS  /tmp/ccTFOe4z.s 			page 7


 178:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 ); \
 179:Lib/FreeRTOS/Source/tasks.c ****         listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );   \
 180:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 )
 181:Lib/FreeRTOS/Source/tasks.c **** 
 182:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 183:Lib/FreeRTOS/Source/tasks.c **** 
 184:Lib/FreeRTOS/Source/tasks.c **** /* A port optimised version is provided, call it only if the TCB being reset
 185:Lib/FreeRTOS/Source/tasks.c ****  * is being referenced from a ready list.  If it is referenced from a delayed
 186:Lib/FreeRTOS/Source/tasks.c ****  * or suspended list then it won't be in a ready list. */
 187:Lib/FreeRTOS/Source/tasks.c ****     #define taskRESET_READY_PRIORITY( uxPriority )                                                 
 188:Lib/FreeRTOS/Source/tasks.c ****     do {                                                                                           
 189:Lib/FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 
 190:Lib/FreeRTOS/Source/tasks.c ****         {                                                                                          
 191:Lib/FreeRTOS/Source/tasks.c ****             portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );                    
 192:Lib/FreeRTOS/Source/tasks.c ****         }                                                                                          
 193:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 )
 194:Lib/FreeRTOS/Source/tasks.c **** 
 195:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
 196:Lib/FreeRTOS/Source/tasks.c **** 
 197:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 198:Lib/FreeRTOS/Source/tasks.c **** 
 199:Lib/FreeRTOS/Source/tasks.c **** /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
 200:Lib/FreeRTOS/Source/tasks.c ****  * count overflows. */
 201:Lib/FreeRTOS/Source/tasks.c **** #define taskSWITCH_DELAYED_LISTS()                                                \
 202:Lib/FreeRTOS/Source/tasks.c ****     do {                                                                          \
 203:Lib/FreeRTOS/Source/tasks.c ****         List_t * pxTemp;                                                          \
 204:Lib/FreeRTOS/Source/tasks.c ****                                                                                   \
 205:Lib/FreeRTOS/Source/tasks.c ****         /* The delayed tasks list should be empty when the lists are switched. */ \
 206:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );               \
 207:Lib/FreeRTOS/Source/tasks.c ****                                                                                   \
 208:Lib/FreeRTOS/Source/tasks.c ****         pxTemp = pxDelayedTaskList;                                               \
 209:Lib/FreeRTOS/Source/tasks.c ****         pxDelayedTaskList = pxOverflowDelayedTaskList;                            \
 210:Lib/FreeRTOS/Source/tasks.c ****         pxOverflowDelayedTaskList = pxTemp;                                       \
 211:Lib/FreeRTOS/Source/tasks.c ****         xNumOfOverflows++;                                                        \
 212:Lib/FreeRTOS/Source/tasks.c ****         prvResetNextTaskUnblockTime();                                            \
 213:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 )
 214:Lib/FreeRTOS/Source/tasks.c **** 
 215:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 216:Lib/FreeRTOS/Source/tasks.c **** 
 217:Lib/FreeRTOS/Source/tasks.c **** /*
 218:Lib/FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready list for
 219:Lib/FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.
 220:Lib/FreeRTOS/Source/tasks.c ****  */
 221:Lib/FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyList( pxTCB )                                                             
 222:Lib/FreeRTOS/Source/tasks.c ****     do {                                                                                           
 223:Lib/FreeRTOS/Source/tasks.c ****         traceMOVED_TASK_TO_READY_STATE( pxTCB );                                                   
 224:Lib/FreeRTOS/Source/tasks.c ****         taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );                                        
 225:Lib/FreeRTOS/Source/tasks.c ****         listINSERT_END( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xStateListIt
 226:Lib/FreeRTOS/Source/tasks.c ****         tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB );                                              
 227:Lib/FreeRTOS/Source/tasks.c ****     } while( 0 )
 228:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 229:Lib/FreeRTOS/Source/tasks.c **** 
 230:Lib/FreeRTOS/Source/tasks.c **** /*
 231:Lib/FreeRTOS/Source/tasks.c ****  * Several functions take a TaskHandle_t parameter that can optionally be NULL,
 232:Lib/FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 233:Lib/FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 234:Lib/FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
ARM GAS  /tmp/ccTFOe4z.s 			page 8


 235:Lib/FreeRTOS/Source/tasks.c ****  */
 236:Lib/FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle )    ( ( ( pxHandle ) == NULL ) ? pxCurrentTCB : ( pxHandle )
 237:Lib/FreeRTOS/Source/tasks.c **** 
 238:Lib/FreeRTOS/Source/tasks.c **** /* The item value of the event list item is normally used to hold the priority
 239:Lib/FreeRTOS/Source/tasks.c ****  * of the task to which it belongs (coded to allow it to be held in reverse
 240:Lib/FreeRTOS/Source/tasks.c ****  * priority order).  However, it is occasionally borrowed for other purposes.  It
 241:Lib/FreeRTOS/Source/tasks.c ****  * is important its value is not updated due to a task priority change while it is
 242:Lib/FreeRTOS/Source/tasks.c ****  * being used for another purpose.  The following bit definition is used to inform
 243:Lib/FreeRTOS/Source/tasks.c ****  * the scheduler that the value should not be changed - in which case it is the
 244:Lib/FreeRTOS/Source/tasks.c ****  * responsibility of whichever module is using the value to ensure it gets set back
 245:Lib/FreeRTOS/Source/tasks.c ****  * to its original value when it is released. */
 246:Lib/FreeRTOS/Source/tasks.c **** #if ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_16_BITS )
 247:Lib/FreeRTOS/Source/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000U
 248:Lib/FreeRTOS/Source/tasks.c **** #elif ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_32_BITS )
 249:Lib/FreeRTOS/Source/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x80000000UL
 250:Lib/FreeRTOS/Source/tasks.c **** #elif ( configTICK_TYPE_WIDTH_IN_BITS == TICK_TYPE_WIDTH_64_BITS )
 251:Lib/FreeRTOS/Source/tasks.c ****     #define taskEVENT_LIST_ITEM_VALUE_IN_USE    0x8000000000000000ULL
 252:Lib/FreeRTOS/Source/tasks.c **** #endif
 253:Lib/FreeRTOS/Source/tasks.c **** 
 254:Lib/FreeRTOS/Source/tasks.c **** /*
 255:Lib/FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated for each task,
 256:Lib/FreeRTOS/Source/tasks.c ****  * and stores task state information, including a pointer to the task's context
 257:Lib/FreeRTOS/Source/tasks.c ****  * (the task's run time environment, including register values)
 258:Lib/FreeRTOS/Source/tasks.c ****  */
 259:Lib/FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock       /* The old naming convention is used to prevent breaking k
 260:Lib/FreeRTOS/Source/tasks.c **** {
 261:Lib/FreeRTOS/Source/tasks.c ****     volatile StackType_t * pxTopOfStack; /**< Points to the location of the last item placed on the
 262:Lib/FreeRTOS/Source/tasks.c **** 
 263:Lib/FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 264:Lib/FreeRTOS/Source/tasks.c ****         xMPU_SETTINGS xMPUSettings; /**< The MPU settings are defined as part of the port layer.  T
 265:Lib/FreeRTOS/Source/tasks.c ****     #endif
 266:Lib/FreeRTOS/Source/tasks.c **** 
 267:Lib/FreeRTOS/Source/tasks.c ****     ListItem_t xStateListItem;                  /**< The list that the state list item of a task is
 268:Lib/FreeRTOS/Source/tasks.c ****     ListItem_t xEventListItem;                  /**< Used to reference a task from an event list. *
 269:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxPriority;                     /**< The priority of the task.  0 is the lowest pri
 270:Lib/FreeRTOS/Source/tasks.c ****     StackType_t * pxStack;                      /**< Points to the start of the stack. */
 271:Lib/FreeRTOS/Source/tasks.c ****     char pcTaskName[ configMAX_TASK_NAME_LEN ]; /**< Descriptive name given to the task when create
 272:Lib/FreeRTOS/Source/tasks.c **** 
 273:Lib/FreeRTOS/Source/tasks.c ****     #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
 274:Lib/FreeRTOS/Source/tasks.c ****         StackType_t * pxEndOfStack; /**< Points to the highest valid address for the stack. */
 275:Lib/FreeRTOS/Source/tasks.c ****     #endif
 276:Lib/FreeRTOS/Source/tasks.c **** 
 277:Lib/FreeRTOS/Source/tasks.c ****     #if ( portCRITICAL_NESTING_IN_TCB == 1 )
 278:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxCriticalNesting; /**< Holds the critical section nesting depth for ports that
 279:Lib/FreeRTOS/Source/tasks.c ****     #endif
 280:Lib/FreeRTOS/Source/tasks.c **** 
 281:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 282:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTCBNumber;  /**< Stores a number that increments each time a TCB is created. 
 283:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTaskNumber; /**< Stores a number specifically for use by third party trace co
 284:Lib/FreeRTOS/Source/tasks.c ****     #endif
 285:Lib/FreeRTOS/Source/tasks.c **** 
 286:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 287:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxBasePriority; /**< The priority last assigned to the task - used by the prior
 288:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxMutexesHeld;
 289:Lib/FreeRTOS/Source/tasks.c ****     #endif
 290:Lib/FreeRTOS/Source/tasks.c **** 
 291:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_APPLICATION_TASK_TAG == 1 )
ARM GAS  /tmp/ccTFOe4z.s 			page 9


 292:Lib/FreeRTOS/Source/tasks.c ****         TaskHookFunction_t pxTaskTag;
 293:Lib/FreeRTOS/Source/tasks.c ****     #endif
 294:Lib/FreeRTOS/Source/tasks.c **** 
 295:Lib/FreeRTOS/Source/tasks.c ****     #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
 296:Lib/FreeRTOS/Source/tasks.c ****         void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
 297:Lib/FreeRTOS/Source/tasks.c ****     #endif
 298:Lib/FreeRTOS/Source/tasks.c **** 
 299:Lib/FreeRTOS/Source/tasks.c ****     #if ( configGENERATE_RUN_TIME_STATS == 1 )
 300:Lib/FreeRTOS/Source/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /**< Stores the amount of time the task has s
 301:Lib/FreeRTOS/Source/tasks.c ****     #endif
 302:Lib/FreeRTOS/Source/tasks.c **** 
 303:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
 304:Lib/FreeRTOS/Source/tasks.c ****         configTLS_BLOCK_TYPE xTLSBlock; /**< Memory block used as Thread Local Storage (TLS) Block 
 305:Lib/FreeRTOS/Source/tasks.c ****     #endif
 306:Lib/FreeRTOS/Source/tasks.c **** 
 307:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_TASK_NOTIFICATIONS == 1 )
 308:Lib/FreeRTOS/Source/tasks.c ****         volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 309:Lib/FreeRTOS/Source/tasks.c ****         volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];
 310:Lib/FreeRTOS/Source/tasks.c ****     #endif
 311:Lib/FreeRTOS/Source/tasks.c **** 
 312:Lib/FreeRTOS/Source/tasks.c ****     /* See the comments in FreeRTOS.h with the definition of
 313:Lib/FreeRTOS/Source/tasks.c ****      * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */
 314:Lib/FreeRTOS/Source/tasks.c ****     #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been conso
 315:Lib/FreeRTOS/Source/tasks.c ****         uint8_t ucStaticallyAllocated;                     /**< Set to pdTRUE if the task is a stat
 316:Lib/FreeRTOS/Source/tasks.c ****     #endif
 317:Lib/FreeRTOS/Source/tasks.c **** 
 318:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
 319:Lib/FreeRTOS/Source/tasks.c ****         uint8_t ucDelayAborted;
 320:Lib/FreeRTOS/Source/tasks.c ****     #endif
 321:Lib/FreeRTOS/Source/tasks.c **** 
 322:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_POSIX_ERRNO == 1 )
 323:Lib/FreeRTOS/Source/tasks.c ****         int iTaskErrno;
 324:Lib/FreeRTOS/Source/tasks.c ****     #endif
 325:Lib/FreeRTOS/Source/tasks.c **** } tskTCB;
 326:Lib/FreeRTOS/Source/tasks.c **** 
 327:Lib/FreeRTOS/Source/tasks.c **** /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
 328:Lib/FreeRTOS/Source/tasks.c ****  * below to enable the use of older kernel aware debuggers. */
 329:Lib/FreeRTOS/Source/tasks.c **** typedef tskTCB TCB_t;
 330:Lib/FreeRTOS/Source/tasks.c **** 
 331:Lib/FreeRTOS/Source/tasks.c **** /*lint -save -e956 A manual analysis and inspection has been used to determine
 332:Lib/FreeRTOS/Source/tasks.c ****  * which static variables must be declared volatile. */
 333:Lib/FreeRTOS/Source/tasks.c **** portDONT_DISCARD PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
 334:Lib/FreeRTOS/Source/tasks.c **** 
 335:Lib/FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------
 336:Lib/FreeRTOS/Source/tasks.c ****  * xDelayedTaskList1 and xDelayedTaskList2 could be moved to function scope but
 337:Lib/FreeRTOS/Source/tasks.c ****  * doing so breaks some kernel aware debuggers and debuggers that rely on removing
 338:Lib/FreeRTOS/Source/tasks.c ****  * the static qualifier. */
 339:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ]; /**< Prioritised ready tas
 340:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList1;                         /**< Delayed tasks. */
 341:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xDelayedTaskList2;                         /**< Delayed tasks (two li
 342:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;              /**< Points to the delayed
 343:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;      /**< Points to the delayed
 344:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static List_t xPendingReadyList;                         /**< Tasks that have been 
 345:Lib/FreeRTOS/Source/tasks.c **** 
 346:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 347:Lib/FreeRTOS/Source/tasks.c **** 
 348:Lib/FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static List_t xTasksWaitingTermination; /**< Tasks that have been deleted - but
ARM GAS  /tmp/ccTFOe4z.s 			page 10


 349:Lib/FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static volatile UBaseType_t uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 350:Lib/FreeRTOS/Source/tasks.c **** 
 351:Lib/FreeRTOS/Source/tasks.c **** #endif
 352:Lib/FreeRTOS/Source/tasks.c **** 
 353:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 354:Lib/FreeRTOS/Source/tasks.c **** 
 355:Lib/FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static List_t xSuspendedTaskList; /**< Tasks that are currently suspended. */
 356:Lib/FreeRTOS/Source/tasks.c **** 
 357:Lib/FreeRTOS/Source/tasks.c **** #endif
 358:Lib/FreeRTOS/Source/tasks.c **** 
 359:Lib/FreeRTOS/Source/tasks.c **** /* Global POSIX errno. Its value is changed upon context switching to match
 360:Lib/FreeRTOS/Source/tasks.c ****  * the errno of the currently running task. */
 361:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_POSIX_ERRNO == 1 )
 362:Lib/FreeRTOS/Source/tasks.c ****     int FreeRTOS_errno = 0;
 363:Lib/FreeRTOS/Source/tasks.c **** #endif
 364:Lib/FreeRTOS/Source/tasks.c **** 
 365:Lib/FreeRTOS/Source/tasks.c **** /* Other file private variables. --------------------------------*/
 366:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
 367:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 368:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority = tskIDLE_PRIORITY;
 369:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning = pdFALSE;
 370:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xPendedTicks = ( TickType_t ) 0U;
 371:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xYieldPending = pdFALSE;
 372:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows = ( BaseType_t ) 0;
 373:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static UBaseType_t uxTaskNumber = ( UBaseType_t ) 0U;
 374:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime = ( TickType_t ) 0U; /* Initialised
 375:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;                          /**< Holds the
 376:Lib/FreeRTOS/Source/tasks.c **** 
 377:Lib/FreeRTOS/Source/tasks.c **** /* Improve support for OpenOCD. The kernel tracks Ready tasks via priority lists.
 378:Lib/FreeRTOS/Source/tasks.c ****  * For tracking the state of remote threads, OpenOCD uses uxTopUsedPriority
 379:Lib/FreeRTOS/Source/tasks.c ****  * to determine the number of priority lists to read back from the remote target. */
 380:Lib/FreeRTOS/Source/tasks.c **** const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
 381:Lib/FreeRTOS/Source/tasks.c **** 
 382:Lib/FreeRTOS/Source/tasks.c **** /* Context switches are held pending while the scheduler is suspended.  Also,
 383:Lib/FreeRTOS/Source/tasks.c ****  * interrupts must not manipulate the xStateListItem of a TCB, or any of the
 384:Lib/FreeRTOS/Source/tasks.c ****  * lists the xStateListItem can be referenced from, if the scheduler is suspended.
 385:Lib/FreeRTOS/Source/tasks.c ****  * If an interrupt needs to unblock a task while the scheduler is suspended then it
 386:Lib/FreeRTOS/Source/tasks.c ****  * moves the task's event list item into the xPendingReadyList, ready for the
 387:Lib/FreeRTOS/Source/tasks.c ****  * kernel to move the task from the pending ready list into the real ready list
 388:Lib/FreeRTOS/Source/tasks.c ****  * when the scheduler is unsuspended.  The pending ready list itself can only be
 389:Lib/FreeRTOS/Source/tasks.c ****  * accessed from a critical section. */
 390:Lib/FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended = ( UBaseType_t ) 0U;
 391:Lib/FreeRTOS/Source/tasks.c **** 
 392:Lib/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 393:Lib/FreeRTOS/Source/tasks.c **** 
 394:Lib/FreeRTOS/Source/tasks.c **** /* Do not move these variables to function scope as doing so prevents the
 395:Lib/FreeRTOS/Source/tasks.c ****  * code working with debuggers that need to remove the static qualifier. */
 396:Lib/FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static configRUN_TIME_COUNTER_TYPE ulTaskSwitchedInTime = 0UL;    /**< Holds th
 397:Lib/FreeRTOS/Source/tasks.c ****     PRIVILEGED_DATA static volatile configRUN_TIME_COUNTER_TYPE ulTotalRunTime = 0UL; /**< Holds th
 398:Lib/FreeRTOS/Source/tasks.c **** 
 399:Lib/FreeRTOS/Source/tasks.c **** #endif
 400:Lib/FreeRTOS/Source/tasks.c **** 
 401:Lib/FreeRTOS/Source/tasks.c **** /*lint -restore */
 402:Lib/FreeRTOS/Source/tasks.c **** 
 403:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 404:Lib/FreeRTOS/Source/tasks.c **** 
 405:Lib/FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
ARM GAS  /tmp/ccTFOe4z.s 			page 11


 406:Lib/FreeRTOS/Source/tasks.c **** 
 407:Lib/FreeRTOS/Source/tasks.c **** /**
 408:Lib/FreeRTOS/Source/tasks.c ****  * Utility task that simply returns pdTRUE if the task referenced by xTask is
 409:Lib/FreeRTOS/Source/tasks.c ****  * currently in the Suspended state, or pdFALSE if the task referenced by xTask
 410:Lib/FreeRTOS/Source/tasks.c ****  * is in any other state.
 411:Lib/FreeRTOS/Source/tasks.c ****  */
 412:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 413:Lib/FreeRTOS/Source/tasks.c **** 
 414:Lib/FreeRTOS/Source/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
 415:Lib/FreeRTOS/Source/tasks.c **** 
 416:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
 417:Lib/FreeRTOS/Source/tasks.c **** 
 418:Lib/FreeRTOS/Source/tasks.c **** /*
 419:Lib/FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 420:Lib/FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 421:Lib/FreeRTOS/Source/tasks.c ****  */
 422:Lib/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 423:Lib/FreeRTOS/Source/tasks.c **** 
 424:Lib/FreeRTOS/Source/tasks.c **** /*
 425:Lib/FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 426:Lib/FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 427:Lib/FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 428:Lib/FreeRTOS/Source/tasks.c ****  *
 429:Lib/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 430:Lib/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 431:Lib/FreeRTOS/Source/tasks.c ****  *
 432:Lib/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 433:Lib/FreeRTOS/Source/tasks.c ****  *
 434:Lib/FreeRTOS/Source/tasks.c ****  */
 435:Lib/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters ) PRIVILEGED_FUNCTION;
 436:Lib/FreeRTOS/Source/tasks.c **** 
 437:Lib/FreeRTOS/Source/tasks.c **** /*
 438:Lib/FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 439:Lib/FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 440:Lib/FreeRTOS/Source/tasks.c ****  *
 441:Lib/FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 442:Lib/FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 443:Lib/FreeRTOS/Source/tasks.c ****  */
 444:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 445:Lib/FreeRTOS/Source/tasks.c **** 
 446:Lib/FreeRTOS/Source/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB ) PRIVILEGED_FUNCTION;
 447:Lib/FreeRTOS/Source/tasks.c **** 
 448:Lib/FreeRTOS/Source/tasks.c **** #endif
 449:Lib/FreeRTOS/Source/tasks.c **** 
 450:Lib/FreeRTOS/Source/tasks.c **** /*
 451:Lib/FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 452:Lib/FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 453:Lib/FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 454:Lib/FreeRTOS/Source/tasks.c ****  */
 455:Lib/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 456:Lib/FreeRTOS/Source/tasks.c **** 
 457:Lib/FreeRTOS/Source/tasks.c **** /*
 458:Lib/FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 459:Lib/FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 460:Lib/FreeRTOS/Source/tasks.c ****  */
 461:Lib/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
 462:Lib/FreeRTOS/Source/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely ) PRIVILEGED_FUN
ARM GAS  /tmp/ccTFOe4z.s 			page 12


 463:Lib/FreeRTOS/Source/tasks.c **** 
 464:Lib/FreeRTOS/Source/tasks.c **** /*
 465:Lib/FreeRTOS/Source/tasks.c ****  * Fills an TaskStatus_t structure with information on each task that is
 466:Lib/FreeRTOS/Source/tasks.c ****  * referenced from the pxList list (which may be a ready list, a delayed list,
 467:Lib/FreeRTOS/Source/tasks.c ****  * a suspended list, etc.).
 468:Lib/FreeRTOS/Source/tasks.c ****  *
 469:Lib/FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 470:Lib/FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 471:Lib/FreeRTOS/Source/tasks.c ****  */
 472:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 473:Lib/FreeRTOS/Source/tasks.c **** 
 474:Lib/FreeRTOS/Source/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
 475:Lib/FreeRTOS/Source/tasks.c ****                                                      List_t * pxList,
 476:Lib/FreeRTOS/Source/tasks.c ****                                                      eTaskState eState ) PRIVILEGED_FUNCTION;
 477:Lib/FreeRTOS/Source/tasks.c **** 
 478:Lib/FreeRTOS/Source/tasks.c **** #endif
 479:Lib/FreeRTOS/Source/tasks.c **** 
 480:Lib/FreeRTOS/Source/tasks.c **** /*
 481:Lib/FreeRTOS/Source/tasks.c ****  * Searches pxList for a task with name pcNameToQuery - returning a handle to
 482:Lib/FreeRTOS/Source/tasks.c ****  * the task if it is found, or NULL if the task is not found.
 483:Lib/FreeRTOS/Source/tasks.c ****  */
 484:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
 485:Lib/FreeRTOS/Source/tasks.c **** 
 486:Lib/FreeRTOS/Source/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
 487:Lib/FreeRTOS/Source/tasks.c ****                                                      const char pcNameToQuery[] ) PRIVILEGED_FUNCTI
 488:Lib/FreeRTOS/Source/tasks.c **** 
 489:Lib/FreeRTOS/Source/tasks.c **** #endif
 490:Lib/FreeRTOS/Source/tasks.c **** 
 491:Lib/FreeRTOS/Source/tasks.c **** /*
 492:Lib/FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 493:Lib/FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 494:Lib/FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 495:Lib/FreeRTOS/Source/tasks.c ****  */
 496:Lib/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
 497:Lib/FreeRTOS/Source/tasks.c **** 
 498:Lib/FreeRTOS/Source/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVIL
 499:Lib/FreeRTOS/Source/tasks.c **** 
 500:Lib/FreeRTOS/Source/tasks.c **** #endif
 501:Lib/FreeRTOS/Source/tasks.c **** 
 502:Lib/FreeRTOS/Source/tasks.c **** /*
 503:Lib/FreeRTOS/Source/tasks.c ****  * Return the amount of time, in ticks, that will pass before the kernel will
 504:Lib/FreeRTOS/Source/tasks.c ****  * next move a task from the Blocked state to the Running state.
 505:Lib/FreeRTOS/Source/tasks.c ****  *
 506:Lib/FreeRTOS/Source/tasks.c ****  * This conditional compilation should use inequality to 0, not equality to 1.
 507:Lib/FreeRTOS/Source/tasks.c ****  * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
 508:Lib/FreeRTOS/Source/tasks.c ****  * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
 509:Lib/FreeRTOS/Source/tasks.c ****  * set to a value other than 1.
 510:Lib/FreeRTOS/Source/tasks.c ****  */
 511:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
 512:Lib/FreeRTOS/Source/tasks.c **** 
 513:Lib/FreeRTOS/Source/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
 514:Lib/FreeRTOS/Source/tasks.c **** 
 515:Lib/FreeRTOS/Source/tasks.c **** #endif
 516:Lib/FreeRTOS/Source/tasks.c **** 
 517:Lib/FreeRTOS/Source/tasks.c **** /*
 518:Lib/FreeRTOS/Source/tasks.c ****  * Set xNextTaskUnblockTime to the time at which the next Blocked state task
 519:Lib/FreeRTOS/Source/tasks.c ****  * will exit the Blocked state.
ARM GAS  /tmp/ccTFOe4z.s 			page 13


 520:Lib/FreeRTOS/Source/tasks.c ****  */
 521:Lib/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void ) PRIVILEGED_FUNCTION;
 522:Lib/FreeRTOS/Source/tasks.c **** 
 523:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )
 524:Lib/FreeRTOS/Source/tasks.c **** 
 525:Lib/FreeRTOS/Source/tasks.c **** /*
 526:Lib/FreeRTOS/Source/tasks.c ****  * Helper function used to pad task names with spaces when printing out
 527:Lib/FreeRTOS/Source/tasks.c ****  * human readable tables of task information.
 528:Lib/FreeRTOS/Source/tasks.c ****  */
 529:Lib/FreeRTOS/Source/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
 530:Lib/FreeRTOS/Source/tasks.c ****                                         const char * pcTaskName ) PRIVILEGED_FUNCTION;
 531:Lib/FreeRTOS/Source/tasks.c **** 
 532:Lib/FreeRTOS/Source/tasks.c **** #endif
 533:Lib/FreeRTOS/Source/tasks.c **** 
 534:Lib/FreeRTOS/Source/tasks.c **** /*
 535:Lib/FreeRTOS/Source/tasks.c ****  * Called after a Task_t structure has been allocated either statically or
 536:Lib/FreeRTOS/Source/tasks.c ****  * dynamically to fill in the structure's members.
 537:Lib/FreeRTOS/Source/tasks.c ****  */
 538:Lib/FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 539:Lib/FreeRTOS/Source/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 540:Lib/FreeRTOS/Source/tasks.c ****                                   const uint32_t ulStackDepth,
 541:Lib/FreeRTOS/Source/tasks.c ****                                   void * const pvParameters,
 542:Lib/FreeRTOS/Source/tasks.c ****                                   UBaseType_t uxPriority,
 543:Lib/FreeRTOS/Source/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 544:Lib/FreeRTOS/Source/tasks.c ****                                   TCB_t * pxNewTCB,
 545:Lib/FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions ) PRIVILEGED_FUNCTION;
 546:Lib/FreeRTOS/Source/tasks.c **** 
 547:Lib/FreeRTOS/Source/tasks.c **** /*
 548:Lib/FreeRTOS/Source/tasks.c ****  * Called after a new task has been created and initialised to place the task
 549:Lib/FreeRTOS/Source/tasks.c ****  * under the control of the scheduler.
 550:Lib/FreeRTOS/Source/tasks.c ****  */
 551:Lib/FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB ) PRIVILEGED_FUNCTION;
 552:Lib/FreeRTOS/Source/tasks.c **** 
 553:Lib/FreeRTOS/Source/tasks.c **** /*
 554:Lib/FreeRTOS/Source/tasks.c ****  * freertos_tasks_c_additions_init() should only be called if the user definable
 555:Lib/FreeRTOS/Source/tasks.c ****  * macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is the only macro
 556:Lib/FreeRTOS/Source/tasks.c ****  * called by the function.
 557:Lib/FreeRTOS/Source/tasks.c ****  */
 558:Lib/FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
 559:Lib/FreeRTOS/Source/tasks.c **** 
 560:Lib/FreeRTOS/Source/tasks.c ****     static void freertos_tasks_c_additions_init( void ) PRIVILEGED_FUNCTION;
 561:Lib/FreeRTOS/Source/tasks.c **** 
 562:Lib/FreeRTOS/Source/tasks.c **** #endif
 563:Lib/FreeRTOS/Source/tasks.c **** 
 564:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 565:Lib/FreeRTOS/Source/tasks.c **** 
 566:Lib/FreeRTOS/Source/tasks.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 567:Lib/FreeRTOS/Source/tasks.c **** 
 568:Lib/FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode,
 569:Lib/FreeRTOS/Source/tasks.c ****                                     const char * const pcName, /*lint !e971 Unqualified char types 
 570:Lib/FreeRTOS/Source/tasks.c ****                                     const uint32_t ulStackDepth,
 571:Lib/FreeRTOS/Source/tasks.c ****                                     void * const pvParameters,
 572:Lib/FreeRTOS/Source/tasks.c ****                                     UBaseType_t uxPriority,
 573:Lib/FreeRTOS/Source/tasks.c ****                                     StackType_t * const puxStackBuffer,
 574:Lib/FreeRTOS/Source/tasks.c ****                                     StaticTask_t * const pxTaskBuffer )
 575:Lib/FreeRTOS/Source/tasks.c ****     {
 187              		.loc 1 575 5
ARM GAS  /tmp/ccTFOe4z.s 			page 14


 188              		.cfi_startproc
 189              		@ args = 12, pretend = 0, frame = 32
 190              		@ frame_needed = 1, uses_anonymous_args = 0
 191 0000 80B5     		push	{r7, lr}
 192              		.cfi_def_cfa_offset 8
 193              		.cfi_offset 7, -8
 194              		.cfi_offset 14, -4
 195 0002 8CB0     		sub	sp, sp, #48
 196              		.cfi_def_cfa_offset 56
 197 0004 04AF     		add	r7, sp, #16
 198              		.cfi_def_cfa 7, 40
 199 0006 F860     		str	r0, [r7, #12]
 200 0008 B960     		str	r1, [r7, #8]
 201 000a 7A60     		str	r2, [r7, #4]
 202 000c 3B60     		str	r3, [r7]
 576:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 577:Lib/FreeRTOS/Source/tasks.c ****         TaskHandle_t xReturn;
 578:Lib/FreeRTOS/Source/tasks.c **** 
 579:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( puxStackBuffer != NULL );
 203              		.loc 1 579 9
 204 000e FB6A     		ldr	r3, [r7, #44]
 205 0010 002B     		cmp	r3, #0
 206 0012 08D1     		bne	.L2
 207              		.loc 1 579 9 is_stmt 0 discriminator 1
 208 0014 FFF7FEFF 		bl	ulSetInterruptMask
 209 0018 254B     		ldr	r3, .L8
 210 001a 264A     		ldr	r2, .L8+4
 211 001c 40F24321 		movw	r1, #579
 212 0020 2548     		ldr	r0, .L8+8
 213 0022 FFF7FEFF 		bl	__assert_func
 214              	.L2:
 580:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskBuffer != NULL );
 215              		.loc 1 580 9 is_stmt 1
 216 0026 3B6B     		ldr	r3, [r7, #48]
 217 0028 002B     		cmp	r3, #0
 218 002a 08D1     		bne	.L3
 219              		.loc 1 580 9 is_stmt 0 discriminator 1
 220 002c FFF7FEFF 		bl	ulSetInterruptMask
 221 0030 1F4B     		ldr	r3, .L8
 222 0032 204A     		ldr	r2, .L8+4
 223 0034 4FF41171 		mov	r1, #580
 224 0038 1F48     		ldr	r0, .L8+8
 225 003a FFF7FEFF 		bl	__assert_func
 226              	.L3:
 227              	.LBB2:
 581:Lib/FreeRTOS/Source/tasks.c **** 
 582:Lib/FreeRTOS/Source/tasks.c ****         #if ( configASSERT_DEFINED == 1 )
 583:Lib/FreeRTOS/Source/tasks.c ****         {
 584:Lib/FreeRTOS/Source/tasks.c ****             /* Sanity check that the size of the structure used to declare a
 585:Lib/FreeRTOS/Source/tasks.c ****              * variable of type StaticTask_t equals the size of the real task
 586:Lib/FreeRTOS/Source/tasks.c ****              * structure. */
 587:Lib/FreeRTOS/Source/tasks.c ****             volatile size_t xSize = sizeof( StaticTask_t );
 228              		.loc 1 587 29 is_stmt 1
 229 003e 6023     		movs	r3, #96
 230 0040 7B61     		str	r3, [r7, #20]
 588:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( xSize == sizeof( TCB_t ) );
 231              		.loc 1 588 13
ARM GAS  /tmp/ccTFOe4z.s 			page 15


 232 0042 7B69     		ldr	r3, [r7, #20]
 233 0044 602B     		cmp	r3, #96
 234 0046 08D0     		beq	.L4
 235              		.loc 1 588 13 is_stmt 0 discriminator 1
 236 0048 FFF7FEFF 		bl	ulSetInterruptMask
 237 004c 184B     		ldr	r3, .L8
 238 004e 194A     		ldr	r2, .L8+4
 239 0050 4FF41371 		mov	r1, #588
 240 0054 1848     		ldr	r0, .L8+8
 241 0056 FFF7FEFF 		bl	__assert_func
 242              	.L4:
 589:Lib/FreeRTOS/Source/tasks.c ****             ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 243              		.loc 1 589 13 is_stmt 1
 244 005a 7B69     		ldr	r3, [r7, #20]
 245              	.LBE2:
 590:Lib/FreeRTOS/Source/tasks.c ****         }
 591:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configASSERT_DEFINED */
 592:Lib/FreeRTOS/Source/tasks.c **** 
 593:Lib/FreeRTOS/Source/tasks.c ****         if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 246              		.loc 1 593 11
 247 005c 3B6B     		ldr	r3, [r7, #48]
 248 005e 002B     		cmp	r3, #0
 249 0060 1FD0     		beq	.L5
 250              		.loc 1 593 38 discriminator 1
 251 0062 FB6A     		ldr	r3, [r7, #44]
 252 0064 002B     		cmp	r3, #0
 253 0066 1CD0     		beq	.L5
 594:Lib/FreeRTOS/Source/tasks.c ****         {
 595:Lib/FreeRTOS/Source/tasks.c ****             /* The memory used for the task's TCB and stack are passed into this
 596:Lib/FreeRTOS/Source/tasks.c ****              * function - use them. */
 597:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the stru
 254              		.loc 1 597 22
 255 0068 3B6B     		ldr	r3, [r7, #48]
 256 006a FB61     		str	r3, [r7, #28]
 598:Lib/FreeRTOS/Source/tasks.c ****             memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 257              		.loc 1 598 13
 258 006c 6022     		movs	r2, #96
 259 006e 0021     		movs	r1, #0
 260 0070 F869     		ldr	r0, [r7, #28]
 261 0072 FFF7FEFF 		bl	memset
 599:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 262              		.loc 1 599 31
 263 0076 FB69     		ldr	r3, [r7, #28]
 264 0078 FA6A     		ldr	r2, [r7, #44]
 265 007a 1A63     		str	r2, [r3, #48]
 600:Lib/FreeRTOS/Source/tasks.c **** 
 601:Lib/FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has be
 602:Lib/FreeRTOS/Source/tasks.c ****             {
 603:Lib/FreeRTOS/Source/tasks.c ****                 /* Tasks can be created statically or dynamically, so note this
 604:Lib/FreeRTOS/Source/tasks.c ****                  * task was created statically in case the task is later deleted. */
 605:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 606:Lib/FreeRTOS/Source/tasks.c ****             }
 607:Lib/FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 608:Lib/FreeRTOS/Source/tasks.c **** 
 609:Lib/FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xRet
 266              		.loc 1 609 13
 267 007c 0023     		movs	r3, #0
ARM GAS  /tmp/ccTFOe4z.s 			page 16


 268 007e 0393     		str	r3, [sp, #12]
 269 0080 FB69     		ldr	r3, [r7, #28]
 270 0082 0293     		str	r3, [sp, #8]
 271 0084 07F11803 		add	r3, r7, #24
 272 0088 0193     		str	r3, [sp, #4]
 273 008a BB6A     		ldr	r3, [r7, #40]
 274 008c 0093     		str	r3, [sp]
 275 008e 3B68     		ldr	r3, [r7]
 276 0090 7A68     		ldr	r2, [r7, #4]
 277 0092 B968     		ldr	r1, [r7, #8]
 278 0094 F868     		ldr	r0, [r7, #12]
 279 0096 FFF7FEFF 		bl	prvInitialiseNewTask
 610:Lib/FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 280              		.loc 1 610 13
 281 009a F869     		ldr	r0, [r7, #28]
 282 009c FFF7FEFF 		bl	prvAddNewTaskToReadyList
 283 00a0 01E0     		b	.L6
 284              	.L5:
 611:Lib/FreeRTOS/Source/tasks.c ****         }
 612:Lib/FreeRTOS/Source/tasks.c ****         else
 613:Lib/FreeRTOS/Source/tasks.c ****         {
 614:Lib/FreeRTOS/Source/tasks.c ****             xReturn = NULL;
 285              		.loc 1 614 21
 286 00a2 0023     		movs	r3, #0
 287 00a4 BB61     		str	r3, [r7, #24]
 288              	.L6:
 615:Lib/FreeRTOS/Source/tasks.c ****         }
 616:Lib/FreeRTOS/Source/tasks.c **** 
 617:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 289              		.loc 1 617 16
 290 00a6 BB69     		ldr	r3, [r7, #24]
 618:Lib/FreeRTOS/Source/tasks.c ****     }
 291              		.loc 1 618 5
 292 00a8 1846     		mov	r0, r3
 293 00aa 2037     		adds	r7, r7, #32
 294              		.cfi_def_cfa_offset 8
 295 00ac BD46     		mov	sp, r7
 296              		.cfi_def_cfa_register 13
 297              		@ sp needed
 298 00ae 80BD     		pop	{r7, pc}
 299              	.L9:
 300              		.align	2
 301              	.L8:
 302 00b0 00000000 		.word	.LC0
 303 00b4 00000000 		.word	__func__.34
 304 00b8 04000000 		.word	.LC1
 305              		.cfi_endproc
 306              	.LFE0:
 308              		.section	.text.prvInitialiseNewTask,"ax",%progbits
 309              		.align	1
 310              		.syntax unified
 311              		.thumb
 312              		.thumb_func
 314              	prvInitialiseNewTask:
 315              	.LFB1:
 619:Lib/FreeRTOS/Source/tasks.c **** 
 620:Lib/FreeRTOS/Source/tasks.c **** #endif /* SUPPORT_STATIC_ALLOCATION */
ARM GAS  /tmp/ccTFOe4z.s 			page 17


 621:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 622:Lib/FreeRTOS/Source/tasks.c **** 
 623:Lib/FreeRTOS/Source/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 624:Lib/FreeRTOS/Source/tasks.c **** 
 625:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition,
 626:Lib/FreeRTOS/Source/tasks.c ****                                             TaskHandle_t * pxCreatedTask )
 627:Lib/FreeRTOS/Source/tasks.c ****     {
 628:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 629:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 630:Lib/FreeRTOS/Source/tasks.c **** 
 631:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 632:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 633:Lib/FreeRTOS/Source/tasks.c **** 
 634:Lib/FreeRTOS/Source/tasks.c ****         if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NUL
 635:Lib/FreeRTOS/Source/tasks.c ****         {
 636:Lib/FreeRTOS/Source/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 637:Lib/FreeRTOS/Source/tasks.c ****              * on the implementation of the port malloc function and whether or
 638:Lib/FreeRTOS/Source/tasks.c ****              * not static allocation is being used. */
 639:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pxTaskDefinition->pxTaskBuffer;
 640:Lib/FreeRTOS/Source/tasks.c ****             memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 641:Lib/FreeRTOS/Source/tasks.c **** 
 642:Lib/FreeRTOS/Source/tasks.c ****             /* Store the stack location in the TCB. */
 643:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 644:Lib/FreeRTOS/Source/tasks.c **** 
 645:Lib/FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 646:Lib/FreeRTOS/Source/tasks.c ****             {
 647:Lib/FreeRTOS/Source/tasks.c ****                 /* Tasks can be created statically or dynamically, so note this
 648:Lib/FreeRTOS/Source/tasks.c ****                  * task was created statically in case the task is later deleted. */
 649:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 650:Lib/FreeRTOS/Source/tasks.c ****             }
 651:Lib/FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 652:Lib/FreeRTOS/Source/tasks.c **** 
 653:Lib/FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 654:Lib/FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->pcName,
 655:Lib/FreeRTOS/Source/tasks.c ****                                   ( uint32_t ) pxTaskDefinition->usStackDepth,
 656:Lib/FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->pvParameters,
 657:Lib/FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->uxPriority,
 658:Lib/FreeRTOS/Source/tasks.c ****                                   pxCreatedTask, pxNewTCB,
 659:Lib/FreeRTOS/Source/tasks.c ****                                   pxTaskDefinition->xRegions );
 660:Lib/FreeRTOS/Source/tasks.c **** 
 661:Lib/FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 662:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdPASS;
 663:Lib/FreeRTOS/Source/tasks.c ****         }
 664:Lib/FreeRTOS/Source/tasks.c **** 
 665:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 666:Lib/FreeRTOS/Source/tasks.c ****     }
 667:Lib/FreeRTOS/Source/tasks.c **** 
 668:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
 669:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 670:Lib/FreeRTOS/Source/tasks.c **** 
 671:Lib/FreeRTOS/Source/tasks.c **** #if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 672:Lib/FreeRTOS/Source/tasks.c **** 
 673:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition,
 674:Lib/FreeRTOS/Source/tasks.c ****                                       TaskHandle_t * pxCreatedTask )
 675:Lib/FreeRTOS/Source/tasks.c ****     {
 676:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 677:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
ARM GAS  /tmp/ccTFOe4z.s 			page 18


 678:Lib/FreeRTOS/Source/tasks.c **** 
 679:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTaskDefinition->puxStackBuffer );
 680:Lib/FreeRTOS/Source/tasks.c **** 
 681:Lib/FreeRTOS/Source/tasks.c ****         if( pxTaskDefinition->puxStackBuffer != NULL )
 682:Lib/FreeRTOS/Source/tasks.c ****         {
 683:Lib/FreeRTOS/Source/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends
 684:Lib/FreeRTOS/Source/tasks.c ****              * on the implementation of the port malloc function and whether or
 685:Lib/FreeRTOS/Source/tasks.c ****              * not static allocation is being used. */
 686:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 687:Lib/FreeRTOS/Source/tasks.c **** 
 688:Lib/FreeRTOS/Source/tasks.c ****             if( pxNewTCB != NULL )
 689:Lib/FreeRTOS/Source/tasks.c ****             {
 690:Lib/FreeRTOS/Source/tasks.c ****                 memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 691:Lib/FreeRTOS/Source/tasks.c **** 
 692:Lib/FreeRTOS/Source/tasks.c ****                 /* Store the stack location in the TCB. */
 693:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 694:Lib/FreeRTOS/Source/tasks.c **** 
 695:Lib/FreeRTOS/Source/tasks.c ****                 #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
 696:Lib/FreeRTOS/Source/tasks.c ****                 {
 697:Lib/FreeRTOS/Source/tasks.c ****                     /* Tasks can be created statically or dynamically, so note
 698:Lib/FreeRTOS/Source/tasks.c ****                      * this task had a statically allocated stack in case it is
 699:Lib/FreeRTOS/Source/tasks.c ****                      * later deleted.  The TCB was allocated dynamically. */
 700:Lib/FreeRTOS/Source/tasks.c ****                     pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 701:Lib/FreeRTOS/Source/tasks.c ****                 }
 702:Lib/FreeRTOS/Source/tasks.c ****                 #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 703:Lib/FreeRTOS/Source/tasks.c **** 
 704:Lib/FreeRTOS/Source/tasks.c ****                 prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 705:Lib/FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->pcName,
 706:Lib/FreeRTOS/Source/tasks.c ****                                       ( uint32_t ) pxTaskDefinition->usStackDepth,
 707:Lib/FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->pvParameters,
 708:Lib/FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->uxPriority,
 709:Lib/FreeRTOS/Source/tasks.c ****                                       pxCreatedTask, pxNewTCB,
 710:Lib/FreeRTOS/Source/tasks.c ****                                       pxTaskDefinition->xRegions );
 711:Lib/FreeRTOS/Source/tasks.c **** 
 712:Lib/FreeRTOS/Source/tasks.c ****                 prvAddNewTaskToReadyList( pxNewTCB );
 713:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
 714:Lib/FreeRTOS/Source/tasks.c ****             }
 715:Lib/FreeRTOS/Source/tasks.c ****         }
 716:Lib/FreeRTOS/Source/tasks.c **** 
 717:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 718:Lib/FreeRTOS/Source/tasks.c ****     }
 719:Lib/FreeRTOS/Source/tasks.c **** 
 720:Lib/FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
 721:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 722:Lib/FreeRTOS/Source/tasks.c **** 
 723:Lib/FreeRTOS/Source/tasks.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 724:Lib/FreeRTOS/Source/tasks.c **** 
 725:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCreate( TaskFunction_t pxTaskCode,
 726:Lib/FreeRTOS/Source/tasks.c ****                             const char * const pcName, /*lint !e971 Unqualified char types are allo
 727:Lib/FreeRTOS/Source/tasks.c ****                             const configSTACK_DEPTH_TYPE usStackDepth,
 728:Lib/FreeRTOS/Source/tasks.c ****                             void * const pvParameters,
 729:Lib/FreeRTOS/Source/tasks.c ****                             UBaseType_t uxPriority,
 730:Lib/FreeRTOS/Source/tasks.c ****                             TaskHandle_t * const pxCreatedTask )
 731:Lib/FreeRTOS/Source/tasks.c ****     {
 732:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxNewTCB;
 733:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
 734:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 19


 735:Lib/FreeRTOS/Source/tasks.c ****         /* If the stack grows down then allocate the stack then the TCB so the stack
 736:Lib/FreeRTOS/Source/tasks.c ****          * does not grow into the TCB.  Likewise if the stack grows up then allocate
 737:Lib/FreeRTOS/Source/tasks.c ****          * the TCB then the stack. */
 738:Lib/FreeRTOS/Source/tasks.c ****         #if ( portSTACK_GROWTH > 0 )
 739:Lib/FreeRTOS/Source/tasks.c ****         {
 740:Lib/FreeRTOS/Source/tasks.c ****             /* Allocate space for the TCB.  Where the memory comes from depends on
 741:Lib/FreeRTOS/Source/tasks.c ****              * the implementation of the port malloc function and whether or not static
 742:Lib/FreeRTOS/Source/tasks.c ****              * allocation is being used. */
 743:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 744:Lib/FreeRTOS/Source/tasks.c **** 
 745:Lib/FreeRTOS/Source/tasks.c ****             if( pxNewTCB != NULL )
 746:Lib/FreeRTOS/Source/tasks.c ****             {
 747:Lib/FreeRTOS/Source/tasks.c ****                 memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 748:Lib/FreeRTOS/Source/tasks.c **** 
 749:Lib/FreeRTOS/Source/tasks.c ****                 /* Allocate space for the stack used by the task being created.
 750:Lib/FreeRTOS/Source/tasks.c ****                  * The base of the stack memory stored in the TCB so the task can
 751:Lib/FreeRTOS/Source/tasks.c ****                  * be deleted later if required. */
 752:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocStack( ( ( ( size_t ) usStackDept
 753:Lib/FreeRTOS/Source/tasks.c **** 
 754:Lib/FreeRTOS/Source/tasks.c ****                 if( pxNewTCB->pxStack == NULL )
 755:Lib/FreeRTOS/Source/tasks.c ****                 {
 756:Lib/FreeRTOS/Source/tasks.c ****                     /* Could not allocate the stack.  Delete the allocated TCB. */
 757:Lib/FreeRTOS/Source/tasks.c ****                     vPortFree( pxNewTCB );
 758:Lib/FreeRTOS/Source/tasks.c ****                     pxNewTCB = NULL;
 759:Lib/FreeRTOS/Source/tasks.c ****                 }
 760:Lib/FreeRTOS/Source/tasks.c ****             }
 761:Lib/FreeRTOS/Source/tasks.c ****         }
 762:Lib/FreeRTOS/Source/tasks.c ****         #else /* portSTACK_GROWTH */
 763:Lib/FreeRTOS/Source/tasks.c ****         {
 764:Lib/FreeRTOS/Source/tasks.c ****             StackType_t * pxStack;
 765:Lib/FreeRTOS/Source/tasks.c **** 
 766:Lib/FreeRTOS/Source/tasks.c ****             /* Allocate space for the stack used by the task being created. */
 767:Lib/FreeRTOS/Source/tasks.c ****             pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) );
 768:Lib/FreeRTOS/Source/tasks.c **** 
 769:Lib/FreeRTOS/Source/tasks.c ****             if( pxStack != NULL )
 770:Lib/FreeRTOS/Source/tasks.c ****             {
 771:Lib/FreeRTOS/Source/tasks.c ****                 /* Allocate space for the TCB. */
 772:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All va
 773:Lib/FreeRTOS/Source/tasks.c **** 
 774:Lib/FreeRTOS/Source/tasks.c ****                 if( pxNewTCB != NULL )
 775:Lib/FreeRTOS/Source/tasks.c ****                 {
 776:Lib/FreeRTOS/Source/tasks.c ****                     memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 777:Lib/FreeRTOS/Source/tasks.c **** 
 778:Lib/FreeRTOS/Source/tasks.c ****                     /* Store the stack location in the TCB. */
 779:Lib/FreeRTOS/Source/tasks.c ****                     pxNewTCB->pxStack = pxStack;
 780:Lib/FreeRTOS/Source/tasks.c ****                 }
 781:Lib/FreeRTOS/Source/tasks.c ****                 else
 782:Lib/FreeRTOS/Source/tasks.c ****                 {
 783:Lib/FreeRTOS/Source/tasks.c ****                     /* The stack cannot be used as the TCB was not created.  Free
 784:Lib/FreeRTOS/Source/tasks.c ****                      * it again. */
 785:Lib/FreeRTOS/Source/tasks.c ****                     vPortFreeStack( pxStack );
 786:Lib/FreeRTOS/Source/tasks.c ****                 }
 787:Lib/FreeRTOS/Source/tasks.c ****             }
 788:Lib/FreeRTOS/Source/tasks.c ****             else
 789:Lib/FreeRTOS/Source/tasks.c ****             {
 790:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB = NULL;
 791:Lib/FreeRTOS/Source/tasks.c ****             }
ARM GAS  /tmp/ccTFOe4z.s 			page 20


 792:Lib/FreeRTOS/Source/tasks.c ****         }
 793:Lib/FreeRTOS/Source/tasks.c ****         #endif /* portSTACK_GROWTH */
 794:Lib/FreeRTOS/Source/tasks.c **** 
 795:Lib/FreeRTOS/Source/tasks.c ****         if( pxNewTCB != NULL )
 796:Lib/FreeRTOS/Source/tasks.c ****         {
 797:Lib/FreeRTOS/Source/tasks.c ****             #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has be
 798:Lib/FreeRTOS/Source/tasks.c ****             {
 799:Lib/FreeRTOS/Source/tasks.c ****                 /* Tasks can be created statically or dynamically, so note this
 800:Lib/FreeRTOS/Source/tasks.c ****                  * task was created dynamically in case it is later deleted. */
 801:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 802:Lib/FreeRTOS/Source/tasks.c ****             }
 803:Lib/FreeRTOS/Source/tasks.c ****             #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */
 804:Lib/FreeRTOS/Source/tasks.c **** 
 805:Lib/FreeRTOS/Source/tasks.c ****             prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPr
 806:Lib/FreeRTOS/Source/tasks.c ****             prvAddNewTaskToReadyList( pxNewTCB );
 807:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdPASS;
 808:Lib/FreeRTOS/Source/tasks.c ****         }
 809:Lib/FreeRTOS/Source/tasks.c ****         else
 810:Lib/FreeRTOS/Source/tasks.c ****         {
 811:Lib/FreeRTOS/Source/tasks.c ****             xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 812:Lib/FreeRTOS/Source/tasks.c ****         }
 813:Lib/FreeRTOS/Source/tasks.c **** 
 814:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 815:Lib/FreeRTOS/Source/tasks.c ****     }
 816:Lib/FreeRTOS/Source/tasks.c **** 
 817:Lib/FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 818:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 819:Lib/FreeRTOS/Source/tasks.c **** 
 820:Lib/FreeRTOS/Source/tasks.c **** static void prvInitialiseNewTask( TaskFunction_t pxTaskCode,
 821:Lib/FreeRTOS/Source/tasks.c ****                                   const char * const pcName, /*lint !e971 Unqualified char types ar
 822:Lib/FreeRTOS/Source/tasks.c ****                                   const uint32_t ulStackDepth,
 823:Lib/FreeRTOS/Source/tasks.c ****                                   void * const pvParameters,
 824:Lib/FreeRTOS/Source/tasks.c ****                                   UBaseType_t uxPriority,
 825:Lib/FreeRTOS/Source/tasks.c ****                                   TaskHandle_t * const pxCreatedTask,
 826:Lib/FreeRTOS/Source/tasks.c ****                                   TCB_t * pxNewTCB,
 827:Lib/FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions )
 828:Lib/FreeRTOS/Source/tasks.c **** {
 316              		.loc 1 828 1
 317              		.cfi_startproc
 318              		@ args = 16, pretend = 0, frame = 24
 319              		@ frame_needed = 1, uses_anonymous_args = 0
 320 0000 80B5     		push	{r7, lr}
 321              		.cfi_def_cfa_offset 8
 322              		.cfi_offset 7, -8
 323              		.cfi_offset 14, -4
 324 0002 86B0     		sub	sp, sp, #24
 325              		.cfi_def_cfa_offset 32
 326 0004 00AF     		add	r7, sp, #0
 327              		.cfi_def_cfa_register 7
 328 0006 F860     		str	r0, [r7, #12]
 329 0008 B960     		str	r1, [r7, #8]
 330 000a 7A60     		str	r2, [r7, #4]
 331 000c 3B60     		str	r3, [r7]
 829:Lib/FreeRTOS/Source/tasks.c ****     StackType_t * pxTopOfStack;
 830:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t x;
 831:Lib/FreeRTOS/Source/tasks.c **** 
 832:Lib/FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
ARM GAS  /tmp/ccTFOe4z.s 			page 21


 833:Lib/FreeRTOS/Source/tasks.c ****         /* Should the task be created in privileged mode? */
 834:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xRunPrivileged;
 835:Lib/FreeRTOS/Source/tasks.c **** 
 836:Lib/FreeRTOS/Source/tasks.c ****         if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 837:Lib/FreeRTOS/Source/tasks.c ****         {
 838:Lib/FreeRTOS/Source/tasks.c ****             xRunPrivileged = pdTRUE;
 839:Lib/FreeRTOS/Source/tasks.c ****         }
 840:Lib/FreeRTOS/Source/tasks.c ****         else
 841:Lib/FreeRTOS/Source/tasks.c ****         {
 842:Lib/FreeRTOS/Source/tasks.c ****             xRunPrivileged = pdFALSE;
 843:Lib/FreeRTOS/Source/tasks.c ****         }
 844:Lib/FreeRTOS/Source/tasks.c ****         uxPriority &= ~portPRIVILEGE_BIT;
 845:Lib/FreeRTOS/Source/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS == 1 */
 846:Lib/FreeRTOS/Source/tasks.c **** 
 847:Lib/FreeRTOS/Source/tasks.c ****     /* Avoid dependency on memset() if it is not required. */
 848:Lib/FreeRTOS/Source/tasks.c ****     #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
 849:Lib/FreeRTOS/Source/tasks.c ****     {
 850:Lib/FreeRTOS/Source/tasks.c ****         /* Fill the stack with a known value to assist debugging. */
 851:Lib/FreeRTOS/Source/tasks.c ****         ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * s
 332              		.loc 1 851 34
 333 000e BB6A     		ldr	r3, [r7, #40]
 334 0010 186B     		ldr	r0, [r3, #48]
 335              		.loc 1 851 18
 336 0012 7B68     		ldr	r3, [r7, #4]
 337 0014 9B00     		lsls	r3, r3, #2
 338 0016 1A46     		mov	r2, r3
 339 0018 A521     		movs	r1, #165
 340 001a FFF7FEFF 		bl	memset
 852:Lib/FreeRTOS/Source/tasks.c ****     }
 853:Lib/FreeRTOS/Source/tasks.c ****     #endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
 854:Lib/FreeRTOS/Source/tasks.c **** 
 855:Lib/FreeRTOS/Source/tasks.c ****     /* Calculate the top of stack address.  This depends on whether the stack
 856:Lib/FreeRTOS/Source/tasks.c ****      * grows from high memory to low (as per the 80x86) or vice versa.
 857:Lib/FreeRTOS/Source/tasks.c ****      * portSTACK_GROWTH is used to make the result positive or negative as required
 858:Lib/FreeRTOS/Source/tasks.c ****      * by the port. */
 859:Lib/FreeRTOS/Source/tasks.c ****     #if ( portSTACK_GROWTH < 0 )
 860:Lib/FreeRTOS/Source/tasks.c ****     {
 861:Lib/FreeRTOS/Source/tasks.c ****         pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 341              		.loc 1 861 35
 342 001e BB6A     		ldr	r3, [r7, #40]
 343 0020 1A6B     		ldr	r2, [r3, #48]
 344              		.loc 1 861 44
 345 0022 7B68     		ldr	r3, [r7, #4]
 346 0024 03F18043 		add	r3, r3, #1073741824
 347 0028 013B     		subs	r3, r3, #1
 348 002a 9B00     		lsls	r3, r3, #2
 349              		.loc 1 861 22
 350 002c 1344     		add	r3, r3, r2
 351 002e 3B61     		str	r3, [r7, #16]
 862:Lib/FreeRTOS/Source/tasks.c ****         pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( port
 352              		.loc 1 862 46
 353 0030 3B69     		ldr	r3, [r7, #16]
 354              		.loc 1 862 87
 355 0032 23F00703 		bic	r3, r3, #7
 356              		.loc 1 862 22
 357 0036 3B61     		str	r3, [r7, #16]
 863:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 22


 864:Lib/FreeRTOS/Source/tasks.c ****         /* Check the alignment of the calculated top of stack is correct. */
 865:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBY
 358              		.loc 1 865 9
 359 0038 3B69     		ldr	r3, [r7, #16]
 360 003a 03F00703 		and	r3, r3, #7
 361 003e 002B     		cmp	r3, #0
 362 0040 08D0     		beq	.L11
 363              		.loc 1 865 9 is_stmt 0 discriminator 1
 364 0042 FFF7FEFF 		bl	ulSetInterruptMask
 365 0046 344B     		ldr	r3, .L22
 366 0048 344A     		ldr	r2, .L22+4
 367 004a 40F26131 		movw	r1, #865
 368 004e 3448     		ldr	r0, .L22+8
 369 0050 FFF7FEFF 		bl	__assert_func
 370              	.L11:
 866:Lib/FreeRTOS/Source/tasks.c **** 
 867:Lib/FreeRTOS/Source/tasks.c ****         #if ( configRECORD_STACK_HIGH_ADDRESS == 1 )
 868:Lib/FreeRTOS/Source/tasks.c ****         {
 869:Lib/FreeRTOS/Source/tasks.c ****             /* Also record the stack's high address, which may assist
 870:Lib/FreeRTOS/Source/tasks.c ****              * debugging. */
 871:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pxEndOfStack = pxTopOfStack;
 872:Lib/FreeRTOS/Source/tasks.c ****         }
 873:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configRECORD_STACK_HIGH_ADDRESS */
 874:Lib/FreeRTOS/Source/tasks.c ****     }
 875:Lib/FreeRTOS/Source/tasks.c ****     #else /* portSTACK_GROWTH */
 876:Lib/FreeRTOS/Source/tasks.c ****     {
 877:Lib/FreeRTOS/Source/tasks.c ****         pxTopOfStack = pxNewTCB->pxStack;
 878:Lib/FreeRTOS/Source/tasks.c **** 
 879:Lib/FreeRTOS/Source/tasks.c ****         /* Check the alignment of the stack buffer is correct. */
 880:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) p
 881:Lib/FreeRTOS/Source/tasks.c **** 
 882:Lib/FreeRTOS/Source/tasks.c ****         /* The other extreme of the stack space is required if stack checking is
 883:Lib/FreeRTOS/Source/tasks.c ****          * performed. */
 884:Lib/FreeRTOS/Source/tasks.c ****         pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 885:Lib/FreeRTOS/Source/tasks.c ****     }
 886:Lib/FreeRTOS/Source/tasks.c ****     #endif /* portSTACK_GROWTH */
 887:Lib/FreeRTOS/Source/tasks.c **** 
 888:Lib/FreeRTOS/Source/tasks.c ****     /* Store the task name in the TCB. */
 889:Lib/FreeRTOS/Source/tasks.c ****     if( pcName != NULL )
 371              		.loc 1 889 7 is_stmt 1
 372 0054 BB68     		ldr	r3, [r7, #8]
 373 0056 002B     		cmp	r3, #0
 374 0058 1ED0     		beq	.L12
 890:Lib/FreeRTOS/Source/tasks.c ****     {
 891:Lib/FreeRTOS/Source/tasks.c ****         for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 375              		.loc 1 891 16
 376 005a 0023     		movs	r3, #0
 377 005c 7B61     		str	r3, [r7, #20]
 378              		.loc 1 891 9
 379 005e 12E0     		b	.L13
 380              	.L16:
 892:Lib/FreeRTOS/Source/tasks.c ****         {
 893:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 381              		.loc 1 893 47
 382 0060 BA68     		ldr	r2, [r7, #8]
 383 0062 7B69     		ldr	r3, [r7, #20]
 384 0064 1344     		add	r3, r3, r2
ARM GAS  /tmp/ccTFOe4z.s 			page 23


 385 0066 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 386              		.loc 1 893 39
 387 0068 BA6A     		ldr	r2, [r7, #40]
 388 006a 7B69     		ldr	r3, [r7, #20]
 389 006c 1344     		add	r3, r3, r2
 390 006e 3433     		adds	r3, r3, #52
 391 0070 0A46     		mov	r2, r1
 392 0072 1A70     		strb	r2, [r3]
 894:Lib/FreeRTOS/Source/tasks.c **** 
 895:Lib/FreeRTOS/Source/tasks.c ****             /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
 896:Lib/FreeRTOS/Source/tasks.c ****              * configMAX_TASK_NAME_LEN characters just in case the memory after the
 897:Lib/FreeRTOS/Source/tasks.c ****              * string is not accessible (extremely unlikely). */
 898:Lib/FreeRTOS/Source/tasks.c ****             if( pcName[ x ] == ( char ) 0x00 )
 393              		.loc 1 898 23
 394 0074 BA68     		ldr	r2, [r7, #8]
 395 0076 7B69     		ldr	r3, [r7, #20]
 396 0078 1344     		add	r3, r3, r2
 397 007a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 398              		.loc 1 898 15
 399 007c 002B     		cmp	r3, #0
 400 007e 06D0     		beq	.L20
 891:Lib/FreeRTOS/Source/tasks.c ****         {
 401              		.loc 1 891 83 discriminator 2
 402 0080 7B69     		ldr	r3, [r7, #20]
 403 0082 0133     		adds	r3, r3, #1
 404 0084 7B61     		str	r3, [r7, #20]
 405              	.L13:
 891:Lib/FreeRTOS/Source/tasks.c ****         {
 406              		.loc 1 891 39 discriminator 1
 407 0086 7B69     		ldr	r3, [r7, #20]
 408 0088 0F2B     		cmp	r3, #15
 409 008a E9D9     		bls	.L16
 410 008c 00E0     		b	.L15
 411              	.L20:
 899:Lib/FreeRTOS/Source/tasks.c ****             {
 900:Lib/FreeRTOS/Source/tasks.c ****                 break;
 412              		.loc 1 900 17
 413 008e 00BF     		nop
 414              	.L15:
 901:Lib/FreeRTOS/Source/tasks.c ****             }
 902:Lib/FreeRTOS/Source/tasks.c ****             else
 903:Lib/FreeRTOS/Source/tasks.c ****             {
 904:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
 905:Lib/FreeRTOS/Source/tasks.c ****             }
 906:Lib/FreeRTOS/Source/tasks.c ****         }
 907:Lib/FreeRTOS/Source/tasks.c **** 
 908:Lib/FreeRTOS/Source/tasks.c ****         /* Ensure the name string is terminated in the case that the string length
 909:Lib/FreeRTOS/Source/tasks.c ****          * was greater or equal to configMAX_TASK_NAME_LEN. */
 910:Lib/FreeRTOS/Source/tasks.c ****         pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 415              		.loc 1 910 61
 416 0090 BB6A     		ldr	r3, [r7, #40]
 417 0092 0022     		movs	r2, #0
 418 0094 83F84320 		strb	r2, [r3, #67]
 419              	.L12:
 911:Lib/FreeRTOS/Source/tasks.c ****     }
 912:Lib/FreeRTOS/Source/tasks.c ****     else
 913:Lib/FreeRTOS/Source/tasks.c ****     {
ARM GAS  /tmp/ccTFOe4z.s 			page 24


 914:Lib/FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
 915:Lib/FreeRTOS/Source/tasks.c ****     }
 916:Lib/FreeRTOS/Source/tasks.c **** 
 917:Lib/FreeRTOS/Source/tasks.c ****     /* This is used as an array index so must ensure it's not too large. */
 918:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( uxPriority < configMAX_PRIORITIES );
 420              		.loc 1 918 5
 421 0098 3B6A     		ldr	r3, [r7, #32]
 422 009a 372B     		cmp	r3, #55
 423 009c 08D9     		bls	.L17
 424              		.loc 1 918 5 is_stmt 0 discriminator 1
 425 009e FFF7FEFF 		bl	ulSetInterruptMask
 426 00a2 1D4B     		ldr	r3, .L22
 427 00a4 1D4A     		ldr	r2, .L22+4
 428 00a6 40F29631 		movw	r1, #918
 429 00aa 1D48     		ldr	r0, .L22+8
 430 00ac FFF7FEFF 		bl	__assert_func
 431              	.L17:
 919:Lib/FreeRTOS/Source/tasks.c **** 
 920:Lib/FreeRTOS/Source/tasks.c ****     if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 432              		.loc 1 920 7 is_stmt 1
 433 00b0 3B6A     		ldr	r3, [r7, #32]
 434 00b2 372B     		cmp	r3, #55
 435 00b4 01D9     		bls	.L18
 921:Lib/FreeRTOS/Source/tasks.c ****     {
 922:Lib/FreeRTOS/Source/tasks.c ****         uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 436              		.loc 1 922 20
 437 00b6 3723     		movs	r3, #55
 438 00b8 3B62     		str	r3, [r7, #32]
 439              	.L18:
 923:Lib/FreeRTOS/Source/tasks.c ****     }
 924:Lib/FreeRTOS/Source/tasks.c ****     else
 925:Lib/FreeRTOS/Source/tasks.c ****     {
 926:Lib/FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
 927:Lib/FreeRTOS/Source/tasks.c ****     }
 928:Lib/FreeRTOS/Source/tasks.c **** 
 929:Lib/FreeRTOS/Source/tasks.c ****     pxNewTCB->uxPriority = uxPriority;
 440              		.loc 1 929 26
 441 00ba BB6A     		ldr	r3, [r7, #40]
 442 00bc 3A6A     		ldr	r2, [r7, #32]
 443 00be DA62     		str	r2, [r3, #44]
 930:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_MUTEXES == 1 )
 931:Lib/FreeRTOS/Source/tasks.c ****     {
 932:Lib/FreeRTOS/Source/tasks.c ****         pxNewTCB->uxBasePriority = uxPriority;
 444              		.loc 1 932 34
 445 00c0 BB6A     		ldr	r3, [r7, #40]
 446 00c2 3A6A     		ldr	r2, [r7, #32]
 447 00c4 DA64     		str	r2, [r3, #76]
 933:Lib/FreeRTOS/Source/tasks.c ****     }
 934:Lib/FreeRTOS/Source/tasks.c ****     #endif /* configUSE_MUTEXES */
 935:Lib/FreeRTOS/Source/tasks.c **** 
 936:Lib/FreeRTOS/Source/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 448              		.loc 1 936 5
 449 00c6 BB6A     		ldr	r3, [r7, #40]
 450 00c8 0433     		adds	r3, r3, #4
 451 00ca 1846     		mov	r0, r3
 452 00cc FFF7FEFF 		bl	vListInitialiseItem
 937:Lib/FreeRTOS/Source/tasks.c ****     vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
ARM GAS  /tmp/ccTFOe4z.s 			page 25


 453              		.loc 1 937 5
 454 00d0 BB6A     		ldr	r3, [r7, #40]
 455 00d2 1833     		adds	r3, r3, #24
 456 00d4 1846     		mov	r0, r3
 457 00d6 FFF7FEFF 		bl	vListInitialiseItem
 938:Lib/FreeRTOS/Source/tasks.c **** 
 939:Lib/FreeRTOS/Source/tasks.c ****     /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
 940:Lib/FreeRTOS/Source/tasks.c ****      * back to  the containing TCB from a generic item in a list. */
 941:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 458              		.loc 1 941 5
 459 00da BB6A     		ldr	r3, [r7, #40]
 460 00dc BA6A     		ldr	r2, [r7, #40]
 461 00de 1A61     		str	r2, [r3, #16]
 942:Lib/FreeRTOS/Source/tasks.c **** 
 943:Lib/FreeRTOS/Source/tasks.c ****     /* Event lists are always in priority order. */
 944:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - (
 462              		.loc 1 944 5
 463 00e0 3B6A     		ldr	r3, [r7, #32]
 464 00e2 C3F13802 		rsb	r2, r3, #56
 465 00e6 BB6A     		ldr	r3, [r7, #40]
 466 00e8 9A61     		str	r2, [r3, #24]
 945:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 467              		.loc 1 945 5
 468 00ea BB6A     		ldr	r3, [r7, #40]
 469 00ec BA6A     		ldr	r2, [r7, #40]
 470 00ee 5A62     		str	r2, [r3, #36]
 946:Lib/FreeRTOS/Source/tasks.c **** 
 947:Lib/FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 948:Lib/FreeRTOS/Source/tasks.c ****     {
 949:Lib/FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStac
 950:Lib/FreeRTOS/Source/tasks.c ****     }
 951:Lib/FreeRTOS/Source/tasks.c ****     #else
 952:Lib/FreeRTOS/Source/tasks.c ****     {
 953:Lib/FreeRTOS/Source/tasks.c ****         /* Avoid compiler warning about unreferenced parameter. */
 954:Lib/FreeRTOS/Source/tasks.c ****         ( void ) xRegions;
 955:Lib/FreeRTOS/Source/tasks.c ****     }
 956:Lib/FreeRTOS/Source/tasks.c ****     #endif
 957:Lib/FreeRTOS/Source/tasks.c **** 
 958:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
 959:Lib/FreeRTOS/Source/tasks.c ****     {
 960:Lib/FreeRTOS/Source/tasks.c ****         /* Allocate and initialize memory for the task's TLS Block. */
 961:Lib/FreeRTOS/Source/tasks.c ****         configINIT_TLS_BLOCK( pxNewTCB->xTLSBlock, pxTopOfStack );
 962:Lib/FreeRTOS/Source/tasks.c ****     }
 963:Lib/FreeRTOS/Source/tasks.c ****     #endif
 964:Lib/FreeRTOS/Source/tasks.c **** 
 965:Lib/FreeRTOS/Source/tasks.c ****     /* Initialize the TCB stack to look as if the task was already running,
 966:Lib/FreeRTOS/Source/tasks.c ****      * but had been interrupted by the scheduler.  The return address is set
 967:Lib/FreeRTOS/Source/tasks.c ****      * to the start of the task function. Once the stack has been initialised
 968:Lib/FreeRTOS/Source/tasks.c ****      * the top of stack variable is updated. */
 969:Lib/FreeRTOS/Source/tasks.c ****     #if ( portUSING_MPU_WRAPPERS == 1 )
 970:Lib/FreeRTOS/Source/tasks.c ****     {
 971:Lib/FreeRTOS/Source/tasks.c ****         /* If the port has capability to detect stack overflow,
 972:Lib/FreeRTOS/Source/tasks.c ****          * pass the stack end address to the stack initialization
 973:Lib/FreeRTOS/Source/tasks.c ****          * function as well. */
 974:Lib/FreeRTOS/Source/tasks.c ****         #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
 975:Lib/FreeRTOS/Source/tasks.c ****         {
 976:Lib/FreeRTOS/Source/tasks.c ****             #if ( portSTACK_GROWTH < 0 )
ARM GAS  /tmp/ccTFOe4z.s 			page 26


 977:Lib/FreeRTOS/Source/tasks.c ****             {
 978:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, px
 979:Lib/FreeRTOS/Source/tasks.c ****             }
 980:Lib/FreeRTOS/Source/tasks.c ****             #else /* portSTACK_GROWTH */
 981:Lib/FreeRTOS/Source/tasks.c ****             {
 982:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStac
 983:Lib/FreeRTOS/Source/tasks.c ****             }
 984:Lib/FreeRTOS/Source/tasks.c ****             #endif /* portSTACK_GROWTH */
 985:Lib/FreeRTOS/Source/tasks.c ****         }
 986:Lib/FreeRTOS/Source/tasks.c ****         #else /* portHAS_STACK_OVERFLOW_CHECKING */
 987:Lib/FreeRTOS/Source/tasks.c ****         {
 988:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters,
 989:Lib/FreeRTOS/Source/tasks.c ****         }
 990:Lib/FreeRTOS/Source/tasks.c ****         #endif /* portHAS_STACK_OVERFLOW_CHECKING */
 991:Lib/FreeRTOS/Source/tasks.c ****     }
 992:Lib/FreeRTOS/Source/tasks.c ****     #else /* portUSING_MPU_WRAPPERS */
 993:Lib/FreeRTOS/Source/tasks.c ****     {
 994:Lib/FreeRTOS/Source/tasks.c ****         /* If the port has capability to detect stack overflow,
 995:Lib/FreeRTOS/Source/tasks.c ****          * pass the stack end address to the stack initialization
 996:Lib/FreeRTOS/Source/tasks.c ****          * function as well. */
 997:Lib/FreeRTOS/Source/tasks.c ****         #if ( portHAS_STACK_OVERFLOW_CHECKING == 1 )
 998:Lib/FreeRTOS/Source/tasks.c ****         {
 999:Lib/FreeRTOS/Source/tasks.c ****             #if ( portSTACK_GROWTH < 0 )
1000:Lib/FreeRTOS/Source/tasks.c ****             {
1001:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxStack, px
 471              		.loc 1 1001 42
 472 00f0 BB6A     		ldr	r3, [r7, #40]
 473 00f2 196B     		ldr	r1, [r3, #48]
 474 00f4 3B68     		ldr	r3, [r7]
 475 00f6 FA68     		ldr	r2, [r7, #12]
 476 00f8 3869     		ldr	r0, [r7, #16]
 477 00fa FFF7FEFF 		bl	pxPortInitialiseStack
 478 00fe 0246     		mov	r2, r0
 479              		.loc 1 1001 40 discriminator 1
 480 0100 BB6A     		ldr	r3, [r7, #40]
 481 0102 1A60     		str	r2, [r3]
1002:Lib/FreeRTOS/Source/tasks.c ****             }
1003:Lib/FreeRTOS/Source/tasks.c ****             #else /* portSTACK_GROWTH */
1004:Lib/FreeRTOS/Source/tasks.c ****             {
1005:Lib/FreeRTOS/Source/tasks.c ****                 pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxNewTCB->pxEndOfStac
1006:Lib/FreeRTOS/Source/tasks.c ****             }
1007:Lib/FreeRTOS/Source/tasks.c ****             #endif /* portSTACK_GROWTH */
1008:Lib/FreeRTOS/Source/tasks.c ****         }
1009:Lib/FreeRTOS/Source/tasks.c ****         #else /* portHAS_STACK_OVERFLOW_CHECKING */
1010:Lib/FreeRTOS/Source/tasks.c ****         {
1011:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters 
1012:Lib/FreeRTOS/Source/tasks.c ****         }
1013:Lib/FreeRTOS/Source/tasks.c ****         #endif /* portHAS_STACK_OVERFLOW_CHECKING */
1014:Lib/FreeRTOS/Source/tasks.c ****     }
1015:Lib/FreeRTOS/Source/tasks.c ****     #endif /* portUSING_MPU_WRAPPERS */
1016:Lib/FreeRTOS/Source/tasks.c **** 
1017:Lib/FreeRTOS/Source/tasks.c ****     if( pxCreatedTask != NULL )
 482              		.loc 1 1017 7
 483 0104 7B6A     		ldr	r3, [r7, #36]
 484 0106 002B     		cmp	r3, #0
 485 0108 02D0     		beq	.L21
1018:Lib/FreeRTOS/Source/tasks.c ****     {
ARM GAS  /tmp/ccTFOe4z.s 			page 27


1019:Lib/FreeRTOS/Source/tasks.c ****         /* Pass the handle out in an anonymous way.  The handle can be used to
1020:Lib/FreeRTOS/Source/tasks.c ****          * change the created task's priority, delete the created task, etc.*/
1021:Lib/FreeRTOS/Source/tasks.c ****         *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 486              		.loc 1 1021 24
 487 010a 7B6A     		ldr	r3, [r7, #36]
 488 010c BA6A     		ldr	r2, [r7, #40]
 489 010e 1A60     		str	r2, [r3]
 490              	.L21:
1022:Lib/FreeRTOS/Source/tasks.c ****     }
1023:Lib/FreeRTOS/Source/tasks.c ****     else
1024:Lib/FreeRTOS/Source/tasks.c ****     {
1025:Lib/FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1026:Lib/FreeRTOS/Source/tasks.c ****     }
1027:Lib/FreeRTOS/Source/tasks.c **** }
 491              		.loc 1 1027 1
 492 0110 00BF     		nop
 493 0112 1837     		adds	r7, r7, #24
 494              		.cfi_def_cfa_offset 8
 495 0114 BD46     		mov	sp, r7
 496              		.cfi_def_cfa_register 13
 497              		@ sp needed
 498 0116 80BD     		pop	{r7, pc}
 499              	.L23:
 500              		.align	2
 501              	.L22:
 502 0118 00000000 		.word	.LC0
 503 011c 00000000 		.word	__func__.33
 504 0120 04000000 		.word	.LC1
 505              		.cfi_endproc
 506              	.LFE1:
 508              		.section	.text.prvAddNewTaskToReadyList,"ax",%progbits
 509              		.align	1
 510              		.syntax unified
 511              		.thumb
 512              		.thumb_func
 514              	prvAddNewTaskToReadyList:
 515              	.LFB2:
1028:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1029:Lib/FreeRTOS/Source/tasks.c **** 
1030:Lib/FreeRTOS/Source/tasks.c **** static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
1031:Lib/FreeRTOS/Source/tasks.c **** {
 516              		.loc 1 1031 1
 517              		.cfi_startproc
 518              		@ args = 0, pretend = 0, frame = 16
 519              		@ frame_needed = 1, uses_anonymous_args = 0
 520 0000 80B5     		push	{r7, lr}
 521              		.cfi_def_cfa_offset 8
 522              		.cfi_offset 7, -8
 523              		.cfi_offset 14, -4
 524 0002 84B0     		sub	sp, sp, #16
 525              		.cfi_def_cfa_offset 24
 526 0004 00AF     		add	r7, sp, #0
 527              		.cfi_def_cfa_register 7
 528 0006 7860     		str	r0, [r7, #4]
1032:Lib/FreeRTOS/Source/tasks.c ****     /* Ensure interrupts don't access the task lists while the lists are being
1033:Lib/FreeRTOS/Source/tasks.c ****      * updated. */
1034:Lib/FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
ARM GAS  /tmp/ccTFOe4z.s 			page 28


 529              		.loc 1 1034 5
 530 0008 FFF7FEFF 		bl	vPortEnterCritical
1035:Lib/FreeRTOS/Source/tasks.c ****     {
1036:Lib/FreeRTOS/Source/tasks.c ****         uxCurrentNumberOfTasks++;
 531              		.loc 1 1036 31
 532 000c 3E4B     		ldr	r3, .L30
 533 000e 1B68     		ldr	r3, [r3]
 534 0010 0133     		adds	r3, r3, #1
 535 0012 3D4A     		ldr	r2, .L30
 536 0014 1360     		str	r3, [r2]
1037:Lib/FreeRTOS/Source/tasks.c **** 
1038:Lib/FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB == NULL )
 537              		.loc 1 1038 26
 538 0016 3D4B     		ldr	r3, .L30+4
 539 0018 1B68     		ldr	r3, [r3]
 540              		.loc 1 1038 11
 541 001a 002B     		cmp	r3, #0
 542 001c 09D1     		bne	.L25
1039:Lib/FreeRTOS/Source/tasks.c ****         {
1040:Lib/FreeRTOS/Source/tasks.c ****             /* There are no other tasks, or all the other tasks are in
1041:Lib/FreeRTOS/Source/tasks.c ****              * the suspended state - make this the current task. */
1042:Lib/FreeRTOS/Source/tasks.c ****             pxCurrentTCB = pxNewTCB;
 543              		.loc 1 1042 26
 544 001e 3B4A     		ldr	r2, .L30+4
 545 0020 7B68     		ldr	r3, [r7, #4]
 546 0022 1360     		str	r3, [r2]
1043:Lib/FreeRTOS/Source/tasks.c **** 
1044:Lib/FreeRTOS/Source/tasks.c ****             if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 547              		.loc 1 1044 40
 548 0024 384B     		ldr	r3, .L30
 549 0026 1B68     		ldr	r3, [r3]
 550              		.loc 1 1044 15
 551 0028 012B     		cmp	r3, #1
 552 002a 10D1     		bne	.L26
1045:Lib/FreeRTOS/Source/tasks.c ****             {
1046:Lib/FreeRTOS/Source/tasks.c ****                 /* This is the first task to be created so do the preliminary
1047:Lib/FreeRTOS/Source/tasks.c ****                  * initialisation required.  We will not recover if this call
1048:Lib/FreeRTOS/Source/tasks.c ****                  * fails, but we will report the failure. */
1049:Lib/FreeRTOS/Source/tasks.c ****                 prvInitialiseTaskLists();
 553              		.loc 1 1049 17
 554 002c FFF7FEFF 		bl	prvInitialiseTaskLists
 555 0030 0DE0     		b	.L26
 556              	.L25:
1050:Lib/FreeRTOS/Source/tasks.c ****             }
1051:Lib/FreeRTOS/Source/tasks.c ****             else
1052:Lib/FreeRTOS/Source/tasks.c ****             {
1053:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1054:Lib/FreeRTOS/Source/tasks.c ****             }
1055:Lib/FreeRTOS/Source/tasks.c ****         }
1056:Lib/FreeRTOS/Source/tasks.c ****         else
1057:Lib/FreeRTOS/Source/tasks.c ****         {
1058:Lib/FreeRTOS/Source/tasks.c ****             /* If the scheduler is not already running, make this task the
1059:Lib/FreeRTOS/Source/tasks.c ****              * current task if it is the highest priority task to be created
1060:Lib/FreeRTOS/Source/tasks.c ****              * so far. */
1061:Lib/FreeRTOS/Source/tasks.c ****             if( xSchedulerRunning == pdFALSE )
 557              		.loc 1 1061 35
 558 0032 374B     		ldr	r3, .L30+8
ARM GAS  /tmp/ccTFOe4z.s 			page 29


 559 0034 1B68     		ldr	r3, [r3]
 560              		.loc 1 1061 15
 561 0036 002B     		cmp	r3, #0
 562 0038 09D1     		bne	.L26
1062:Lib/FreeRTOS/Source/tasks.c ****             {
1063:Lib/FreeRTOS/Source/tasks.c ****                 if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 563              		.loc 1 1063 33
 564 003a 344B     		ldr	r3, .L30+4
 565 003c 1B68     		ldr	r3, [r3]
 566 003e DA6A     		ldr	r2, [r3, #44]
 567              		.loc 1 1063 57
 568 0040 7B68     		ldr	r3, [r7, #4]
 569 0042 DB6A     		ldr	r3, [r3, #44]
 570              		.loc 1 1063 19
 571 0044 9A42     		cmp	r2, r3
 572 0046 02D8     		bhi	.L26
1064:Lib/FreeRTOS/Source/tasks.c ****                 {
1065:Lib/FreeRTOS/Source/tasks.c ****                     pxCurrentTCB = pxNewTCB;
 573              		.loc 1 1065 34
 574 0048 304A     		ldr	r2, .L30+4
 575 004a 7B68     		ldr	r3, [r7, #4]
 576 004c 1360     		str	r3, [r2]
 577              	.L26:
1066:Lib/FreeRTOS/Source/tasks.c ****                 }
1067:Lib/FreeRTOS/Source/tasks.c ****                 else
1068:Lib/FreeRTOS/Source/tasks.c ****                 {
1069:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1070:Lib/FreeRTOS/Source/tasks.c ****                 }
1071:Lib/FreeRTOS/Source/tasks.c ****             }
1072:Lib/FreeRTOS/Source/tasks.c ****             else
1073:Lib/FreeRTOS/Source/tasks.c ****             {
1074:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1075:Lib/FreeRTOS/Source/tasks.c ****             }
1076:Lib/FreeRTOS/Source/tasks.c ****         }
1077:Lib/FreeRTOS/Source/tasks.c **** 
1078:Lib/FreeRTOS/Source/tasks.c ****         uxTaskNumber++;
 578              		.loc 1 1078 21
 579 004e 314B     		ldr	r3, .L30+12
 580 0050 1B68     		ldr	r3, [r3]
 581 0052 0133     		adds	r3, r3, #1
 582 0054 2F4A     		ldr	r2, .L30+12
 583 0056 1360     		str	r3, [r2]
1079:Lib/FreeRTOS/Source/tasks.c **** 
1080:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_TRACE_FACILITY == 1 )
1081:Lib/FreeRTOS/Source/tasks.c ****         {
1082:Lib/FreeRTOS/Source/tasks.c ****             /* Add a counter into the TCB for tracing only. */
1083:Lib/FreeRTOS/Source/tasks.c ****             pxNewTCB->uxTCBNumber = uxTaskNumber;
 584              		.loc 1 1083 35
 585 0058 2E4B     		ldr	r3, .L30+12
 586 005a 1A68     		ldr	r2, [r3]
 587 005c 7B68     		ldr	r3, [r7, #4]
 588 005e 5A64     		str	r2, [r3, #68]
1084:Lib/FreeRTOS/Source/tasks.c ****         }
1085:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TRACE_FACILITY */
1086:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_CREATE( pxNewTCB );
1087:Lib/FreeRTOS/Source/tasks.c **** 
1088:Lib/FreeRTOS/Source/tasks.c ****         prvAddTaskToReadyList( pxNewTCB );
ARM GAS  /tmp/ccTFOe4z.s 			page 30


 589              		.loc 1 1088 9
 590 0060 7B68     		ldr	r3, [r7, #4]
 591 0062 DA6A     		ldr	r2, [r3, #44]
 592 0064 2C4B     		ldr	r3, .L30+16
 593 0066 1B68     		ldr	r3, [r3]
 594 0068 9A42     		cmp	r2, r3
 595 006a 03D9     		bls	.L27
 596              		.loc 1 1088 9 is_stmt 0 discriminator 1
 597 006c 7B68     		ldr	r3, [r7, #4]
 598 006e DB6A     		ldr	r3, [r3, #44]
 599 0070 294A     		ldr	r2, .L30+16
 600 0072 1360     		str	r3, [r2]
 601              	.L27:
 602              	.LBB3:
 603              		.loc 1 1088 9 discriminator 3
 604 0074 7B68     		ldr	r3, [r7, #4]
 605 0076 DA6A     		ldr	r2, [r3, #44]
 606 0078 2849     		ldr	r1, .L30+20
 607 007a 1346     		mov	r3, r2
 608 007c 9B00     		lsls	r3, r3, #2
 609 007e 1344     		add	r3, r3, r2
 610 0080 9B00     		lsls	r3, r3, #2
 611 0082 0B44     		add	r3, r3, r1
 612 0084 0433     		adds	r3, r3, #4
 613 0086 1B68     		ldr	r3, [r3]
 614 0088 FB60     		str	r3, [r7, #12]
 615 008a 7B68     		ldr	r3, [r7, #4]
 616 008c FA68     		ldr	r2, [r7, #12]
 617 008e 9A60     		str	r2, [r3, #8]
 618 0090 FB68     		ldr	r3, [r7, #12]
 619 0092 9A68     		ldr	r2, [r3, #8]
 620 0094 7B68     		ldr	r3, [r7, #4]
 621 0096 DA60     		str	r2, [r3, #12]
 622 0098 FB68     		ldr	r3, [r7, #12]
 623 009a 9B68     		ldr	r3, [r3, #8]
 624 009c 7A68     		ldr	r2, [r7, #4]
 625 009e 0432     		adds	r2, r2, #4
 626 00a0 5A60     		str	r2, [r3, #4]
 627 00a2 7B68     		ldr	r3, [r7, #4]
 628 00a4 1A1D     		adds	r2, r3, #4
 629 00a6 FB68     		ldr	r3, [r7, #12]
 630 00a8 9A60     		str	r2, [r3, #8]
 631 00aa 7B68     		ldr	r3, [r7, #4]
 632 00ac DA6A     		ldr	r2, [r3, #44]
 633 00ae 1346     		mov	r3, r2
 634 00b0 9B00     		lsls	r3, r3, #2
 635 00b2 1344     		add	r3, r3, r2
 636 00b4 9B00     		lsls	r3, r3, #2
 637 00b6 194A     		ldr	r2, .L30+20
 638 00b8 1A44     		add	r2, r2, r3
 639 00ba 7B68     		ldr	r3, [r7, #4]
 640 00bc 5A61     		str	r2, [r3, #20]
 641 00be 7B68     		ldr	r3, [r7, #4]
 642 00c0 DA6A     		ldr	r2, [r3, #44]
 643 00c2 1649     		ldr	r1, .L30+20
 644 00c4 1346     		mov	r3, r2
 645 00c6 9B00     		lsls	r3, r3, #2
ARM GAS  /tmp/ccTFOe4z.s 			page 31


 646 00c8 1344     		add	r3, r3, r2
 647 00ca 9B00     		lsls	r3, r3, #2
 648 00cc 0B44     		add	r3, r3, r1
 649 00ce 1B68     		ldr	r3, [r3]
 650 00d0 591C     		adds	r1, r3, #1
 651 00d2 1248     		ldr	r0, .L30+20
 652 00d4 1346     		mov	r3, r2
 653 00d6 9B00     		lsls	r3, r3, #2
 654 00d8 1344     		add	r3, r3, r2
 655 00da 9B00     		lsls	r3, r3, #2
 656 00dc 0344     		add	r3, r3, r0
 657 00de 1960     		str	r1, [r3]
 658              	.LBE3:
1089:Lib/FreeRTOS/Source/tasks.c **** 
1090:Lib/FreeRTOS/Source/tasks.c ****         portSETUP_TCB( pxNewTCB );
1091:Lib/FreeRTOS/Source/tasks.c ****     }
1092:Lib/FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
 659              		.loc 1 1092 5 is_stmt 1
 660 00e0 FFF7FEFF 		bl	vPortExitCritical
1093:Lib/FreeRTOS/Source/tasks.c **** 
1094:Lib/FreeRTOS/Source/tasks.c ****     if( xSchedulerRunning != pdFALSE )
 661              		.loc 1 1094 27
 662 00e4 0A4B     		ldr	r3, .L30+8
 663 00e6 1B68     		ldr	r3, [r3]
 664              		.loc 1 1094 7
 665 00e8 002B     		cmp	r3, #0
 666 00ea 08D0     		beq	.L29
1095:Lib/FreeRTOS/Source/tasks.c ****     {
1096:Lib/FreeRTOS/Source/tasks.c ****         /* If the created task is of a higher priority than the current task
1097:Lib/FreeRTOS/Source/tasks.c ****          * then it should run now. */
1098:Lib/FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 667              		.loc 1 1098 25
 668 00ec 074B     		ldr	r3, .L30+4
 669 00ee 1B68     		ldr	r3, [r3]
 670 00f0 DA6A     		ldr	r2, [r3, #44]
 671              		.loc 1 1098 48
 672 00f2 7B68     		ldr	r3, [r7, #4]
 673 00f4 DB6A     		ldr	r3, [r3, #44]
 674              		.loc 1 1098 11
 675 00f6 9A42     		cmp	r2, r3
 676 00f8 01D2     		bcs	.L29
1099:Lib/FreeRTOS/Source/tasks.c ****         {
1100:Lib/FreeRTOS/Source/tasks.c ****             taskYIELD_IF_USING_PREEMPTION();
 677              		.loc 1 1100 13
 678 00fa FFF7FEFF 		bl	vPortYield
 679              	.L29:
1101:Lib/FreeRTOS/Source/tasks.c ****         }
1102:Lib/FreeRTOS/Source/tasks.c ****         else
1103:Lib/FreeRTOS/Source/tasks.c ****         {
1104:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1105:Lib/FreeRTOS/Source/tasks.c ****         }
1106:Lib/FreeRTOS/Source/tasks.c ****     }
1107:Lib/FreeRTOS/Source/tasks.c ****     else
1108:Lib/FreeRTOS/Source/tasks.c ****     {
1109:Lib/FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
1110:Lib/FreeRTOS/Source/tasks.c ****     }
1111:Lib/FreeRTOS/Source/tasks.c **** }
ARM GAS  /tmp/ccTFOe4z.s 			page 32


 680              		.loc 1 1111 1
 681 00fe 00BF     		nop
 682 0100 1037     		adds	r7, r7, #16
 683              		.cfi_def_cfa_offset 8
 684 0102 BD46     		mov	sp, r7
 685              		.cfi_def_cfa_register 13
 686              		@ sp needed
 687 0104 80BD     		pop	{r7, pc}
 688              	.L31:
 689 0106 00BF     		.align	2
 690              	.L30:
 691 0108 00000000 		.word	uxCurrentNumberOfTasks
 692 010c 00000000 		.word	pxCurrentTCB
 693 0110 00000000 		.word	xSchedulerRunning
 694 0114 00000000 		.word	uxTaskNumber
 695 0118 00000000 		.word	uxTopReadyPriority
 696 011c 00000000 		.word	pxReadyTasksLists
 697              		.cfi_endproc
 698              	.LFE2:
 700              		.section	.text.vTaskDelete,"ax",%progbits
 701              		.align	1
 702              		.global	vTaskDelete
 703              		.syntax unified
 704              		.thumb
 705              		.thumb_func
 707              	vTaskDelete:
 708              	.LFB3:
1112:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1113:Lib/FreeRTOS/Source/tasks.c **** 
1114:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
1115:Lib/FreeRTOS/Source/tasks.c **** 
1116:Lib/FreeRTOS/Source/tasks.c ****     void vTaskDelete( TaskHandle_t xTaskToDelete )
1117:Lib/FreeRTOS/Source/tasks.c ****     {
 709              		.loc 1 1117 5
 710              		.cfi_startproc
 711              		@ args = 0, pretend = 0, frame = 16
 712              		@ frame_needed = 1, uses_anonymous_args = 0
 713 0000 80B5     		push	{r7, lr}
 714              		.cfi_def_cfa_offset 8
 715              		.cfi_offset 7, -8
 716              		.cfi_offset 14, -4
 717 0002 84B0     		sub	sp, sp, #16
 718              		.cfi_def_cfa_offset 24
 719 0004 00AF     		add	r7, sp, #0
 720              		.cfi_def_cfa_register 7
 721 0006 7860     		str	r0, [r7, #4]
1118:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1119:Lib/FreeRTOS/Source/tasks.c **** 
1120:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 722              		.loc 1 1120 9
 723 0008 FFF7FEFF 		bl	vPortEnterCritical
1121:Lib/FreeRTOS/Source/tasks.c ****         {
1122:Lib/FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the calling task that is
1123:Lib/FreeRTOS/Source/tasks.c ****              * being deleted. */
1124:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 724              		.loc 1 1124 21
 725 000c 7B68     		ldr	r3, [r7, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 33


 726 000e 002B     		cmp	r3, #0
 727 0010 02D1     		bne	.L33
 728              		.loc 1 1124 21 is_stmt 0 discriminator 1
 729 0012 2B4B     		ldr	r3, .L42
 730 0014 1B68     		ldr	r3, [r3]
 731 0016 00E0     		b	.L34
 732              	.L33:
 733              		.loc 1 1124 21 discriminator 2
 734 0018 7B68     		ldr	r3, [r7, #4]
 735              	.L34:
 736              		.loc 1 1124 19 is_stmt 1 discriminator 4
 737 001a FB60     		str	r3, [r7, #12]
1125:Lib/FreeRTOS/Source/tasks.c **** 
1126:Lib/FreeRTOS/Source/tasks.c ****             /* Remove task from the ready/delayed list. */
1127:Lib/FreeRTOS/Source/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 738              		.loc 1 1127 17
 739 001c FB68     		ldr	r3, [r7, #12]
 740 001e 0433     		adds	r3, r3, #4
 741 0020 1846     		mov	r0, r3
 742 0022 FFF7FEFF 		bl	uxListRemove
1128:Lib/FreeRTOS/Source/tasks.c ****             {
1129:Lib/FreeRTOS/Source/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1130:Lib/FreeRTOS/Source/tasks.c ****             }
1131:Lib/FreeRTOS/Source/tasks.c ****             else
1132:Lib/FreeRTOS/Source/tasks.c ****             {
1133:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1134:Lib/FreeRTOS/Source/tasks.c ****             }
1135:Lib/FreeRTOS/Source/tasks.c **** 
1136:Lib/FreeRTOS/Source/tasks.c ****             /* Is the task waiting on an event also? */
1137:Lib/FreeRTOS/Source/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 743              		.loc 1 1137 17
 744 0026 FB68     		ldr	r3, [r7, #12]
 745 0028 9B6A     		ldr	r3, [r3, #40]
 746              		.loc 1 1137 15
 747 002a 002B     		cmp	r3, #0
 748 002c 04D0     		beq	.L35
1138:Lib/FreeRTOS/Source/tasks.c ****             {
1139:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 749              		.loc 1 1139 26
 750 002e FB68     		ldr	r3, [r7, #12]
 751 0030 1833     		adds	r3, r3, #24
 752 0032 1846     		mov	r0, r3
 753 0034 FFF7FEFF 		bl	uxListRemove
 754              	.L35:
1140:Lib/FreeRTOS/Source/tasks.c ****             }
1141:Lib/FreeRTOS/Source/tasks.c ****             else
1142:Lib/FreeRTOS/Source/tasks.c ****             {
1143:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1144:Lib/FreeRTOS/Source/tasks.c ****             }
1145:Lib/FreeRTOS/Source/tasks.c **** 
1146:Lib/FreeRTOS/Source/tasks.c ****             /* Increment the uxTaskNumber also so kernel aware debuggers can
1147:Lib/FreeRTOS/Source/tasks.c ****              * detect that the task lists need re-generating.  This is done before
1148:Lib/FreeRTOS/Source/tasks.c ****              * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
1149:Lib/FreeRTOS/Source/tasks.c ****              * not return. */
1150:Lib/FreeRTOS/Source/tasks.c ****             uxTaskNumber++;
 755              		.loc 1 1150 25
 756 0038 224B     		ldr	r3, .L42+4
ARM GAS  /tmp/ccTFOe4z.s 			page 34


 757 003a 1B68     		ldr	r3, [r3]
 758 003c 0133     		adds	r3, r3, #1
 759 003e 214A     		ldr	r2, .L42+4
 760 0040 1360     		str	r3, [r2]
1151:Lib/FreeRTOS/Source/tasks.c **** 
1152:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
 761              		.loc 1 1152 23
 762 0042 1F4B     		ldr	r3, .L42
 763 0044 1B68     		ldr	r3, [r3]
 764              		.loc 1 1152 15
 765 0046 FA68     		ldr	r2, [r7, #12]
 766 0048 9A42     		cmp	r2, r3
 767 004a 0BD1     		bne	.L36
1153:Lib/FreeRTOS/Source/tasks.c ****             {
1154:Lib/FreeRTOS/Source/tasks.c ****                 /* A task is deleting itself.  This cannot complete within the
1155:Lib/FreeRTOS/Source/tasks.c ****                  * task itself, as a context switch to another task is required.
1156:Lib/FreeRTOS/Source/tasks.c ****                  * Place the task in the termination list.  The idle task will
1157:Lib/FreeRTOS/Source/tasks.c ****                  * check the termination list and free up any memory allocated by
1158:Lib/FreeRTOS/Source/tasks.c ****                  * the scheduler for the TCB and stack of the deleted task. */
1159:Lib/FreeRTOS/Source/tasks.c ****                 vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 768              		.loc 1 1159 17
 769 004c FB68     		ldr	r3, [r7, #12]
 770 004e 0433     		adds	r3, r3, #4
 771 0050 1946     		mov	r1, r3
 772 0052 1D48     		ldr	r0, .L42+8
 773 0054 FFF7FEFF 		bl	vListInsertEnd
1160:Lib/FreeRTOS/Source/tasks.c **** 
1161:Lib/FreeRTOS/Source/tasks.c ****                 /* Increment the ucTasksDeleted variable so the idle task knows
1162:Lib/FreeRTOS/Source/tasks.c ****                  * there is a task that has been deleted and that it should therefore
1163:Lib/FreeRTOS/Source/tasks.c ****                  * check the xTasksWaitingTermination list. */
1164:Lib/FreeRTOS/Source/tasks.c ****                 ++uxDeletedTasksWaitingCleanUp;
 774              		.loc 1 1164 17
 775 0058 1C4B     		ldr	r3, .L42+12
 776 005a 1B68     		ldr	r3, [r3]
 777 005c 0133     		adds	r3, r3, #1
 778 005e 1B4A     		ldr	r2, .L42+12
 779 0060 1360     		str	r3, [r2]
 780 0062 06E0     		b	.L37
 781              	.L36:
1165:Lib/FreeRTOS/Source/tasks.c **** 
1166:Lib/FreeRTOS/Source/tasks.c ****                 /* Call the delete hook before portPRE_TASK_DELETE_HOOK() as
1167:Lib/FreeRTOS/Source/tasks.c ****                  * portPRE_TASK_DELETE_HOOK() does not return in the Win32 port. */
1168:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_DELETE( pxTCB );
1169:Lib/FreeRTOS/Source/tasks.c **** 
1170:Lib/FreeRTOS/Source/tasks.c ****                 /* The pre-delete hook is primarily for the Windows simulator,
1171:Lib/FreeRTOS/Source/tasks.c ****                  * in which Windows specific clean up operations are performed,
1172:Lib/FreeRTOS/Source/tasks.c ****                  * after which it is not possible to yield away from this task -
1173:Lib/FreeRTOS/Source/tasks.c ****                  * hence xYieldPending is used to latch that a context switch is
1174:Lib/FreeRTOS/Source/tasks.c ****                  * required. */
1175:Lib/FreeRTOS/Source/tasks.c ****                 portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
1176:Lib/FreeRTOS/Source/tasks.c ****             }
1177:Lib/FreeRTOS/Source/tasks.c ****             else
1178:Lib/FreeRTOS/Source/tasks.c ****             {
1179:Lib/FreeRTOS/Source/tasks.c ****                 --uxCurrentNumberOfTasks;
 782              		.loc 1 1179 17
 783 0064 1A4B     		ldr	r3, .L42+16
 784 0066 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 35


 785 0068 013B     		subs	r3, r3, #1
 786 006a 194A     		ldr	r2, .L42+16
 787 006c 1360     		str	r3, [r2]
1180:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_DELETE( pxTCB );
1181:Lib/FreeRTOS/Source/tasks.c **** 
1182:Lib/FreeRTOS/Source/tasks.c ****                 /* Reset the next expected unblock time in case it referred to
1183:Lib/FreeRTOS/Source/tasks.c ****                  * the task that has just been deleted. */
1184:Lib/FreeRTOS/Source/tasks.c ****                 prvResetNextTaskUnblockTime();
 788              		.loc 1 1184 17
 789 006e FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 790              	.L37:
1185:Lib/FreeRTOS/Source/tasks.c ****             }
1186:Lib/FreeRTOS/Source/tasks.c ****         }
1187:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 791              		.loc 1 1187 9
 792 0072 FFF7FEFF 		bl	vPortExitCritical
1188:Lib/FreeRTOS/Source/tasks.c **** 
1189:Lib/FreeRTOS/Source/tasks.c ****         /* If the task is not deleting itself, call prvDeleteTCB from outside of
1190:Lib/FreeRTOS/Source/tasks.c ****          * critical section. If a task deletes itself, prvDeleteTCB is called
1191:Lib/FreeRTOS/Source/tasks.c ****          * from prvCheckTasksWaitingTermination which is called from Idle task. */
1192:Lib/FreeRTOS/Source/tasks.c ****         if( pxTCB != pxCurrentTCB )
 793              		.loc 1 1192 19
 794 0076 124B     		ldr	r3, .L42
 795 0078 1B68     		ldr	r3, [r3]
 796              		.loc 1 1192 11
 797 007a FA68     		ldr	r2, [r7, #12]
 798 007c 9A42     		cmp	r2, r3
 799 007e 02D0     		beq	.L38
1193:Lib/FreeRTOS/Source/tasks.c ****         {
1194:Lib/FreeRTOS/Source/tasks.c ****             prvDeleteTCB( pxTCB );
 800              		.loc 1 1194 13
 801 0080 F868     		ldr	r0, [r7, #12]
 802 0082 FFF7FEFF 		bl	prvDeleteTCB
 803              	.L38:
1195:Lib/FreeRTOS/Source/tasks.c ****         }
1196:Lib/FreeRTOS/Source/tasks.c **** 
1197:Lib/FreeRTOS/Source/tasks.c ****         /* Force a reschedule if it is the currently running task that has just
1198:Lib/FreeRTOS/Source/tasks.c ****          * been deleted. */
1199:Lib/FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
 804              		.loc 1 1199 31
 805 0086 134B     		ldr	r3, .L42+20
 806 0088 1B68     		ldr	r3, [r3]
 807              		.loc 1 1199 11
 808 008a 002B     		cmp	r3, #0
 809 008c 13D0     		beq	.L41
1200:Lib/FreeRTOS/Source/tasks.c ****         {
1201:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
 810              		.loc 1 1201 23
 811 008e 0C4B     		ldr	r3, .L42
 812 0090 1B68     		ldr	r3, [r3]
 813              		.loc 1 1201 15
 814 0092 FA68     		ldr	r2, [r7, #12]
 815 0094 9A42     		cmp	r2, r3
 816 0096 0ED1     		bne	.L41
1202:Lib/FreeRTOS/Source/tasks.c ****             {
1203:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 817              		.loc 1 1203 17
ARM GAS  /tmp/ccTFOe4z.s 			page 36


 818 0098 0F4B     		ldr	r3, .L42+24
 819 009a 1B68     		ldr	r3, [r3]
 820 009c 002B     		cmp	r3, #0
 821 009e 08D0     		beq	.L40
 822              		.loc 1 1203 17 is_stmt 0 discriminator 1
 823 00a0 FFF7FEFF 		bl	ulSetInterruptMask
 824 00a4 0D4B     		ldr	r3, .L42+28
 825 00a6 0E4A     		ldr	r2, .L42+32
 826 00a8 40F2B341 		movw	r1, #1203
 827 00ac 0D48     		ldr	r0, .L42+36
 828 00ae FFF7FEFF 		bl	__assert_func
 829              	.L40:
1204:Lib/FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 830              		.loc 1 1204 17 is_stmt 1
 831 00b2 FFF7FEFF 		bl	vPortYield
 832              	.L41:
1205:Lib/FreeRTOS/Source/tasks.c ****             }
1206:Lib/FreeRTOS/Source/tasks.c ****             else
1207:Lib/FreeRTOS/Source/tasks.c ****             {
1208:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1209:Lib/FreeRTOS/Source/tasks.c ****             }
1210:Lib/FreeRTOS/Source/tasks.c ****         }
1211:Lib/FreeRTOS/Source/tasks.c ****     }
 833              		.loc 1 1211 5
 834 00b6 00BF     		nop
 835 00b8 1037     		adds	r7, r7, #16
 836              		.cfi_def_cfa_offset 8
 837 00ba BD46     		mov	sp, r7
 838              		.cfi_def_cfa_register 13
 839              		@ sp needed
 840 00bc 80BD     		pop	{r7, pc}
 841              	.L43:
 842 00be 00BF     		.align	2
 843              	.L42:
 844 00c0 00000000 		.word	pxCurrentTCB
 845 00c4 00000000 		.word	uxTaskNumber
 846 00c8 00000000 		.word	xTasksWaitingTermination
 847 00cc 00000000 		.word	uxDeletedTasksWaitingCleanUp
 848 00d0 00000000 		.word	uxCurrentNumberOfTasks
 849 00d4 00000000 		.word	xSchedulerRunning
 850 00d8 00000000 		.word	uxSchedulerSuspended
 851 00dc 00000000 		.word	.LC0
 852 00e0 00000000 		.word	__func__.32
 853 00e4 04000000 		.word	.LC1
 854              		.cfi_endproc
 855              	.LFE3:
 857              		.section	.text.xTaskDelayUntil,"ax",%progbits
 858              		.align	1
 859              		.global	xTaskDelayUntil
 860              		.syntax unified
 861              		.thumb
 862              		.thumb_func
 864              	xTaskDelayUntil:
 865              	.LFB4:
1212:Lib/FreeRTOS/Source/tasks.c **** 
1213:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
1214:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/ccTFOe4z.s 			page 37


1215:Lib/FreeRTOS/Source/tasks.c **** 
1216:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskDelayUntil == 1 )
1217:Lib/FreeRTOS/Source/tasks.c **** 
1218:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
1219:Lib/FreeRTOS/Source/tasks.c ****                                 const TickType_t xTimeIncrement )
1220:Lib/FreeRTOS/Source/tasks.c ****     {
 866              		.loc 1 1220 5
 867              		.cfi_startproc
 868              		@ args = 0, pretend = 0, frame = 24
 869              		@ frame_needed = 1, uses_anonymous_args = 0
 870 0000 80B5     		push	{r7, lr}
 871              		.cfi_def_cfa_offset 8
 872              		.cfi_offset 7, -8
 873              		.cfi_offset 14, -4
 874 0002 86B0     		sub	sp, sp, #24
 875              		.cfi_def_cfa_offset 32
 876 0004 00AF     		add	r7, sp, #0
 877              		.cfi_def_cfa_register 7
 878 0006 7860     		str	r0, [r7, #4]
 879 0008 3960     		str	r1, [r7]
1221:Lib/FreeRTOS/Source/tasks.c ****         TickType_t xTimeToWake;
1222:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 880              		.loc 1 1222 37
 881 000a 0023     		movs	r3, #0
 882 000c 7B61     		str	r3, [r7, #20]
1223:Lib/FreeRTOS/Source/tasks.c **** 
1224:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxPreviousWakeTime );
 883              		.loc 1 1224 9
 884 000e 7B68     		ldr	r3, [r7, #4]
 885 0010 002B     		cmp	r3, #0
 886 0012 08D1     		bne	.L45
 887              		.loc 1 1224 9 is_stmt 0 discriminator 1
 888 0014 FFF7FEFF 		bl	ulSetInterruptMask
 889 0018 2F4B     		ldr	r3, .L54
 890 001a 304A     		ldr	r2, .L54+4
 891 001c 4FF49961 		mov	r1, #1224
 892 0020 2F48     		ldr	r0, .L54+8
 893 0022 FFF7FEFF 		bl	__assert_func
 894              	.L45:
1225:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( xTimeIncrement > 0U ) );
 895              		.loc 1 1225 9 is_stmt 1
 896 0026 3B68     		ldr	r3, [r7]
 897 0028 002B     		cmp	r3, #0
 898 002a 08D1     		bne	.L46
 899              		.loc 1 1225 9 is_stmt 0 discriminator 1
 900 002c FFF7FEFF 		bl	ulSetInterruptMask
 901 0030 294B     		ldr	r3, .L54
 902 0032 2A4A     		ldr	r2, .L54+4
 903 0034 40F2C941 		movw	r1, #1225
 904 0038 2948     		ldr	r0, .L54+8
 905 003a FFF7FEFF 		bl	__assert_func
 906              	.L46:
1226:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 907              		.loc 1 1226 9 is_stmt 1
 908 003e 294B     		ldr	r3, .L54+12
 909 0040 1B68     		ldr	r3, [r3]
 910 0042 002B     		cmp	r3, #0
ARM GAS  /tmp/ccTFOe4z.s 			page 38


 911 0044 08D0     		beq	.L47
 912              		.loc 1 1226 9 is_stmt 0 discriminator 1
 913 0046 FFF7FEFF 		bl	ulSetInterruptMask
 914 004a 234B     		ldr	r3, .L54
 915 004c 234A     		ldr	r2, .L54+4
 916 004e 40F2CA41 		movw	r1, #1226
 917 0052 2348     		ldr	r0, .L54+8
 918 0054 FFF7FEFF 		bl	__assert_func
 919              	.L47:
1227:Lib/FreeRTOS/Source/tasks.c **** 
1228:Lib/FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
 920              		.loc 1 1228 9 is_stmt 1
 921 0058 FFF7FEFF 		bl	vTaskSuspendAll
 922              	.LBB4:
1229:Lib/FreeRTOS/Source/tasks.c ****         {
1230:Lib/FreeRTOS/Source/tasks.c ****             /* Minor optimisation.  The tick count cannot change in this
1231:Lib/FreeRTOS/Source/tasks.c ****              * block. */
1232:Lib/FreeRTOS/Source/tasks.c ****             const TickType_t xConstTickCount = xTickCount;
 923              		.loc 1 1232 30
 924 005c 224B     		ldr	r3, .L54+16
 925 005e 1B68     		ldr	r3, [r3]
 926 0060 3B61     		str	r3, [r7, #16]
1233:Lib/FreeRTOS/Source/tasks.c **** 
1234:Lib/FreeRTOS/Source/tasks.c ****             /* Generate the tick time at which the task wants to wake. */
1235:Lib/FreeRTOS/Source/tasks.c ****             xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 927              		.loc 1 1235 27
 928 0062 7B68     		ldr	r3, [r7, #4]
 929 0064 1B68     		ldr	r3, [r3]
 930              		.loc 1 1235 25
 931 0066 3A68     		ldr	r2, [r7]
 932 0068 1344     		add	r3, r3, r2
 933 006a FB60     		str	r3, [r7, #12]
1236:Lib/FreeRTOS/Source/tasks.c **** 
1237:Lib/FreeRTOS/Source/tasks.c ****             if( xConstTickCount < *pxPreviousWakeTime )
 934              		.loc 1 1237 35
 935 006c 7B68     		ldr	r3, [r7, #4]
 936 006e 1B68     		ldr	r3, [r3]
 937              		.loc 1 1237 15
 938 0070 3A69     		ldr	r2, [r7, #16]
 939 0072 9A42     		cmp	r2, r3
 940 0074 0BD2     		bcs	.L48
1238:Lib/FreeRTOS/Source/tasks.c ****             {
1239:Lib/FreeRTOS/Source/tasks.c ****                 /* The tick count has overflowed since this function was
1240:Lib/FreeRTOS/Source/tasks.c ****                  * lasted called.  In this case the only time we should ever
1241:Lib/FreeRTOS/Source/tasks.c ****                  * actually delay is if the wake time has also  overflowed,
1242:Lib/FreeRTOS/Source/tasks.c ****                  * and the wake time is greater than the tick time.  When this
1243:Lib/FreeRTOS/Source/tasks.c ****                  * is the case it is as if neither time had overflowed. */
1244:Lib/FreeRTOS/Source/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 941              		.loc 1 1244 37
 942 0076 7B68     		ldr	r3, [r7, #4]
 943 0078 1B68     		ldr	r3, [r3]
 944              		.loc 1 1244 19
 945 007a FA68     		ldr	r2, [r7, #12]
 946 007c 9A42     		cmp	r2, r3
 947 007e 11D2     		bcs	.L49
 948              		.loc 1 1244 59 discriminator 1
 949 0080 FA68     		ldr	r2, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 39


 950 0082 3B69     		ldr	r3, [r7, #16]
 951 0084 9A42     		cmp	r2, r3
 952 0086 0DD9     		bls	.L49
1245:Lib/FreeRTOS/Source/tasks.c ****                 {
1246:Lib/FreeRTOS/Source/tasks.c ****                     xShouldDelay = pdTRUE;
 953              		.loc 1 1246 34
 954 0088 0123     		movs	r3, #1
 955 008a 7B61     		str	r3, [r7, #20]
 956 008c 0AE0     		b	.L49
 957              	.L48:
1247:Lib/FreeRTOS/Source/tasks.c ****                 }
1248:Lib/FreeRTOS/Source/tasks.c ****                 else
1249:Lib/FreeRTOS/Source/tasks.c ****                 {
1250:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1251:Lib/FreeRTOS/Source/tasks.c ****                 }
1252:Lib/FreeRTOS/Source/tasks.c ****             }
1253:Lib/FreeRTOS/Source/tasks.c ****             else
1254:Lib/FreeRTOS/Source/tasks.c ****             {
1255:Lib/FreeRTOS/Source/tasks.c ****                 /* The tick time has not overflowed.  In this case we will
1256:Lib/FreeRTOS/Source/tasks.c ****                  * delay if either the wake time has overflowed, and/or the
1257:Lib/FreeRTOS/Source/tasks.c ****                  * tick time is less than the wake time. */
1258:Lib/FreeRTOS/Source/tasks.c ****                 if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 958              		.loc 1 1258 37
 959 008e 7B68     		ldr	r3, [r7, #4]
 960 0090 1B68     		ldr	r3, [r3]
 961              		.loc 1 1258 19
 962 0092 FA68     		ldr	r2, [r7, #12]
 963 0094 9A42     		cmp	r2, r3
 964 0096 03D3     		bcc	.L50
 965              		.loc 1 1258 59 discriminator 1
 966 0098 FA68     		ldr	r2, [r7, #12]
 967 009a 3B69     		ldr	r3, [r7, #16]
 968 009c 9A42     		cmp	r2, r3
 969 009e 01D9     		bls	.L49
 970              	.L50:
1259:Lib/FreeRTOS/Source/tasks.c ****                 {
1260:Lib/FreeRTOS/Source/tasks.c ****                     xShouldDelay = pdTRUE;
 971              		.loc 1 1260 34
 972 00a0 0123     		movs	r3, #1
 973 00a2 7B61     		str	r3, [r7, #20]
 974              	.L49:
1261:Lib/FreeRTOS/Source/tasks.c ****                 }
1262:Lib/FreeRTOS/Source/tasks.c ****                 else
1263:Lib/FreeRTOS/Source/tasks.c ****                 {
1264:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1265:Lib/FreeRTOS/Source/tasks.c ****                 }
1266:Lib/FreeRTOS/Source/tasks.c ****             }
1267:Lib/FreeRTOS/Source/tasks.c **** 
1268:Lib/FreeRTOS/Source/tasks.c ****             /* Update the wake time ready for the next call. */
1269:Lib/FreeRTOS/Source/tasks.c ****             *pxPreviousWakeTime = xTimeToWake;
 975              		.loc 1 1269 33
 976 00a4 7B68     		ldr	r3, [r7, #4]
 977 00a6 FA68     		ldr	r2, [r7, #12]
 978 00a8 1A60     		str	r2, [r3]
1270:Lib/FreeRTOS/Source/tasks.c **** 
1271:Lib/FreeRTOS/Source/tasks.c ****             if( xShouldDelay != pdFALSE )
 979              		.loc 1 1271 15
ARM GAS  /tmp/ccTFOe4z.s 			page 40


 980 00aa 7B69     		ldr	r3, [r7, #20]
 981 00ac 002B     		cmp	r3, #0
 982 00ae 06D0     		beq	.L51
1272:Lib/FreeRTOS/Source/tasks.c ****             {
1273:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_DELAY_UNTIL( xTimeToWake );
1274:Lib/FreeRTOS/Source/tasks.c **** 
1275:Lib/FreeRTOS/Source/tasks.c ****                 /* prvAddCurrentTaskToDelayedList() needs the block time, not
1276:Lib/FreeRTOS/Source/tasks.c ****                  * the time to wake, so subtract the current tick count. */
1277:Lib/FreeRTOS/Source/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 983              		.loc 1 1277 17
 984 00b0 FA68     		ldr	r2, [r7, #12]
 985 00b2 3B69     		ldr	r3, [r7, #16]
 986 00b4 D31A     		subs	r3, r2, r3
 987 00b6 0021     		movs	r1, #0
 988 00b8 1846     		mov	r0, r3
 989 00ba FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 990              	.L51:
 991              	.LBE4:
1278:Lib/FreeRTOS/Source/tasks.c ****             }
1279:Lib/FreeRTOS/Source/tasks.c ****             else
1280:Lib/FreeRTOS/Source/tasks.c ****             {
1281:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1282:Lib/FreeRTOS/Source/tasks.c ****             }
1283:Lib/FreeRTOS/Source/tasks.c ****         }
1284:Lib/FreeRTOS/Source/tasks.c ****         xAlreadyYielded = xTaskResumeAll();
 992              		.loc 1 1284 27
 993 00be FFF7FEFF 		bl	xTaskResumeAll
 994 00c2 B860     		str	r0, [r7, #8]
1285:Lib/FreeRTOS/Source/tasks.c **** 
1286:Lib/FreeRTOS/Source/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1287:Lib/FreeRTOS/Source/tasks.c ****          * have put ourselves to sleep. */
1288:Lib/FreeRTOS/Source/tasks.c ****         if( xAlreadyYielded == pdFALSE )
 995              		.loc 1 1288 11
 996 00c4 BB68     		ldr	r3, [r7, #8]
 997 00c6 002B     		cmp	r3, #0
 998 00c8 01D1     		bne	.L52
1289:Lib/FreeRTOS/Source/tasks.c ****         {
1290:Lib/FreeRTOS/Source/tasks.c ****             portYIELD_WITHIN_API();
 999              		.loc 1 1290 13
 1000 00ca FFF7FEFF 		bl	vPortYield
 1001              	.L52:
1291:Lib/FreeRTOS/Source/tasks.c ****         }
1292:Lib/FreeRTOS/Source/tasks.c ****         else
1293:Lib/FreeRTOS/Source/tasks.c ****         {
1294:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1295:Lib/FreeRTOS/Source/tasks.c ****         }
1296:Lib/FreeRTOS/Source/tasks.c **** 
1297:Lib/FreeRTOS/Source/tasks.c ****         return xShouldDelay;
 1002              		.loc 1 1297 16
 1003 00ce 7B69     		ldr	r3, [r7, #20]
1298:Lib/FreeRTOS/Source/tasks.c ****     }
 1004              		.loc 1 1298 5
 1005 00d0 1846     		mov	r0, r3
 1006 00d2 1837     		adds	r7, r7, #24
 1007              		.cfi_def_cfa_offset 8
 1008 00d4 BD46     		mov	sp, r7
 1009              		.cfi_def_cfa_register 13
ARM GAS  /tmp/ccTFOe4z.s 			page 41


 1010              		@ sp needed
 1011 00d6 80BD     		pop	{r7, pc}
 1012              	.L55:
 1013              		.align	2
 1014              	.L54:
 1015 00d8 00000000 		.word	.LC0
 1016 00dc 00000000 		.word	__func__.31
 1017 00e0 04000000 		.word	.LC1
 1018 00e4 00000000 		.word	uxSchedulerSuspended
 1019 00e8 00000000 		.word	xTickCount
 1020              		.cfi_endproc
 1021              	.LFE4:
 1023              		.section	.text.vTaskDelay,"ax",%progbits
 1024              		.align	1
 1025              		.global	vTaskDelay
 1026              		.syntax unified
 1027              		.thumb
 1028              		.thumb_func
 1030              	vTaskDelay:
 1031              	.LFB5:
1299:Lib/FreeRTOS/Source/tasks.c **** 
1300:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskDelayUntil */
1301:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1302:Lib/FreeRTOS/Source/tasks.c **** 
1303:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
1304:Lib/FreeRTOS/Source/tasks.c **** 
1305:Lib/FreeRTOS/Source/tasks.c ****     void vTaskDelay( const TickType_t xTicksToDelay )
1306:Lib/FreeRTOS/Source/tasks.c ****     {
 1032              		.loc 1 1306 5
 1033              		.cfi_startproc
 1034              		@ args = 0, pretend = 0, frame = 16
 1035              		@ frame_needed = 1, uses_anonymous_args = 0
 1036 0000 80B5     		push	{r7, lr}
 1037              		.cfi_def_cfa_offset 8
 1038              		.cfi_offset 7, -8
 1039              		.cfi_offset 14, -4
 1040 0002 84B0     		sub	sp, sp, #16
 1041              		.cfi_def_cfa_offset 24
 1042 0004 00AF     		add	r7, sp, #0
 1043              		.cfi_def_cfa_register 7
 1044 0006 7860     		str	r0, [r7, #4]
1307:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xAlreadyYielded = pdFALSE;
 1045              		.loc 1 1307 20
 1046 0008 0023     		movs	r3, #0
 1047 000a FB60     		str	r3, [r7, #12]
1308:Lib/FreeRTOS/Source/tasks.c **** 
1309:Lib/FreeRTOS/Source/tasks.c ****         /* A delay time of zero just forces a reschedule. */
1310:Lib/FreeRTOS/Source/tasks.c ****         if( xTicksToDelay > ( TickType_t ) 0U )
 1048              		.loc 1 1310 11
 1049 000c 7B68     		ldr	r3, [r7, #4]
 1050 000e 002B     		cmp	r3, #0
 1051 0010 15D0     		beq	.L57
1311:Lib/FreeRTOS/Source/tasks.c ****         {
1312:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 1052              		.loc 1 1312 13
 1053 0012 0F4B     		ldr	r3, .L61
 1054 0014 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 42


 1055 0016 002B     		cmp	r3, #0
 1056 0018 08D0     		beq	.L58
 1057              		.loc 1 1312 13 is_stmt 0 discriminator 1
 1058 001a FFF7FEFF 		bl	ulSetInterruptMask
 1059 001e 0D4B     		ldr	r3, .L61+4
 1060 0020 0D4A     		ldr	r2, .L61+8
 1061 0022 4FF4A461 		mov	r1, #1312
 1062 0026 0D48     		ldr	r0, .L61+12
 1063 0028 FFF7FEFF 		bl	__assert_func
 1064              	.L58:
1313:Lib/FreeRTOS/Source/tasks.c ****             vTaskSuspendAll();
 1065              		.loc 1 1313 13 is_stmt 1
 1066 002c FFF7FEFF 		bl	vTaskSuspendAll
1314:Lib/FreeRTOS/Source/tasks.c ****             {
1315:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_DELAY();
1316:Lib/FreeRTOS/Source/tasks.c **** 
1317:Lib/FreeRTOS/Source/tasks.c ****                 /* A task that is removed from the event list while the
1318:Lib/FreeRTOS/Source/tasks.c ****                  * scheduler is suspended will not get placed in the ready
1319:Lib/FreeRTOS/Source/tasks.c ****                  * list or removed from the blocked list until the scheduler
1320:Lib/FreeRTOS/Source/tasks.c ****                  * is resumed.
1321:Lib/FreeRTOS/Source/tasks.c ****                  *
1322:Lib/FreeRTOS/Source/tasks.c ****                  * This task cannot be in an event list as it is the currently
1323:Lib/FreeRTOS/Source/tasks.c ****                  * executing task. */
1324:Lib/FreeRTOS/Source/tasks.c ****                 prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 1067              		.loc 1 1324 17
 1068 0030 0021     		movs	r1, #0
 1069 0032 7868     		ldr	r0, [r7, #4]
 1070 0034 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
1325:Lib/FreeRTOS/Source/tasks.c ****             }
1326:Lib/FreeRTOS/Source/tasks.c ****             xAlreadyYielded = xTaskResumeAll();
 1071              		.loc 1 1326 31
 1072 0038 FFF7FEFF 		bl	xTaskResumeAll
 1073 003c F860     		str	r0, [r7, #12]
 1074              	.L57:
1327:Lib/FreeRTOS/Source/tasks.c ****         }
1328:Lib/FreeRTOS/Source/tasks.c ****         else
1329:Lib/FreeRTOS/Source/tasks.c ****         {
1330:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1331:Lib/FreeRTOS/Source/tasks.c ****         }
1332:Lib/FreeRTOS/Source/tasks.c **** 
1333:Lib/FreeRTOS/Source/tasks.c ****         /* Force a reschedule if xTaskResumeAll has not already done so, we may
1334:Lib/FreeRTOS/Source/tasks.c ****          * have put ourselves to sleep. */
1335:Lib/FreeRTOS/Source/tasks.c ****         if( xAlreadyYielded == pdFALSE )
 1075              		.loc 1 1335 11
 1076 003e FB68     		ldr	r3, [r7, #12]
 1077 0040 002B     		cmp	r3, #0
 1078 0042 01D1     		bne	.L60
1336:Lib/FreeRTOS/Source/tasks.c ****         {
1337:Lib/FreeRTOS/Source/tasks.c ****             portYIELD_WITHIN_API();
 1079              		.loc 1 1337 13
 1080 0044 FFF7FEFF 		bl	vPortYield
 1081              	.L60:
1338:Lib/FreeRTOS/Source/tasks.c ****         }
1339:Lib/FreeRTOS/Source/tasks.c ****         else
1340:Lib/FreeRTOS/Source/tasks.c ****         {
1341:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1342:Lib/FreeRTOS/Source/tasks.c ****         }
ARM GAS  /tmp/ccTFOe4z.s 			page 43


1343:Lib/FreeRTOS/Source/tasks.c ****     }
 1082              		.loc 1 1343 5
 1083 0048 00BF     		nop
 1084 004a 1037     		adds	r7, r7, #16
 1085              		.cfi_def_cfa_offset 8
 1086 004c BD46     		mov	sp, r7
 1087              		.cfi_def_cfa_register 13
 1088              		@ sp needed
 1089 004e 80BD     		pop	{r7, pc}
 1090              	.L62:
 1091              		.align	2
 1092              	.L61:
 1093 0050 00000000 		.word	uxSchedulerSuspended
 1094 0054 00000000 		.word	.LC0
 1095 0058 00000000 		.word	__func__.30
 1096 005c 04000000 		.word	.LC1
 1097              		.cfi_endproc
 1098              	.LFE5:
 1100              		.section	.text.eTaskGetState,"ax",%progbits
 1101              		.align	1
 1102              		.global	eTaskGetState
 1103              		.syntax unified
 1104              		.thumb
 1105              		.thumb_func
 1107              	eTaskGetState:
 1108              	.LFB6:
1344:Lib/FreeRTOS/Source/tasks.c **** 
1345:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelay */
1346:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1347:Lib/FreeRTOS/Source/tasks.c **** 
1348:Lib/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDe
1349:Lib/FreeRTOS/Source/tasks.c **** 
1350:Lib/FreeRTOS/Source/tasks.c ****     eTaskState eTaskGetState( TaskHandle_t xTask )
1351:Lib/FreeRTOS/Source/tasks.c ****     {
 1109              		.loc 1 1351 5
 1110              		.cfi_startproc
 1111              		@ args = 0, pretend = 0, frame = 40
 1112              		@ frame_needed = 1, uses_anonymous_args = 0
 1113 0000 80B5     		push	{r7, lr}
 1114              		.cfi_def_cfa_offset 8
 1115              		.cfi_offset 7, -8
 1116              		.cfi_offset 14, -4
 1117 0002 8AB0     		sub	sp, sp, #40
 1118              		.cfi_def_cfa_offset 48
 1119 0004 00AF     		add	r7, sp, #0
 1120              		.cfi_def_cfa_register 7
 1121 0006 7860     		str	r0, [r7, #4]
1352:Lib/FreeRTOS/Source/tasks.c ****         eTaskState eReturn;
1353:Lib/FreeRTOS/Source/tasks.c ****         List_t const * pxStateList;
1354:Lib/FreeRTOS/Source/tasks.c ****         List_t const * pxEventList;
1355:Lib/FreeRTOS/Source/tasks.c ****         List_t const * pxDelayedList;
1356:Lib/FreeRTOS/Source/tasks.c ****         List_t const * pxOverflowedDelayedList;
1357:Lib/FreeRTOS/Source/tasks.c ****         const TCB_t * const pxTCB = xTask;
 1122              		.loc 1 1357 29
 1123 0008 7B68     		ldr	r3, [r7, #4]
 1124 000a FB61     		str	r3, [r7, #28]
1358:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 44


1359:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTCB );
 1125              		.loc 1 1359 9
 1126 000c FB69     		ldr	r3, [r7, #28]
 1127 000e 002B     		cmp	r3, #0
 1128 0010 08D1     		bne	.L64
 1129              		.loc 1 1359 9 is_stmt 0 discriminator 1
 1130 0012 FFF7FEFF 		bl	ulSetInterruptMask
 1131 0016 364B     		ldr	r3, .L79
 1132 0018 364A     		ldr	r2, .L79+4
 1133 001a 40F24F51 		movw	r1, #1359
 1134 001e 3648     		ldr	r0, .L79+8
 1135 0020 FFF7FEFF 		bl	__assert_func
 1136              	.L64:
1360:Lib/FreeRTOS/Source/tasks.c **** 
1361:Lib/FreeRTOS/Source/tasks.c ****         if( pxTCB == pxCurrentTCB )
 1137              		.loc 1 1361 19 is_stmt 1
 1138 0024 354B     		ldr	r3, .L79+12
 1139 0026 1B68     		ldr	r3, [r3]
 1140              		.loc 1 1361 11
 1141 0028 FA69     		ldr	r2, [r7, #28]
 1142 002a 9A42     		cmp	r2, r3
 1143 002c 03D1     		bne	.L65
1362:Lib/FreeRTOS/Source/tasks.c ****         {
1363:Lib/FreeRTOS/Source/tasks.c ****             /* The task calling this function is querying its own state. */
1364:Lib/FreeRTOS/Source/tasks.c ****             eReturn = eRunning;
 1144              		.loc 1 1364 21
 1145 002e 0023     		movs	r3, #0
 1146 0030 87F82730 		strb	r3, [r7, #39]
 1147 0034 56E0     		b	.L66
 1148              	.L65:
1365:Lib/FreeRTOS/Source/tasks.c ****         }
1366:Lib/FreeRTOS/Source/tasks.c ****         else
1367:Lib/FreeRTOS/Source/tasks.c ****         {
1368:Lib/FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
 1149              		.loc 1 1368 13
 1150 0036 FFF7FEFF 		bl	vPortEnterCritical
1369:Lib/FreeRTOS/Source/tasks.c ****             {
1370:Lib/FreeRTOS/Source/tasks.c ****                 pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 1151              		.loc 1 1370 29
 1152 003a FB69     		ldr	r3, [r7, #28]
 1153 003c 5B69     		ldr	r3, [r3, #20]
 1154 003e BB61     		str	r3, [r7, #24]
1371:Lib/FreeRTOS/Source/tasks.c ****                 pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );
 1155              		.loc 1 1371 29
 1156 0040 FB69     		ldr	r3, [r7, #28]
 1157 0042 9B6A     		ldr	r3, [r3, #40]
 1158 0044 7B61     		str	r3, [r7, #20]
1372:Lib/FreeRTOS/Source/tasks.c ****                 pxDelayedList = pxDelayedTaskList;
 1159              		.loc 1 1372 31
 1160 0046 2E4B     		ldr	r3, .L79+16
 1161 0048 1B68     		ldr	r3, [r3]
 1162 004a 3B61     		str	r3, [r7, #16]
1373:Lib/FreeRTOS/Source/tasks.c ****                 pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 1163              		.loc 1 1373 41
 1164 004c 2D4B     		ldr	r3, .L79+20
 1165 004e 1B68     		ldr	r3, [r3]
 1166 0050 FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 45


1374:Lib/FreeRTOS/Source/tasks.c ****             }
1375:Lib/FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
 1167              		.loc 1 1375 13
 1168 0052 FFF7FEFF 		bl	vPortExitCritical
1376:Lib/FreeRTOS/Source/tasks.c **** 
1377:Lib/FreeRTOS/Source/tasks.c ****             if( pxEventList == &xPendingReadyList )
 1169              		.loc 1 1377 15
 1170 0056 7B69     		ldr	r3, [r7, #20]
 1171 0058 2B4A     		ldr	r2, .L79+24
 1172 005a 9342     		cmp	r3, r2
 1173 005c 03D1     		bne	.L67
1378:Lib/FreeRTOS/Source/tasks.c ****             {
1379:Lib/FreeRTOS/Source/tasks.c ****                 /* The task has been placed on the pending ready list, so its
1380:Lib/FreeRTOS/Source/tasks.c ****                  * state is eReady regardless of what list the task's state list
1381:Lib/FreeRTOS/Source/tasks.c ****                  * item is currently placed on. */
1382:Lib/FreeRTOS/Source/tasks.c ****                 eReturn = eReady;
 1174              		.loc 1 1382 25
 1175 005e 0123     		movs	r3, #1
 1176 0060 87F82730 		strb	r3, [r7, #39]
 1177 0064 3EE0     		b	.L66
 1178              	.L67:
1383:Lib/FreeRTOS/Source/tasks.c ****             }
1384:Lib/FreeRTOS/Source/tasks.c ****             else if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList )
 1179              		.loc 1 1384 20
 1180 0066 BA69     		ldr	r2, [r7, #24]
 1181 0068 3B69     		ldr	r3, [r7, #16]
 1182 006a 9A42     		cmp	r2, r3
 1183 006c 03D0     		beq	.L68
 1184              		.loc 1 1384 55 discriminator 1
 1185 006e BA69     		ldr	r2, [r7, #24]
 1186 0070 FB68     		ldr	r3, [r7, #12]
 1187 0072 9A42     		cmp	r2, r3
 1188 0074 03D1     		bne	.L69
 1189              	.L68:
1385:Lib/FreeRTOS/Source/tasks.c ****             {
1386:Lib/FreeRTOS/Source/tasks.c ****                 /* The task being queried is referenced from one of the Blocked
1387:Lib/FreeRTOS/Source/tasks.c ****                  * lists. */
1388:Lib/FreeRTOS/Source/tasks.c ****                 eReturn = eBlocked;
 1190              		.loc 1 1388 25
 1191 0076 0223     		movs	r3, #2
 1192 0078 87F82730 		strb	r3, [r7, #39]
 1193 007c 32E0     		b	.L66
 1194              	.L69:
1389:Lib/FreeRTOS/Source/tasks.c ****             }
1390:Lib/FreeRTOS/Source/tasks.c **** 
1391:Lib/FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
1392:Lib/FreeRTOS/Source/tasks.c ****                 else if( pxStateList == &xSuspendedTaskList )
 1195              		.loc 1 1392 24
 1196 007e BB69     		ldr	r3, [r7, #24]
 1197 0080 224A     		ldr	r2, .L79+28
 1198 0082 9342     		cmp	r3, r2
 1199 0084 20D1     		bne	.L70
1393:Lib/FreeRTOS/Source/tasks.c ****                 {
1394:Lib/FreeRTOS/Source/tasks.c ****                     /* The task being queried is referenced from the suspended
1395:Lib/FreeRTOS/Source/tasks.c ****                      * list.  Is it genuinely suspended or is it blocked
1396:Lib/FreeRTOS/Source/tasks.c ****                      * indefinitely? */
1397:Lib/FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
ARM GAS  /tmp/ccTFOe4z.s 			page 46


 1200              		.loc 1 1397 25
 1201 0086 FB69     		ldr	r3, [r7, #28]
 1202 0088 9B6A     		ldr	r3, [r3, #40]
 1203              		.loc 1 1397 23
 1204 008a 002B     		cmp	r3, #0
 1205 008c 18D1     		bne	.L71
 1206              	.LBB5:
1398:Lib/FreeRTOS/Source/tasks.c ****                     {
1399:Lib/FreeRTOS/Source/tasks.c ****                         #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1400:Lib/FreeRTOS/Source/tasks.c ****                         {
1401:Lib/FreeRTOS/Source/tasks.c ****                             BaseType_t x;
1402:Lib/FreeRTOS/Source/tasks.c **** 
1403:Lib/FreeRTOS/Source/tasks.c ****                             /* The task does not appear on the event list item of
1404:Lib/FreeRTOS/Source/tasks.c ****                              * and of the RTOS objects, but could still be in the
1405:Lib/FreeRTOS/Source/tasks.c ****                              * blocked state if it is waiting on its notification
1406:Lib/FreeRTOS/Source/tasks.c ****                              * rather than waiting on an object.  If not, is
1407:Lib/FreeRTOS/Source/tasks.c ****                              * suspended. */
1408:Lib/FreeRTOS/Source/tasks.c ****                             eReturn = eSuspended;
 1207              		.loc 1 1408 37
 1208 008e 0323     		movs	r3, #3
 1209 0090 87F82730 		strb	r3, [r7, #39]
1409:Lib/FreeRTOS/Source/tasks.c **** 
1410:Lib/FreeRTOS/Source/tasks.c ****                             for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 1210              		.loc 1 1410 36
 1211 0094 0023     		movs	r3, #0
 1212 0096 3B62     		str	r3, [r7, #32]
 1213              		.loc 1 1410 29
 1214 0098 0EE0     		b	.L72
 1215              	.L75:
1411:Lib/FreeRTOS/Source/tasks.c ****                             {
1412:Lib/FreeRTOS/Source/tasks.c ****                                 if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 1216              		.loc 1 1412 57
 1217 009a FA69     		ldr	r2, [r7, #28]
 1218 009c 3B6A     		ldr	r3, [r7, #32]
 1219 009e 1344     		add	r3, r3, r2
 1220 00a0 5C33     		adds	r3, r3, #92
 1221 00a2 1B78     		ldrb	r3, [r3]
 1222 00a4 DBB2     		uxtb	r3, r3
 1223              		.loc 1 1412 35
 1224 00a6 012B     		cmp	r3, #1
 1225 00a8 03D1     		bne	.L73
1413:Lib/FreeRTOS/Source/tasks.c ****                                 {
1414:Lib/FreeRTOS/Source/tasks.c ****                                     eReturn = eBlocked;
 1226              		.loc 1 1414 45
 1227 00aa 0223     		movs	r3, #2
 1228 00ac 87F82730 		strb	r3, [r7, #39]
1415:Lib/FreeRTOS/Source/tasks.c ****                                     break;
 1229              		.loc 1 1415 37
 1230 00b0 18E0     		b	.L66
 1231              	.L73:
1410:Lib/FreeRTOS/Source/tasks.c ****                             {
 1232              		.loc 1 1410 85 discriminator 2
 1233 00b2 3B6A     		ldr	r3, [r7, #32]
 1234 00b4 0133     		adds	r3, r3, #1
 1235 00b6 3B62     		str	r3, [r7, #32]
 1236              	.L72:
1410:Lib/FreeRTOS/Source/tasks.c ****                             {
ARM GAS  /tmp/ccTFOe4z.s 			page 47


 1237              		.loc 1 1410 43 discriminator 1
 1238 00b8 3B6A     		ldr	r3, [r7, #32]
 1239 00ba 002B     		cmp	r3, #0
 1240 00bc EDDD     		ble	.L75
 1241 00be 11E0     		b	.L66
 1242              	.L71:
 1243              	.LBE5:
1416:Lib/FreeRTOS/Source/tasks.c ****                                 }
1417:Lib/FreeRTOS/Source/tasks.c ****                             }
1418:Lib/FreeRTOS/Source/tasks.c ****                         }
1419:Lib/FreeRTOS/Source/tasks.c ****                         #else /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1420:Lib/FreeRTOS/Source/tasks.c ****                         {
1421:Lib/FreeRTOS/Source/tasks.c ****                             eReturn = eSuspended;
1422:Lib/FreeRTOS/Source/tasks.c ****                         }
1423:Lib/FreeRTOS/Source/tasks.c ****                         #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1424:Lib/FreeRTOS/Source/tasks.c ****                     }
1425:Lib/FreeRTOS/Source/tasks.c ****                     else
1426:Lib/FreeRTOS/Source/tasks.c ****                     {
1427:Lib/FreeRTOS/Source/tasks.c ****                         eReturn = eBlocked;
 1244              		.loc 1 1427 33
 1245 00c0 0223     		movs	r3, #2
 1246 00c2 87F82730 		strb	r3, [r7, #39]
 1247 00c6 0DE0     		b	.L66
 1248              	.L70:
1428:Lib/FreeRTOS/Source/tasks.c ****                     }
1429:Lib/FreeRTOS/Source/tasks.c ****                 }
1430:Lib/FreeRTOS/Source/tasks.c ****             #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */
1431:Lib/FreeRTOS/Source/tasks.c **** 
1432:Lib/FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
1433:Lib/FreeRTOS/Source/tasks.c ****                 else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 1249              		.loc 1 1433 24
 1250 00c8 BB69     		ldr	r3, [r7, #24]
 1251 00ca 114A     		ldr	r2, .L79+32
 1252 00cc 9342     		cmp	r3, r2
 1253 00ce 02D0     		beq	.L76
 1254              		.loc 1 1433 71 discriminator 1
 1255 00d0 BB69     		ldr	r3, [r7, #24]
 1256 00d2 002B     		cmp	r3, #0
 1257 00d4 03D1     		bne	.L77
 1258              	.L76:
1434:Lib/FreeRTOS/Source/tasks.c ****                 {
1435:Lib/FreeRTOS/Source/tasks.c ****                     /* The task being queried is referenced from the deleted
1436:Lib/FreeRTOS/Source/tasks.c ****                      * tasks list, or it is not referenced from any lists at
1437:Lib/FreeRTOS/Source/tasks.c ****                      * all. */
1438:Lib/FreeRTOS/Source/tasks.c ****                     eReturn = eDeleted;
 1259              		.loc 1 1438 29
 1260 00d6 0423     		movs	r3, #4
 1261 00d8 87F82730 		strb	r3, [r7, #39]
 1262 00dc 02E0     		b	.L66
 1263              	.L77:
1439:Lib/FreeRTOS/Source/tasks.c ****                 }
1440:Lib/FreeRTOS/Source/tasks.c ****             #endif
1441:Lib/FreeRTOS/Source/tasks.c **** 
1442:Lib/FreeRTOS/Source/tasks.c ****             else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer
1443:Lib/FreeRTOS/Source/tasks.c ****             {
1444:Lib/FreeRTOS/Source/tasks.c ****                 /* If the task is not in any other state, it must be in the
1445:Lib/FreeRTOS/Source/tasks.c ****                  * Ready (including pending ready) state. */
ARM GAS  /tmp/ccTFOe4z.s 			page 48


1446:Lib/FreeRTOS/Source/tasks.c ****                 eReturn = eReady;
 1264              		.loc 1 1446 25
 1265 00de 0123     		movs	r3, #1
 1266 00e0 87F82730 		strb	r3, [r7, #39]
 1267              	.L66:
1447:Lib/FreeRTOS/Source/tasks.c ****             }
1448:Lib/FreeRTOS/Source/tasks.c ****         }
1449:Lib/FreeRTOS/Source/tasks.c **** 
1450:Lib/FreeRTOS/Source/tasks.c ****         return eReturn;
 1268              		.loc 1 1450 16
 1269 00e4 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
1451:Lib/FreeRTOS/Source/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1270              		.loc 1 1451 5
 1271 00e8 1846     		mov	r0, r3
 1272 00ea 2837     		adds	r7, r7, #40
 1273              		.cfi_def_cfa_offset 8
 1274 00ec BD46     		mov	sp, r7
 1275              		.cfi_def_cfa_register 13
 1276              		@ sp needed
 1277 00ee 80BD     		pop	{r7, pc}
 1278              	.L80:
 1279              		.align	2
 1280              	.L79:
 1281 00f0 00000000 		.word	.LC0
 1282 00f4 00000000 		.word	__func__.29
 1283 00f8 04000000 		.word	.LC1
 1284 00fc 00000000 		.word	pxCurrentTCB
 1285 0100 00000000 		.word	pxDelayedTaskList
 1286 0104 00000000 		.word	pxOverflowDelayedTaskList
 1287 0108 00000000 		.word	xPendingReadyList
 1288 010c 00000000 		.word	xSuspendedTaskList
 1289 0110 00000000 		.word	xTasksWaitingTermination
 1290              		.cfi_endproc
 1291              	.LFE6:
 1293              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 1294              		.align	1
 1295              		.global	uxTaskPriorityGet
 1296              		.syntax unified
 1297              		.thumb
 1298              		.thumb_func
 1300              	uxTaskPriorityGet:
 1301              	.LFB7:
1452:Lib/FreeRTOS/Source/tasks.c **** 
1453:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_eTaskGetState */
1454:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1455:Lib/FreeRTOS/Source/tasks.c **** 
1456:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1457:Lib/FreeRTOS/Source/tasks.c **** 
1458:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
1459:Lib/FreeRTOS/Source/tasks.c ****     {
 1302              		.loc 1 1459 5
 1303              		.cfi_startproc
 1304              		@ args = 0, pretend = 0, frame = 16
 1305              		@ frame_needed = 1, uses_anonymous_args = 0
 1306 0000 80B5     		push	{r7, lr}
 1307              		.cfi_def_cfa_offset 8
 1308              		.cfi_offset 7, -8
ARM GAS  /tmp/ccTFOe4z.s 			page 49


 1309              		.cfi_offset 14, -4
 1310 0002 84B0     		sub	sp, sp, #16
 1311              		.cfi_def_cfa_offset 24
 1312 0004 00AF     		add	r7, sp, #0
 1313              		.cfi_def_cfa_register 7
 1314 0006 7860     		str	r0, [r7, #4]
1460:Lib/FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
1461:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
1462:Lib/FreeRTOS/Source/tasks.c **** 
1463:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 1315              		.loc 1 1463 9
 1316 0008 FFF7FEFF 		bl	vPortEnterCritical
1464:Lib/FreeRTOS/Source/tasks.c ****         {
1465:Lib/FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the task
1466:Lib/FreeRTOS/Source/tasks.c ****              * that called uxTaskPriorityGet() that is being queried. */
1467:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
 1317              		.loc 1 1467 21
 1318 000c 7B68     		ldr	r3, [r7, #4]
 1319 000e 002B     		cmp	r3, #0
 1320 0010 02D1     		bne	.L82
 1321              		.loc 1 1467 21 is_stmt 0 discriminator 1
 1322 0012 074B     		ldr	r3, .L85
 1323 0014 1B68     		ldr	r3, [r3]
 1324 0016 00E0     		b	.L83
 1325              	.L82:
 1326              		.loc 1 1467 21 discriminator 2
 1327 0018 7B68     		ldr	r3, [r7, #4]
 1328              	.L83:
 1329              		.loc 1 1467 19 is_stmt 1 discriminator 4
 1330 001a FB60     		str	r3, [r7, #12]
1468:Lib/FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1331              		.loc 1 1468 22
 1332 001c FB68     		ldr	r3, [r7, #12]
 1333 001e DB6A     		ldr	r3, [r3, #44]
 1334 0020 BB60     		str	r3, [r7, #8]
1469:Lib/FreeRTOS/Source/tasks.c ****         }
1470:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 1335              		.loc 1 1470 9
 1336 0022 FFF7FEFF 		bl	vPortExitCritical
1471:Lib/FreeRTOS/Source/tasks.c **** 
1472:Lib/FreeRTOS/Source/tasks.c ****         return uxReturn;
 1337              		.loc 1 1472 16
 1338 0026 BB68     		ldr	r3, [r7, #8]
1473:Lib/FreeRTOS/Source/tasks.c ****     }
 1339              		.loc 1 1473 5
 1340 0028 1846     		mov	r0, r3
 1341 002a 1037     		adds	r7, r7, #16
 1342              		.cfi_def_cfa_offset 8
 1343 002c BD46     		mov	sp, r7
 1344              		.cfi_def_cfa_register 13
 1345              		@ sp needed
 1346 002e 80BD     		pop	{r7, pc}
 1347              	.L86:
 1348              		.align	2
 1349              	.L85:
 1350 0030 00000000 		.word	pxCurrentTCB
 1351              		.cfi_endproc
ARM GAS  /tmp/ccTFOe4z.s 			page 50


 1352              	.LFE7:
 1354              		.section	.text.uxTaskPriorityGetFromISR,"ax",%progbits
 1355              		.align	1
 1356              		.global	uxTaskPriorityGetFromISR
 1357              		.syntax unified
 1358              		.thumb
 1359              		.thumb_func
 1361              	uxTaskPriorityGetFromISR:
 1362              	.LFB8:
1474:Lib/FreeRTOS/Source/tasks.c **** 
1475:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1476:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1477:Lib/FreeRTOS/Source/tasks.c **** 
1478:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
1479:Lib/FreeRTOS/Source/tasks.c **** 
1480:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
1481:Lib/FreeRTOS/Source/tasks.c ****     {
 1363              		.loc 1 1481 5
 1364              		.cfi_startproc
 1365              		@ args = 0, pretend = 0, frame = 24
 1366              		@ frame_needed = 1, uses_anonymous_args = 0
 1367 0000 80B5     		push	{r7, lr}
 1368              		.cfi_def_cfa_offset 8
 1369              		.cfi_offset 7, -8
 1370              		.cfi_offset 14, -4
 1371 0002 86B0     		sub	sp, sp, #24
 1372              		.cfi_def_cfa_offset 32
 1373 0004 00AF     		add	r7, sp, #0
 1374              		.cfi_def_cfa_register 7
 1375 0006 7860     		str	r0, [r7, #4]
1482:Lib/FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
1483:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
1484:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptState;
1485:Lib/FreeRTOS/Source/tasks.c **** 
1486:Lib/FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1487:Lib/FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
1488:Lib/FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1489:Lib/FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1490:Lib/FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1491:Lib/FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
1492:Lib/FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1493:Lib/FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1494:Lib/FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
1495:Lib/FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1496:Lib/FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1497:Lib/FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1498:Lib/FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1499:Lib/FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1500:Lib/FreeRTOS/Source/tasks.c ****          * provided on the following link:
1501:Lib/FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1502:Lib/FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1376              		.loc 1 1502 9
 1377 0008 FFF7FEFF 		bl	vPortValidateInterruptPriority
1503:Lib/FreeRTOS/Source/tasks.c **** 
1504:Lib/FreeRTOS/Source/tasks.c ****         uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 1378              		.loc 1 1504 33
 1379 000c FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/ccTFOe4z.s 			page 51


 1380 0010 7861     		str	r0, [r7, #20]
1505:Lib/FreeRTOS/Source/tasks.c ****         {
1506:Lib/FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1507:Lib/FreeRTOS/Source/tasks.c ****              * task that is being queried. */
1508:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
 1381              		.loc 1 1508 21
 1382 0012 7B68     		ldr	r3, [r7, #4]
 1383 0014 002B     		cmp	r3, #0
 1384 0016 02D1     		bne	.L88
 1385              		.loc 1 1508 21 is_stmt 0 discriminator 1
 1386 0018 074B     		ldr	r3, .L91
 1387 001a 1B68     		ldr	r3, [r3]
 1388 001c 00E0     		b	.L89
 1389              	.L88:
 1390              		.loc 1 1508 21 discriminator 2
 1391 001e 7B68     		ldr	r3, [r7, #4]
 1392              	.L89:
 1393              		.loc 1 1508 19 is_stmt 1 discriminator 4
 1394 0020 3B61     		str	r3, [r7, #16]
1509:Lib/FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxPriority;
 1395              		.loc 1 1509 22
 1396 0022 3B69     		ldr	r3, [r7, #16]
 1397 0024 DB6A     		ldr	r3, [r3, #44]
 1398 0026 FB60     		str	r3, [r7, #12]
1510:Lib/FreeRTOS/Source/tasks.c ****         }
1511:Lib/FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
 1399              		.loc 1 1511 9
 1400 0028 7869     		ldr	r0, [r7, #20]
 1401 002a FFF7FEFF 		bl	vClearInterruptMask
1512:Lib/FreeRTOS/Source/tasks.c **** 
1513:Lib/FreeRTOS/Source/tasks.c ****         return uxReturn;
 1402              		.loc 1 1513 16
 1403 002e FB68     		ldr	r3, [r7, #12]
1514:Lib/FreeRTOS/Source/tasks.c ****     }
 1404              		.loc 1 1514 5
 1405 0030 1846     		mov	r0, r3
 1406 0032 1837     		adds	r7, r7, #24
 1407              		.cfi_def_cfa_offset 8
 1408 0034 BD46     		mov	sp, r7
 1409              		.cfi_def_cfa_register 13
 1410              		@ sp needed
 1411 0036 80BD     		pop	{r7, pc}
 1412              	.L92:
 1413              		.align	2
 1414              	.L91:
 1415 0038 00000000 		.word	pxCurrentTCB
 1416              		.cfi_endproc
 1417              	.LFE8:
 1419              		.section	.text.vTaskPrioritySet,"ax",%progbits
 1420              		.align	1
 1421              		.global	vTaskPrioritySet
 1422              		.syntax unified
 1423              		.thumb
 1424              		.thumb_func
 1426              	vTaskPrioritySet:
 1427              	.LFB9:
1515:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 52


1516:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskPriorityGet */
1517:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1518:Lib/FreeRTOS/Source/tasks.c **** 
1519:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
1520:Lib/FreeRTOS/Source/tasks.c **** 
1521:Lib/FreeRTOS/Source/tasks.c ****     void vTaskPrioritySet( TaskHandle_t xTask,
1522:Lib/FreeRTOS/Source/tasks.c ****                            UBaseType_t uxNewPriority )
1523:Lib/FreeRTOS/Source/tasks.c ****     {
 1428              		.loc 1 1523 5
 1429              		.cfi_startproc
 1430              		@ args = 0, pretend = 0, frame = 32
 1431              		@ frame_needed = 1, uses_anonymous_args = 0
 1432 0000 80B5     		push	{r7, lr}
 1433              		.cfi_def_cfa_offset 8
 1434              		.cfi_offset 7, -8
 1435              		.cfi_offset 14, -4
 1436 0002 88B0     		sub	sp, sp, #32
 1437              		.cfi_def_cfa_offset 40
 1438 0004 00AF     		add	r7, sp, #0
 1439              		.cfi_def_cfa_register 7
 1440 0006 7860     		str	r0, [r7, #4]
 1441 0008 3960     		str	r1, [r7]
1524:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1525:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1526:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 1442              		.loc 1 1526 20
 1443 000a 0023     		movs	r3, #0
 1444 000c FB61     		str	r3, [r7, #28]
1527:Lib/FreeRTOS/Source/tasks.c **** 
1528:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxNewPriority < configMAX_PRIORITIES );
 1445              		.loc 1 1528 9
 1446 000e 3B68     		ldr	r3, [r7]
 1447 0010 372B     		cmp	r3, #55
 1448 0012 08D9     		bls	.L94
 1449              		.loc 1 1528 9 is_stmt 0 discriminator 1
 1450 0014 FFF7FEFF 		bl	ulSetInterruptMask
 1451 0018 544B     		ldr	r3, .L105
 1452 001a 554A     		ldr	r2, .L105+4
 1453 001c 4FF4BF61 		mov	r1, #1528
 1454 0020 5448     		ldr	r0, .L105+8
 1455 0022 FFF7FEFF 		bl	__assert_func
 1456              	.L94:
1529:Lib/FreeRTOS/Source/tasks.c **** 
1530:Lib/FreeRTOS/Source/tasks.c ****         /* Ensure the new priority is valid. */
1531:Lib/FreeRTOS/Source/tasks.c ****         if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1457              		.loc 1 1531 11 is_stmt 1
 1458 0026 3B68     		ldr	r3, [r7]
 1459 0028 372B     		cmp	r3, #55
 1460 002a 01D9     		bls	.L95
1532:Lib/FreeRTOS/Source/tasks.c ****         {
1533:Lib/FreeRTOS/Source/tasks.c ****             uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1461              		.loc 1 1533 27
 1462 002c 3723     		movs	r3, #55
 1463 002e 3B60     		str	r3, [r7]
 1464              	.L95:
1534:Lib/FreeRTOS/Source/tasks.c ****         }
1535:Lib/FreeRTOS/Source/tasks.c ****         else
ARM GAS  /tmp/ccTFOe4z.s 			page 53


1536:Lib/FreeRTOS/Source/tasks.c ****         {
1537:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1538:Lib/FreeRTOS/Source/tasks.c ****         }
1539:Lib/FreeRTOS/Source/tasks.c **** 
1540:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 1465              		.loc 1 1540 9
 1466 0030 FFF7FEFF 		bl	vPortEnterCritical
1541:Lib/FreeRTOS/Source/tasks.c ****         {
1542:Lib/FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the priority of the calling
1543:Lib/FreeRTOS/Source/tasks.c ****              * task that is being changed. */
1544:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTask );
 1467              		.loc 1 1544 21
 1468 0034 7B68     		ldr	r3, [r7, #4]
 1469 0036 002B     		cmp	r3, #0
 1470 0038 02D1     		bne	.L96
 1471              		.loc 1 1544 21 is_stmt 0 discriminator 1
 1472 003a 4F4B     		ldr	r3, .L105+12
 1473 003c 1B68     		ldr	r3, [r3]
 1474 003e 00E0     		b	.L97
 1475              	.L96:
 1476              		.loc 1 1544 21 discriminator 2
 1477 0040 7B68     		ldr	r3, [r7, #4]
 1478              	.L97:
 1479              		.loc 1 1544 19 is_stmt 1 discriminator 4
 1480 0042 BB61     		str	r3, [r7, #24]
1545:Lib/FreeRTOS/Source/tasks.c **** 
1546:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1547:Lib/FreeRTOS/Source/tasks.c **** 
1548:Lib/FreeRTOS/Source/tasks.c ****             #if ( configUSE_MUTEXES == 1 )
1549:Lib/FreeRTOS/Source/tasks.c ****             {
1550:Lib/FreeRTOS/Source/tasks.c ****                 uxCurrentBasePriority = pxTCB->uxBasePriority;
 1481              		.loc 1 1550 39
 1482 0044 BB69     		ldr	r3, [r7, #24]
 1483 0046 DB6C     		ldr	r3, [r3, #76]
 1484 0048 7B61     		str	r3, [r7, #20]
1551:Lib/FreeRTOS/Source/tasks.c ****             }
1552:Lib/FreeRTOS/Source/tasks.c ****             #else
1553:Lib/FreeRTOS/Source/tasks.c ****             {
1554:Lib/FreeRTOS/Source/tasks.c ****                 uxCurrentBasePriority = pxTCB->uxPriority;
1555:Lib/FreeRTOS/Source/tasks.c ****             }
1556:Lib/FreeRTOS/Source/tasks.c ****             #endif
1557:Lib/FreeRTOS/Source/tasks.c **** 
1558:Lib/FreeRTOS/Source/tasks.c ****             if( uxCurrentBasePriority != uxNewPriority )
 1485              		.loc 1 1558 15
 1486 004a 7A69     		ldr	r2, [r7, #20]
 1487 004c 3B68     		ldr	r3, [r7]
 1488 004e 9A42     		cmp	r2, r3
 1489 0050 00F08680 		beq	.L98
1559:Lib/FreeRTOS/Source/tasks.c ****             {
1560:Lib/FreeRTOS/Source/tasks.c ****                 /* The priority change may have readied a task of higher
1561:Lib/FreeRTOS/Source/tasks.c ****                  * priority than the calling task. */
1562:Lib/FreeRTOS/Source/tasks.c ****                 if( uxNewPriority > uxCurrentBasePriority )
 1490              		.loc 1 1562 19
 1491 0054 3A68     		ldr	r2, [r7]
 1492 0056 7B69     		ldr	r3, [r7, #20]
 1493 0058 9A42     		cmp	r2, r3
 1494 005a 0DD9     		bls	.L99
ARM GAS  /tmp/ccTFOe4z.s 			page 54


1563:Lib/FreeRTOS/Source/tasks.c ****                 {
1564:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB != pxCurrentTCB )
 1495              		.loc 1 1564 31
 1496 005c 464B     		ldr	r3, .L105+12
 1497 005e 1B68     		ldr	r3, [r3]
 1498              		.loc 1 1564 23
 1499 0060 BA69     		ldr	r2, [r7, #24]
 1500 0062 9A42     		cmp	r2, r3
 1501 0064 0FD0     		beq	.L100
1565:Lib/FreeRTOS/Source/tasks.c ****                     {
1566:Lib/FreeRTOS/Source/tasks.c ****                         /* The priority of a task other than the currently
1567:Lib/FreeRTOS/Source/tasks.c ****                          * running task is being raised.  Is the priority being
1568:Lib/FreeRTOS/Source/tasks.c ****                          * raised above that of the running task? */
1569:Lib/FreeRTOS/Source/tasks.c ****                         if( uxNewPriority > pxCurrentTCB->uxPriority )
 1502              		.loc 1 1569 57
 1503 0066 444B     		ldr	r3, .L105+12
 1504 0068 1B68     		ldr	r3, [r3]
 1505 006a DB6A     		ldr	r3, [r3, #44]
 1506              		.loc 1 1569 27
 1507 006c 3A68     		ldr	r2, [r7]
 1508 006e 9A42     		cmp	r2, r3
 1509 0070 09D9     		bls	.L100
1570:Lib/FreeRTOS/Source/tasks.c ****                         {
1571:Lib/FreeRTOS/Source/tasks.c ****                             xYieldRequired = pdTRUE;
 1510              		.loc 1 1571 44
 1511 0072 0123     		movs	r3, #1
 1512 0074 FB61     		str	r3, [r7, #28]
 1513 0076 06E0     		b	.L100
 1514              	.L99:
1572:Lib/FreeRTOS/Source/tasks.c ****                         }
1573:Lib/FreeRTOS/Source/tasks.c ****                         else
1574:Lib/FreeRTOS/Source/tasks.c ****                         {
1575:Lib/FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
1576:Lib/FreeRTOS/Source/tasks.c ****                         }
1577:Lib/FreeRTOS/Source/tasks.c ****                     }
1578:Lib/FreeRTOS/Source/tasks.c ****                     else
1579:Lib/FreeRTOS/Source/tasks.c ****                     {
1580:Lib/FreeRTOS/Source/tasks.c ****                         /* The priority of the running task is being raised,
1581:Lib/FreeRTOS/Source/tasks.c ****                          * but the running task must already be the highest
1582:Lib/FreeRTOS/Source/tasks.c ****                          * priority task able to run so no yield is required. */
1583:Lib/FreeRTOS/Source/tasks.c ****                     }
1584:Lib/FreeRTOS/Source/tasks.c ****                 }
1585:Lib/FreeRTOS/Source/tasks.c ****                 else if( pxTCB == pxCurrentTCB )
 1515              		.loc 1 1585 32
 1516 0078 3F4B     		ldr	r3, .L105+12
 1517 007a 1B68     		ldr	r3, [r3]
 1518              		.loc 1 1585 24
 1519 007c BA69     		ldr	r2, [r7, #24]
 1520 007e 9A42     		cmp	r2, r3
 1521 0080 01D1     		bne	.L100
1586:Lib/FreeRTOS/Source/tasks.c ****                 {
1587:Lib/FreeRTOS/Source/tasks.c ****                     /* Setting the priority of the running task down means
1588:Lib/FreeRTOS/Source/tasks.c ****                      * there may now be another task of higher priority that
1589:Lib/FreeRTOS/Source/tasks.c ****                      * is ready to execute. */
1590:Lib/FreeRTOS/Source/tasks.c ****                     xYieldRequired = pdTRUE;
 1522              		.loc 1 1590 36
 1523 0082 0123     		movs	r3, #1
ARM GAS  /tmp/ccTFOe4z.s 			page 55


 1524 0084 FB61     		str	r3, [r7, #28]
 1525              	.L100:
1591:Lib/FreeRTOS/Source/tasks.c ****                 }
1592:Lib/FreeRTOS/Source/tasks.c ****                 else
1593:Lib/FreeRTOS/Source/tasks.c ****                 {
1594:Lib/FreeRTOS/Source/tasks.c ****                     /* Setting the priority of any other task down does not
1595:Lib/FreeRTOS/Source/tasks.c ****                      * require a yield as the running task must be above the
1596:Lib/FreeRTOS/Source/tasks.c ****                      * new priority of the task being modified. */
1597:Lib/FreeRTOS/Source/tasks.c ****                 }
1598:Lib/FreeRTOS/Source/tasks.c **** 
1599:Lib/FreeRTOS/Source/tasks.c ****                 /* Remember the ready list the task might be referenced from
1600:Lib/FreeRTOS/Source/tasks.c ****                  * before its uxPriority member is changed so the
1601:Lib/FreeRTOS/Source/tasks.c ****                  * taskRESET_READY_PRIORITY() macro can function correctly. */
1602:Lib/FreeRTOS/Source/tasks.c ****                 uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1526              		.loc 1 1602 39
 1527 0086 BB69     		ldr	r3, [r7, #24]
 1528 0088 DB6A     		ldr	r3, [r3, #44]
 1529 008a 3B61     		str	r3, [r7, #16]
1603:Lib/FreeRTOS/Source/tasks.c **** 
1604:Lib/FreeRTOS/Source/tasks.c ****                 #if ( configUSE_MUTEXES == 1 )
1605:Lib/FreeRTOS/Source/tasks.c ****                 {
1606:Lib/FreeRTOS/Source/tasks.c ****                     /* Only change the priority being used if the task is not
1607:Lib/FreeRTOS/Source/tasks.c ****                      * currently using an inherited priority. */
1608:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1530              		.loc 1 1608 30
 1531 008c BB69     		ldr	r3, [r7, #24]
 1532 008e DA6C     		ldr	r2, [r3, #76]
 1533              		.loc 1 1608 55
 1534 0090 BB69     		ldr	r3, [r7, #24]
 1535 0092 DB6A     		ldr	r3, [r3, #44]
 1536              		.loc 1 1608 23
 1537 0094 9A42     		cmp	r2, r3
 1538 0096 02D1     		bne	.L101
1609:Lib/FreeRTOS/Source/tasks.c ****                     {
1610:Lib/FreeRTOS/Source/tasks.c ****                         pxTCB->uxPriority = uxNewPriority;
 1539              		.loc 1 1610 43
 1540 0098 BB69     		ldr	r3, [r7, #24]
 1541 009a 3A68     		ldr	r2, [r7]
 1542 009c DA62     		str	r2, [r3, #44]
 1543              	.L101:
1611:Lib/FreeRTOS/Source/tasks.c ****                     }
1612:Lib/FreeRTOS/Source/tasks.c ****                     else
1613:Lib/FreeRTOS/Source/tasks.c ****                     {
1614:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1615:Lib/FreeRTOS/Source/tasks.c ****                     }
1616:Lib/FreeRTOS/Source/tasks.c **** 
1617:Lib/FreeRTOS/Source/tasks.c ****                     /* The base priority gets set whatever. */
1618:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->uxBasePriority = uxNewPriority;
 1544              		.loc 1 1618 43
 1545 009e BB69     		ldr	r3, [r7, #24]
 1546 00a0 3A68     		ldr	r2, [r7]
 1547 00a2 DA64     		str	r2, [r3, #76]
1619:Lib/FreeRTOS/Source/tasks.c ****                 }
1620:Lib/FreeRTOS/Source/tasks.c ****                 #else /* if ( configUSE_MUTEXES == 1 ) */
1621:Lib/FreeRTOS/Source/tasks.c ****                 {
1622:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->uxPriority = uxNewPriority;
1623:Lib/FreeRTOS/Source/tasks.c ****                 }
ARM GAS  /tmp/ccTFOe4z.s 			page 56


1624:Lib/FreeRTOS/Source/tasks.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1625:Lib/FreeRTOS/Source/tasks.c **** 
1626:Lib/FreeRTOS/Source/tasks.c ****                 /* Only reset the event list item value if the value is not
1627:Lib/FreeRTOS/Source/tasks.c ****                  * being used for anything else. */
1628:Lib/FreeRTOS/Source/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_V
 1548              		.loc 1 1628 23
 1549 00a4 BB69     		ldr	r3, [r7, #24]
 1550 00a6 9B69     		ldr	r3, [r3, #24]
 1551              		.loc 1 1628 19
 1552 00a8 002B     		cmp	r3, #0
 1553 00aa 04DB     		blt	.L102
1629:Lib/FreeRTOS/Source/tasks.c ****                 {
1630:Lib/FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX
 1554              		.loc 1 1630 21
 1555 00ac 3B68     		ldr	r3, [r7]
 1556 00ae C3F13802 		rsb	r2, r3, #56
 1557 00b2 BB69     		ldr	r3, [r7, #24]
 1558 00b4 9A61     		str	r2, [r3, #24]
 1559              	.L102:
1631:Lib/FreeRTOS/Source/tasks.c ****                 }
1632:Lib/FreeRTOS/Source/tasks.c ****                 else
1633:Lib/FreeRTOS/Source/tasks.c ****                 {
1634:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1635:Lib/FreeRTOS/Source/tasks.c ****                 }
1636:Lib/FreeRTOS/Source/tasks.c **** 
1637:Lib/FreeRTOS/Source/tasks.c ****                 /* If the task is in the blocked or suspended list we need do
1638:Lib/FreeRTOS/Source/tasks.c ****                  * nothing more than change its priority variable. However, if
1639:Lib/FreeRTOS/Source/tasks.c ****                  * the task is in a ready list it needs to be removed and placed
1640:Lib/FreeRTOS/Source/tasks.c ****                  * in the list appropriate to its new priority. */
1641:Lib/FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( px
 1560              		.loc 1 1641 21
 1561 00b6 BB69     		ldr	r3, [r7, #24]
 1562 00b8 5969     		ldr	r1, [r3, #20]
 1563 00ba 3A69     		ldr	r2, [r7, #16]
 1564 00bc 1346     		mov	r3, r2
 1565 00be 9B00     		lsls	r3, r3, #2
 1566 00c0 1344     		add	r3, r3, r2
 1567 00c2 9B00     		lsls	r3, r3, #2
 1568 00c4 2D4A     		ldr	r2, .L105+16
 1569 00c6 1344     		add	r3, r3, r2
 1570              		.loc 1 1641 19
 1571 00c8 9942     		cmp	r1, r3
 1572 00ca 44D1     		bne	.L103
1642:Lib/FreeRTOS/Source/tasks.c ****                 {
1643:Lib/FreeRTOS/Source/tasks.c ****                     /* The task is currently in its ready list - remove before
1644:Lib/FreeRTOS/Source/tasks.c ****                      * adding it to its new ready list.  As we are in a critical
1645:Lib/FreeRTOS/Source/tasks.c ****                      * section we can do this even if the scheduler is suspended. */
1646:Lib/FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1573              		.loc 1 1646 25
 1574 00cc BB69     		ldr	r3, [r7, #24]
 1575 00ce 0433     		adds	r3, r3, #4
 1576 00d0 1846     		mov	r0, r3
 1577 00d2 FFF7FEFF 		bl	uxListRemove
1647:Lib/FreeRTOS/Source/tasks.c ****                     {
1648:Lib/FreeRTOS/Source/tasks.c ****                         /* It is known that the task is in its ready list so
1649:Lib/FreeRTOS/Source/tasks.c ****                          * there is no need to check again and the port level
1650:Lib/FreeRTOS/Source/tasks.c ****                          * reset macro can be called directly. */
ARM GAS  /tmp/ccTFOe4z.s 			page 57


1651:Lib/FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1652:Lib/FreeRTOS/Source/tasks.c ****                     }
1653:Lib/FreeRTOS/Source/tasks.c ****                     else
1654:Lib/FreeRTOS/Source/tasks.c ****                     {
1655:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1656:Lib/FreeRTOS/Source/tasks.c ****                     }
1657:Lib/FreeRTOS/Source/tasks.c **** 
1658:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 1578              		.loc 1 1658 21
 1579 00d6 BB69     		ldr	r3, [r7, #24]
 1580 00d8 DA6A     		ldr	r2, [r3, #44]
 1581 00da 294B     		ldr	r3, .L105+20
 1582 00dc 1B68     		ldr	r3, [r3]
 1583 00de 9A42     		cmp	r2, r3
 1584 00e0 03D9     		bls	.L104
 1585              		.loc 1 1658 21 is_stmt 0 discriminator 1
 1586 00e2 BB69     		ldr	r3, [r7, #24]
 1587 00e4 DB6A     		ldr	r3, [r3, #44]
 1588 00e6 264A     		ldr	r2, .L105+20
 1589 00e8 1360     		str	r3, [r2]
 1590              	.L104:
 1591              	.LBB6:
 1592              		.loc 1 1658 21 discriminator 3
 1593 00ea BB69     		ldr	r3, [r7, #24]
 1594 00ec DA6A     		ldr	r2, [r3, #44]
 1595 00ee 2349     		ldr	r1, .L105+16
 1596 00f0 1346     		mov	r3, r2
 1597 00f2 9B00     		lsls	r3, r3, #2
 1598 00f4 1344     		add	r3, r3, r2
 1599 00f6 9B00     		lsls	r3, r3, #2
 1600 00f8 0B44     		add	r3, r3, r1
 1601 00fa 0433     		adds	r3, r3, #4
 1602 00fc 1B68     		ldr	r3, [r3]
 1603 00fe FB60     		str	r3, [r7, #12]
 1604 0100 BB69     		ldr	r3, [r7, #24]
 1605 0102 FA68     		ldr	r2, [r7, #12]
 1606 0104 9A60     		str	r2, [r3, #8]
 1607 0106 FB68     		ldr	r3, [r7, #12]
 1608 0108 9A68     		ldr	r2, [r3, #8]
 1609 010a BB69     		ldr	r3, [r7, #24]
 1610 010c DA60     		str	r2, [r3, #12]
 1611 010e FB68     		ldr	r3, [r7, #12]
 1612 0110 9B68     		ldr	r3, [r3, #8]
 1613 0112 BA69     		ldr	r2, [r7, #24]
 1614 0114 0432     		adds	r2, r2, #4
 1615 0116 5A60     		str	r2, [r3, #4]
 1616 0118 BB69     		ldr	r3, [r7, #24]
 1617 011a 1A1D     		adds	r2, r3, #4
 1618 011c FB68     		ldr	r3, [r7, #12]
 1619 011e 9A60     		str	r2, [r3, #8]
 1620 0120 BB69     		ldr	r3, [r7, #24]
 1621 0122 DA6A     		ldr	r2, [r3, #44]
 1622 0124 1346     		mov	r3, r2
 1623 0126 9B00     		lsls	r3, r3, #2
 1624 0128 1344     		add	r3, r3, r2
 1625 012a 9B00     		lsls	r3, r3, #2
 1626 012c 134A     		ldr	r2, .L105+16
ARM GAS  /tmp/ccTFOe4z.s 			page 58


 1627 012e 1A44     		add	r2, r2, r3
 1628 0130 BB69     		ldr	r3, [r7, #24]
 1629 0132 5A61     		str	r2, [r3, #20]
 1630 0134 BB69     		ldr	r3, [r7, #24]
 1631 0136 DA6A     		ldr	r2, [r3, #44]
 1632 0138 1049     		ldr	r1, .L105+16
 1633 013a 1346     		mov	r3, r2
 1634 013c 9B00     		lsls	r3, r3, #2
 1635 013e 1344     		add	r3, r3, r2
 1636 0140 9B00     		lsls	r3, r3, #2
 1637 0142 0B44     		add	r3, r3, r1
 1638 0144 1B68     		ldr	r3, [r3]
 1639 0146 591C     		adds	r1, r3, #1
 1640 0148 0C48     		ldr	r0, .L105+16
 1641 014a 1346     		mov	r3, r2
 1642 014c 9B00     		lsls	r3, r3, #2
 1643 014e 1344     		add	r3, r3, r2
 1644 0150 9B00     		lsls	r3, r3, #2
 1645 0152 0344     		add	r3, r3, r0
 1646 0154 1960     		str	r1, [r3]
 1647              	.L103:
 1648              	.LBE6:
1659:Lib/FreeRTOS/Source/tasks.c ****                 }
1660:Lib/FreeRTOS/Source/tasks.c ****                 else
1661:Lib/FreeRTOS/Source/tasks.c ****                 {
1662:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1663:Lib/FreeRTOS/Source/tasks.c ****                 }
1664:Lib/FreeRTOS/Source/tasks.c **** 
1665:Lib/FreeRTOS/Source/tasks.c ****                 if( xYieldRequired != pdFALSE )
 1649              		.loc 1 1665 19 is_stmt 1
 1650 0156 FB69     		ldr	r3, [r7, #28]
 1651 0158 002B     		cmp	r3, #0
 1652 015a 01D0     		beq	.L98
1666:Lib/FreeRTOS/Source/tasks.c ****                 {
1667:Lib/FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
 1653              		.loc 1 1667 21
 1654 015c FFF7FEFF 		bl	vPortYield
 1655              	.L98:
1668:Lib/FreeRTOS/Source/tasks.c ****                 }
1669:Lib/FreeRTOS/Source/tasks.c ****                 else
1670:Lib/FreeRTOS/Source/tasks.c ****                 {
1671:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1672:Lib/FreeRTOS/Source/tasks.c ****                 }
1673:Lib/FreeRTOS/Source/tasks.c **** 
1674:Lib/FreeRTOS/Source/tasks.c ****                 /* Remove compiler warning about unused variables when the port
1675:Lib/FreeRTOS/Source/tasks.c ****                  * optimised task selection is not being used. */
1676:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) uxPriorityUsedOnEntry;
1677:Lib/FreeRTOS/Source/tasks.c ****             }
1678:Lib/FreeRTOS/Source/tasks.c ****         }
1679:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 1656              		.loc 1 1679 9
 1657 0160 FFF7FEFF 		bl	vPortExitCritical
1680:Lib/FreeRTOS/Source/tasks.c ****     }
 1658              		.loc 1 1680 5
 1659 0164 00BF     		nop
 1660 0166 2037     		adds	r7, r7, #32
 1661              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccTFOe4z.s 			page 59


 1662 0168 BD46     		mov	sp, r7
 1663              		.cfi_def_cfa_register 13
 1664              		@ sp needed
 1665 016a 80BD     		pop	{r7, pc}
 1666              	.L106:
 1667              		.align	2
 1668              	.L105:
 1669 016c 00000000 		.word	.LC0
 1670 0170 00000000 		.word	__func__.28
 1671 0174 04000000 		.word	.LC1
 1672 0178 00000000 		.word	pxCurrentTCB
 1673 017c 00000000 		.word	pxReadyTasksLists
 1674 0180 00000000 		.word	uxTopReadyPriority
 1675              		.cfi_endproc
 1676              	.LFE9:
 1678              		.section	.text.vTaskSuspend,"ax",%progbits
 1679              		.align	1
 1680              		.global	vTaskSuspend
 1681              		.syntax unified
 1682              		.thumb
 1683              		.thumb_func
 1685              	vTaskSuspend:
 1686              	.LFB10:
1681:Lib/FreeRTOS/Source/tasks.c **** 
1682:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskPrioritySet */
1683:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1684:Lib/FreeRTOS/Source/tasks.c **** 
1685:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1686:Lib/FreeRTOS/Source/tasks.c **** 
1687:Lib/FreeRTOS/Source/tasks.c ****     void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1688:Lib/FreeRTOS/Source/tasks.c ****     {
 1687              		.loc 1 1688 5
 1688              		.cfi_startproc
 1689              		@ args = 0, pretend = 0, frame = 16
 1690              		@ frame_needed = 1, uses_anonymous_args = 0
 1691 0000 80B5     		push	{r7, lr}
 1692              		.cfi_def_cfa_offset 8
 1693              		.cfi_offset 7, -8
 1694              		.cfi_offset 14, -4
 1695 0002 84B0     		sub	sp, sp, #16
 1696              		.cfi_def_cfa_offset 24
 1697 0004 00AF     		add	r7, sp, #0
 1698              		.cfi_def_cfa_register 7
 1699 0006 7860     		str	r0, [r7, #4]
1689:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
1690:Lib/FreeRTOS/Source/tasks.c **** 
1691:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 1700              		.loc 1 1691 9
 1701 0008 FFF7FEFF 		bl	vPortEnterCritical
1692:Lib/FreeRTOS/Source/tasks.c ****         {
1693:Lib/FreeRTOS/Source/tasks.c ****             /* If null is passed in here then it is the running task that is
1694:Lib/FreeRTOS/Source/tasks.c ****              * being suspended. */
1695:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1702              		.loc 1 1695 21
 1703 000c 7B68     		ldr	r3, [r7, #4]
 1704 000e 002B     		cmp	r3, #0
 1705 0010 02D1     		bne	.L108
ARM GAS  /tmp/ccTFOe4z.s 			page 60


 1706              		.loc 1 1695 21 is_stmt 0 discriminator 1
 1707 0012 324B     		ldr	r3, .L120
 1708 0014 1B68     		ldr	r3, [r3]
 1709 0016 00E0     		b	.L109
 1710              	.L108:
 1711              		.loc 1 1695 21 discriminator 2
 1712 0018 7B68     		ldr	r3, [r7, #4]
 1713              	.L109:
 1714              		.loc 1 1695 19 is_stmt 1 discriminator 4
 1715 001a BB60     		str	r3, [r7, #8]
1696:Lib/FreeRTOS/Source/tasks.c **** 
1697:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_SUSPEND( pxTCB );
1698:Lib/FreeRTOS/Source/tasks.c **** 
1699:Lib/FreeRTOS/Source/tasks.c ****             /* Remove task from the ready/delayed list and place in the
1700:Lib/FreeRTOS/Source/tasks.c ****              * suspended list. */
1701:Lib/FreeRTOS/Source/tasks.c ****             if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1716              		.loc 1 1701 17
 1717 001c BB68     		ldr	r3, [r7, #8]
 1718 001e 0433     		adds	r3, r3, #4
 1719 0020 1846     		mov	r0, r3
 1720 0022 FFF7FEFF 		bl	uxListRemove
1702:Lib/FreeRTOS/Source/tasks.c ****             {
1703:Lib/FreeRTOS/Source/tasks.c ****                 taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1704:Lib/FreeRTOS/Source/tasks.c ****             }
1705:Lib/FreeRTOS/Source/tasks.c ****             else
1706:Lib/FreeRTOS/Source/tasks.c ****             {
1707:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1708:Lib/FreeRTOS/Source/tasks.c ****             }
1709:Lib/FreeRTOS/Source/tasks.c **** 
1710:Lib/FreeRTOS/Source/tasks.c ****             /* Is the task waiting on an event also? */
1711:Lib/FreeRTOS/Source/tasks.c ****             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1721              		.loc 1 1711 17
 1722 0026 BB68     		ldr	r3, [r7, #8]
 1723 0028 9B6A     		ldr	r3, [r3, #40]
 1724              		.loc 1 1711 15
 1725 002a 002B     		cmp	r3, #0
 1726 002c 04D0     		beq	.L110
1712:Lib/FreeRTOS/Source/tasks.c ****             {
1713:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1727              		.loc 1 1713 26
 1728 002e BB68     		ldr	r3, [r7, #8]
 1729 0030 1833     		adds	r3, r3, #24
 1730 0032 1846     		mov	r0, r3
 1731 0034 FFF7FEFF 		bl	uxListRemove
 1732              	.L110:
1714:Lib/FreeRTOS/Source/tasks.c ****             }
1715:Lib/FreeRTOS/Source/tasks.c ****             else
1716:Lib/FreeRTOS/Source/tasks.c ****             {
1717:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1718:Lib/FreeRTOS/Source/tasks.c ****             }
1719:Lib/FreeRTOS/Source/tasks.c **** 
1720:Lib/FreeRTOS/Source/tasks.c ****             vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1733              		.loc 1 1720 13
 1734 0038 BB68     		ldr	r3, [r7, #8]
 1735 003a 0433     		adds	r3, r3, #4
 1736 003c 1946     		mov	r1, r3
 1737 003e 2848     		ldr	r0, .L120+4
ARM GAS  /tmp/ccTFOe4z.s 			page 61


 1738 0040 FFF7FEFF 		bl	vListInsertEnd
 1739              	.LBB7:
1721:Lib/FreeRTOS/Source/tasks.c **** 
1722:Lib/FreeRTOS/Source/tasks.c ****             #if ( configUSE_TASK_NOTIFICATIONS == 1 )
1723:Lib/FreeRTOS/Source/tasks.c ****             {
1724:Lib/FreeRTOS/Source/tasks.c ****                 BaseType_t x;
1725:Lib/FreeRTOS/Source/tasks.c **** 
1726:Lib/FreeRTOS/Source/tasks.c ****                 for( x = 0; x < configTASK_NOTIFICATION_ARRAY_ENTRIES; x++ )
 1740              		.loc 1 1726 24
 1741 0044 0023     		movs	r3, #0
 1742 0046 FB60     		str	r3, [r7, #12]
 1743              		.loc 1 1726 17
 1744 0048 10E0     		b	.L111
 1745              	.L113:
1727:Lib/FreeRTOS/Source/tasks.c ****                 {
1728:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 1746              		.loc 1 1728 45
 1747 004a BA68     		ldr	r2, [r7, #8]
 1748 004c FB68     		ldr	r3, [r7, #12]
 1749 004e 1344     		add	r3, r3, r2
 1750 0050 5C33     		adds	r3, r3, #92
 1751 0052 1B78     		ldrb	r3, [r3]
 1752 0054 DBB2     		uxtb	r3, r3
 1753              		.loc 1 1728 23
 1754 0056 012B     		cmp	r3, #1
 1755 0058 05D1     		bne	.L112
1729:Lib/FreeRTOS/Source/tasks.c ****                     {
1730:Lib/FreeRTOS/Source/tasks.c ****                         /* The task was blocked to wait for a notification, but is
1731:Lib/FreeRTOS/Source/tasks.c ****                          * now suspended, so no notification was received. */
1732:Lib/FreeRTOS/Source/tasks.c ****                         pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 1756              		.loc 1 1732 51
 1757 005a BA68     		ldr	r2, [r7, #8]
 1758 005c FB68     		ldr	r3, [r7, #12]
 1759 005e 1344     		add	r3, r3, r2
 1760 0060 5C33     		adds	r3, r3, #92
 1761 0062 0022     		movs	r2, #0
 1762 0064 1A70     		strb	r2, [r3]
 1763              	.L112:
1726:Lib/FreeRTOS/Source/tasks.c ****                 {
 1764              		.loc 1 1726 73 discriminator 2
 1765 0066 FB68     		ldr	r3, [r7, #12]
 1766 0068 0133     		adds	r3, r3, #1
 1767 006a FB60     		str	r3, [r7, #12]
 1768              	.L111:
1726:Lib/FreeRTOS/Source/tasks.c ****                 {
 1769              		.loc 1 1726 31 discriminator 1
 1770 006c FB68     		ldr	r3, [r7, #12]
 1771 006e 002B     		cmp	r3, #0
 1772 0070 EBDD     		ble	.L113
 1773              	.LBE7:
1733:Lib/FreeRTOS/Source/tasks.c ****                     }
1734:Lib/FreeRTOS/Source/tasks.c ****                 }
1735:Lib/FreeRTOS/Source/tasks.c ****             }
1736:Lib/FreeRTOS/Source/tasks.c ****             #endif /* if ( configUSE_TASK_NOTIFICATIONS == 1 ) */
1737:Lib/FreeRTOS/Source/tasks.c ****         }
1738:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 1774              		.loc 1 1738 9
ARM GAS  /tmp/ccTFOe4z.s 			page 62


 1775 0072 FFF7FEFF 		bl	vPortExitCritical
1739:Lib/FreeRTOS/Source/tasks.c **** 
1740:Lib/FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
 1776              		.loc 1 1740 31
 1777 0076 1B4B     		ldr	r3, .L120+8
 1778 0078 1B68     		ldr	r3, [r3]
 1779              		.loc 1 1740 11
 1780 007a 002B     		cmp	r3, #0
 1781 007c 05D0     		beq	.L114
1741:Lib/FreeRTOS/Source/tasks.c ****         {
1742:Lib/FreeRTOS/Source/tasks.c ****             /* Reset the next expected unblock time in case it referred to the
1743:Lib/FreeRTOS/Source/tasks.c ****              * task that is now in the Suspended state. */
1744:Lib/FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
 1782              		.loc 1 1744 13
 1783 007e FFF7FEFF 		bl	vPortEnterCritical
1745:Lib/FreeRTOS/Source/tasks.c ****             {
1746:Lib/FreeRTOS/Source/tasks.c ****                 prvResetNextTaskUnblockTime();
 1784              		.loc 1 1746 17
 1785 0082 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
1747:Lib/FreeRTOS/Source/tasks.c ****             }
1748:Lib/FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
 1786              		.loc 1 1748 13
 1787 0086 FFF7FEFF 		bl	vPortExitCritical
 1788              	.L114:
1749:Lib/FreeRTOS/Source/tasks.c ****         }
1750:Lib/FreeRTOS/Source/tasks.c ****         else
1751:Lib/FreeRTOS/Source/tasks.c ****         {
1752:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1753:Lib/FreeRTOS/Source/tasks.c ****         }
1754:Lib/FreeRTOS/Source/tasks.c **** 
1755:Lib/FreeRTOS/Source/tasks.c ****         if( pxTCB == pxCurrentTCB )
 1789              		.loc 1 1755 19
 1790 008a 144B     		ldr	r3, .L120
 1791 008c 1B68     		ldr	r3, [r3]
 1792              		.loc 1 1755 11
 1793 008e BA68     		ldr	r2, [r7, #8]
 1794 0090 9A42     		cmp	r2, r3
 1795 0092 1FD1     		bne	.L119
1756:Lib/FreeRTOS/Source/tasks.c ****         {
1757:Lib/FreeRTOS/Source/tasks.c ****             if( xSchedulerRunning != pdFALSE )
 1796              		.loc 1 1757 35
 1797 0094 134B     		ldr	r3, .L120+8
 1798 0096 1B68     		ldr	r3, [r3]
 1799              		.loc 1 1757 15
 1800 0098 002B     		cmp	r3, #0
 1801 009a 0FD0     		beq	.L116
1758:Lib/FreeRTOS/Source/tasks.c ****             {
1759:Lib/FreeRTOS/Source/tasks.c ****                 /* The current task has just been suspended. */
1760:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 1802              		.loc 1 1760 17
 1803 009c 124B     		ldr	r3, .L120+12
 1804 009e 1B68     		ldr	r3, [r3]
 1805 00a0 002B     		cmp	r3, #0
 1806 00a2 08D0     		beq	.L117
 1807              		.loc 1 1760 17 is_stmt 0 discriminator 1
 1808 00a4 FFF7FEFF 		bl	ulSetInterruptMask
 1809 00a8 104B     		ldr	r3, .L120+16
ARM GAS  /tmp/ccTFOe4z.s 			page 63


 1810 00aa 114A     		ldr	r2, .L120+20
 1811 00ac 4FF4DC61 		mov	r1, #1760
 1812 00b0 1048     		ldr	r0, .L120+24
 1813 00b2 FFF7FEFF 		bl	__assert_func
 1814              	.L117:
1761:Lib/FreeRTOS/Source/tasks.c ****                 portYIELD_WITHIN_API();
 1815              		.loc 1 1761 17 is_stmt 1
 1816 00b6 FFF7FEFF 		bl	vPortYield
1762:Lib/FreeRTOS/Source/tasks.c ****             }
1763:Lib/FreeRTOS/Source/tasks.c ****             else
1764:Lib/FreeRTOS/Source/tasks.c ****             {
1765:Lib/FreeRTOS/Source/tasks.c ****                 /* The scheduler is not running, but the task that was pointed
1766:Lib/FreeRTOS/Source/tasks.c ****                  * to by pxCurrentTCB has just been suspended and pxCurrentTCB
1767:Lib/FreeRTOS/Source/tasks.c ****                  * must be adjusted to point to a different task. */
1768:Lib/FreeRTOS/Source/tasks.c ****                 if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*li
1769:Lib/FreeRTOS/Source/tasks.c ****                 {
1770:Lib/FreeRTOS/Source/tasks.c ****                     /* No other tasks are ready, so set pxCurrentTCB back to
1771:Lib/FreeRTOS/Source/tasks.c ****                      * NULL so when the next task is created pxCurrentTCB will
1772:Lib/FreeRTOS/Source/tasks.c ****                      * be set to point to it no matter what its relative priority
1773:Lib/FreeRTOS/Source/tasks.c ****                      * is. */
1774:Lib/FreeRTOS/Source/tasks.c ****                     pxCurrentTCB = NULL;
1775:Lib/FreeRTOS/Source/tasks.c ****                 }
1776:Lib/FreeRTOS/Source/tasks.c ****                 else
1777:Lib/FreeRTOS/Source/tasks.c ****                 {
1778:Lib/FreeRTOS/Source/tasks.c ****                     vTaskSwitchContext();
1779:Lib/FreeRTOS/Source/tasks.c ****                 }
1780:Lib/FreeRTOS/Source/tasks.c ****             }
1781:Lib/FreeRTOS/Source/tasks.c ****         }
1782:Lib/FreeRTOS/Source/tasks.c ****         else
1783:Lib/FreeRTOS/Source/tasks.c ****         {
1784:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1785:Lib/FreeRTOS/Source/tasks.c ****         }
1786:Lib/FreeRTOS/Source/tasks.c ****     }
 1817              		.loc 1 1786 5
 1818 00ba 0BE0     		b	.L119
 1819              	.L116:
1768:Lib/FreeRTOS/Source/tasks.c ****                 {
 1820              		.loc 1 1768 21
 1821 00bc 084B     		ldr	r3, .L120+4
 1822 00be 1A68     		ldr	r2, [r3]
1768:Lib/FreeRTOS/Source/tasks.c ****                 {
 1823              		.loc 1 1768 68
 1824 00c0 0D4B     		ldr	r3, .L120+28
 1825 00c2 1B68     		ldr	r3, [r3]
1768:Lib/FreeRTOS/Source/tasks.c ****                 {
 1826              		.loc 1 1768 19
 1827 00c4 9A42     		cmp	r2, r3
 1828 00c6 03D1     		bne	.L118
1774:Lib/FreeRTOS/Source/tasks.c ****                 }
 1829              		.loc 1 1774 34
 1830 00c8 044B     		ldr	r3, .L120
 1831 00ca 0022     		movs	r2, #0
 1832 00cc 1A60     		str	r2, [r3]
 1833              		.loc 1 1786 5
 1834 00ce 01E0     		b	.L119
 1835              	.L118:
1778:Lib/FreeRTOS/Source/tasks.c ****                 }
ARM GAS  /tmp/ccTFOe4z.s 			page 64


 1836              		.loc 1 1778 21
 1837 00d0 FFF7FEFF 		bl	vTaskSwitchContext
 1838              	.L119:
 1839              		.loc 1 1786 5
 1840 00d4 00BF     		nop
 1841 00d6 1037     		adds	r7, r7, #16
 1842              		.cfi_def_cfa_offset 8
 1843 00d8 BD46     		mov	sp, r7
 1844              		.cfi_def_cfa_register 13
 1845              		@ sp needed
 1846 00da 80BD     		pop	{r7, pc}
 1847              	.L121:
 1848              		.align	2
 1849              	.L120:
 1850 00dc 00000000 		.word	pxCurrentTCB
 1851 00e0 00000000 		.word	xSuspendedTaskList
 1852 00e4 00000000 		.word	xSchedulerRunning
 1853 00e8 00000000 		.word	uxSchedulerSuspended
 1854 00ec 00000000 		.word	.LC0
 1855 00f0 00000000 		.word	__func__.27
 1856 00f4 04000000 		.word	.LC1
 1857 00f8 00000000 		.word	uxCurrentNumberOfTasks
 1858              		.cfi_endproc
 1859              	.LFE10:
 1861              		.section	.text.prvTaskIsTaskSuspended,"ax",%progbits
 1862              		.align	1
 1863              		.syntax unified
 1864              		.thumb
 1865              		.thumb_func
 1867              	prvTaskIsTaskSuspended:
 1868              	.LFB11:
1787:Lib/FreeRTOS/Source/tasks.c **** 
1788:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1789:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1790:Lib/FreeRTOS/Source/tasks.c **** 
1791:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1792:Lib/FreeRTOS/Source/tasks.c **** 
1793:Lib/FreeRTOS/Source/tasks.c ****     static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1794:Lib/FreeRTOS/Source/tasks.c ****     {
 1869              		.loc 1 1794 5
 1870              		.cfi_startproc
 1871              		@ args = 0, pretend = 0, frame = 16
 1872              		@ frame_needed = 1, uses_anonymous_args = 0
 1873 0000 80B5     		push	{r7, lr}
 1874              		.cfi_def_cfa_offset 8
 1875              		.cfi_offset 7, -8
 1876              		.cfi_offset 14, -4
 1877 0002 84B0     		sub	sp, sp, #16
 1878              		.cfi_def_cfa_offset 24
 1879 0004 00AF     		add	r7, sp, #0
 1880              		.cfi_def_cfa_register 7
 1881 0006 7860     		str	r0, [r7, #4]
1795:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
 1882              		.loc 1 1795 20
 1883 0008 0023     		movs	r3, #0
 1884 000a FB60     		str	r3, [r7, #12]
1796:Lib/FreeRTOS/Source/tasks.c ****         const TCB_t * const pxTCB = xTask;
ARM GAS  /tmp/ccTFOe4z.s 			page 65


 1885              		.loc 1 1796 29
 1886 000c 7B68     		ldr	r3, [r7, #4]
 1887 000e BB60     		str	r3, [r7, #8]
1797:Lib/FreeRTOS/Source/tasks.c **** 
1798:Lib/FreeRTOS/Source/tasks.c ****         /* Accesses xPendingReadyList so must be called from a critical
1799:Lib/FreeRTOS/Source/tasks.c ****          * section. */
1800:Lib/FreeRTOS/Source/tasks.c **** 
1801:Lib/FreeRTOS/Source/tasks.c ****         /* It does not make sense to check if the calling task is suspended. */
1802:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTask );
 1888              		.loc 1 1802 9
 1889 0010 7B68     		ldr	r3, [r7, #4]
 1890 0012 002B     		cmp	r3, #0
 1891 0014 08D1     		bne	.L123
 1892              		.loc 1 1802 9 is_stmt 0 discriminator 1
 1893 0016 FFF7FEFF 		bl	ulSetInterruptMask
 1894 001a 0E4B     		ldr	r3, .L126
 1895 001c 0E4A     		ldr	r2, .L126+4
 1896 001e 40F20A71 		movw	r1, #1802
 1897 0022 0E48     		ldr	r0, .L126+8
 1898 0024 FFF7FEFF 		bl	__assert_func
 1899              	.L123:
1803:Lib/FreeRTOS/Source/tasks.c **** 
1804:Lib/FreeRTOS/Source/tasks.c ****         /* Is the task being resumed actually in the suspended list? */
1805:Lib/FreeRTOS/Source/tasks.c ****         if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1900              		.loc 1 1805 13 is_stmt 1
 1901 0028 BB68     		ldr	r3, [r7, #8]
 1902 002a 5B69     		ldr	r3, [r3, #20]
 1903              		.loc 1 1805 11
 1904 002c 0C4A     		ldr	r2, .L126+12
 1905 002e 9342     		cmp	r3, r2
 1906 0030 0AD1     		bne	.L124
1806:Lib/FreeRTOS/Source/tasks.c ****         {
1807:Lib/FreeRTOS/Source/tasks.c ****             /* Has the task already been resumed from within an ISR? */
1808:Lib/FreeRTOS/Source/tasks.c ****             if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALS
 1907              		.loc 1 1808 17
 1908 0032 BB68     		ldr	r3, [r7, #8]
 1909 0034 9B6A     		ldr	r3, [r3, #40]
 1910              		.loc 1 1808 15
 1911 0036 0B4A     		ldr	r2, .L126+16
 1912 0038 9342     		cmp	r3, r2
 1913 003a 05D0     		beq	.L124
1809:Lib/FreeRTOS/Source/tasks.c ****             {
1810:Lib/FreeRTOS/Source/tasks.c ****                 /* Is it in the suspended list because it is in the Suspended
1811:Lib/FreeRTOS/Source/tasks.c ****                  * state, or because is is blocked with no timeout? */
1812:Lib/FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint
 1914              		.loc 1 1812 21
 1915 003c BB68     		ldr	r3, [r7, #8]
 1916 003e 9B6A     		ldr	r3, [r3, #40]
 1917              		.loc 1 1812 19
 1918 0040 002B     		cmp	r3, #0
 1919 0042 01D1     		bne	.L124
1813:Lib/FreeRTOS/Source/tasks.c ****                 {
1814:Lib/FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
 1920              		.loc 1 1814 29
 1921 0044 0123     		movs	r3, #1
 1922 0046 FB60     		str	r3, [r7, #12]
 1923              	.L124:
ARM GAS  /tmp/ccTFOe4z.s 			page 66


1815:Lib/FreeRTOS/Source/tasks.c ****                 }
1816:Lib/FreeRTOS/Source/tasks.c ****                 else
1817:Lib/FreeRTOS/Source/tasks.c ****                 {
1818:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1819:Lib/FreeRTOS/Source/tasks.c ****                 }
1820:Lib/FreeRTOS/Source/tasks.c ****             }
1821:Lib/FreeRTOS/Source/tasks.c ****             else
1822:Lib/FreeRTOS/Source/tasks.c ****             {
1823:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1824:Lib/FreeRTOS/Source/tasks.c ****             }
1825:Lib/FreeRTOS/Source/tasks.c ****         }
1826:Lib/FreeRTOS/Source/tasks.c ****         else
1827:Lib/FreeRTOS/Source/tasks.c ****         {
1828:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1829:Lib/FreeRTOS/Source/tasks.c ****         }
1830:Lib/FreeRTOS/Source/tasks.c **** 
1831:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 1924              		.loc 1 1831 16
 1925 0048 FB68     		ldr	r3, [r7, #12]
1832:Lib/FreeRTOS/Source/tasks.c ****     } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1926              		.loc 1 1832 5
 1927 004a 1846     		mov	r0, r3
 1928 004c 1037     		adds	r7, r7, #16
 1929              		.cfi_def_cfa_offset 8
 1930 004e BD46     		mov	sp, r7
 1931              		.cfi_def_cfa_register 13
 1932              		@ sp needed
 1933 0050 80BD     		pop	{r7, pc}
 1934              	.L127:
 1935 0052 00BF     		.align	2
 1936              	.L126:
 1937 0054 00000000 		.word	.LC0
 1938 0058 00000000 		.word	__func__.26
 1939 005c 04000000 		.word	.LC1
 1940 0060 00000000 		.word	xSuspendedTaskList
 1941 0064 00000000 		.word	xPendingReadyList
 1942              		.cfi_endproc
 1943              	.LFE11:
 1945              		.section	.text.vTaskResume,"ax",%progbits
 1946              		.align	1
 1947              		.global	vTaskResume
 1948              		.syntax unified
 1949              		.thumb
 1950              		.thumb_func
 1952              	vTaskResume:
 1953              	.LFB12:
1833:Lib/FreeRTOS/Source/tasks.c **** 
1834:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1835:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1836:Lib/FreeRTOS/Source/tasks.c **** 
1837:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1838:Lib/FreeRTOS/Source/tasks.c **** 
1839:Lib/FreeRTOS/Source/tasks.c ****     void vTaskResume( TaskHandle_t xTaskToResume )
1840:Lib/FreeRTOS/Source/tasks.c ****     {
 1954              		.loc 1 1840 5
 1955              		.cfi_startproc
 1956              		@ args = 0, pretend = 0, frame = 16
ARM GAS  /tmp/ccTFOe4z.s 			page 67


 1957              		@ frame_needed = 1, uses_anonymous_args = 0
 1958 0000 80B5     		push	{r7, lr}
 1959              		.cfi_def_cfa_offset 8
 1960              		.cfi_offset 7, -8
 1961              		.cfi_offset 14, -4
 1962 0002 84B0     		sub	sp, sp, #16
 1963              		.cfi_def_cfa_offset 24
 1964 0004 00AF     		add	r7, sp, #0
 1965              		.cfi_def_cfa_register 7
 1966 0006 7860     		str	r0, [r7, #4]
1841:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 1967              		.loc 1 1841 23
 1968 0008 7B68     		ldr	r3, [r7, #4]
 1969 000a FB60     		str	r3, [r7, #12]
1842:Lib/FreeRTOS/Source/tasks.c **** 
1843:Lib/FreeRTOS/Source/tasks.c ****         /* It does not make sense to resume the calling task. */
1844:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToResume );
 1970              		.loc 1 1844 9
 1971 000c 7B68     		ldr	r3, [r7, #4]
 1972 000e 002B     		cmp	r3, #0
 1973 0010 08D1     		bne	.L129
 1974              		.loc 1 1844 9 is_stmt 0 discriminator 1
 1975 0012 FFF7FEFF 		bl	ulSetInterruptMask
 1976 0016 354B     		ldr	r3, .L134
 1977 0018 354A     		ldr	r2, .L134+4
 1978 001a 40F23471 		movw	r1, #1844
 1979 001e 3548     		ldr	r0, .L134+8
 1980 0020 FFF7FEFF 		bl	__assert_func
 1981              	.L129:
1845:Lib/FreeRTOS/Source/tasks.c **** 
1846:Lib/FreeRTOS/Source/tasks.c ****         /* The parameter cannot be NULL as it is impossible to resume the
1847:Lib/FreeRTOS/Source/tasks.c ****          * currently executing task. */
1848:Lib/FreeRTOS/Source/tasks.c ****         if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 1982              		.loc 1 1848 21 is_stmt 1
 1983 0024 344B     		ldr	r3, .L134+12
 1984 0026 1B68     		ldr	r3, [r3]
 1985              		.loc 1 1848 11
 1986 0028 FA68     		ldr	r2, [r7, #12]
 1987 002a 9A42     		cmp	r2, r3
 1988 002c 5AD0     		beq	.L133
 1989              		.loc 1 1848 39 discriminator 1
 1990 002e FB68     		ldr	r3, [r7, #12]
 1991 0030 002B     		cmp	r3, #0
 1992 0032 57D0     		beq	.L133
1849:Lib/FreeRTOS/Source/tasks.c ****         {
1850:Lib/FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
 1993              		.loc 1 1850 13
 1994 0034 FFF7FEFF 		bl	vPortEnterCritical
1851:Lib/FreeRTOS/Source/tasks.c ****             {
1852:Lib/FreeRTOS/Source/tasks.c ****                 if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1995              		.loc 1 1852 21
 1996 0038 F868     		ldr	r0, [r7, #12]
 1997 003a FFF7FEFF 		bl	prvTaskIsTaskSuspended
 1998 003e 0346     		mov	r3, r0
 1999              		.loc 1 1852 19 discriminator 1
 2000 0040 002B     		cmp	r3, #0
 2001 0042 4DD0     		beq	.L131
ARM GAS  /tmp/ccTFOe4z.s 			page 68


1853:Lib/FreeRTOS/Source/tasks.c ****                 {
1854:Lib/FreeRTOS/Source/tasks.c ****                     traceTASK_RESUME( pxTCB );
1855:Lib/FreeRTOS/Source/tasks.c **** 
1856:Lib/FreeRTOS/Source/tasks.c ****                     /* The ready list can be accessed even if the scheduler is
1857:Lib/FreeRTOS/Source/tasks.c ****                      * suspended because this is inside a critical section. */
1858:Lib/FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2002              		.loc 1 1858 30
 2003 0044 FB68     		ldr	r3, [r7, #12]
 2004 0046 0433     		adds	r3, r3, #4
 2005 0048 1846     		mov	r0, r3
 2006 004a FFF7FEFF 		bl	uxListRemove
1859:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2007              		.loc 1 1859 21
 2008 004e FB68     		ldr	r3, [r7, #12]
 2009 0050 DA6A     		ldr	r2, [r3, #44]
 2010 0052 2A4B     		ldr	r3, .L134+16
 2011 0054 1B68     		ldr	r3, [r3]
 2012 0056 9A42     		cmp	r2, r3
 2013 0058 03D9     		bls	.L132
 2014              		.loc 1 1859 21 is_stmt 0 discriminator 1
 2015 005a FB68     		ldr	r3, [r7, #12]
 2016 005c DB6A     		ldr	r3, [r3, #44]
 2017 005e 274A     		ldr	r2, .L134+16
 2018 0060 1360     		str	r3, [r2]
 2019              	.L132:
 2020              	.LBB8:
 2021              		.loc 1 1859 21 discriminator 3
 2022 0062 FB68     		ldr	r3, [r7, #12]
 2023 0064 DA6A     		ldr	r2, [r3, #44]
 2024 0066 2649     		ldr	r1, .L134+20
 2025 0068 1346     		mov	r3, r2
 2026 006a 9B00     		lsls	r3, r3, #2
 2027 006c 1344     		add	r3, r3, r2
 2028 006e 9B00     		lsls	r3, r3, #2
 2029 0070 0B44     		add	r3, r3, r1
 2030 0072 0433     		adds	r3, r3, #4
 2031 0074 1B68     		ldr	r3, [r3]
 2032 0076 BB60     		str	r3, [r7, #8]
 2033 0078 FB68     		ldr	r3, [r7, #12]
 2034 007a BA68     		ldr	r2, [r7, #8]
 2035 007c 9A60     		str	r2, [r3, #8]
 2036 007e BB68     		ldr	r3, [r7, #8]
 2037 0080 9A68     		ldr	r2, [r3, #8]
 2038 0082 FB68     		ldr	r3, [r7, #12]
 2039 0084 DA60     		str	r2, [r3, #12]
 2040 0086 BB68     		ldr	r3, [r7, #8]
 2041 0088 9B68     		ldr	r3, [r3, #8]
 2042 008a FA68     		ldr	r2, [r7, #12]
 2043 008c 0432     		adds	r2, r2, #4
 2044 008e 5A60     		str	r2, [r3, #4]
 2045 0090 FB68     		ldr	r3, [r7, #12]
 2046 0092 1A1D     		adds	r2, r3, #4
 2047 0094 BB68     		ldr	r3, [r7, #8]
 2048 0096 9A60     		str	r2, [r3, #8]
 2049 0098 FB68     		ldr	r3, [r7, #12]
 2050 009a DA6A     		ldr	r2, [r3, #44]
 2051 009c 1346     		mov	r3, r2
ARM GAS  /tmp/ccTFOe4z.s 			page 69


 2052 009e 9B00     		lsls	r3, r3, #2
 2053 00a0 1344     		add	r3, r3, r2
 2054 00a2 9B00     		lsls	r3, r3, #2
 2055 00a4 164A     		ldr	r2, .L134+20
 2056 00a6 1A44     		add	r2, r2, r3
 2057 00a8 FB68     		ldr	r3, [r7, #12]
 2058 00aa 5A61     		str	r2, [r3, #20]
 2059 00ac FB68     		ldr	r3, [r7, #12]
 2060 00ae DA6A     		ldr	r2, [r3, #44]
 2061 00b0 1349     		ldr	r1, .L134+20
 2062 00b2 1346     		mov	r3, r2
 2063 00b4 9B00     		lsls	r3, r3, #2
 2064 00b6 1344     		add	r3, r3, r2
 2065 00b8 9B00     		lsls	r3, r3, #2
 2066 00ba 0B44     		add	r3, r3, r1
 2067 00bc 1B68     		ldr	r3, [r3]
 2068 00be 591C     		adds	r1, r3, #1
 2069 00c0 0F48     		ldr	r0, .L134+20
 2070 00c2 1346     		mov	r3, r2
 2071 00c4 9B00     		lsls	r3, r3, #2
 2072 00c6 1344     		add	r3, r3, r2
 2073 00c8 9B00     		lsls	r3, r3, #2
 2074 00ca 0344     		add	r3, r3, r0
 2075 00cc 1960     		str	r1, [r3]
 2076              	.LBE8:
1860:Lib/FreeRTOS/Source/tasks.c **** 
1861:Lib/FreeRTOS/Source/tasks.c ****                     /* A higher priority task may have just been resumed. */
1862:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2077              		.loc 1 1862 30 is_stmt 1
 2078 00ce FB68     		ldr	r3, [r7, #12]
 2079 00d0 DA6A     		ldr	r2, [r3, #44]
 2080              		.loc 1 1862 57
 2081 00d2 094B     		ldr	r3, .L134+12
 2082 00d4 1B68     		ldr	r3, [r3]
 2083 00d6 DB6A     		ldr	r3, [r3, #44]
 2084              		.loc 1 1862 23
 2085 00d8 9A42     		cmp	r2, r3
 2086 00da 01D9     		bls	.L131
1863:Lib/FreeRTOS/Source/tasks.c ****                     {
1864:Lib/FreeRTOS/Source/tasks.c ****                         /* This yield may not cause the task just resumed to run,
1865:Lib/FreeRTOS/Source/tasks.c ****                          * but will leave the lists in the correct state for the
1866:Lib/FreeRTOS/Source/tasks.c ****                          * next yield. */
1867:Lib/FreeRTOS/Source/tasks.c ****                         taskYIELD_IF_USING_PREEMPTION();
 2087              		.loc 1 1867 25
 2088 00dc FFF7FEFF 		bl	vPortYield
 2089              	.L131:
1868:Lib/FreeRTOS/Source/tasks.c ****                     }
1869:Lib/FreeRTOS/Source/tasks.c ****                     else
1870:Lib/FreeRTOS/Source/tasks.c ****                     {
1871:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1872:Lib/FreeRTOS/Source/tasks.c ****                     }
1873:Lib/FreeRTOS/Source/tasks.c ****                 }
1874:Lib/FreeRTOS/Source/tasks.c ****                 else
1875:Lib/FreeRTOS/Source/tasks.c ****                 {
1876:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
1877:Lib/FreeRTOS/Source/tasks.c ****                 }
1878:Lib/FreeRTOS/Source/tasks.c ****             }
ARM GAS  /tmp/ccTFOe4z.s 			page 70


1879:Lib/FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
 2090              		.loc 1 1879 13
 2091 00e0 FFF7FEFF 		bl	vPortExitCritical
 2092              	.L133:
1880:Lib/FreeRTOS/Source/tasks.c ****         }
1881:Lib/FreeRTOS/Source/tasks.c ****         else
1882:Lib/FreeRTOS/Source/tasks.c ****         {
1883:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
1884:Lib/FreeRTOS/Source/tasks.c ****         }
1885:Lib/FreeRTOS/Source/tasks.c ****     }
 2093              		.loc 1 1885 5
 2094 00e4 00BF     		nop
 2095 00e6 1037     		adds	r7, r7, #16
 2096              		.cfi_def_cfa_offset 8
 2097 00e8 BD46     		mov	sp, r7
 2098              		.cfi_def_cfa_register 13
 2099              		@ sp needed
 2100 00ea 80BD     		pop	{r7, pc}
 2101              	.L135:
 2102              		.align	2
 2103              	.L134:
 2104 00ec 00000000 		.word	.LC0
 2105 00f0 00000000 		.word	__func__.25
 2106 00f4 04000000 		.word	.LC1
 2107 00f8 00000000 		.word	pxCurrentTCB
 2108 00fc 00000000 		.word	uxTopReadyPriority
 2109 0100 00000000 		.word	pxReadyTasksLists
 2110              		.cfi_endproc
 2111              	.LFE12:
 2113              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 2114              		.align	1
 2115              		.global	xTaskResumeFromISR
 2116              		.syntax unified
 2117              		.thumb
 2118              		.thumb_func
 2120              	xTaskResumeFromISR:
 2121              	.LFB13:
1886:Lib/FreeRTOS/Source/tasks.c **** 
1887:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskSuspend */
1888:Lib/FreeRTOS/Source/tasks.c **** 
1889:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1890:Lib/FreeRTOS/Source/tasks.c **** 
1891:Lib/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1892:Lib/FreeRTOS/Source/tasks.c **** 
1893:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1894:Lib/FreeRTOS/Source/tasks.c ****     {
 2122              		.loc 1 1894 5
 2123              		.cfi_startproc
 2124              		@ args = 0, pretend = 0, frame = 24
 2125              		@ frame_needed = 1, uses_anonymous_args = 0
 2126 0000 80B5     		push	{r7, lr}
 2127              		.cfi_def_cfa_offset 8
 2128              		.cfi_offset 7, -8
 2129              		.cfi_offset 14, -4
 2130 0002 86B0     		sub	sp, sp, #24
 2131              		.cfi_def_cfa_offset 32
 2132 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/ccTFOe4z.s 			page 71


 2133              		.cfi_def_cfa_register 7
 2134 0006 7860     		str	r0, [r7, #4]
1895:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xYieldRequired = pdFALSE;
 2135              		.loc 1 1895 20
 2136 0008 0023     		movs	r3, #0
 2137 000a 7B61     		str	r3, [r7, #20]
1896:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = xTaskToResume;
 2138              		.loc 1 1896 23
 2139 000c 7B68     		ldr	r3, [r7, #4]
 2140 000e 3B61     		str	r3, [r7, #16]
1897:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
1898:Lib/FreeRTOS/Source/tasks.c **** 
1899:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToResume );
 2141              		.loc 1 1899 9
 2142 0010 7B68     		ldr	r3, [r7, #4]
 2143 0012 002B     		cmp	r3, #0
 2144 0014 08D1     		bne	.L137
 2145              		.loc 1 1899 9 is_stmt 0 discriminator 1
 2146 0016 FFF7FEFF 		bl	ulSetInterruptMask
 2147 001a 3B4B     		ldr	r3, .L143
 2148 001c 3B4A     		ldr	r2, .L143+4
 2149 001e 40F26B71 		movw	r1, #1899
 2150 0022 3B48     		ldr	r0, .L143+8
 2151 0024 FFF7FEFF 		bl	__assert_func
 2152              	.L137:
1900:Lib/FreeRTOS/Source/tasks.c **** 
1901:Lib/FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
1902:Lib/FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
1903:Lib/FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
1904:Lib/FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
1905:Lib/FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1906:Lib/FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
1907:Lib/FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1908:Lib/FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
1909:Lib/FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
1910:Lib/FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
1911:Lib/FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
1912:Lib/FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
1913:Lib/FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
1914:Lib/FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
1915:Lib/FreeRTOS/Source/tasks.c ****          * provided on the following link:
1916:Lib/FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1917:Lib/FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2153              		.loc 1 1917 9 is_stmt 1
 2154 0028 FFF7FEFF 		bl	vPortValidateInterruptPriority
1918:Lib/FreeRTOS/Source/tasks.c **** 
1919:Lib/FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2155              		.loc 1 1919 34
 2156 002c FFF7FEFF 		bl	ulSetInterruptMask
 2157 0030 F860     		str	r0, [r7, #12]
1920:Lib/FreeRTOS/Source/tasks.c ****         {
1921:Lib/FreeRTOS/Source/tasks.c ****             if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 2158              		.loc 1 1921 17
 2159 0032 3869     		ldr	r0, [r7, #16]
 2160 0034 FFF7FEFF 		bl	prvTaskIsTaskSuspended
 2161 0038 0346     		mov	r3, r0
 2162              		.loc 1 1921 15 discriminator 1
ARM GAS  /tmp/ccTFOe4z.s 			page 72


 2163 003a 002B     		cmp	r3, #0
 2164 003c 5BD0     		beq	.L138
1922:Lib/FreeRTOS/Source/tasks.c ****             {
1923:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_RESUME_FROM_ISR( pxTCB );
1924:Lib/FreeRTOS/Source/tasks.c **** 
1925:Lib/FreeRTOS/Source/tasks.c ****                 /* Check the ready lists can be accessed. */
1926:Lib/FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 2165              		.loc 1 1926 42
 2166 003e 354B     		ldr	r3, .L143+12
 2167 0040 1B68     		ldr	r3, [r3]
 2168              		.loc 1 1926 19
 2169 0042 002B     		cmp	r3, #0
 2170 0044 51D1     		bne	.L139
1927:Lib/FreeRTOS/Source/tasks.c ****                 {
1928:Lib/FreeRTOS/Source/tasks.c ****                     /* Ready lists can be accessed so move the task from the
1929:Lib/FreeRTOS/Source/tasks.c ****                      * suspended list to the ready list directly. */
1930:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2171              		.loc 1 1930 30
 2172 0046 3B69     		ldr	r3, [r7, #16]
 2173 0048 DA6A     		ldr	r2, [r3, #44]
 2174              		.loc 1 1930 57
 2175 004a 334B     		ldr	r3, .L143+16
 2176 004c 1B68     		ldr	r3, [r3]
 2177 004e DB6A     		ldr	r3, [r3, #44]
 2178              		.loc 1 1930 23
 2179 0050 9A42     		cmp	r2, r3
 2180 0052 04D9     		bls	.L140
1931:Lib/FreeRTOS/Source/tasks.c ****                     {
1932:Lib/FreeRTOS/Source/tasks.c ****                         xYieldRequired = pdTRUE;
 2181              		.loc 1 1932 40
 2182 0054 0123     		movs	r3, #1
 2183 0056 7B61     		str	r3, [r7, #20]
1933:Lib/FreeRTOS/Source/tasks.c **** 
1934:Lib/FreeRTOS/Source/tasks.c ****                         /* Mark that a yield is pending in case the user is not
1935:Lib/FreeRTOS/Source/tasks.c ****                          * using the return value to initiate a context switch
1936:Lib/FreeRTOS/Source/tasks.c ****                          * from the ISR using portYIELD_FROM_ISR. */
1937:Lib/FreeRTOS/Source/tasks.c ****                         xYieldPending = pdTRUE;
 2184              		.loc 1 1937 39
 2185 0058 304B     		ldr	r3, .L143+20
 2186 005a 0122     		movs	r2, #1
 2187 005c 1A60     		str	r2, [r3]
 2188              	.L140:
1938:Lib/FreeRTOS/Source/tasks.c ****                     }
1939:Lib/FreeRTOS/Source/tasks.c ****                     else
1940:Lib/FreeRTOS/Source/tasks.c ****                     {
1941:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
1942:Lib/FreeRTOS/Source/tasks.c ****                     }
1943:Lib/FreeRTOS/Source/tasks.c **** 
1944:Lib/FreeRTOS/Source/tasks.c ****                     ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2189              		.loc 1 1944 30
 2190 005e 3B69     		ldr	r3, [r7, #16]
 2191 0060 0433     		adds	r3, r3, #4
 2192 0062 1846     		mov	r0, r3
 2193 0064 FFF7FEFF 		bl	uxListRemove
1945:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2194              		.loc 1 1945 21
 2195 0068 3B69     		ldr	r3, [r7, #16]
ARM GAS  /tmp/ccTFOe4z.s 			page 73


 2196 006a DA6A     		ldr	r2, [r3, #44]
 2197 006c 2C4B     		ldr	r3, .L143+24
 2198 006e 1B68     		ldr	r3, [r3]
 2199 0070 9A42     		cmp	r2, r3
 2200 0072 03D9     		bls	.L141
 2201              		.loc 1 1945 21 is_stmt 0 discriminator 1
 2202 0074 3B69     		ldr	r3, [r7, #16]
 2203 0076 DB6A     		ldr	r3, [r3, #44]
 2204 0078 294A     		ldr	r2, .L143+24
 2205 007a 1360     		str	r3, [r2]
 2206              	.L141:
 2207              	.LBB9:
 2208              		.loc 1 1945 21 discriminator 3
 2209 007c 3B69     		ldr	r3, [r7, #16]
 2210 007e DA6A     		ldr	r2, [r3, #44]
 2211 0080 2849     		ldr	r1, .L143+28
 2212 0082 1346     		mov	r3, r2
 2213 0084 9B00     		lsls	r3, r3, #2
 2214 0086 1344     		add	r3, r3, r2
 2215 0088 9B00     		lsls	r3, r3, #2
 2216 008a 0B44     		add	r3, r3, r1
 2217 008c 0433     		adds	r3, r3, #4
 2218 008e 1B68     		ldr	r3, [r3]
 2219 0090 BB60     		str	r3, [r7, #8]
 2220 0092 3B69     		ldr	r3, [r7, #16]
 2221 0094 BA68     		ldr	r2, [r7, #8]
 2222 0096 9A60     		str	r2, [r3, #8]
 2223 0098 BB68     		ldr	r3, [r7, #8]
 2224 009a 9A68     		ldr	r2, [r3, #8]
 2225 009c 3B69     		ldr	r3, [r7, #16]
 2226 009e DA60     		str	r2, [r3, #12]
 2227 00a0 BB68     		ldr	r3, [r7, #8]
 2228 00a2 9B68     		ldr	r3, [r3, #8]
 2229 00a4 3A69     		ldr	r2, [r7, #16]
 2230 00a6 0432     		adds	r2, r2, #4
 2231 00a8 5A60     		str	r2, [r3, #4]
 2232 00aa 3B69     		ldr	r3, [r7, #16]
 2233 00ac 1A1D     		adds	r2, r3, #4
 2234 00ae BB68     		ldr	r3, [r7, #8]
 2235 00b0 9A60     		str	r2, [r3, #8]
 2236 00b2 3B69     		ldr	r3, [r7, #16]
 2237 00b4 DA6A     		ldr	r2, [r3, #44]
 2238 00b6 1346     		mov	r3, r2
 2239 00b8 9B00     		lsls	r3, r3, #2
 2240 00ba 1344     		add	r3, r3, r2
 2241 00bc 9B00     		lsls	r3, r3, #2
 2242 00be 194A     		ldr	r2, .L143+28
 2243 00c0 1A44     		add	r2, r2, r3
 2244 00c2 3B69     		ldr	r3, [r7, #16]
 2245 00c4 5A61     		str	r2, [r3, #20]
 2246 00c6 3B69     		ldr	r3, [r7, #16]
 2247 00c8 DA6A     		ldr	r2, [r3, #44]
 2248 00ca 1649     		ldr	r1, .L143+28
 2249 00cc 1346     		mov	r3, r2
 2250 00ce 9B00     		lsls	r3, r3, #2
 2251 00d0 1344     		add	r3, r3, r2
 2252 00d2 9B00     		lsls	r3, r3, #2
ARM GAS  /tmp/ccTFOe4z.s 			page 74


 2253 00d4 0B44     		add	r3, r3, r1
 2254 00d6 1B68     		ldr	r3, [r3]
 2255 00d8 591C     		adds	r1, r3, #1
 2256 00da 1248     		ldr	r0, .L143+28
 2257 00dc 1346     		mov	r3, r2
 2258 00de 9B00     		lsls	r3, r3, #2
 2259 00e0 1344     		add	r3, r3, r2
 2260 00e2 9B00     		lsls	r3, r3, #2
 2261 00e4 0344     		add	r3, r3, r0
 2262 00e6 1960     		str	r1, [r3]
 2263              	.LBE9:
 2264 00e8 05E0     		b	.L138
 2265              	.L139:
1946:Lib/FreeRTOS/Source/tasks.c ****                 }
1947:Lib/FreeRTOS/Source/tasks.c ****                 else
1948:Lib/FreeRTOS/Source/tasks.c ****                 {
1949:Lib/FreeRTOS/Source/tasks.c ****                     /* The delayed or ready lists cannot be accessed so the task
1950:Lib/FreeRTOS/Source/tasks.c ****                      * is held in the pending ready list until the scheduler is
1951:Lib/FreeRTOS/Source/tasks.c ****                      * unsuspended. */
1952:Lib/FreeRTOS/Source/tasks.c ****                     vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 2266              		.loc 1 1952 21 is_stmt 1
 2267 00ea 3B69     		ldr	r3, [r7, #16]
 2268 00ec 1833     		adds	r3, r3, #24
 2269 00ee 1946     		mov	r1, r3
 2270 00f0 0D48     		ldr	r0, .L143+32
 2271 00f2 FFF7FEFF 		bl	vListInsertEnd
 2272              	.L138:
1953:Lib/FreeRTOS/Source/tasks.c ****                 }
1954:Lib/FreeRTOS/Source/tasks.c ****             }
1955:Lib/FreeRTOS/Source/tasks.c ****             else
1956:Lib/FreeRTOS/Source/tasks.c ****             {
1957:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
1958:Lib/FreeRTOS/Source/tasks.c ****             }
1959:Lib/FreeRTOS/Source/tasks.c ****         }
1960:Lib/FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2273              		.loc 1 1960 9
 2274 00f6 F868     		ldr	r0, [r7, #12]
 2275 00f8 FFF7FEFF 		bl	vClearInterruptMask
1961:Lib/FreeRTOS/Source/tasks.c **** 
1962:Lib/FreeRTOS/Source/tasks.c ****         return xYieldRequired;
 2276              		.loc 1 1962 16
 2277 00fc 7B69     		ldr	r3, [r7, #20]
1963:Lib/FreeRTOS/Source/tasks.c ****     }
 2278              		.loc 1 1963 5
 2279 00fe 1846     		mov	r0, r3
 2280 0100 1837     		adds	r7, r7, #24
 2281              		.cfi_def_cfa_offset 8
 2282 0102 BD46     		mov	sp, r7
 2283              		.cfi_def_cfa_register 13
 2284              		@ sp needed
 2285 0104 80BD     		pop	{r7, pc}
 2286              	.L144:
 2287 0106 00BF     		.align	2
 2288              	.L143:
 2289 0108 00000000 		.word	.LC0
 2290 010c 00000000 		.word	__func__.24
 2291 0110 04000000 		.word	.LC1
ARM GAS  /tmp/ccTFOe4z.s 			page 75


 2292 0114 00000000 		.word	uxSchedulerSuspended
 2293 0118 00000000 		.word	pxCurrentTCB
 2294 011c 00000000 		.word	xYieldPending
 2295 0120 00000000 		.word	uxTopReadyPriority
 2296 0124 00000000 		.word	pxReadyTasksLists
 2297 0128 00000000 		.word	xPendingReadyList
 2298              		.cfi_endproc
 2299              	.LFE13:
 2301              		.section	.rodata
 2302              		.align	2
 2303              	.LC2:
 2304 0020 49444C45 		.ascii	"IDLE\000"
 2304      00
 2305              		.section	.text.vTaskStartScheduler,"ax",%progbits
 2306              		.align	1
 2307              		.global	vTaskStartScheduler
 2308              		.syntax unified
 2309              		.thumb
 2310              		.thumb_func
 2312              	vTaskStartScheduler:
 2313              	.LFB14:
1964:Lib/FreeRTOS/Source/tasks.c **** 
1965:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1966:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1967:Lib/FreeRTOS/Source/tasks.c **** 
1968:Lib/FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1969:Lib/FreeRTOS/Source/tasks.c **** {
 2314              		.loc 1 1969 1
 2315              		.cfi_startproc
 2316              		@ args = 0, pretend = 0, frame = 16
 2317              		@ frame_needed = 1, uses_anonymous_args = 0
 2318 0000 80B5     		push	{r7, lr}
 2319              		.cfi_def_cfa_offset 8
 2320              		.cfi_offset 7, -8
 2321              		.cfi_offset 14, -4
 2322 0002 88B0     		sub	sp, sp, #32
 2323              		.cfi_def_cfa_offset 40
 2324 0004 04AF     		add	r7, sp, #16
 2325              		.cfi_def_cfa 7, 24
 2326              	.LBB10:
1970:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
1971:Lib/FreeRTOS/Source/tasks.c **** 
1972:Lib/FreeRTOS/Source/tasks.c ****     /* Add the idle task at the lowest priority. */
1973:Lib/FreeRTOS/Source/tasks.c ****     #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
1974:Lib/FreeRTOS/Source/tasks.c ****     {
1975:Lib/FreeRTOS/Source/tasks.c ****         StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 2327              		.loc 1 1975 24
 2328 0006 0023     		movs	r3, #0
 2329 0008 BB60     		str	r3, [r7, #8]
1976:Lib/FreeRTOS/Source/tasks.c ****         StackType_t * pxIdleTaskStackBuffer = NULL;
 2330              		.loc 1 1976 23
 2331 000a 0023     		movs	r3, #0
 2332 000c 7B60     		str	r3, [r7, #4]
1977:Lib/FreeRTOS/Source/tasks.c ****         uint32_t ulIdleTaskStackSize;
1978:Lib/FreeRTOS/Source/tasks.c **** 
1979:Lib/FreeRTOS/Source/tasks.c ****         /* The Idle task is created using user provided RAM - obtain the
1980:Lib/FreeRTOS/Source/tasks.c ****          * address of the RAM then create the idle task. */
ARM GAS  /tmp/ccTFOe4z.s 			page 76


1981:Lib/FreeRTOS/Source/tasks.c ****         vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskSta
 2333              		.loc 1 1981 9
 2334 000e 3A46     		mov	r2, r7
 2335 0010 391D     		adds	r1, r7, #4
 2336 0012 07F10803 		add	r3, r7, #8
 2337 0016 1846     		mov	r0, r3
 2338 0018 FFF7FEFF 		bl	vApplicationGetIdleTaskMemory
1982:Lib/FreeRTOS/Source/tasks.c ****         xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 2339              		.loc 1 1982 27
 2340 001c 3968     		ldr	r1, [r7]
 2341 001e 7B68     		ldr	r3, [r7, #4]
 2342 0020 BA68     		ldr	r2, [r7, #8]
 2343 0022 0292     		str	r2, [sp, #8]
 2344 0024 0193     		str	r3, [sp, #4]
 2345 0026 0023     		movs	r3, #0
 2346 0028 0093     		str	r3, [sp]
 2347 002a 0023     		movs	r3, #0
 2348 002c 0A46     		mov	r2, r1
 2349 002e 1F49     		ldr	r1, .L151
 2350 0030 1F48     		ldr	r0, .L151+4
 2351 0032 FFF7FEFF 		bl	xTaskCreateStatic
 2352 0036 0346     		mov	r3, r0
 2353              		.loc 1 1982 25 discriminator 1
 2354 0038 1E4A     		ldr	r2, .L151+8
 2355 003a 1360     		str	r3, [r2]
1983:Lib/FreeRTOS/Source/tasks.c ****                                              configIDLE_TASK_NAME,
1984:Lib/FreeRTOS/Source/tasks.c ****                                              ulIdleTaskStackSize,
1985:Lib/FreeRTOS/Source/tasks.c ****                                              ( void * ) NULL,       /*lint !e961.  The cast is not 
1986:Lib/FreeRTOS/Source/tasks.c ****                                              portPRIVILEGE_BIT,     /* In effect ( tskIDLE_PRIORITY
1987:Lib/FreeRTOS/Source/tasks.c ****                                              pxIdleTaskStackBuffer,
1988:Lib/FreeRTOS/Source/tasks.c ****                                              pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, j
1989:Lib/FreeRTOS/Source/tasks.c **** 
1990:Lib/FreeRTOS/Source/tasks.c ****         if( xIdleTaskHandle != NULL )
 2356              		.loc 1 1990 29
 2357 003c 1D4B     		ldr	r3, .L151+8
 2358 003e 1B68     		ldr	r3, [r3]
 2359              		.loc 1 1990 11
 2360 0040 002B     		cmp	r3, #0
 2361 0042 02D0     		beq	.L146
1991:Lib/FreeRTOS/Source/tasks.c ****         {
1992:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdPASS;
 2362              		.loc 1 1992 21
 2363 0044 0123     		movs	r3, #1
 2364 0046 FB60     		str	r3, [r7, #12]
 2365 0048 01E0     		b	.L147
 2366              	.L146:
1993:Lib/FreeRTOS/Source/tasks.c ****         }
1994:Lib/FreeRTOS/Source/tasks.c ****         else
1995:Lib/FreeRTOS/Source/tasks.c ****         {
1996:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdFAIL;
 2367              		.loc 1 1996 21
 2368 004a 0023     		movs	r3, #0
 2369 004c FB60     		str	r3, [r7, #12]
 2370              	.L147:
 2371              	.LBE10:
1997:Lib/FreeRTOS/Source/tasks.c ****         }
1998:Lib/FreeRTOS/Source/tasks.c ****     }
ARM GAS  /tmp/ccTFOe4z.s 			page 77


1999:Lib/FreeRTOS/Source/tasks.c ****     #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
2000:Lib/FreeRTOS/Source/tasks.c ****     {
2001:Lib/FreeRTOS/Source/tasks.c ****         /* The Idle task is being created using dynamically allocated RAM. */
2002:Lib/FreeRTOS/Source/tasks.c ****         xReturn = xTaskCreate( prvIdleTask,
2003:Lib/FreeRTOS/Source/tasks.c ****                                configIDLE_TASK_NAME,
2004:Lib/FreeRTOS/Source/tasks.c ****                                configMINIMAL_STACK_SIZE,
2005:Lib/FreeRTOS/Source/tasks.c ****                                ( void * ) NULL,
2006:Lib/FreeRTOS/Source/tasks.c ****                                portPRIVILEGE_BIT,  /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_
2007:Lib/FreeRTOS/Source/tasks.c ****                                &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is
2008:Lib/FreeRTOS/Source/tasks.c ****     }
2009:Lib/FreeRTOS/Source/tasks.c ****     #endif /* configSUPPORT_STATIC_ALLOCATION */
2010:Lib/FreeRTOS/Source/tasks.c **** 
2011:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_TIMERS == 1 )
2012:Lib/FreeRTOS/Source/tasks.c ****     {
2013:Lib/FreeRTOS/Source/tasks.c ****         if( xReturn == pdPASS )
 2372              		.loc 1 2013 11
 2373 004e FB68     		ldr	r3, [r7, #12]
 2374 0050 012B     		cmp	r3, #1
 2375 0052 02D1     		bne	.L148
2014:Lib/FreeRTOS/Source/tasks.c ****         {
2015:Lib/FreeRTOS/Source/tasks.c ****             xReturn = xTimerCreateTimerTask();
 2376              		.loc 1 2015 23
 2377 0054 FFF7FEFF 		bl	xTimerCreateTimerTask
 2378 0058 F860     		str	r0, [r7, #12]
 2379              	.L148:
2016:Lib/FreeRTOS/Source/tasks.c ****         }
2017:Lib/FreeRTOS/Source/tasks.c ****         else
2018:Lib/FreeRTOS/Source/tasks.c ****         {
2019:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2020:Lib/FreeRTOS/Source/tasks.c ****         }
2021:Lib/FreeRTOS/Source/tasks.c ****     }
2022:Lib/FreeRTOS/Source/tasks.c ****     #endif /* configUSE_TIMERS */
2023:Lib/FreeRTOS/Source/tasks.c **** 
2024:Lib/FreeRTOS/Source/tasks.c ****     if( xReturn == pdPASS )
 2380              		.loc 1 2024 7
 2381 005a FB68     		ldr	r3, [r7, #12]
 2382 005c 012B     		cmp	r3, #1
 2383 005e 12D1     		bne	.L149
2025:Lib/FreeRTOS/Source/tasks.c ****     {
2026:Lib/FreeRTOS/Source/tasks.c ****         /* freertos_tasks_c_additions_init() should only be called if the user
2027:Lib/FreeRTOS/Source/tasks.c ****          * definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
2028:Lib/FreeRTOS/Source/tasks.c ****          * the only macro called by the function. */
2029:Lib/FreeRTOS/Source/tasks.c ****         #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
2030:Lib/FreeRTOS/Source/tasks.c ****         {
2031:Lib/FreeRTOS/Source/tasks.c ****             freertos_tasks_c_additions_init();
 2384              		.loc 1 2031 13
 2385 0060 FFF7FEFF 		bl	freertos_tasks_c_additions_init
2032:Lib/FreeRTOS/Source/tasks.c ****         }
2033:Lib/FreeRTOS/Source/tasks.c ****         #endif
2034:Lib/FreeRTOS/Source/tasks.c **** 
2035:Lib/FreeRTOS/Source/tasks.c ****         /* Interrupts are turned off here, to ensure a tick does not occur
2036:Lib/FreeRTOS/Source/tasks.c ****          * before or during the call to xPortStartScheduler().  The stacks of
2037:Lib/FreeRTOS/Source/tasks.c ****          * the created tasks contain a status word with interrupts switched on
2038:Lib/FreeRTOS/Source/tasks.c ****          * so interrupts will automatically get re-enabled when the first task
2039:Lib/FreeRTOS/Source/tasks.c ****          * starts to run. */
2040:Lib/FreeRTOS/Source/tasks.c ****         portDISABLE_INTERRUPTS();
 2386              		.loc 1 2040 9
ARM GAS  /tmp/ccTFOe4z.s 			page 78


 2387 0064 FFF7FEFF 		bl	ulSetInterruptMask
2041:Lib/FreeRTOS/Source/tasks.c **** 
2042:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
2043:Lib/FreeRTOS/Source/tasks.c ****         {
2044:Lib/FreeRTOS/Source/tasks.c ****             /* Switch C-Runtime's TLS Block to point to the TLS
2045:Lib/FreeRTOS/Source/tasks.c ****              * block specific to the task that will run first. */
2046:Lib/FreeRTOS/Source/tasks.c ****             configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
2047:Lib/FreeRTOS/Source/tasks.c ****         }
2048:Lib/FreeRTOS/Source/tasks.c ****         #endif
2049:Lib/FreeRTOS/Source/tasks.c **** 
2050:Lib/FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
 2388              		.loc 1 2050 30
 2389 0068 134B     		ldr	r3, .L151+12
 2390 006a 4FF0FF32 		mov	r2, #-1
 2391 006e 1A60     		str	r2, [r3]
2051:Lib/FreeRTOS/Source/tasks.c ****         xSchedulerRunning = pdTRUE;
 2392              		.loc 1 2051 27
 2393 0070 124B     		ldr	r3, .L151+16
 2394 0072 0122     		movs	r2, #1
 2395 0074 1A60     		str	r2, [r3]
2052:Lib/FreeRTOS/Source/tasks.c ****         xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 2396              		.loc 1 2052 20
 2397 0076 124B     		ldr	r3, .L151+20
 2398 0078 0022     		movs	r2, #0
 2399 007a 1A60     		str	r2, [r3]
2053:Lib/FreeRTOS/Source/tasks.c **** 
2054:Lib/FreeRTOS/Source/tasks.c ****         /* If configGENERATE_RUN_TIME_STATS is defined then the following
2055:Lib/FreeRTOS/Source/tasks.c ****          * macro must be defined to configure the timer/counter used to generate
2056:Lib/FreeRTOS/Source/tasks.c ****          * the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
2057:Lib/FreeRTOS/Source/tasks.c ****          * is set to 0 and the following line fails to build then ensure you do not
2058:Lib/FreeRTOS/Source/tasks.c ****          * have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
2059:Lib/FreeRTOS/Source/tasks.c ****          * FreeRTOSConfig.h file. */
2060:Lib/FreeRTOS/Source/tasks.c ****         portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 2400              		.loc 1 2060 9
 2401 007c FFF7FEFF 		bl	TIM4_Config
2061:Lib/FreeRTOS/Source/tasks.c **** 
2062:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
2063:Lib/FreeRTOS/Source/tasks.c **** 
2064:Lib/FreeRTOS/Source/tasks.c ****         /* Setting up the timer tick is hardware specific and thus in the
2065:Lib/FreeRTOS/Source/tasks.c ****          * portable interface. */
2066:Lib/FreeRTOS/Source/tasks.c ****         xPortStartScheduler();
 2402              		.loc 1 2066 9
 2403 0080 FFF7FEFF 		bl	xPortStartScheduler
 2404 0084 0CE0     		b	.L150
 2405              	.L149:
2067:Lib/FreeRTOS/Source/tasks.c **** 
2068:Lib/FreeRTOS/Source/tasks.c ****         /* In most cases, xPortStartScheduler() will not return. If it
2069:Lib/FreeRTOS/Source/tasks.c ****          * returns pdTRUE then there was not enough heap memory available
2070:Lib/FreeRTOS/Source/tasks.c ****          * to create either the Idle or the Timer task. If it returned
2071:Lib/FreeRTOS/Source/tasks.c ****          * pdFALSE, then the application called xTaskEndScheduler().
2072:Lib/FreeRTOS/Source/tasks.c ****          * Most ports don't implement xTaskEndScheduler() as there is
2073:Lib/FreeRTOS/Source/tasks.c ****          * nothing to return to. */
2074:Lib/FreeRTOS/Source/tasks.c ****     }
2075:Lib/FreeRTOS/Source/tasks.c ****     else
2076:Lib/FreeRTOS/Source/tasks.c ****     {
2077:Lib/FreeRTOS/Source/tasks.c ****         /* This line will only be reached if the kernel could not be started,
2078:Lib/FreeRTOS/Source/tasks.c ****          * because there was not enough FreeRTOS heap to create the idle task
ARM GAS  /tmp/ccTFOe4z.s 			page 79


2079:Lib/FreeRTOS/Source/tasks.c ****          * or the timer task. */
2080:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 2406              		.loc 1 2080 9
 2407 0086 FB68     		ldr	r3, [r7, #12]
 2408 0088 B3F1FF3F 		cmp	r3, #-1
 2409 008c 08D1     		bne	.L150
 2410              		.loc 1 2080 9 is_stmt 0 discriminator 1
 2411 008e FFF7FEFF 		bl	ulSetInterruptMask
 2412 0092 0C4B     		ldr	r3, .L151+24
 2413 0094 0C4A     		ldr	r2, .L151+28
 2414 0096 4FF40261 		mov	r1, #2080
 2415 009a 0C48     		ldr	r0, .L151+32
 2416 009c FFF7FEFF 		bl	__assert_func
 2417              	.L150:
2081:Lib/FreeRTOS/Source/tasks.c ****     }
2082:Lib/FreeRTOS/Source/tasks.c **** 
2083:Lib/FreeRTOS/Source/tasks.c ****     /* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
2084:Lib/FreeRTOS/Source/tasks.c ****      * meaning xIdleTaskHandle is not used anywhere else. */
2085:Lib/FreeRTOS/Source/tasks.c ****     ( void ) xIdleTaskHandle;
2086:Lib/FreeRTOS/Source/tasks.c **** 
2087:Lib/FreeRTOS/Source/tasks.c ****     /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
2088:Lib/FreeRTOS/Source/tasks.c ****      * from getting optimized out as it is no longer used by the kernel. */
2089:Lib/FreeRTOS/Source/tasks.c ****     ( void ) uxTopUsedPriority;
 2418              		.loc 1 2089 5 is_stmt 1
 2419 00a0 0B4B     		ldr	r3, .L151+36
 2420 00a2 1B68     		ldr	r3, [r3]
2090:Lib/FreeRTOS/Source/tasks.c **** }
 2421              		.loc 1 2090 1
 2422 00a4 00BF     		nop
 2423 00a6 1037     		adds	r7, r7, #16
 2424              		.cfi_def_cfa_offset 8
 2425 00a8 BD46     		mov	sp, r7
 2426              		.cfi_def_cfa_register 13
 2427              		@ sp needed
 2428 00aa 80BD     		pop	{r7, pc}
 2429              	.L152:
 2430              		.align	2
 2431              	.L151:
 2432 00ac 20000000 		.word	.LC2
 2433 00b0 00000000 		.word	prvIdleTask
 2434 00b4 00000000 		.word	xIdleTaskHandle
 2435 00b8 00000000 		.word	xNextTaskUnblockTime
 2436 00bc 00000000 		.word	xSchedulerRunning
 2437 00c0 00000000 		.word	xTickCount
 2438 00c4 00000000 		.word	.LC0
 2439 00c8 00000000 		.word	__func__.23
 2440 00cc 04000000 		.word	.LC1
 2441 00d0 00000000 		.word	uxTopUsedPriority
 2442              		.cfi_endproc
 2443              	.LFE14:
 2445              		.section	.text.vTaskEndScheduler,"ax",%progbits
 2446              		.align	1
 2447              		.global	vTaskEndScheduler
 2448              		.syntax unified
 2449              		.thumb
 2450              		.thumb_func
 2452              	vTaskEndScheduler:
ARM GAS  /tmp/ccTFOe4z.s 			page 80


 2453              	.LFB15:
2091:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2092:Lib/FreeRTOS/Source/tasks.c **** 
2093:Lib/FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
2094:Lib/FreeRTOS/Source/tasks.c **** {
 2454              		.loc 1 2094 1
 2455              		.cfi_startproc
 2456              		@ args = 0, pretend = 0, frame = 0
 2457              		@ frame_needed = 1, uses_anonymous_args = 0
 2458 0000 80B5     		push	{r7, lr}
 2459              		.cfi_def_cfa_offset 8
 2460              		.cfi_offset 7, -8
 2461              		.cfi_offset 14, -4
 2462 0002 00AF     		add	r7, sp, #0
 2463              		.cfi_def_cfa_register 7
2095:Lib/FreeRTOS/Source/tasks.c ****     /* Stop the scheduler interrupts and call the portable scheduler end
2096:Lib/FreeRTOS/Source/tasks.c ****      * routine so the original ISRs can be restored if necessary.  The port
2097:Lib/FreeRTOS/Source/tasks.c ****      * layer must ensure interrupts enable  bit is left in the correct state. */
2098:Lib/FreeRTOS/Source/tasks.c ****     portDISABLE_INTERRUPTS();
 2464              		.loc 1 2098 5
 2465 0004 FFF7FEFF 		bl	ulSetInterruptMask
2099:Lib/FreeRTOS/Source/tasks.c ****     xSchedulerRunning = pdFALSE;
 2466              		.loc 1 2099 23
 2467 0008 034B     		ldr	r3, .L154
 2468 000a 0022     		movs	r2, #0
 2469 000c 1A60     		str	r2, [r3]
2100:Lib/FreeRTOS/Source/tasks.c ****     vPortEndScheduler();
 2470              		.loc 1 2100 5
 2471 000e FFF7FEFF 		bl	vPortEndScheduler
2101:Lib/FreeRTOS/Source/tasks.c **** }
 2472              		.loc 1 2101 1
 2473 0012 00BF     		nop
 2474 0014 80BD     		pop	{r7, pc}
 2475              	.L155:
 2476 0016 00BF     		.align	2
 2477              	.L154:
 2478 0018 00000000 		.word	xSchedulerRunning
 2479              		.cfi_endproc
 2480              	.LFE15:
 2482              		.section	.text.vTaskSuspendAll,"ax",%progbits
 2483              		.align	1
 2484              		.global	vTaskSuspendAll
 2485              		.syntax unified
 2486              		.thumb
 2487              		.thumb_func
 2489              	vTaskSuspendAll:
 2490              	.LFB16:
2102:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2103:Lib/FreeRTOS/Source/tasks.c **** 
2104:Lib/FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
2105:Lib/FreeRTOS/Source/tasks.c **** {
 2491              		.loc 1 2105 1
 2492              		.cfi_startproc
 2493              		@ args = 0, pretend = 0, frame = 0
 2494              		@ frame_needed = 1, uses_anonymous_args = 0
 2495              		@ link register save eliminated.
 2496 0000 80B4     		push	{r7}
ARM GAS  /tmp/ccTFOe4z.s 			page 81


 2497              		.cfi_def_cfa_offset 4
 2498              		.cfi_offset 7, -4
 2499 0002 00AF     		add	r7, sp, #0
 2500              		.cfi_def_cfa_register 7
2106:Lib/FreeRTOS/Source/tasks.c ****     /* A critical section is not required as the variable is of type
2107:Lib/FreeRTOS/Source/tasks.c ****      * BaseType_t.  Please read Richard Barry's reply in the following link to a
2108:Lib/FreeRTOS/Source/tasks.c ****      * post in the FreeRTOS support forum before reporting this as a bug! -
2109:Lib/FreeRTOS/Source/tasks.c ****      * https://goo.gl/wu4acr */
2110:Lib/FreeRTOS/Source/tasks.c **** 
2111:Lib/FreeRTOS/Source/tasks.c ****     /* portSOFTWARE_BARRIER() is only implemented for emulated/simulated ports that
2112:Lib/FreeRTOS/Source/tasks.c ****      * do not otherwise exhibit real time behaviour. */
2113:Lib/FreeRTOS/Source/tasks.c ****     portSOFTWARE_BARRIER();
2114:Lib/FreeRTOS/Source/tasks.c **** 
2115:Lib/FreeRTOS/Source/tasks.c ****     /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
2116:Lib/FreeRTOS/Source/tasks.c ****      * is used to allow calls to vTaskSuspendAll() to nest. */
2117:Lib/FreeRTOS/Source/tasks.c ****     ++uxSchedulerSuspended;
 2501              		.loc 1 2117 5
 2502 0004 044B     		ldr	r3, .L157
 2503 0006 1B68     		ldr	r3, [r3]
 2504 0008 0133     		adds	r3, r3, #1
 2505 000a 034A     		ldr	r2, .L157
 2506 000c 1360     		str	r3, [r2]
2118:Lib/FreeRTOS/Source/tasks.c **** 
2119:Lib/FreeRTOS/Source/tasks.c ****     /* Enforces ordering for ports and optimised compilers that may otherwise place
2120:Lib/FreeRTOS/Source/tasks.c ****      * the above increment elsewhere. */
2121:Lib/FreeRTOS/Source/tasks.c ****     portMEMORY_BARRIER();
 2507              		.loc 1 2121 5
2122:Lib/FreeRTOS/Source/tasks.c **** }
 2508              		.loc 1 2122 1
 2509 000e 00BF     		nop
 2510 0010 BD46     		mov	sp, r7
 2511              		.cfi_def_cfa_register 13
 2512              		@ sp needed
 2513 0012 5DF8047B 		ldr	r7, [sp], #4
 2514              		.cfi_restore 7
 2515              		.cfi_def_cfa_offset 0
 2516 0016 7047     		bx	lr
 2517              	.L158:
 2518              		.align	2
 2519              	.L157:
 2520 0018 00000000 		.word	uxSchedulerSuspended
 2521              		.cfi_endproc
 2522              	.LFE16:
 2524              		.section	.text.xTaskResumeAll,"ax",%progbits
 2525              		.align	1
 2526              		.global	xTaskResumeAll
 2527              		.syntax unified
 2528              		.thumb
 2529              		.thumb_func
 2531              	xTaskResumeAll:
 2532              	.LFB17:
2123:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2124:Lib/FreeRTOS/Source/tasks.c **** 
2125:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2126:Lib/FreeRTOS/Source/tasks.c **** 
2127:Lib/FreeRTOS/Source/tasks.c ****     static TickType_t prvGetExpectedIdleTime( void )
2128:Lib/FreeRTOS/Source/tasks.c ****     {
ARM GAS  /tmp/ccTFOe4z.s 			page 82


2129:Lib/FreeRTOS/Source/tasks.c ****         TickType_t xReturn;
2130:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
2131:Lib/FreeRTOS/Source/tasks.c **** 
2132:Lib/FreeRTOS/Source/tasks.c ****         /* uxHigherPriorityReadyTasks takes care of the case where
2133:Lib/FreeRTOS/Source/tasks.c ****          * configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
2134:Lib/FreeRTOS/Source/tasks.c ****          * task that are in the Ready state, even though the idle task is
2135:Lib/FreeRTOS/Source/tasks.c ****          * running. */
2136:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
2137:Lib/FreeRTOS/Source/tasks.c ****         {
2138:Lib/FreeRTOS/Source/tasks.c ****             if( uxTopReadyPriority > tskIDLE_PRIORITY )
2139:Lib/FreeRTOS/Source/tasks.c ****             {
2140:Lib/FreeRTOS/Source/tasks.c ****                 uxHigherPriorityReadyTasks = pdTRUE;
2141:Lib/FreeRTOS/Source/tasks.c ****             }
2142:Lib/FreeRTOS/Source/tasks.c ****         }
2143:Lib/FreeRTOS/Source/tasks.c ****         #else
2144:Lib/FreeRTOS/Source/tasks.c ****         {
2145:Lib/FreeRTOS/Source/tasks.c ****             const UBaseType_t uxLeastSignificantBit = ( UBaseType_t ) 0x01;
2146:Lib/FreeRTOS/Source/tasks.c **** 
2147:Lib/FreeRTOS/Source/tasks.c ****             /* When port optimised task selection is used the uxTopReadyPriority
2148:Lib/FreeRTOS/Source/tasks.c ****              * variable is used as a bit map.  If bits other than the least
2149:Lib/FreeRTOS/Source/tasks.c ****              * significant bit are set then there are tasks that have a priority
2150:Lib/FreeRTOS/Source/tasks.c ****              * above the idle priority that are in the Ready state.  This takes
2151:Lib/FreeRTOS/Source/tasks.c ****              * care of the case where the co-operative scheduler is in use. */
2152:Lib/FreeRTOS/Source/tasks.c ****             if( uxTopReadyPriority > uxLeastSignificantBit )
2153:Lib/FreeRTOS/Source/tasks.c ****             {
2154:Lib/FreeRTOS/Source/tasks.c ****                 uxHigherPriorityReadyTasks = pdTRUE;
2155:Lib/FreeRTOS/Source/tasks.c ****             }
2156:Lib/FreeRTOS/Source/tasks.c ****         }
2157:Lib/FreeRTOS/Source/tasks.c ****         #endif /* if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 ) */
2158:Lib/FreeRTOS/Source/tasks.c **** 
2159:Lib/FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
2160:Lib/FreeRTOS/Source/tasks.c ****         {
2161:Lib/FreeRTOS/Source/tasks.c ****             xReturn = 0;
2162:Lib/FreeRTOS/Source/tasks.c ****         }
2163:Lib/FreeRTOS/Source/tasks.c ****         else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
2164:Lib/FreeRTOS/Source/tasks.c ****         {
2165:Lib/FreeRTOS/Source/tasks.c ****             /* There are other idle priority tasks in the ready state.  If
2166:Lib/FreeRTOS/Source/tasks.c ****              * time slicing is used then the very next tick interrupt must be
2167:Lib/FreeRTOS/Source/tasks.c ****              * processed. */
2168:Lib/FreeRTOS/Source/tasks.c ****             xReturn = 0;
2169:Lib/FreeRTOS/Source/tasks.c ****         }
2170:Lib/FreeRTOS/Source/tasks.c ****         else if( uxHigherPriorityReadyTasks != pdFALSE )
2171:Lib/FreeRTOS/Source/tasks.c ****         {
2172:Lib/FreeRTOS/Source/tasks.c ****             /* There are tasks in the Ready state that have a priority above the
2173:Lib/FreeRTOS/Source/tasks.c ****              * idle priority.  This path can only be reached if
2174:Lib/FreeRTOS/Source/tasks.c ****              * configUSE_PREEMPTION is 0. */
2175:Lib/FreeRTOS/Source/tasks.c ****             xReturn = 0;
2176:Lib/FreeRTOS/Source/tasks.c ****         }
2177:Lib/FreeRTOS/Source/tasks.c ****         else
2178:Lib/FreeRTOS/Source/tasks.c ****         {
2179:Lib/FreeRTOS/Source/tasks.c ****             xReturn = xNextTaskUnblockTime - xTickCount;
2180:Lib/FreeRTOS/Source/tasks.c ****         }
2181:Lib/FreeRTOS/Source/tasks.c **** 
2182:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
2183:Lib/FreeRTOS/Source/tasks.c ****     }
2184:Lib/FreeRTOS/Source/tasks.c **** 
2185:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
ARM GAS  /tmp/ccTFOe4z.s 			page 83


2186:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2187:Lib/FreeRTOS/Source/tasks.c **** 
2188:Lib/FreeRTOS/Source/tasks.c **** BaseType_t xTaskResumeAll( void )
2189:Lib/FreeRTOS/Source/tasks.c **** {
 2533              		.loc 1 2189 1
 2534              		.cfi_startproc
 2535              		@ args = 0, pretend = 0, frame = 24
 2536              		@ frame_needed = 1, uses_anonymous_args = 0
 2537 0000 80B5     		push	{r7, lr}
 2538              		.cfi_def_cfa_offset 8
 2539              		.cfi_offset 7, -8
 2540              		.cfi_offset 14, -4
 2541 0002 86B0     		sub	sp, sp, #24
 2542              		.cfi_def_cfa_offset 32
 2543 0004 00AF     		add	r7, sp, #0
 2544              		.cfi_def_cfa_register 7
2190:Lib/FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB = NULL;
 2545              		.loc 1 2190 13
 2546 0006 0023     		movs	r3, #0
 2547 0008 7B61     		str	r3, [r7, #20]
2191:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xAlreadyYielded = pdFALSE;
 2548              		.loc 1 2191 16
 2549 000a 0023     		movs	r3, #0
 2550 000c 3B61     		str	r3, [r7, #16]
2192:Lib/FreeRTOS/Source/tasks.c **** 
2193:Lib/FreeRTOS/Source/tasks.c ****     /* If uxSchedulerSuspended is zero then this function does not match a
2194:Lib/FreeRTOS/Source/tasks.c ****      * previous call to vTaskSuspendAll(). */
2195:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 2551              		.loc 1 2195 5
 2552 000e 6D4B     		ldr	r3, .L173
 2553 0010 1B68     		ldr	r3, [r3]
 2554 0012 002B     		cmp	r3, #0
 2555 0014 08D1     		bne	.L160
 2556              		.loc 1 2195 5 is_stmt 0 discriminator 1
 2557 0016 FFF7FEFF 		bl	ulSetInterruptMask
 2558 001a 6B4B     		ldr	r3, .L173+4
 2559 001c 6B4A     		ldr	r2, .L173+8
 2560 001e 40F69301 		movw	r1, #2195
 2561 0022 6B48     		ldr	r0, .L173+12
 2562 0024 FFF7FEFF 		bl	__assert_func
 2563              	.L160:
2196:Lib/FreeRTOS/Source/tasks.c **** 
2197:Lib/FreeRTOS/Source/tasks.c ****     /* It is possible that an ISR caused a task to be removed from an event
2198:Lib/FreeRTOS/Source/tasks.c ****      * list while the scheduler was suspended.  If this was the case then the
2199:Lib/FreeRTOS/Source/tasks.c ****      * removed task will have been added to the xPendingReadyList.  Once the
2200:Lib/FreeRTOS/Source/tasks.c ****      * scheduler has been resumed it is safe to move all the pending ready
2201:Lib/FreeRTOS/Source/tasks.c ****      * tasks from this list into their appropriate ready list. */
2202:Lib/FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 2564              		.loc 1 2202 5 is_stmt 1
 2565 0028 FFF7FEFF 		bl	vPortEnterCritical
2203:Lib/FreeRTOS/Source/tasks.c ****     {
2204:Lib/FreeRTOS/Source/tasks.c ****         --uxSchedulerSuspended;
 2566              		.loc 1 2204 9
 2567 002c 654B     		ldr	r3, .L173
 2568 002e 1B68     		ldr	r3, [r3]
 2569 0030 013B     		subs	r3, r3, #1
 2570 0032 644A     		ldr	r2, .L173
ARM GAS  /tmp/ccTFOe4z.s 			page 84


 2571 0034 1360     		str	r3, [r2]
2205:Lib/FreeRTOS/Source/tasks.c **** 
2206:Lib/FreeRTOS/Source/tasks.c ****         if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 2572              		.loc 1 2206 34
 2573 0036 634B     		ldr	r3, .L173
 2574 0038 1B68     		ldr	r3, [r3]
 2575              		.loc 1 2206 11
 2576 003a 002B     		cmp	r3, #0
 2577 003c 40F0BB80 		bne	.L161
2207:Lib/FreeRTOS/Source/tasks.c ****         {
2208:Lib/FreeRTOS/Source/tasks.c ****             if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 2578              		.loc 1 2208 40
 2579 0040 644B     		ldr	r3, .L173+16
 2580 0042 1B68     		ldr	r3, [r3]
 2581              		.loc 1 2208 15
 2582 0044 002B     		cmp	r3, #0
 2583 0046 00F0B680 		beq	.L161
2209:Lib/FreeRTOS/Source/tasks.c ****             {
2210:Lib/FreeRTOS/Source/tasks.c ****                 /* Move any readied tasks from the pending list into the
2211:Lib/FreeRTOS/Source/tasks.c ****                  * appropriate ready list. */
2212:Lib/FreeRTOS/Source/tasks.c ****                 while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 2584              		.loc 1 2212 22
 2585 004a 8BE0     		b	.L162
 2586              	.L167:
2213:Lib/FreeRTOS/Source/tasks.c ****                 {
2214:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 vo
 2587              		.loc 1 2214 29
 2588 004c 624B     		ldr	r3, .L173+20
 2589 004e DB68     		ldr	r3, [r3, #12]
 2590              		.loc 1 2214 27
 2591 0050 DB68     		ldr	r3, [r3, #12]
 2592 0052 7B61     		str	r3, [r7, #20]
 2593              	.LBB11:
2215:Lib/FreeRTOS/Source/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 2594              		.loc 1 2215 21
 2595 0054 7B69     		ldr	r3, [r7, #20]
 2596 0056 9B6A     		ldr	r3, [r3, #40]
 2597 0058 BB60     		str	r3, [r7, #8]
 2598 005a 7B69     		ldr	r3, [r7, #20]
 2599 005c DB69     		ldr	r3, [r3, #28]
 2600 005e 7A69     		ldr	r2, [r7, #20]
 2601 0060 126A     		ldr	r2, [r2, #32]
 2602 0062 9A60     		str	r2, [r3, #8]
 2603 0064 7B69     		ldr	r3, [r7, #20]
 2604 0066 1B6A     		ldr	r3, [r3, #32]
 2605 0068 7A69     		ldr	r2, [r7, #20]
 2606 006a D269     		ldr	r2, [r2, #28]
 2607 006c 5A60     		str	r2, [r3, #4]
 2608 006e BB68     		ldr	r3, [r7, #8]
 2609 0070 5A68     		ldr	r2, [r3, #4]
 2610 0072 7B69     		ldr	r3, [r7, #20]
 2611 0074 1833     		adds	r3, r3, #24
 2612 0076 9A42     		cmp	r2, r3
 2613 0078 03D1     		bne	.L163
 2614              		.loc 1 2215 21 is_stmt 0 discriminator 1
 2615 007a 7B69     		ldr	r3, [r7, #20]
 2616 007c 1A6A     		ldr	r2, [r3, #32]
ARM GAS  /tmp/ccTFOe4z.s 			page 85


 2617 007e BB68     		ldr	r3, [r7, #8]
 2618 0080 5A60     		str	r2, [r3, #4]
 2619              	.L163:
 2620              		.loc 1 2215 21 discriminator 3
 2621 0082 7B69     		ldr	r3, [r7, #20]
 2622 0084 0022     		movs	r2, #0
 2623 0086 9A62     		str	r2, [r3, #40]
 2624 0088 BB68     		ldr	r3, [r7, #8]
 2625 008a 1B68     		ldr	r3, [r3]
 2626 008c 5A1E     		subs	r2, r3, #1
 2627 008e BB68     		ldr	r3, [r7, #8]
 2628 0090 1A60     		str	r2, [r3]
 2629              	.LBE11:
2216:Lib/FreeRTOS/Source/tasks.c ****                     portMEMORY_BARRIER();
 2630              		.loc 1 2216 21 is_stmt 1
 2631              	.LBB12:
2217:Lib/FreeRTOS/Source/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 2632              		.loc 1 2217 21
 2633 0092 7B69     		ldr	r3, [r7, #20]
 2634 0094 5B69     		ldr	r3, [r3, #20]
 2635 0096 7B60     		str	r3, [r7, #4]
 2636 0098 7B69     		ldr	r3, [r7, #20]
 2637 009a 9B68     		ldr	r3, [r3, #8]
 2638 009c 7A69     		ldr	r2, [r7, #20]
 2639 009e D268     		ldr	r2, [r2, #12]
 2640 00a0 9A60     		str	r2, [r3, #8]
 2641 00a2 7B69     		ldr	r3, [r7, #20]
 2642 00a4 DB68     		ldr	r3, [r3, #12]
 2643 00a6 7A69     		ldr	r2, [r7, #20]
 2644 00a8 9268     		ldr	r2, [r2, #8]
 2645 00aa 5A60     		str	r2, [r3, #4]
 2646 00ac 7B68     		ldr	r3, [r7, #4]
 2647 00ae 5A68     		ldr	r2, [r3, #4]
 2648 00b0 7B69     		ldr	r3, [r7, #20]
 2649 00b2 0433     		adds	r3, r3, #4
 2650 00b4 9A42     		cmp	r2, r3
 2651 00b6 03D1     		bne	.L164
 2652              		.loc 1 2217 21 is_stmt 0 discriminator 1
 2653 00b8 7B69     		ldr	r3, [r7, #20]
 2654 00ba DA68     		ldr	r2, [r3, #12]
 2655 00bc 7B68     		ldr	r3, [r7, #4]
 2656 00be 5A60     		str	r2, [r3, #4]
 2657              	.L164:
 2658              		.loc 1 2217 21 discriminator 3
 2659 00c0 7B69     		ldr	r3, [r7, #20]
 2660 00c2 0022     		movs	r2, #0
 2661 00c4 5A61     		str	r2, [r3, #20]
 2662 00c6 7B68     		ldr	r3, [r7, #4]
 2663 00c8 1B68     		ldr	r3, [r3]
 2664 00ca 5A1E     		subs	r2, r3, #1
 2665 00cc 7B68     		ldr	r3, [r7, #4]
 2666 00ce 1A60     		str	r2, [r3]
 2667              	.LBE12:
2218:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 2668              		.loc 1 2218 21 is_stmt 1
 2669 00d0 7B69     		ldr	r3, [r7, #20]
 2670 00d2 DA6A     		ldr	r2, [r3, #44]
ARM GAS  /tmp/ccTFOe4z.s 			page 86


 2671 00d4 414B     		ldr	r3, .L173+24
 2672 00d6 1B68     		ldr	r3, [r3]
 2673 00d8 9A42     		cmp	r2, r3
 2674 00da 03D9     		bls	.L165
 2675              		.loc 1 2218 21 is_stmt 0 discriminator 1
 2676 00dc 7B69     		ldr	r3, [r7, #20]
 2677 00de DB6A     		ldr	r3, [r3, #44]
 2678 00e0 3E4A     		ldr	r2, .L173+24
 2679 00e2 1360     		str	r3, [r2]
 2680              	.L165:
 2681              	.LBB13:
 2682              		.loc 1 2218 21 discriminator 3
 2683 00e4 7B69     		ldr	r3, [r7, #20]
 2684 00e6 DA6A     		ldr	r2, [r3, #44]
 2685 00e8 3D49     		ldr	r1, .L173+28
 2686 00ea 1346     		mov	r3, r2
 2687 00ec 9B00     		lsls	r3, r3, #2
 2688 00ee 1344     		add	r3, r3, r2
 2689 00f0 9B00     		lsls	r3, r3, #2
 2690 00f2 0B44     		add	r3, r3, r1
 2691 00f4 0433     		adds	r3, r3, #4
 2692 00f6 1B68     		ldr	r3, [r3]
 2693 00f8 3B60     		str	r3, [r7]
 2694 00fa 7B69     		ldr	r3, [r7, #20]
 2695 00fc 3A68     		ldr	r2, [r7]
 2696 00fe 9A60     		str	r2, [r3, #8]
 2697 0100 3B68     		ldr	r3, [r7]
 2698 0102 9A68     		ldr	r2, [r3, #8]
 2699 0104 7B69     		ldr	r3, [r7, #20]
 2700 0106 DA60     		str	r2, [r3, #12]
 2701 0108 3B68     		ldr	r3, [r7]
 2702 010a 9B68     		ldr	r3, [r3, #8]
 2703 010c 7A69     		ldr	r2, [r7, #20]
 2704 010e 0432     		adds	r2, r2, #4
 2705 0110 5A60     		str	r2, [r3, #4]
 2706 0112 7B69     		ldr	r3, [r7, #20]
 2707 0114 1A1D     		adds	r2, r3, #4
 2708 0116 3B68     		ldr	r3, [r7]
 2709 0118 9A60     		str	r2, [r3, #8]
 2710 011a 7B69     		ldr	r3, [r7, #20]
 2711 011c DA6A     		ldr	r2, [r3, #44]
 2712 011e 1346     		mov	r3, r2
 2713 0120 9B00     		lsls	r3, r3, #2
 2714 0122 1344     		add	r3, r3, r2
 2715 0124 9B00     		lsls	r3, r3, #2
 2716 0126 2E4A     		ldr	r2, .L173+28
 2717 0128 1A44     		add	r2, r2, r3
 2718 012a 7B69     		ldr	r3, [r7, #20]
 2719 012c 5A61     		str	r2, [r3, #20]
 2720 012e 7B69     		ldr	r3, [r7, #20]
 2721 0130 DA6A     		ldr	r2, [r3, #44]
 2722 0132 2B49     		ldr	r1, .L173+28
 2723 0134 1346     		mov	r3, r2
 2724 0136 9B00     		lsls	r3, r3, #2
 2725 0138 1344     		add	r3, r3, r2
 2726 013a 9B00     		lsls	r3, r3, #2
 2727 013c 0B44     		add	r3, r3, r1
ARM GAS  /tmp/ccTFOe4z.s 			page 87


 2728 013e 1B68     		ldr	r3, [r3]
 2729 0140 591C     		adds	r1, r3, #1
 2730 0142 2748     		ldr	r0, .L173+28
 2731 0144 1346     		mov	r3, r2
 2732 0146 9B00     		lsls	r3, r3, #2
 2733 0148 1344     		add	r3, r3, r2
 2734 014a 9B00     		lsls	r3, r3, #2
 2735 014c 0344     		add	r3, r3, r0
 2736 014e 1960     		str	r1, [r3]
 2737              	.LBE13:
2219:Lib/FreeRTOS/Source/tasks.c **** 
2220:Lib/FreeRTOS/Source/tasks.c ****                     /* If the moved task has a priority higher than the current
2221:Lib/FreeRTOS/Source/tasks.c ****                      * task then a yield must be performed. */
2222:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 2738              		.loc 1 2222 30 is_stmt 1
 2739 0150 7B69     		ldr	r3, [r7, #20]
 2740 0152 DA6A     		ldr	r2, [r3, #44]
 2741              		.loc 1 2222 57
 2742 0154 234B     		ldr	r3, .L173+32
 2743 0156 1B68     		ldr	r3, [r3]
 2744 0158 DB6A     		ldr	r3, [r3, #44]
 2745              		.loc 1 2222 23
 2746 015a 9A42     		cmp	r2, r3
 2747 015c 02D9     		bls	.L162
2223:Lib/FreeRTOS/Source/tasks.c ****                     {
2224:Lib/FreeRTOS/Source/tasks.c ****                         xYieldPending = pdTRUE;
 2748              		.loc 1 2224 39
 2749 015e 224B     		ldr	r3, .L173+36
 2750 0160 0122     		movs	r2, #1
 2751 0162 1A60     		str	r2, [r3]
 2752              	.L162:
2212:Lib/FreeRTOS/Source/tasks.c ****                 {
 2753              		.loc 1 2212 24
 2754 0164 1C4B     		ldr	r3, .L173+20
 2755 0166 1B68     		ldr	r3, [r3]
2212:Lib/FreeRTOS/Source/tasks.c ****                 {
 2756              		.loc 1 2212 64
 2757 0168 002B     		cmp	r3, #0
 2758 016a 7FF46FAF 		bne	.L167
2225:Lib/FreeRTOS/Source/tasks.c ****                     }
2226:Lib/FreeRTOS/Source/tasks.c ****                     else
2227:Lib/FreeRTOS/Source/tasks.c ****                     {
2228:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2229:Lib/FreeRTOS/Source/tasks.c ****                     }
2230:Lib/FreeRTOS/Source/tasks.c ****                 }
2231:Lib/FreeRTOS/Source/tasks.c **** 
2232:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB != NULL )
 2759              		.loc 1 2232 19
 2760 016e 7B69     		ldr	r3, [r7, #20]
 2761 0170 002B     		cmp	r3, #0
 2762 0172 01D0     		beq	.L168
2233:Lib/FreeRTOS/Source/tasks.c ****                 {
2234:Lib/FreeRTOS/Source/tasks.c ****                     /* A task was unblocked while the scheduler was suspended,
2235:Lib/FreeRTOS/Source/tasks.c ****                      * which may have prevented the next unblock time from being
2236:Lib/FreeRTOS/Source/tasks.c ****                      * re-calculated, in which case re-calculate it now.  Mainly
2237:Lib/FreeRTOS/Source/tasks.c ****                      * important for low power tickless implementations, where
2238:Lib/FreeRTOS/Source/tasks.c ****                      * this can prevent an unnecessary exit from low power
ARM GAS  /tmp/ccTFOe4z.s 			page 88


2239:Lib/FreeRTOS/Source/tasks.c ****                      * state. */
2240:Lib/FreeRTOS/Source/tasks.c ****                     prvResetNextTaskUnblockTime();
 2763              		.loc 1 2240 21
 2764 0174 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 2765              	.L168:
 2766              	.LBB14:
2241:Lib/FreeRTOS/Source/tasks.c ****                 }
2242:Lib/FreeRTOS/Source/tasks.c **** 
2243:Lib/FreeRTOS/Source/tasks.c ****                 /* If any ticks occurred while the scheduler was suspended then
2244:Lib/FreeRTOS/Source/tasks.c ****                  * they should be processed now.  This ensures the tick count does
2245:Lib/FreeRTOS/Source/tasks.c ****                  * not  slip, and that any delayed tasks are resumed at the correct
2246:Lib/FreeRTOS/Source/tasks.c ****                  * time. */
2247:Lib/FreeRTOS/Source/tasks.c ****                 {
2248:Lib/FreeRTOS/Source/tasks.c ****                     TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 2767              		.loc 1 2248 32
 2768 0178 1C4B     		ldr	r3, .L173+40
 2769 017a 1B68     		ldr	r3, [r3]
 2770 017c FB60     		str	r3, [r7, #12]
2249:Lib/FreeRTOS/Source/tasks.c **** 
2250:Lib/FreeRTOS/Source/tasks.c ****                     if( xPendedCounts > ( TickType_t ) 0U )
 2771              		.loc 1 2250 23
 2772 017e FB68     		ldr	r3, [r7, #12]
 2773 0180 002B     		cmp	r3, #0
 2774 0182 10D0     		beq	.L169
 2775              	.L171:
2251:Lib/FreeRTOS/Source/tasks.c ****                     {
2252:Lib/FreeRTOS/Source/tasks.c ****                         do
2253:Lib/FreeRTOS/Source/tasks.c ****                         {
2254:Lib/FreeRTOS/Source/tasks.c ****                             if( xTaskIncrementTick() != pdFALSE )
 2776              		.loc 1 2254 33
 2777 0184 FFF7FEFF 		bl	xTaskIncrementTick
 2778 0188 0346     		mov	r3, r0
 2779              		.loc 1 2254 31 discriminator 1
 2780 018a 002B     		cmp	r3, #0
 2781 018c 02D0     		beq	.L170
2255:Lib/FreeRTOS/Source/tasks.c ****                             {
2256:Lib/FreeRTOS/Source/tasks.c ****                                 xYieldPending = pdTRUE;
 2782              		.loc 1 2256 47
 2783 018e 164B     		ldr	r3, .L173+36
 2784 0190 0122     		movs	r2, #1
 2785 0192 1A60     		str	r2, [r3]
 2786              	.L170:
2257:Lib/FreeRTOS/Source/tasks.c ****                             }
2258:Lib/FreeRTOS/Source/tasks.c ****                             else
2259:Lib/FreeRTOS/Source/tasks.c ****                             {
2260:Lib/FreeRTOS/Source/tasks.c ****                                 mtCOVERAGE_TEST_MARKER();
2261:Lib/FreeRTOS/Source/tasks.c ****                             }
2262:Lib/FreeRTOS/Source/tasks.c **** 
2263:Lib/FreeRTOS/Source/tasks.c ****                             --xPendedCounts;
 2787              		.loc 1 2263 29
 2788 0194 FB68     		ldr	r3, [r7, #12]
 2789 0196 013B     		subs	r3, r3, #1
 2790 0198 FB60     		str	r3, [r7, #12]
2264:Lib/FreeRTOS/Source/tasks.c ****                         } while( xPendedCounts > ( TickType_t ) 0U );
 2791              		.loc 1 2264 48
 2792 019a FB68     		ldr	r3, [r7, #12]
 2793 019c 002B     		cmp	r3, #0
ARM GAS  /tmp/ccTFOe4z.s 			page 89


 2794 019e F1D1     		bne	.L171
2265:Lib/FreeRTOS/Source/tasks.c **** 
2266:Lib/FreeRTOS/Source/tasks.c ****                         xPendedTicks = 0;
 2795              		.loc 1 2266 38
 2796 01a0 124B     		ldr	r3, .L173+40
 2797 01a2 0022     		movs	r2, #0
 2798 01a4 1A60     		str	r2, [r3]
 2799              	.L169:
 2800              	.LBE14:
2267:Lib/FreeRTOS/Source/tasks.c ****                     }
2268:Lib/FreeRTOS/Source/tasks.c ****                     else
2269:Lib/FreeRTOS/Source/tasks.c ****                     {
2270:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2271:Lib/FreeRTOS/Source/tasks.c ****                     }
2272:Lib/FreeRTOS/Source/tasks.c ****                 }
2273:Lib/FreeRTOS/Source/tasks.c **** 
2274:Lib/FreeRTOS/Source/tasks.c ****                 if( xYieldPending != pdFALSE )
 2801              		.loc 1 2274 35
 2802 01a6 104B     		ldr	r3, .L173+36
 2803 01a8 1B68     		ldr	r3, [r3]
 2804              		.loc 1 2274 19
 2805 01aa 002B     		cmp	r3, #0
 2806 01ac 03D0     		beq	.L161
2275:Lib/FreeRTOS/Source/tasks.c ****                 {
2276:Lib/FreeRTOS/Source/tasks.c ****                     #if ( configUSE_PREEMPTION != 0 )
2277:Lib/FreeRTOS/Source/tasks.c ****                     {
2278:Lib/FreeRTOS/Source/tasks.c ****                         xAlreadyYielded = pdTRUE;
 2807              		.loc 1 2278 41
 2808 01ae 0123     		movs	r3, #1
 2809 01b0 3B61     		str	r3, [r7, #16]
2279:Lib/FreeRTOS/Source/tasks.c ****                     }
2280:Lib/FreeRTOS/Source/tasks.c ****                     #endif
2281:Lib/FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
 2810              		.loc 1 2281 21
 2811 01b2 FFF7FEFF 		bl	vPortYield
 2812              	.L161:
2282:Lib/FreeRTOS/Source/tasks.c ****                 }
2283:Lib/FreeRTOS/Source/tasks.c ****                 else
2284:Lib/FreeRTOS/Source/tasks.c ****                 {
2285:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
2286:Lib/FreeRTOS/Source/tasks.c ****                 }
2287:Lib/FreeRTOS/Source/tasks.c ****             }
2288:Lib/FreeRTOS/Source/tasks.c ****         }
2289:Lib/FreeRTOS/Source/tasks.c ****         else
2290:Lib/FreeRTOS/Source/tasks.c ****         {
2291:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2292:Lib/FreeRTOS/Source/tasks.c ****         }
2293:Lib/FreeRTOS/Source/tasks.c ****     }
2294:Lib/FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
 2813              		.loc 1 2294 5
 2814 01b6 FFF7FEFF 		bl	vPortExitCritical
2295:Lib/FreeRTOS/Source/tasks.c **** 
2296:Lib/FreeRTOS/Source/tasks.c ****     return xAlreadyYielded;
 2815              		.loc 1 2296 12
 2816 01ba 3B69     		ldr	r3, [r7, #16]
2297:Lib/FreeRTOS/Source/tasks.c **** }
 2817              		.loc 1 2297 1
ARM GAS  /tmp/ccTFOe4z.s 			page 90


 2818 01bc 1846     		mov	r0, r3
 2819 01be 1837     		adds	r7, r7, #24
 2820              		.cfi_def_cfa_offset 8
 2821 01c0 BD46     		mov	sp, r7
 2822              		.cfi_def_cfa_register 13
 2823              		@ sp needed
 2824 01c2 80BD     		pop	{r7, pc}
 2825              	.L174:
 2826              		.align	2
 2827              	.L173:
 2828 01c4 00000000 		.word	uxSchedulerSuspended
 2829 01c8 00000000 		.word	.LC0
 2830 01cc 00000000 		.word	__func__.22
 2831 01d0 04000000 		.word	.LC1
 2832 01d4 00000000 		.word	uxCurrentNumberOfTasks
 2833 01d8 00000000 		.word	xPendingReadyList
 2834 01dc 00000000 		.word	uxTopReadyPriority
 2835 01e0 00000000 		.word	pxReadyTasksLists
 2836 01e4 00000000 		.word	pxCurrentTCB
 2837 01e8 00000000 		.word	xYieldPending
 2838 01ec 00000000 		.word	xPendedTicks
 2839              		.cfi_endproc
 2840              	.LFE17:
 2842              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2843              		.align	1
 2844              		.global	xTaskGetTickCount
 2845              		.syntax unified
 2846              		.thumb
 2847              		.thumb_func
 2849              	xTaskGetTickCount:
 2850              	.LFB18:
2298:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2299:Lib/FreeRTOS/Source/tasks.c **** 
2300:Lib/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCount( void )
2301:Lib/FreeRTOS/Source/tasks.c **** {
 2851              		.loc 1 2301 1
 2852              		.cfi_startproc
 2853              		@ args = 0, pretend = 0, frame = 8
 2854              		@ frame_needed = 1, uses_anonymous_args = 0
 2855              		@ link register save eliminated.
 2856 0000 80B4     		push	{r7}
 2857              		.cfi_def_cfa_offset 4
 2858              		.cfi_offset 7, -4
 2859 0002 83B0     		sub	sp, sp, #12
 2860              		.cfi_def_cfa_offset 16
 2861 0004 00AF     		add	r7, sp, #0
 2862              		.cfi_def_cfa_register 7
2302:Lib/FreeRTOS/Source/tasks.c ****     TickType_t xTicks;
2303:Lib/FreeRTOS/Source/tasks.c **** 
2304:Lib/FreeRTOS/Source/tasks.c ****     /* Critical section required if running on a 16 bit processor. */
2305:Lib/FreeRTOS/Source/tasks.c ****     portTICK_TYPE_ENTER_CRITICAL();
2306:Lib/FreeRTOS/Source/tasks.c ****     {
2307:Lib/FreeRTOS/Source/tasks.c ****         xTicks = xTickCount;
 2863              		.loc 1 2307 16
 2864 0006 054B     		ldr	r3, .L177
 2865 0008 1B68     		ldr	r3, [r3]
 2866 000a 7B60     		str	r3, [r7, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 91


2308:Lib/FreeRTOS/Source/tasks.c ****     }
2309:Lib/FreeRTOS/Source/tasks.c ****     portTICK_TYPE_EXIT_CRITICAL();
2310:Lib/FreeRTOS/Source/tasks.c **** 
2311:Lib/FreeRTOS/Source/tasks.c ****     return xTicks;
 2867              		.loc 1 2311 12
 2868 000c 7B68     		ldr	r3, [r7, #4]
2312:Lib/FreeRTOS/Source/tasks.c **** }
 2869              		.loc 1 2312 1
 2870 000e 1846     		mov	r0, r3
 2871 0010 0C37     		adds	r7, r7, #12
 2872              		.cfi_def_cfa_offset 4
 2873 0012 BD46     		mov	sp, r7
 2874              		.cfi_def_cfa_register 13
 2875              		@ sp needed
 2876 0014 5DF8047B 		ldr	r7, [sp], #4
 2877              		.cfi_restore 7
 2878              		.cfi_def_cfa_offset 0
 2879 0018 7047     		bx	lr
 2880              	.L178:
 2881 001a 00BF     		.align	2
 2882              	.L177:
 2883 001c 00000000 		.word	xTickCount
 2884              		.cfi_endproc
 2885              	.LFE18:
 2887              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 2888              		.align	1
 2889              		.global	xTaskGetTickCountFromISR
 2890              		.syntax unified
 2891              		.thumb
 2892              		.thumb_func
 2894              	xTaskGetTickCountFromISR:
 2895              	.LFB19:
2313:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2314:Lib/FreeRTOS/Source/tasks.c **** 
2315:Lib/FreeRTOS/Source/tasks.c **** TickType_t xTaskGetTickCountFromISR( void )
2316:Lib/FreeRTOS/Source/tasks.c **** {
 2896              		.loc 1 2316 1
 2897              		.cfi_startproc
 2898              		@ args = 0, pretend = 0, frame = 8
 2899              		@ frame_needed = 1, uses_anonymous_args = 0
 2900 0000 80B5     		push	{r7, lr}
 2901              		.cfi_def_cfa_offset 8
 2902              		.cfi_offset 7, -8
 2903              		.cfi_offset 14, -4
 2904 0002 82B0     		sub	sp, sp, #8
 2905              		.cfi_def_cfa_offset 16
 2906 0004 00AF     		add	r7, sp, #0
 2907              		.cfi_def_cfa_register 7
2317:Lib/FreeRTOS/Source/tasks.c ****     TickType_t xReturn;
2318:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxSavedInterruptStatus;
2319:Lib/FreeRTOS/Source/tasks.c **** 
2320:Lib/FreeRTOS/Source/tasks.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
2321:Lib/FreeRTOS/Source/tasks.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
2322:Lib/FreeRTOS/Source/tasks.c ****      * above the maximum system call priority are kept permanently enabled, even
2323:Lib/FreeRTOS/Source/tasks.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
2324:Lib/FreeRTOS/Source/tasks.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2325:Lib/FreeRTOS/Source/tasks.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
ARM GAS  /tmp/ccTFOe4z.s 			page 92


2326:Lib/FreeRTOS/Source/tasks.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
2327:Lib/FreeRTOS/Source/tasks.c ****      * assigned a priority above the configured maximum system call priority.
2328:Lib/FreeRTOS/Source/tasks.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
2329:Lib/FreeRTOS/Source/tasks.c ****      * that have been assigned a priority at or (logically) below the maximum
2330:Lib/FreeRTOS/Source/tasks.c ****      * system call  interrupt priority.  FreeRTOS maintains a separate interrupt
2331:Lib/FreeRTOS/Source/tasks.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
2332:Lib/FreeRTOS/Source/tasks.c ****      * More information (albeit Cortex-M specific) is provided on the following
2333:Lib/FreeRTOS/Source/tasks.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2334:Lib/FreeRTOS/Source/tasks.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2908              		.loc 1 2334 5
 2909 0006 FFF7FEFF 		bl	vPortValidateInterruptPriority
2335:Lib/FreeRTOS/Source/tasks.c **** 
2336:Lib/FreeRTOS/Source/tasks.c ****     uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 2910              		.loc 1 2336 28
 2911 000a 0023     		movs	r3, #0
 2912 000c 7B60     		str	r3, [r7, #4]
2337:Lib/FreeRTOS/Source/tasks.c ****     {
2338:Lib/FreeRTOS/Source/tasks.c ****         xReturn = xTickCount;
 2913              		.loc 1 2338 17
 2914 000e 044B     		ldr	r3, .L181
 2915 0010 1B68     		ldr	r3, [r3]
 2916 0012 3B60     		str	r3, [r7]
2339:Lib/FreeRTOS/Source/tasks.c ****     }
2340:Lib/FreeRTOS/Source/tasks.c ****     portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
2341:Lib/FreeRTOS/Source/tasks.c **** 
2342:Lib/FreeRTOS/Source/tasks.c ****     return xReturn;
 2917              		.loc 1 2342 12
 2918 0014 3B68     		ldr	r3, [r7]
2343:Lib/FreeRTOS/Source/tasks.c **** }
 2919              		.loc 1 2343 1
 2920 0016 1846     		mov	r0, r3
 2921 0018 0837     		adds	r7, r7, #8
 2922              		.cfi_def_cfa_offset 8
 2923 001a BD46     		mov	sp, r7
 2924              		.cfi_def_cfa_register 13
 2925              		@ sp needed
 2926 001c 80BD     		pop	{r7, pc}
 2927              	.L182:
 2928 001e 00BF     		.align	2
 2929              	.L181:
 2930 0020 00000000 		.word	xTickCount
 2931              		.cfi_endproc
 2932              	.LFE19:
 2934              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2935              		.align	1
 2936              		.global	uxTaskGetNumberOfTasks
 2937              		.syntax unified
 2938              		.thumb
 2939              		.thumb_func
 2941              	uxTaskGetNumberOfTasks:
 2942              	.LFB20:
2344:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:Lib/FreeRTOS/Source/tasks.c **** 
2346:Lib/FreeRTOS/Source/tasks.c **** UBaseType_t uxTaskGetNumberOfTasks( void )
2347:Lib/FreeRTOS/Source/tasks.c **** {
 2943              		.loc 1 2347 1
 2944              		.cfi_startproc
ARM GAS  /tmp/ccTFOe4z.s 			page 93


 2945              		@ args = 0, pretend = 0, frame = 0
 2946              		@ frame_needed = 1, uses_anonymous_args = 0
 2947              		@ link register save eliminated.
 2948 0000 80B4     		push	{r7}
 2949              		.cfi_def_cfa_offset 4
 2950              		.cfi_offset 7, -4
 2951 0002 00AF     		add	r7, sp, #0
 2952              		.cfi_def_cfa_register 7
2348:Lib/FreeRTOS/Source/tasks.c ****     /* A critical section is not required because the variables are of type
2349:Lib/FreeRTOS/Source/tasks.c ****      * BaseType_t. */
2350:Lib/FreeRTOS/Source/tasks.c ****     return uxCurrentNumberOfTasks;
 2953              		.loc 1 2350 12
 2954 0004 034B     		ldr	r3, .L185
 2955 0006 1B68     		ldr	r3, [r3]
2351:Lib/FreeRTOS/Source/tasks.c **** }
 2956              		.loc 1 2351 1
 2957 0008 1846     		mov	r0, r3
 2958 000a BD46     		mov	sp, r7
 2959              		.cfi_def_cfa_register 13
 2960              		@ sp needed
 2961 000c 5DF8047B 		ldr	r7, [sp], #4
 2962              		.cfi_restore 7
 2963              		.cfi_def_cfa_offset 0
 2964 0010 7047     		bx	lr
 2965              	.L186:
 2966 0012 00BF     		.align	2
 2967              	.L185:
 2968 0014 00000000 		.word	uxCurrentNumberOfTasks
 2969              		.cfi_endproc
 2970              	.LFE20:
 2972              		.section	.text.pcTaskGetName,"ax",%progbits
 2973              		.align	1
 2974              		.global	pcTaskGetName
 2975              		.syntax unified
 2976              		.thumb
 2977              		.thumb_func
 2979              	pcTaskGetName:
 2980              	.LFB21:
2352:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2353:Lib/FreeRTOS/Source/tasks.c **** 
2354:Lib/FreeRTOS/Source/tasks.c **** char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed f
2355:Lib/FreeRTOS/Source/tasks.c **** {
 2981              		.loc 1 2355 1
 2982              		.cfi_startproc
 2983              		@ args = 0, pretend = 0, frame = 16
 2984              		@ frame_needed = 1, uses_anonymous_args = 0
 2985 0000 80B5     		push	{r7, lr}
 2986              		.cfi_def_cfa_offset 8
 2987              		.cfi_offset 7, -8
 2988              		.cfi_offset 14, -4
 2989 0002 84B0     		sub	sp, sp, #16
 2990              		.cfi_def_cfa_offset 24
 2991 0004 00AF     		add	r7, sp, #0
 2992              		.cfi_def_cfa_register 7
 2993 0006 7860     		str	r0, [r7, #4]
2356:Lib/FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
2357:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 94


2358:Lib/FreeRTOS/Source/tasks.c ****     /* If null is passed in here then the name of the calling task is being
2359:Lib/FreeRTOS/Source/tasks.c ****      * queried. */
2360:Lib/FreeRTOS/Source/tasks.c ****     pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 2994              		.loc 1 2360 13
 2995 0008 7B68     		ldr	r3, [r7, #4]
 2996 000a 002B     		cmp	r3, #0
 2997 000c 02D1     		bne	.L188
 2998              		.loc 1 2360 13 is_stmt 0 discriminator 1
 2999 000e 0B4B     		ldr	r3, .L192
 3000 0010 1B68     		ldr	r3, [r3]
 3001 0012 00E0     		b	.L189
 3002              	.L188:
 3003              		.loc 1 2360 13 discriminator 2
 3004 0014 7B68     		ldr	r3, [r7, #4]
 3005              	.L189:
 3006              		.loc 1 2360 11 is_stmt 1 discriminator 4
 3007 0016 FB60     		str	r3, [r7, #12]
2361:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxTCB );
 3008              		.loc 1 2361 5
 3009 0018 FB68     		ldr	r3, [r7, #12]
 3010 001a 002B     		cmp	r3, #0
 3011 001c 08D1     		bne	.L190
 3012              		.loc 1 2361 5 is_stmt 0 discriminator 1
 3013 001e FFF7FEFF 		bl	ulSetInterruptMask
 3014 0022 074B     		ldr	r3, .L192+4
 3015 0024 074A     		ldr	r2, .L192+8
 3016 0026 40F63911 		movw	r1, #2361
 3017 002a 0748     		ldr	r0, .L192+12
 3018 002c FFF7FEFF 		bl	__assert_func
 3019              	.L190:
2362:Lib/FreeRTOS/Source/tasks.c ****     return &( pxTCB->pcTaskName[ 0 ] );
 3020              		.loc 1 2362 12 is_stmt 1
 3021 0030 FB68     		ldr	r3, [r7, #12]
 3022 0032 3433     		adds	r3, r3, #52
2363:Lib/FreeRTOS/Source/tasks.c **** }
 3023              		.loc 1 2363 1
 3024 0034 1846     		mov	r0, r3
 3025 0036 1037     		adds	r7, r7, #16
 3026              		.cfi_def_cfa_offset 8
 3027 0038 BD46     		mov	sp, r7
 3028              		.cfi_def_cfa_register 13
 3029              		@ sp needed
 3030 003a 80BD     		pop	{r7, pc}
 3031              	.L193:
 3032              		.align	2
 3033              	.L192:
 3034 003c 00000000 		.word	pxCurrentTCB
 3035 0040 00000000 		.word	.LC0
 3036 0044 00000000 		.word	__func__.21
 3037 0048 04000000 		.word	.LC1
 3038              		.cfi_endproc
 3039              	.LFE21:
 3041              		.section	.text.xTaskGetStaticBuffers,"ax",%progbits
 3042              		.align	1
 3043              		.global	xTaskGetStaticBuffers
 3044              		.syntax unified
 3045              		.thumb
ARM GAS  /tmp/ccTFOe4z.s 			page 95


 3046              		.thumb_func
 3048              	xTaskGetStaticBuffers:
 3049              	.LFB22:
2364:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2365:Lib/FreeRTOS/Source/tasks.c **** 
2366:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2367:Lib/FreeRTOS/Source/tasks.c **** 
2368:Lib/FreeRTOS/Source/tasks.c ****     static TCB_t * prvSearchForNameWithinSingleList( List_t * pxList,
2369:Lib/FreeRTOS/Source/tasks.c ****                                                      const char pcNameToQuery[] )
2370:Lib/FreeRTOS/Source/tasks.c ****     {
2371:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxNextTCB;
2372:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxFirstTCB;
2373:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxReturn = NULL;
2374:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t x;
2375:Lib/FreeRTOS/Source/tasks.c ****         char cNextChar;
2376:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xBreakLoop;
2377:Lib/FreeRTOS/Source/tasks.c **** 
2378:Lib/FreeRTOS/Source/tasks.c ****         /* This function is called with the scheduler suspended. */
2379:Lib/FreeRTOS/Source/tasks.c **** 
2380:Lib/FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
2381:Lib/FreeRTOS/Source/tasks.c ****         {
2382:Lib/FreeRTOS/Source/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
2383:Lib/FreeRTOS/Source/tasks.c **** 
2384:Lib/FreeRTOS/Source/tasks.c ****             do
2385:Lib/FreeRTOS/Source/tasks.c ****             {
2386:Lib/FreeRTOS/Source/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
2387:Lib/FreeRTOS/Source/tasks.c **** 
2388:Lib/FreeRTOS/Source/tasks.c ****                 /* Check each character in the name looking for a match or
2389:Lib/FreeRTOS/Source/tasks.c ****                  * mismatch. */
2390:Lib/FreeRTOS/Source/tasks.c ****                 xBreakLoop = pdFALSE;
2391:Lib/FreeRTOS/Source/tasks.c **** 
2392:Lib/FreeRTOS/Source/tasks.c ****                 for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
2393:Lib/FreeRTOS/Source/tasks.c ****                 {
2394:Lib/FreeRTOS/Source/tasks.c ****                     cNextChar = pxNextTCB->pcTaskName[ x ];
2395:Lib/FreeRTOS/Source/tasks.c **** 
2396:Lib/FreeRTOS/Source/tasks.c ****                     if( cNextChar != pcNameToQuery[ x ] )
2397:Lib/FreeRTOS/Source/tasks.c ****                     {
2398:Lib/FreeRTOS/Source/tasks.c ****                         /* Characters didn't match. */
2399:Lib/FreeRTOS/Source/tasks.c ****                         xBreakLoop = pdTRUE;
2400:Lib/FreeRTOS/Source/tasks.c ****                     }
2401:Lib/FreeRTOS/Source/tasks.c ****                     else if( cNextChar == ( char ) 0x00 )
2402:Lib/FreeRTOS/Source/tasks.c ****                     {
2403:Lib/FreeRTOS/Source/tasks.c ****                         /* Both strings terminated, a match must have been
2404:Lib/FreeRTOS/Source/tasks.c ****                          * found. */
2405:Lib/FreeRTOS/Source/tasks.c ****                         pxReturn = pxNextTCB;
2406:Lib/FreeRTOS/Source/tasks.c ****                         xBreakLoop = pdTRUE;
2407:Lib/FreeRTOS/Source/tasks.c ****                     }
2408:Lib/FreeRTOS/Source/tasks.c ****                     else
2409:Lib/FreeRTOS/Source/tasks.c ****                     {
2410:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2411:Lib/FreeRTOS/Source/tasks.c ****                     }
2412:Lib/FreeRTOS/Source/tasks.c **** 
2413:Lib/FreeRTOS/Source/tasks.c ****                     if( xBreakLoop != pdFALSE )
2414:Lib/FreeRTOS/Source/tasks.c ****                     {
2415:Lib/FreeRTOS/Source/tasks.c ****                         break;
2416:Lib/FreeRTOS/Source/tasks.c ****                     }
2417:Lib/FreeRTOS/Source/tasks.c ****                 }
ARM GAS  /tmp/ccTFOe4z.s 			page 96


2418:Lib/FreeRTOS/Source/tasks.c **** 
2419:Lib/FreeRTOS/Source/tasks.c ****                 if( pxReturn != NULL )
2420:Lib/FreeRTOS/Source/tasks.c ****                 {
2421:Lib/FreeRTOS/Source/tasks.c ****                     /* The handle has been found. */
2422:Lib/FreeRTOS/Source/tasks.c ****                     break;
2423:Lib/FreeRTOS/Source/tasks.c ****                 }
2424:Lib/FreeRTOS/Source/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
2425:Lib/FreeRTOS/Source/tasks.c ****         }
2426:Lib/FreeRTOS/Source/tasks.c ****         else
2427:Lib/FreeRTOS/Source/tasks.c ****         {
2428:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2429:Lib/FreeRTOS/Source/tasks.c ****         }
2430:Lib/FreeRTOS/Source/tasks.c **** 
2431:Lib/FreeRTOS/Source/tasks.c ****         return pxReturn;
2432:Lib/FreeRTOS/Source/tasks.c ****     }
2433:Lib/FreeRTOS/Source/tasks.c **** 
2434:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2435:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2436:Lib/FreeRTOS/Source/tasks.c **** 
2437:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetHandle == 1 )
2438:Lib/FreeRTOS/Source/tasks.c **** 
2439:Lib/FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetHandle( const char * pcNameToQuery ) /*lint !e971 Unqualified char types a
2440:Lib/FreeRTOS/Source/tasks.c ****     {
2441:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxQueue = configMAX_PRIORITIES;
2442:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2443:Lib/FreeRTOS/Source/tasks.c **** 
2444:Lib/FreeRTOS/Source/tasks.c ****         /* Task names will be truncated to configMAX_TASK_NAME_LEN - 1 bytes. */
2445:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
2446:Lib/FreeRTOS/Source/tasks.c **** 
2447:Lib/FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
2448:Lib/FreeRTOS/Source/tasks.c ****         {
2449:Lib/FreeRTOS/Source/tasks.c ****             /* Search the ready lists. */
2450:Lib/FreeRTOS/Source/tasks.c ****             do
2451:Lib/FreeRTOS/Source/tasks.c ****             {
2452:Lib/FreeRTOS/Source/tasks.c ****                 uxQueue--;
2453:Lib/FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueu
2454:Lib/FreeRTOS/Source/tasks.c **** 
2455:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB != NULL )
2456:Lib/FreeRTOS/Source/tasks.c ****                 {
2457:Lib/FreeRTOS/Source/tasks.c ****                     /* Found the handle. */
2458:Lib/FreeRTOS/Source/tasks.c ****                     break;
2459:Lib/FreeRTOS/Source/tasks.c ****                 }
2460:Lib/FreeRTOS/Source/tasks.c ****             } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as 
2461:Lib/FreeRTOS/Source/tasks.c **** 
2462:Lib/FreeRTOS/Source/tasks.c ****             /* Search the delayed lists. */
2463:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB == NULL )
2464:Lib/FreeRTOS/Source/tasks.c ****             {
2465:Lib/FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQ
2466:Lib/FreeRTOS/Source/tasks.c ****             }
2467:Lib/FreeRTOS/Source/tasks.c **** 
2468:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB == NULL )
2469:Lib/FreeRTOS/Source/tasks.c ****             {
2470:Lib/FreeRTOS/Source/tasks.c ****                 pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, p
2471:Lib/FreeRTOS/Source/tasks.c ****             }
2472:Lib/FreeRTOS/Source/tasks.c **** 
2473:Lib/FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskSuspend == 1 )
2474:Lib/FreeRTOS/Source/tasks.c ****             {
ARM GAS  /tmp/ccTFOe4z.s 			page 97


2475:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB == NULL )
2476:Lib/FreeRTOS/Source/tasks.c ****                 {
2477:Lib/FreeRTOS/Source/tasks.c ****                     /* Search the suspended list. */
2478:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
2479:Lib/FreeRTOS/Source/tasks.c ****                 }
2480:Lib/FreeRTOS/Source/tasks.c ****             }
2481:Lib/FreeRTOS/Source/tasks.c ****             #endif
2482:Lib/FreeRTOS/Source/tasks.c **** 
2483:Lib/FreeRTOS/Source/tasks.c ****             #if ( INCLUDE_vTaskDelete == 1 )
2484:Lib/FreeRTOS/Source/tasks.c ****             {
2485:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB == NULL )
2486:Lib/FreeRTOS/Source/tasks.c ****                 {
2487:Lib/FreeRTOS/Source/tasks.c ****                     /* Search the deleted list. */
2488:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQu
2489:Lib/FreeRTOS/Source/tasks.c ****                 }
2490:Lib/FreeRTOS/Source/tasks.c ****             }
2491:Lib/FreeRTOS/Source/tasks.c ****             #endif
2492:Lib/FreeRTOS/Source/tasks.c ****         }
2493:Lib/FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
2494:Lib/FreeRTOS/Source/tasks.c **** 
2495:Lib/FreeRTOS/Source/tasks.c ****         return pxTCB;
2496:Lib/FreeRTOS/Source/tasks.c ****     }
2497:Lib/FreeRTOS/Source/tasks.c **** 
2498:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetHandle */
2499:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2500:Lib/FreeRTOS/Source/tasks.c **** 
2501:Lib/FreeRTOS/Source/tasks.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
2502:Lib/FreeRTOS/Source/tasks.c **** 
2503:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGetStaticBuffers( TaskHandle_t xTask,
2504:Lib/FreeRTOS/Source/tasks.c ****                                       StackType_t ** ppuxStackBuffer,
2505:Lib/FreeRTOS/Source/tasks.c ****                                       StaticTask_t ** ppxTaskBuffer )
2506:Lib/FreeRTOS/Source/tasks.c ****     {
 3050              		.loc 1 2506 5
 3051              		.cfi_startproc
 3052              		@ args = 0, pretend = 0, frame = 24
 3053              		@ frame_needed = 1, uses_anonymous_args = 0
 3054 0000 80B5     		push	{r7, lr}
 3055              		.cfi_def_cfa_offset 8
 3056              		.cfi_offset 7, -8
 3057              		.cfi_offset 14, -4
 3058 0002 86B0     		sub	sp, sp, #24
 3059              		.cfi_def_cfa_offset 32
 3060 0004 00AF     		add	r7, sp, #0
 3061              		.cfi_def_cfa_register 7
 3062 0006 F860     		str	r0, [r7, #12]
 3063 0008 B960     		str	r1, [r7, #8]
 3064 000a 7A60     		str	r2, [r7, #4]
2507:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
2508:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2509:Lib/FreeRTOS/Source/tasks.c **** 
2510:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ppuxStackBuffer != NULL );
 3065              		.loc 1 2510 9
 3066 000c BB68     		ldr	r3, [r7, #8]
 3067 000e 002B     		cmp	r3, #0
 3068 0010 08D1     		bne	.L195
 3069              		.loc 1 2510 9 is_stmt 0 discriminator 1
 3070 0012 FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/ccTFOe4z.s 			page 98


 3071 0016 144B     		ldr	r3, .L200
 3072 0018 144A     		ldr	r2, .L200+4
 3073 001a 40F6CE11 		movw	r1, #2510
 3074 001e 1448     		ldr	r0, .L200+8
 3075 0020 FFF7FEFF 		bl	__assert_func
 3076              	.L195:
2511:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ppxTaskBuffer != NULL );
 3077              		.loc 1 2511 9 is_stmt 1
 3078 0024 7B68     		ldr	r3, [r7, #4]
 3079 0026 002B     		cmp	r3, #0
 3080 0028 08D1     		bne	.L196
 3081              		.loc 1 2511 9 is_stmt 0 discriminator 1
 3082 002a FFF7FEFF 		bl	ulSetInterruptMask
 3083 002e 0E4B     		ldr	r3, .L200
 3084 0030 0E4A     		ldr	r2, .L200+4
 3085 0032 40F6CF11 		movw	r1, #2511
 3086 0036 0E48     		ldr	r0, .L200+8
 3087 0038 FFF7FEFF 		bl	__assert_func
 3088              	.L196:
2512:Lib/FreeRTOS/Source/tasks.c **** 
2513:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
 3089              		.loc 1 2513 17 is_stmt 1
 3090 003c FB68     		ldr	r3, [r7, #12]
 3091 003e 002B     		cmp	r3, #0
 3092 0040 02D1     		bne	.L197
 3093              		.loc 1 2513 17 is_stmt 0 discriminator 1
 3094 0042 0C4B     		ldr	r3, .L200+12
 3095 0044 1B68     		ldr	r3, [r3]
 3096 0046 00E0     		b	.L198
 3097              	.L197:
 3098              		.loc 1 2513 17 discriminator 2
 3099 0048 FB68     		ldr	r3, [r7, #12]
 3100              	.L198:
 3101              		.loc 1 2513 15 is_stmt 1 discriminator 4
 3102 004a 7B61     		str	r3, [r7, #20]
2514:Lib/FreeRTOS/Source/tasks.c **** 
2515:Lib/FreeRTOS/Source/tasks.c ****         #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
2516:Lib/FreeRTOS/Source/tasks.c ****         {
2517:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB )
2518:Lib/FreeRTOS/Source/tasks.c ****             {
2519:Lib/FreeRTOS/Source/tasks.c ****                 *ppuxStackBuffer = pxTCB->pxStack;
2520:Lib/FreeRTOS/Source/tasks.c ****                 *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;
2521:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
2522:Lib/FreeRTOS/Source/tasks.c ****             }
2523:Lib/FreeRTOS/Source/tasks.c ****             else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
2524:Lib/FreeRTOS/Source/tasks.c ****             {
2525:Lib/FreeRTOS/Source/tasks.c ****                 *ppuxStackBuffer = pxTCB->pxStack;
2526:Lib/FreeRTOS/Source/tasks.c ****                 *ppxTaskBuffer = NULL;
2527:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
2528:Lib/FreeRTOS/Source/tasks.c ****             }
2529:Lib/FreeRTOS/Source/tasks.c ****             else
2530:Lib/FreeRTOS/Source/tasks.c ****             {
2531:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdFALSE;
2532:Lib/FreeRTOS/Source/tasks.c ****             }
2533:Lib/FreeRTOS/Source/tasks.c ****         }
2534:Lib/FreeRTOS/Source/tasks.c ****         #else /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 */
2535:Lib/FreeRTOS/Source/tasks.c ****         {
ARM GAS  /tmp/ccTFOe4z.s 			page 99


2536:Lib/FreeRTOS/Source/tasks.c ****             *ppuxStackBuffer = pxTCB->pxStack;
 3103              		.loc 1 2536 37
 3104 004c 7B69     		ldr	r3, [r7, #20]
 3105 004e 1A6B     		ldr	r2, [r3, #48]
 3106              		.loc 1 2536 30
 3107 0050 BB68     		ldr	r3, [r7, #8]
 3108 0052 1A60     		str	r2, [r3]
2537:Lib/FreeRTOS/Source/tasks.c ****             *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;
 3109              		.loc 1 2537 28
 3110 0054 7B68     		ldr	r3, [r7, #4]
 3111 0056 7A69     		ldr	r2, [r7, #20]
 3112 0058 1A60     		str	r2, [r3]
2538:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
 3113              		.loc 1 2538 21
 3114 005a 0123     		movs	r3, #1
 3115 005c 3B61     		str	r3, [r7, #16]
2539:Lib/FreeRTOS/Source/tasks.c ****         }
2540:Lib/FreeRTOS/Source/tasks.c ****         #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 */
2541:Lib/FreeRTOS/Source/tasks.c **** 
2542:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 3116              		.loc 1 2542 16
 3117 005e 3B69     		ldr	r3, [r7, #16]
2543:Lib/FreeRTOS/Source/tasks.c ****     }
 3118              		.loc 1 2543 5
 3119 0060 1846     		mov	r0, r3
 3120 0062 1837     		adds	r7, r7, #24
 3121              		.cfi_def_cfa_offset 8
 3122 0064 BD46     		mov	sp, r7
 3123              		.cfi_def_cfa_register 13
 3124              		@ sp needed
 3125 0066 80BD     		pop	{r7, pc}
 3126              	.L201:
 3127              		.align	2
 3128              	.L200:
 3129 0068 00000000 		.word	.LC0
 3130 006c 00000000 		.word	__func__.20
 3131 0070 04000000 		.word	.LC1
 3132 0074 00000000 		.word	pxCurrentTCB
 3133              		.cfi_endproc
 3134              	.LFE22:
 3136              		.section	.text.uxTaskGetSystemState,"ax",%progbits
 3137              		.align	1
 3138              		.global	uxTaskGetSystemState
 3139              		.syntax unified
 3140              		.thumb
 3141              		.thumb_func
 3143              	uxTaskGetSystemState:
 3144              	.LFB23:
2544:Lib/FreeRTOS/Source/tasks.c **** 
2545:Lib/FreeRTOS/Source/tasks.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
2546:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2547:Lib/FreeRTOS/Source/tasks.c **** 
2548:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2549:Lib/FreeRTOS/Source/tasks.c **** 
2550:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
2551:Lib/FreeRTOS/Source/tasks.c ****                                       const UBaseType_t uxArraySize,
2552:Lib/FreeRTOS/Source/tasks.c ****                                       configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
ARM GAS  /tmp/ccTFOe4z.s 			page 100


2553:Lib/FreeRTOS/Source/tasks.c ****     {
 3145              		.loc 1 2553 5
 3146              		.cfi_startproc
 3147              		@ args = 0, pretend = 0, frame = 24
 3148              		@ frame_needed = 1, uses_anonymous_args = 0
 3149 0000 80B5     		push	{r7, lr}
 3150              		.cfi_def_cfa_offset 8
 3151              		.cfi_offset 7, -8
 3152              		.cfi_offset 14, -4
 3153 0002 86B0     		sub	sp, sp, #24
 3154              		.cfi_def_cfa_offset 32
 3155 0004 00AF     		add	r7, sp, #0
 3156              		.cfi_def_cfa_register 7
 3157 0006 F860     		str	r0, [r7, #12]
 3158 0008 B960     		str	r1, [r7, #8]
 3159 000a 7A60     		str	r2, [r7, #4]
2554:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 3160              		.loc 1 2554 21
 3161 000c 0023     		movs	r3, #0
 3162 000e 7B61     		str	r3, [r7, #20]
 3163              		.loc 1 2554 33
 3164 0010 3823     		movs	r3, #56
 3165 0012 3B61     		str	r3, [r7, #16]
2555:Lib/FreeRTOS/Source/tasks.c **** 
2556:Lib/FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
 3166              		.loc 1 2556 9
 3167 0014 FFF7FEFF 		bl	vTaskSuspendAll
2557:Lib/FreeRTOS/Source/tasks.c ****         {
2558:Lib/FreeRTOS/Source/tasks.c ****             /* Is there a space in the array for each task in the system? */
2559:Lib/FreeRTOS/Source/tasks.c ****             if( uxArraySize >= uxCurrentNumberOfTasks )
 3168              		.loc 1 2559 29
 3169 0018 3B4B     		ldr	r3, .L206
 3170 001a 1B68     		ldr	r3, [r3]
 3171              		.loc 1 2559 15
 3172 001c BA68     		ldr	r2, [r7, #8]
 3173 001e 9A42     		cmp	r2, r3
 3174 0020 6AD3     		bcc	.L203
 3175              	.L204:
2560:Lib/FreeRTOS/Source/tasks.c ****             {
2561:Lib/FreeRTOS/Source/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2562:Lib/FreeRTOS/Source/tasks.c ****                  * task in the Ready state. */
2563:Lib/FreeRTOS/Source/tasks.c ****                 do
2564:Lib/FreeRTOS/Source/tasks.c ****                 {
2565:Lib/FreeRTOS/Source/tasks.c ****                     uxQueue--;
 3176              		.loc 1 2565 28
 3177 0022 3B69     		ldr	r3, [r7, #16]
 3178 0024 013B     		subs	r3, r3, #1
 3179 0026 3B61     		str	r3, [r7, #16]
2566:Lib/FreeRTOS/Source/tasks.c ****                     uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( px
 3180              		.loc 1 2566 81
 3181 0028 7A69     		ldr	r2, [r7, #20]
 3182 002a 1346     		mov	r3, r2
 3183 002c DB00     		lsls	r3, r3, #3
 3184 002e 1344     		add	r3, r3, r2
 3185 0030 9B00     		lsls	r3, r3, #2
 3186 0032 1A46     		mov	r2, r3
 3187              		.loc 1 2566 61
ARM GAS  /tmp/ccTFOe4z.s 			page 101


 3188 0034 FB68     		ldr	r3, [r7, #12]
 3189 0036 9818     		adds	r0, r3, r2
 3190              		.loc 1 2566 31
 3191 0038 3A69     		ldr	r2, [r7, #16]
 3192 003a 1346     		mov	r3, r2
 3193 003c 9B00     		lsls	r3, r3, #2
 3194 003e 1344     		add	r3, r3, r2
 3195 0040 9B00     		lsls	r3, r3, #2
 3196 0042 324A     		ldr	r2, .L206+4
 3197 0044 1344     		add	r3, r3, r2
 3198 0046 0122     		movs	r2, #1
 3199 0048 1946     		mov	r1, r3
 3200 004a FFF7FEFF 		bl	prvListTasksWithinSingleList
 3201 004e 0246     		mov	r2, r0
 3202              		.loc 1 2566 28 discriminator 1
 3203 0050 7B69     		ldr	r3, [r7, #20]
 3204 0052 1344     		add	r3, r3, r2
 3205 0054 7B61     		str	r3, [r7, #20]
2567:Lib/FreeRTOS/Source/tasks.c ****                 } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception
 3206              		.loc 1 2567 34 discriminator 1
 3207 0056 3B69     		ldr	r3, [r7, #16]
 3208 0058 002B     		cmp	r3, #0
 3209 005a E2D1     		bne	.L204
2568:Lib/FreeRTOS/Source/tasks.c **** 
2569:Lib/FreeRTOS/Source/tasks.c ****                 /* Fill in an TaskStatus_t structure with information on each
2570:Lib/FreeRTOS/Source/tasks.c ****                  * task in the Blocked state. */
2571:Lib/FreeRTOS/Source/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
 3210              		.loc 1 2571 77
 3211 005c 7A69     		ldr	r2, [r7, #20]
 3212 005e 1346     		mov	r3, r2
 3213 0060 DB00     		lsls	r3, r3, #3
 3214 0062 1344     		add	r3, r3, r2
 3215 0064 9B00     		lsls	r3, r3, #2
 3216 0066 1A46     		mov	r2, r3
 3217              		.loc 1 2571 57
 3218 0068 FB68     		ldr	r3, [r7, #12]
 3219 006a 1344     		add	r3, r3, r2
 3220              		.loc 1 2571 27
 3221 006c 284A     		ldr	r2, .L206+8
 3222 006e 1168     		ldr	r1, [r2]
 3223 0070 0222     		movs	r2, #2
 3224 0072 1846     		mov	r0, r3
 3225 0074 FFF7FEFF 		bl	prvListTasksWithinSingleList
 3226 0078 0246     		mov	r2, r0
 3227              		.loc 1 2571 24 discriminator 1
 3228 007a 7B69     		ldr	r3, [r7, #20]
 3229 007c 1344     		add	r3, r3, r2
 3230 007e 7B61     		str	r3, [r7, #20]
2572:Lib/FreeRTOS/Source/tasks.c ****                 uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t 
 3231              		.loc 1 2572 77
 3232 0080 7A69     		ldr	r2, [r7, #20]
 3233 0082 1346     		mov	r3, r2
 3234 0084 DB00     		lsls	r3, r3, #3
 3235 0086 1344     		add	r3, r3, r2
 3236 0088 9B00     		lsls	r3, r3, #2
 3237 008a 1A46     		mov	r2, r3
 3238              		.loc 1 2572 57
ARM GAS  /tmp/ccTFOe4z.s 			page 102


 3239 008c FB68     		ldr	r3, [r7, #12]
 3240 008e 1344     		add	r3, r3, r2
 3241              		.loc 1 2572 27
 3242 0090 204A     		ldr	r2, .L206+12
 3243 0092 1168     		ldr	r1, [r2]
 3244 0094 0222     		movs	r2, #2
 3245 0096 1846     		mov	r0, r3
 3246 0098 FFF7FEFF 		bl	prvListTasksWithinSingleList
 3247 009c 0246     		mov	r2, r0
 3248              		.loc 1 2572 24 discriminator 1
 3249 009e 7B69     		ldr	r3, [r7, #20]
 3250 00a0 1344     		add	r3, r3, r2
 3251 00a2 7B61     		str	r3, [r7, #20]
2573:Lib/FreeRTOS/Source/tasks.c **** 
2574:Lib/FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskDelete == 1 )
2575:Lib/FreeRTOS/Source/tasks.c ****                 {
2576:Lib/FreeRTOS/Source/tasks.c ****                     /* Fill in an TaskStatus_t structure with information on
2577:Lib/FreeRTOS/Source/tasks.c ****                      * each task that has been deleted but not yet cleaned up. */
2578:Lib/FreeRTOS/Source/tasks.c ****                     uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTas
 3252              		.loc 1 2578 81
 3253 00a4 7A69     		ldr	r2, [r7, #20]
 3254 00a6 1346     		mov	r3, r2
 3255 00a8 DB00     		lsls	r3, r3, #3
 3256 00aa 1344     		add	r3, r3, r2
 3257 00ac 9B00     		lsls	r3, r3, #2
 3258 00ae 1A46     		mov	r2, r3
 3259              		.loc 1 2578 61
 3260 00b0 FB68     		ldr	r3, [r7, #12]
 3261 00b2 1344     		add	r3, r3, r2
 3262              		.loc 1 2578 31
 3263 00b4 0422     		movs	r2, #4
 3264 00b6 1849     		ldr	r1, .L206+16
 3265 00b8 1846     		mov	r0, r3
 3266 00ba FFF7FEFF 		bl	prvListTasksWithinSingleList
 3267 00be 0246     		mov	r2, r0
 3268              		.loc 1 2578 28 discriminator 1
 3269 00c0 7B69     		ldr	r3, [r7, #20]
 3270 00c2 1344     		add	r3, r3, r2
 3271 00c4 7B61     		str	r3, [r7, #20]
2579:Lib/FreeRTOS/Source/tasks.c ****                 }
2580:Lib/FreeRTOS/Source/tasks.c ****                 #endif
2581:Lib/FreeRTOS/Source/tasks.c **** 
2582:Lib/FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
2583:Lib/FreeRTOS/Source/tasks.c ****                 {
2584:Lib/FreeRTOS/Source/tasks.c ****                     /* Fill in an TaskStatus_t structure with information on
2585:Lib/FreeRTOS/Source/tasks.c ****                      * each task in the Suspended state. */
2586:Lib/FreeRTOS/Source/tasks.c ****                     uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSus
 3272              		.loc 1 2586 81
 3273 00c6 7A69     		ldr	r2, [r7, #20]
 3274 00c8 1346     		mov	r3, r2
 3275 00ca DB00     		lsls	r3, r3, #3
 3276 00cc 1344     		add	r3, r3, r2
 3277 00ce 9B00     		lsls	r3, r3, #2
 3278 00d0 1A46     		mov	r2, r3
 3279              		.loc 1 2586 61
 3280 00d2 FB68     		ldr	r3, [r7, #12]
 3281 00d4 1344     		add	r3, r3, r2
ARM GAS  /tmp/ccTFOe4z.s 			page 103


 3282              		.loc 1 2586 31
 3283 00d6 0322     		movs	r2, #3
 3284 00d8 1049     		ldr	r1, .L206+20
 3285 00da 1846     		mov	r0, r3
 3286 00dc FFF7FEFF 		bl	prvListTasksWithinSingleList
 3287 00e0 0246     		mov	r2, r0
 3288              		.loc 1 2586 28 discriminator 1
 3289 00e2 7B69     		ldr	r3, [r7, #20]
 3290 00e4 1344     		add	r3, r3, r2
 3291 00e6 7B61     		str	r3, [r7, #20]
2587:Lib/FreeRTOS/Source/tasks.c ****                 }
2588:Lib/FreeRTOS/Source/tasks.c ****                 #endif
2589:Lib/FreeRTOS/Source/tasks.c **** 
2590:Lib/FreeRTOS/Source/tasks.c ****                 #if ( configGENERATE_RUN_TIME_STATS == 1 )
2591:Lib/FreeRTOS/Source/tasks.c ****                 {
2592:Lib/FreeRTOS/Source/tasks.c ****                     if( pulTotalRunTime != NULL )
 3292              		.loc 1 2592 23
 3293 00e8 7B68     		ldr	r3, [r7, #4]
 3294 00ea 002B     		cmp	r3, #0
 3295 00ec 04D0     		beq	.L203
2593:Lib/FreeRTOS/Source/tasks.c ****                     {
2594:Lib/FreeRTOS/Source/tasks.c ****                         #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2595:Lib/FreeRTOS/Source/tasks.c ****                             portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
2596:Lib/FreeRTOS/Source/tasks.c ****                         #else
2597:Lib/FreeRTOS/Source/tasks.c ****                             *pulTotalRunTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COU
 3296              		.loc 1 2597 80
 3297 00ee FFF7FEFF 		bl	TIM4_Get_Value
 3298 00f2 0246     		mov	r2, r0
 3299              		.loc 1 2597 46 discriminator 1
 3300 00f4 7B68     		ldr	r3, [r7, #4]
 3301 00f6 1A60     		str	r2, [r3]
 3302              	.L203:
2598:Lib/FreeRTOS/Source/tasks.c ****                         #endif
2599:Lib/FreeRTOS/Source/tasks.c ****                     }
2600:Lib/FreeRTOS/Source/tasks.c ****                 }
2601:Lib/FreeRTOS/Source/tasks.c ****                 #else /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2602:Lib/FreeRTOS/Source/tasks.c ****                 {
2603:Lib/FreeRTOS/Source/tasks.c ****                     if( pulTotalRunTime != NULL )
2604:Lib/FreeRTOS/Source/tasks.c ****                     {
2605:Lib/FreeRTOS/Source/tasks.c ****                         *pulTotalRunTime = 0;
2606:Lib/FreeRTOS/Source/tasks.c ****                     }
2607:Lib/FreeRTOS/Source/tasks.c ****                 }
2608:Lib/FreeRTOS/Source/tasks.c ****                 #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
2609:Lib/FreeRTOS/Source/tasks.c ****             }
2610:Lib/FreeRTOS/Source/tasks.c ****             else
2611:Lib/FreeRTOS/Source/tasks.c ****             {
2612:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2613:Lib/FreeRTOS/Source/tasks.c ****             }
2614:Lib/FreeRTOS/Source/tasks.c ****         }
2615:Lib/FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
 3303              		.loc 1 2615 18
 3304 00f8 FFF7FEFF 		bl	xTaskResumeAll
2616:Lib/FreeRTOS/Source/tasks.c **** 
2617:Lib/FreeRTOS/Source/tasks.c ****         return uxTask;
 3305              		.loc 1 2617 16
 3306 00fc 7B69     		ldr	r3, [r7, #20]
2618:Lib/FreeRTOS/Source/tasks.c ****     }
ARM GAS  /tmp/ccTFOe4z.s 			page 104


 3307              		.loc 1 2618 5
 3308 00fe 1846     		mov	r0, r3
 3309 0100 1837     		adds	r7, r7, #24
 3310              		.cfi_def_cfa_offset 8
 3311 0102 BD46     		mov	sp, r7
 3312              		.cfi_def_cfa_register 13
 3313              		@ sp needed
 3314 0104 80BD     		pop	{r7, pc}
 3315              	.L207:
 3316 0106 00BF     		.align	2
 3317              	.L206:
 3318 0108 00000000 		.word	uxCurrentNumberOfTasks
 3319 010c 00000000 		.word	pxReadyTasksLists
 3320 0110 00000000 		.word	pxDelayedTaskList
 3321 0114 00000000 		.word	pxOverflowDelayedTaskList
 3322 0118 00000000 		.word	xTasksWaitingTermination
 3323 011c 00000000 		.word	xSuspendedTaskList
 3324              		.cfi_endproc
 3325              	.LFE23:
 3327              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 3328              		.align	1
 3329              		.global	xTaskGetIdleTaskHandle
 3330              		.syntax unified
 3331              		.thumb
 3332              		.thumb_func
 3334              	xTaskGetIdleTaskHandle:
 3335              	.LFB24:
2619:Lib/FreeRTOS/Source/tasks.c **** 
2620:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
2621:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2622:Lib/FreeRTOS/Source/tasks.c **** 
2623:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
2624:Lib/FreeRTOS/Source/tasks.c **** 
2625:Lib/FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetIdleTaskHandle( void )
2626:Lib/FreeRTOS/Source/tasks.c ****     {
 3336              		.loc 1 2626 5
 3337              		.cfi_startproc
 3338              		@ args = 0, pretend = 0, frame = 0
 3339              		@ frame_needed = 1, uses_anonymous_args = 0
 3340 0000 80B5     		push	{r7, lr}
 3341              		.cfi_def_cfa_offset 8
 3342              		.cfi_offset 7, -8
 3343              		.cfi_offset 14, -4
 3344 0002 00AF     		add	r7, sp, #0
 3345              		.cfi_def_cfa_register 7
2627:Lib/FreeRTOS/Source/tasks.c ****         /* If xTaskGetIdleTaskHandle() is called before the scheduler has been
2628:Lib/FreeRTOS/Source/tasks.c ****          * started, then xIdleTaskHandle will be NULL. */
2629:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( xIdleTaskHandle != NULL ) );
 3346              		.loc 1 2629 9
 3347 0004 084B     		ldr	r3, .L211
 3348 0006 1B68     		ldr	r3, [r3]
 3349 0008 002B     		cmp	r3, #0
 3350 000a 08D1     		bne	.L209
 3351              		.loc 1 2629 9 is_stmt 0 discriminator 1
 3352 000c FFF7FEFF 		bl	ulSetInterruptMask
 3353 0010 064B     		ldr	r3, .L211+4
 3354 0012 074A     		ldr	r2, .L211+8
ARM GAS  /tmp/ccTFOe4z.s 			page 105


 3355 0014 40F64521 		movw	r1, #2629
 3356 0018 0648     		ldr	r0, .L211+12
 3357 001a FFF7FEFF 		bl	__assert_func
 3358              	.L209:
2630:Lib/FreeRTOS/Source/tasks.c ****         return xIdleTaskHandle;
 3359              		.loc 1 2630 16 is_stmt 1
 3360 001e 024B     		ldr	r3, .L211
 3361 0020 1B68     		ldr	r3, [r3]
2631:Lib/FreeRTOS/Source/tasks.c ****     }
 3362              		.loc 1 2631 5
 3363 0022 1846     		mov	r0, r3
 3364 0024 80BD     		pop	{r7, pc}
 3365              	.L212:
 3366 0026 00BF     		.align	2
 3367              	.L211:
 3368 0028 00000000 		.word	xIdleTaskHandle
 3369 002c 00000000 		.word	.LC0
 3370 0030 00000000 		.word	__func__.19
 3371 0034 04000000 		.word	.LC1
 3372              		.cfi_endproc
 3373              	.LFE24:
 3375              		.section	.text.xTaskCatchUpTicks,"ax",%progbits
 3376              		.align	1
 3377              		.global	xTaskCatchUpTicks
 3378              		.syntax unified
 3379              		.thumb
 3380              		.thumb_func
 3382              	xTaskCatchUpTicks:
 3383              	.LFB25:
2632:Lib/FreeRTOS/Source/tasks.c **** 
2633:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskGetIdleTaskHandle */
2634:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2635:Lib/FreeRTOS/Source/tasks.c **** 
2636:Lib/FreeRTOS/Source/tasks.c **** /* This conditional compilation should use inequality to 0, not equality to 1.
2637:Lib/FreeRTOS/Source/tasks.c ****  * This is to ensure vTaskStepTick() is available when user defined low power mode
2638:Lib/FreeRTOS/Source/tasks.c ****  * implementations require configUSE_TICKLESS_IDLE to be set to a value other than
2639:Lib/FreeRTOS/Source/tasks.c ****  * 1. */
2640:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
2641:Lib/FreeRTOS/Source/tasks.c **** 
2642:Lib/FreeRTOS/Source/tasks.c ****     void vTaskStepTick( TickType_t xTicksToJump )
2643:Lib/FreeRTOS/Source/tasks.c ****     {
2644:Lib/FreeRTOS/Source/tasks.c ****         /* Correct the tick count value after a period during which the tick
2645:Lib/FreeRTOS/Source/tasks.c ****          * was suppressed.  Note this does *not* call the tick hook function for
2646:Lib/FreeRTOS/Source/tasks.c ****          * each stepped tick. */
2647:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
2648:Lib/FreeRTOS/Source/tasks.c **** 
2649:Lib/FreeRTOS/Source/tasks.c ****         if( ( xTickCount + xTicksToJump ) == xNextTaskUnblockTime )
2650:Lib/FreeRTOS/Source/tasks.c ****         {
2651:Lib/FreeRTOS/Source/tasks.c ****             /* Arrange for xTickCount to reach xNextTaskUnblockTime in
2652:Lib/FreeRTOS/Source/tasks.c ****              * xTaskIncrementTick() when the scheduler resumes.  This ensures
2653:Lib/FreeRTOS/Source/tasks.c ****              * that any delayed tasks are resumed at the correct time. */
2654:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
2655:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( xTicksToJump != ( TickType_t ) 0 );
2656:Lib/FreeRTOS/Source/tasks.c **** 
2657:Lib/FreeRTOS/Source/tasks.c ****             /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
2658:Lib/FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
2659:Lib/FreeRTOS/Source/tasks.c ****             {
ARM GAS  /tmp/ccTFOe4z.s 			page 106


2660:Lib/FreeRTOS/Source/tasks.c ****                 xPendedTicks++;
2661:Lib/FreeRTOS/Source/tasks.c ****             }
2662:Lib/FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
2663:Lib/FreeRTOS/Source/tasks.c ****             xTicksToJump--;
2664:Lib/FreeRTOS/Source/tasks.c ****         }
2665:Lib/FreeRTOS/Source/tasks.c ****         else
2666:Lib/FreeRTOS/Source/tasks.c ****         {
2667:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2668:Lib/FreeRTOS/Source/tasks.c ****         }
2669:Lib/FreeRTOS/Source/tasks.c **** 
2670:Lib/FreeRTOS/Source/tasks.c ****         xTickCount += xTicksToJump;
2671:Lib/FreeRTOS/Source/tasks.c ****         traceINCREASE_TICK_COUNT( xTicksToJump );
2672:Lib/FreeRTOS/Source/tasks.c ****     }
2673:Lib/FreeRTOS/Source/tasks.c **** 
2674:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
2675:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2676:Lib/FreeRTOS/Source/tasks.c **** 
2677:Lib/FreeRTOS/Source/tasks.c **** BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
2678:Lib/FreeRTOS/Source/tasks.c **** {
 3384              		.loc 1 2678 1
 3385              		.cfi_startproc
 3386              		@ args = 0, pretend = 0, frame = 16
 3387              		@ frame_needed = 1, uses_anonymous_args = 0
 3388 0000 80B5     		push	{r7, lr}
 3389              		.cfi_def_cfa_offset 8
 3390              		.cfi_offset 7, -8
 3391              		.cfi_offset 14, -4
 3392 0002 84B0     		sub	sp, sp, #16
 3393              		.cfi_def_cfa_offset 24
 3394 0004 00AF     		add	r7, sp, #0
 3395              		.cfi_def_cfa_register 7
 3396 0006 7860     		str	r0, [r7, #4]
2679:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xYieldOccurred;
2680:Lib/FreeRTOS/Source/tasks.c **** 
2681:Lib/FreeRTOS/Source/tasks.c ****     /* Must not be called with the scheduler suspended as the implementation
2682:Lib/FreeRTOS/Source/tasks.c ****      * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
2683:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 3397              		.loc 1 2683 5
 3398 0008 104B     		ldr	r3, .L216
 3399 000a 1B68     		ldr	r3, [r3]
 3400 000c 002B     		cmp	r3, #0
 3401 000e 08D0     		beq	.L214
 3402              		.loc 1 2683 5 is_stmt 0 discriminator 1
 3403 0010 FFF7FEFF 		bl	ulSetInterruptMask
 3404 0014 0E4B     		ldr	r3, .L216+4
 3405 0016 0F4A     		ldr	r2, .L216+8
 3406 0018 40F67B21 		movw	r1, #2683
 3407 001c 0E48     		ldr	r0, .L216+12
 3408 001e FFF7FEFF 		bl	__assert_func
 3409              	.L214:
2684:Lib/FreeRTOS/Source/tasks.c **** 
2685:Lib/FreeRTOS/Source/tasks.c ****     /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
2686:Lib/FreeRTOS/Source/tasks.c ****      * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
2687:Lib/FreeRTOS/Source/tasks.c ****     vTaskSuspendAll();
 3410              		.loc 1 2687 5 is_stmt 1
 3411 0022 FFF7FEFF 		bl	vTaskSuspendAll
2688:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 107


2689:Lib/FreeRTOS/Source/tasks.c ****     /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
2690:Lib/FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 3412              		.loc 1 2690 5
 3413 0026 FFF7FEFF 		bl	vPortEnterCritical
2691:Lib/FreeRTOS/Source/tasks.c ****     {
2692:Lib/FreeRTOS/Source/tasks.c ****         xPendedTicks += xTicksToCatchUp;
 3414              		.loc 1 2692 22
 3415 002a 0C4B     		ldr	r3, .L216+16
 3416 002c 1A68     		ldr	r2, [r3]
 3417 002e 7B68     		ldr	r3, [r7, #4]
 3418 0030 1344     		add	r3, r3, r2
 3419 0032 0A4A     		ldr	r2, .L216+16
 3420 0034 1360     		str	r3, [r2]
2693:Lib/FreeRTOS/Source/tasks.c ****     }
2694:Lib/FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
 3421              		.loc 1 2694 5
 3422 0036 FFF7FEFF 		bl	vPortExitCritical
2695:Lib/FreeRTOS/Source/tasks.c ****     xYieldOccurred = xTaskResumeAll();
 3423              		.loc 1 2695 22
 3424 003a FFF7FEFF 		bl	xTaskResumeAll
 3425 003e F860     		str	r0, [r7, #12]
2696:Lib/FreeRTOS/Source/tasks.c **** 
2697:Lib/FreeRTOS/Source/tasks.c ****     return xYieldOccurred;
 3426              		.loc 1 2697 12
 3427 0040 FB68     		ldr	r3, [r7, #12]
2698:Lib/FreeRTOS/Source/tasks.c **** }
 3428              		.loc 1 2698 1
 3429 0042 1846     		mov	r0, r3
 3430 0044 1037     		adds	r7, r7, #16
 3431              		.cfi_def_cfa_offset 8
 3432 0046 BD46     		mov	sp, r7
 3433              		.cfi_def_cfa_register 13
 3434              		@ sp needed
 3435 0048 80BD     		pop	{r7, pc}
 3436              	.L217:
 3437 004a 00BF     		.align	2
 3438              	.L216:
 3439 004c 00000000 		.word	uxSchedulerSuspended
 3440 0050 00000000 		.word	.LC0
 3441 0054 00000000 		.word	__func__.18
 3442 0058 04000000 		.word	.LC1
 3443 005c 00000000 		.word	xPendedTicks
 3444              		.cfi_endproc
 3445              	.LFE25:
 3447              		.section	.text.xTaskIncrementTick,"ax",%progbits
 3448              		.align	1
 3449              		.global	xTaskIncrementTick
 3450              		.syntax unified
 3451              		.thumb
 3452              		.thumb_func
 3454              	xTaskIncrementTick:
 3455              	.LFB26:
2699:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2700:Lib/FreeRTOS/Source/tasks.c **** 
2701:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskAbortDelay == 1 )
2702:Lib/FreeRTOS/Source/tasks.c **** 
2703:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskAbortDelay( TaskHandle_t xTask )
ARM GAS  /tmp/ccTFOe4z.s 			page 108


2704:Lib/FreeRTOS/Source/tasks.c ****     {
2705:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB = xTask;
2706:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
2707:Lib/FreeRTOS/Source/tasks.c **** 
2708:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxTCB );
2709:Lib/FreeRTOS/Source/tasks.c **** 
2710:Lib/FreeRTOS/Source/tasks.c ****         vTaskSuspendAll();
2711:Lib/FreeRTOS/Source/tasks.c ****         {
2712:Lib/FreeRTOS/Source/tasks.c ****             /* A task can only be prematurely removed from the Blocked state if
2713:Lib/FreeRTOS/Source/tasks.c ****              * it is actually in the Blocked state. */
2714:Lib/FreeRTOS/Source/tasks.c ****             if( eTaskGetState( xTask ) == eBlocked )
2715:Lib/FreeRTOS/Source/tasks.c ****             {
2716:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
2717:Lib/FreeRTOS/Source/tasks.c **** 
2718:Lib/FreeRTOS/Source/tasks.c ****                 /* Remove the reference to the task from the blocked list.  An
2719:Lib/FreeRTOS/Source/tasks.c ****                  * interrupt won't touch the xStateListItem because the
2720:Lib/FreeRTOS/Source/tasks.c ****                  * scheduler is suspended. */
2721:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
2722:Lib/FreeRTOS/Source/tasks.c **** 
2723:Lib/FreeRTOS/Source/tasks.c ****                 /* Is the task waiting on an event also?  If so remove it from
2724:Lib/FreeRTOS/Source/tasks.c ****                  * the event list too.  Interrupts can touch the event list item,
2725:Lib/FreeRTOS/Source/tasks.c ****                  * even though the scheduler is suspended, so a critical section
2726:Lib/FreeRTOS/Source/tasks.c ****                  * is used. */
2727:Lib/FreeRTOS/Source/tasks.c ****                 taskENTER_CRITICAL();
2728:Lib/FreeRTOS/Source/tasks.c ****                 {
2729:Lib/FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
2730:Lib/FreeRTOS/Source/tasks.c ****                     {
2731:Lib/FreeRTOS/Source/tasks.c ****                         ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
2732:Lib/FreeRTOS/Source/tasks.c **** 
2733:Lib/FreeRTOS/Source/tasks.c ****                         /* This lets the task know it was forcibly removed from the
2734:Lib/FreeRTOS/Source/tasks.c ****                          * blocked state so it should not re-evaluate its block time and
2735:Lib/FreeRTOS/Source/tasks.c ****                          * then block again. */
2736:Lib/FreeRTOS/Source/tasks.c ****                         pxTCB->ucDelayAborted = pdTRUE;
2737:Lib/FreeRTOS/Source/tasks.c ****                     }
2738:Lib/FreeRTOS/Source/tasks.c ****                     else
2739:Lib/FreeRTOS/Source/tasks.c ****                     {
2740:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2741:Lib/FreeRTOS/Source/tasks.c ****                     }
2742:Lib/FreeRTOS/Source/tasks.c ****                 }
2743:Lib/FreeRTOS/Source/tasks.c ****                 taskEXIT_CRITICAL();
2744:Lib/FreeRTOS/Source/tasks.c **** 
2745:Lib/FreeRTOS/Source/tasks.c ****                 /* Place the unblocked task into the appropriate ready list. */
2746:Lib/FreeRTOS/Source/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
2747:Lib/FreeRTOS/Source/tasks.c **** 
2748:Lib/FreeRTOS/Source/tasks.c ****                 /* A task being unblocked cannot cause an immediate context
2749:Lib/FreeRTOS/Source/tasks.c ****                  * switch if preemption is turned off. */
2750:Lib/FreeRTOS/Source/tasks.c ****                 #if ( configUSE_PREEMPTION == 1 )
2751:Lib/FreeRTOS/Source/tasks.c ****                 {
2752:Lib/FreeRTOS/Source/tasks.c ****                     /* Preemption is on, but a context switch should only be
2753:Lib/FreeRTOS/Source/tasks.c ****                      * performed if the unblocked task has a priority that is
2754:Lib/FreeRTOS/Source/tasks.c ****                      * higher than the currently executing task. */
2755:Lib/FreeRTOS/Source/tasks.c ****                     if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
2756:Lib/FreeRTOS/Source/tasks.c ****                     {
2757:Lib/FreeRTOS/Source/tasks.c ****                         /* Pend the yield to be performed when the scheduler
2758:Lib/FreeRTOS/Source/tasks.c ****                          * is unsuspended. */
2759:Lib/FreeRTOS/Source/tasks.c ****                         xYieldPending = pdTRUE;
2760:Lib/FreeRTOS/Source/tasks.c ****                     }
ARM GAS  /tmp/ccTFOe4z.s 			page 109


2761:Lib/FreeRTOS/Source/tasks.c ****                     else
2762:Lib/FreeRTOS/Source/tasks.c ****                     {
2763:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2764:Lib/FreeRTOS/Source/tasks.c ****                     }
2765:Lib/FreeRTOS/Source/tasks.c ****                 }
2766:Lib/FreeRTOS/Source/tasks.c ****                 #endif /* configUSE_PREEMPTION */
2767:Lib/FreeRTOS/Source/tasks.c ****             }
2768:Lib/FreeRTOS/Source/tasks.c ****             else
2769:Lib/FreeRTOS/Source/tasks.c ****             {
2770:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdFAIL;
2771:Lib/FreeRTOS/Source/tasks.c ****             }
2772:Lib/FreeRTOS/Source/tasks.c ****         }
2773:Lib/FreeRTOS/Source/tasks.c ****         ( void ) xTaskResumeAll();
2774:Lib/FreeRTOS/Source/tasks.c **** 
2775:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
2776:Lib/FreeRTOS/Source/tasks.c ****     }
2777:Lib/FreeRTOS/Source/tasks.c **** 
2778:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_xTaskAbortDelay */
2779:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
2780:Lib/FreeRTOS/Source/tasks.c **** 
2781:Lib/FreeRTOS/Source/tasks.c **** BaseType_t xTaskIncrementTick( void )
2782:Lib/FreeRTOS/Source/tasks.c **** {
 3456              		.loc 1 2782 1
 3457              		.cfi_startproc
 3458              		@ args = 0, pretend = 0, frame = 32
 3459              		@ frame_needed = 1, uses_anonymous_args = 0
 3460 0000 80B5     		push	{r7, lr}
 3461              		.cfi_def_cfa_offset 8
 3462              		.cfi_offset 7, -8
 3463              		.cfi_offset 14, -4
 3464 0002 88B0     		sub	sp, sp, #32
 3465              		.cfi_def_cfa_offset 40
 3466 0004 00AF     		add	r7, sp, #0
 3467              		.cfi_def_cfa_register 7
2783:Lib/FreeRTOS/Source/tasks.c ****     TCB_t * pxTCB;
2784:Lib/FreeRTOS/Source/tasks.c ****     TickType_t xItemValue;
2785:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xSwitchRequired = pdFALSE;
 3468              		.loc 1 2785 16
 3469 0006 0023     		movs	r3, #0
 3470 0008 FB61     		str	r3, [r7, #28]
2786:Lib/FreeRTOS/Source/tasks.c **** 
2787:Lib/FreeRTOS/Source/tasks.c ****     /* Called by the portable layer each time a tick interrupt occurs.
2788:Lib/FreeRTOS/Source/tasks.c ****      * Increments the tick then checks to see if the new tick value will cause any
2789:Lib/FreeRTOS/Source/tasks.c ****      * tasks to be unblocked. */
2790:Lib/FreeRTOS/Source/tasks.c ****     traceTASK_INCREMENT_TICK( xTickCount );
2791:Lib/FreeRTOS/Source/tasks.c **** 
2792:Lib/FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 3471              		.loc 1 2792 30
 3472 000a 7D4B     		ldr	r3, .L234
 3473 000c 1B68     		ldr	r3, [r3]
 3474              		.loc 1 2792 7
 3475 000e 002B     		cmp	r3, #0
 3476 0010 40F0EB80 		bne	.L219
 3477              	.LBB15:
2793:Lib/FreeRTOS/Source/tasks.c ****     {
2794:Lib/FreeRTOS/Source/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this
2795:Lib/FreeRTOS/Source/tasks.c ****          * block. */
ARM GAS  /tmp/ccTFOe4z.s 			page 110


2796:Lib/FreeRTOS/Source/tasks.c ****         const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 3478              		.loc 1 2796 55
 3479 0014 7B4B     		ldr	r3, .L234+4
 3480 0016 1B68     		ldr	r3, [r3]
 3481              		.loc 1 2796 26
 3482 0018 0133     		adds	r3, r3, #1
 3483 001a BB61     		str	r3, [r7, #24]
2797:Lib/FreeRTOS/Source/tasks.c **** 
2798:Lib/FreeRTOS/Source/tasks.c ****         /* Increment the RTOS tick, switching the delayed and overflowed
2799:Lib/FreeRTOS/Source/tasks.c ****          * delayed lists if it wraps to 0. */
2800:Lib/FreeRTOS/Source/tasks.c ****         xTickCount = xConstTickCount;
 3484              		.loc 1 2800 20
 3485 001c 794A     		ldr	r2, .L234+4
 3486 001e BB69     		ldr	r3, [r7, #24]
 3487 0020 1360     		str	r3, [r2]
2801:Lib/FreeRTOS/Source/tasks.c **** 
2802:Lib/FreeRTOS/Source/tasks.c ****         if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to fa
 3488              		.loc 1 2802 11
 3489 0022 BB69     		ldr	r3, [r7, #24]
 3490 0024 002B     		cmp	r3, #0
 3491 0026 1ED1     		bne	.L220
 3492              	.LBB16:
2803:Lib/FreeRTOS/Source/tasks.c ****         {
2804:Lib/FreeRTOS/Source/tasks.c ****             taskSWITCH_DELAYED_LISTS();
 3493              		.loc 1 2804 13
 3494 0028 774B     		ldr	r3, .L234+8
 3495 002a 1B68     		ldr	r3, [r3]
 3496 002c 1B68     		ldr	r3, [r3]
 3497 002e 002B     		cmp	r3, #0
 3498 0030 08D0     		beq	.L221
 3499              		.loc 1 2804 13 is_stmt 0 discriminator 1
 3500 0032 FFF7FEFF 		bl	ulSetInterruptMask
 3501 0036 754B     		ldr	r3, .L234+12
 3502 0038 754A     		ldr	r2, .L234+16
 3503 003a 40F6F421 		movw	r1, #2804
 3504 003e 7548     		ldr	r0, .L234+20
 3505 0040 FFF7FEFF 		bl	__assert_func
 3506              	.L221:
 3507              		.loc 1 2804 13 discriminator 2
 3508 0044 704B     		ldr	r3, .L234+8
 3509 0046 1B68     		ldr	r3, [r3]
 3510 0048 7B61     		str	r3, [r7, #20]
 3511 004a 734B     		ldr	r3, .L234+24
 3512 004c 1B68     		ldr	r3, [r3]
 3513 004e 6E4A     		ldr	r2, .L234+8
 3514 0050 1360     		str	r3, [r2]
 3515 0052 714A     		ldr	r2, .L234+24
 3516 0054 7B69     		ldr	r3, [r7, #20]
 3517 0056 1360     		str	r3, [r2]
 3518 0058 704B     		ldr	r3, .L234+28
 3519 005a 1B68     		ldr	r3, [r3]
 3520 005c 0133     		adds	r3, r3, #1
 3521 005e 6F4A     		ldr	r2, .L234+28
 3522 0060 1360     		str	r3, [r2]
 3523 0062 FFF7FEFF 		bl	prvResetNextTaskUnblockTime
 3524              	.L220:
 3525              	.LBE16:
ARM GAS  /tmp/ccTFOe4z.s 			page 111


2805:Lib/FreeRTOS/Source/tasks.c ****         }
2806:Lib/FreeRTOS/Source/tasks.c ****         else
2807:Lib/FreeRTOS/Source/tasks.c ****         {
2808:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
2809:Lib/FreeRTOS/Source/tasks.c ****         }
2810:Lib/FreeRTOS/Source/tasks.c **** 
2811:Lib/FreeRTOS/Source/tasks.c ****         /* See if this tick has made a timeout expire.  Tasks are stored in
2812:Lib/FreeRTOS/Source/tasks.c ****          * the  queue in the order of their wake time - meaning once one task
2813:Lib/FreeRTOS/Source/tasks.c ****          * has been found whose block time has not expired there is no need to
2814:Lib/FreeRTOS/Source/tasks.c ****          * look any further down the list. */
2815:Lib/FreeRTOS/Source/tasks.c ****         if( xConstTickCount >= xNextTaskUnblockTime )
 3526              		.loc 1 2815 29 is_stmt 1
 3527 0066 6E4B     		ldr	r3, .L234+32
 3528 0068 1B68     		ldr	r3, [r3]
 3529              		.loc 1 2815 11
 3530 006a BA69     		ldr	r2, [r7, #24]
 3531 006c 9A42     		cmp	r2, r3
 3532 006e C0F0A780 		bcc	.L222
 3533              	.L230:
2816:Lib/FreeRTOS/Source/tasks.c ****         {
2817:Lib/FreeRTOS/Source/tasks.c ****             for( ; ; )
2818:Lib/FreeRTOS/Source/tasks.c ****             {
2819:Lib/FreeRTOS/Source/tasks.c ****                 if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 3534              		.loc 1 2819 21
 3535 0072 654B     		ldr	r3, .L234+8
 3536 0074 1B68     		ldr	r3, [r3]
 3537 0076 1B68     		ldr	r3, [r3]
 3538              		.loc 1 2819 19
 3539 0078 002B     		cmp	r3, #0
 3540 007a 04D1     		bne	.L223
2820:Lib/FreeRTOS/Source/tasks.c ****                 {
2821:Lib/FreeRTOS/Source/tasks.c ****                     /* The delayed list is empty.  Set xNextTaskUnblockTime
2822:Lib/FreeRTOS/Source/tasks.c ****                      * to the maximum possible value so it is extremely
2823:Lib/FreeRTOS/Source/tasks.c ****                      * unlikely that the
2824:Lib/FreeRTOS/Source/tasks.c ****                      * if( xTickCount >= xNextTaskUnblockTime ) test will pass
2825:Lib/FreeRTOS/Source/tasks.c ****                      * next time through. */
2826:Lib/FreeRTOS/Source/tasks.c ****                     xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts
 3541              		.loc 1 2826 42
 3542 007c 684B     		ldr	r3, .L234+32
 3543 007e 4FF0FF32 		mov	r2, #-1
 3544 0082 1A60     		str	r2, [r3]
2827:Lib/FreeRTOS/Source/tasks.c ****                     break;
 3545              		.loc 1 2827 21
 3546 0084 9CE0     		b	.L222
 3547              	.L223:
2828:Lib/FreeRTOS/Source/tasks.c ****                 }
2829:Lib/FreeRTOS/Source/tasks.c ****                 else
2830:Lib/FreeRTOS/Source/tasks.c ****                 {
2831:Lib/FreeRTOS/Source/tasks.c ****                     /* The delayed list is not empty, get the value of the
2832:Lib/FreeRTOS/Source/tasks.c ****                      * item at the head of the delayed list.  This is the time
2833:Lib/FreeRTOS/Source/tasks.c ****                      * at which the task at the head of the delayed list must
2834:Lib/FreeRTOS/Source/tasks.c ****                      * be removed from the Blocked state. */
2835:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * 
 3548              		.loc 1 2835 29
 3549 0086 604B     		ldr	r3, .L234+8
 3550 0088 1B68     		ldr	r3, [r3]
 3551 008a DB68     		ldr	r3, [r3, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 112


 3552              		.loc 1 2835 27
 3553 008c DB68     		ldr	r3, [r3, #12]
 3554 008e 3B61     		str	r3, [r7, #16]
2836:Lib/FreeRTOS/Source/tasks.c ****                     xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 3555              		.loc 1 2836 32
 3556 0090 3B69     		ldr	r3, [r7, #16]
 3557 0092 5B68     		ldr	r3, [r3, #4]
 3558 0094 FB60     		str	r3, [r7, #12]
2837:Lib/FreeRTOS/Source/tasks.c **** 
2838:Lib/FreeRTOS/Source/tasks.c ****                     if( xConstTickCount < xItemValue )
 3559              		.loc 1 2838 23
 3560 0096 BA69     		ldr	r2, [r7, #24]
 3561 0098 FB68     		ldr	r3, [r7, #12]
 3562 009a 9A42     		cmp	r2, r3
 3563 009c 03D2     		bcs	.L224
2839:Lib/FreeRTOS/Source/tasks.c ****                     {
2840:Lib/FreeRTOS/Source/tasks.c ****                         /* It is not time to unblock this item yet, but the
2841:Lib/FreeRTOS/Source/tasks.c ****                          * item value is the time at which the task at the head
2842:Lib/FreeRTOS/Source/tasks.c ****                          * of the blocked list must be removed from the Blocked
2843:Lib/FreeRTOS/Source/tasks.c ****                          * state -  so record the item value in
2844:Lib/FreeRTOS/Source/tasks.c ****                          * xNextTaskUnblockTime. */
2845:Lib/FreeRTOS/Source/tasks.c ****                         xNextTaskUnblockTime = xItemValue;
 3564              		.loc 1 2845 46
 3565 009e 604A     		ldr	r2, .L234+32
 3566 00a0 FB68     		ldr	r3, [r7, #12]
 3567 00a2 1360     		str	r3, [r2]
2846:Lib/FreeRTOS/Source/tasks.c ****                         break; /*lint !e9011 Code structure here is deemed easier to understand wit
 3568              		.loc 1 2846 25
 3569 00a4 8CE0     		b	.L222
 3570              	.L224:
 3571              	.LBB17:
2847:Lib/FreeRTOS/Source/tasks.c ****                     }
2848:Lib/FreeRTOS/Source/tasks.c ****                     else
2849:Lib/FreeRTOS/Source/tasks.c ****                     {
2850:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2851:Lib/FreeRTOS/Source/tasks.c ****                     }
2852:Lib/FreeRTOS/Source/tasks.c **** 
2853:Lib/FreeRTOS/Source/tasks.c ****                     /* It is time to remove the item from the Blocked state. */
2854:Lib/FreeRTOS/Source/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 3572              		.loc 1 2854 21
 3573 00a6 3B69     		ldr	r3, [r7, #16]
 3574 00a8 5B69     		ldr	r3, [r3, #20]
 3575 00aa BB60     		str	r3, [r7, #8]
 3576 00ac 3B69     		ldr	r3, [r7, #16]
 3577 00ae 9B68     		ldr	r3, [r3, #8]
 3578 00b0 3A69     		ldr	r2, [r7, #16]
 3579 00b2 D268     		ldr	r2, [r2, #12]
 3580 00b4 9A60     		str	r2, [r3, #8]
 3581 00b6 3B69     		ldr	r3, [r7, #16]
 3582 00b8 DB68     		ldr	r3, [r3, #12]
 3583 00ba 3A69     		ldr	r2, [r7, #16]
 3584 00bc 9268     		ldr	r2, [r2, #8]
 3585 00be 5A60     		str	r2, [r3, #4]
 3586 00c0 BB68     		ldr	r3, [r7, #8]
 3587 00c2 5A68     		ldr	r2, [r3, #4]
 3588 00c4 3B69     		ldr	r3, [r7, #16]
 3589 00c6 0433     		adds	r3, r3, #4
ARM GAS  /tmp/ccTFOe4z.s 			page 113


 3590 00c8 9A42     		cmp	r2, r3
 3591 00ca 03D1     		bne	.L225
 3592              		.loc 1 2854 21 is_stmt 0 discriminator 1
 3593 00cc 3B69     		ldr	r3, [r7, #16]
 3594 00ce DA68     		ldr	r2, [r3, #12]
 3595 00d0 BB68     		ldr	r3, [r7, #8]
 3596 00d2 5A60     		str	r2, [r3, #4]
 3597              	.L225:
 3598              		.loc 1 2854 21 discriminator 3
 3599 00d4 3B69     		ldr	r3, [r7, #16]
 3600 00d6 0022     		movs	r2, #0
 3601 00d8 5A61     		str	r2, [r3, #20]
 3602 00da BB68     		ldr	r3, [r7, #8]
 3603 00dc 1B68     		ldr	r3, [r3]
 3604 00de 5A1E     		subs	r2, r3, #1
 3605 00e0 BB68     		ldr	r3, [r7, #8]
 3606 00e2 1A60     		str	r2, [r3]
 3607              	.LBE17:
2855:Lib/FreeRTOS/Source/tasks.c **** 
2856:Lib/FreeRTOS/Source/tasks.c ****                     /* Is the task waiting on an event also?  If so remove
2857:Lib/FreeRTOS/Source/tasks.c ****                      * it from the event list. */
2858:Lib/FreeRTOS/Source/tasks.c ****                     if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 3608              		.loc 1 2858 25 is_stmt 1
 3609 00e4 3B69     		ldr	r3, [r7, #16]
 3610 00e6 9B6A     		ldr	r3, [r3, #40]
 3611              		.loc 1 2858 23
 3612 00e8 002B     		cmp	r3, #0
 3613 00ea 1ED0     		beq	.L226
 3614              	.LBB18:
2859:Lib/FreeRTOS/Source/tasks.c ****                     {
2860:Lib/FreeRTOS/Source/tasks.c ****                         listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 3615              		.loc 1 2860 25
 3616 00ec 3B69     		ldr	r3, [r7, #16]
 3617 00ee 9B6A     		ldr	r3, [r3, #40]
 3618 00f0 7B60     		str	r3, [r7, #4]
 3619 00f2 3B69     		ldr	r3, [r7, #16]
 3620 00f4 DB69     		ldr	r3, [r3, #28]
 3621 00f6 3A69     		ldr	r2, [r7, #16]
 3622 00f8 126A     		ldr	r2, [r2, #32]
 3623 00fa 9A60     		str	r2, [r3, #8]
 3624 00fc 3B69     		ldr	r3, [r7, #16]
 3625 00fe 1B6A     		ldr	r3, [r3, #32]
 3626 0100 3A69     		ldr	r2, [r7, #16]
 3627 0102 D269     		ldr	r2, [r2, #28]
 3628 0104 5A60     		str	r2, [r3, #4]
 3629 0106 7B68     		ldr	r3, [r7, #4]
 3630 0108 5A68     		ldr	r2, [r3, #4]
 3631 010a 3B69     		ldr	r3, [r7, #16]
 3632 010c 1833     		adds	r3, r3, #24
 3633 010e 9A42     		cmp	r2, r3
 3634 0110 03D1     		bne	.L227
 3635              		.loc 1 2860 25 is_stmt 0 discriminator 1
 3636 0112 3B69     		ldr	r3, [r7, #16]
 3637 0114 1A6A     		ldr	r2, [r3, #32]
 3638 0116 7B68     		ldr	r3, [r7, #4]
 3639 0118 5A60     		str	r2, [r3, #4]
 3640              	.L227:
ARM GAS  /tmp/ccTFOe4z.s 			page 114


 3641              		.loc 1 2860 25 discriminator 3
 3642 011a 3B69     		ldr	r3, [r7, #16]
 3643 011c 0022     		movs	r2, #0
 3644 011e 9A62     		str	r2, [r3, #40]
 3645 0120 7B68     		ldr	r3, [r7, #4]
 3646 0122 1B68     		ldr	r3, [r3]
 3647 0124 5A1E     		subs	r2, r3, #1
 3648 0126 7B68     		ldr	r3, [r7, #4]
 3649 0128 1A60     		str	r2, [r3]
 3650              	.L226:
 3651              	.LBE18:
2861:Lib/FreeRTOS/Source/tasks.c ****                     }
2862:Lib/FreeRTOS/Source/tasks.c ****                     else
2863:Lib/FreeRTOS/Source/tasks.c ****                     {
2864:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
2865:Lib/FreeRTOS/Source/tasks.c ****                     }
2866:Lib/FreeRTOS/Source/tasks.c **** 
2867:Lib/FreeRTOS/Source/tasks.c ****                     /* Place the unblocked task into the appropriate ready
2868:Lib/FreeRTOS/Source/tasks.c ****                      * list. */
2869:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 3652              		.loc 1 2869 21 is_stmt 1
 3653 012a 3B69     		ldr	r3, [r7, #16]
 3654 012c DA6A     		ldr	r2, [r3, #44]
 3655 012e 3D4B     		ldr	r3, .L234+36
 3656 0130 1B68     		ldr	r3, [r3]
 3657 0132 9A42     		cmp	r2, r3
 3658 0134 03D9     		bls	.L228
 3659              		.loc 1 2869 21 is_stmt 0 discriminator 1
 3660 0136 3B69     		ldr	r3, [r7, #16]
 3661 0138 DB6A     		ldr	r3, [r3, #44]
 3662 013a 3A4A     		ldr	r2, .L234+36
 3663 013c 1360     		str	r3, [r2]
 3664              	.L228:
 3665              	.LBB19:
 3666              		.loc 1 2869 21 discriminator 3
 3667 013e 3B69     		ldr	r3, [r7, #16]
 3668 0140 DA6A     		ldr	r2, [r3, #44]
 3669 0142 3949     		ldr	r1, .L234+40
 3670 0144 1346     		mov	r3, r2
 3671 0146 9B00     		lsls	r3, r3, #2
 3672 0148 1344     		add	r3, r3, r2
 3673 014a 9B00     		lsls	r3, r3, #2
 3674 014c 0B44     		add	r3, r3, r1
 3675 014e 0433     		adds	r3, r3, #4
 3676 0150 1B68     		ldr	r3, [r3]
 3677 0152 3B60     		str	r3, [r7]
 3678 0154 3B69     		ldr	r3, [r7, #16]
 3679 0156 3A68     		ldr	r2, [r7]
 3680 0158 9A60     		str	r2, [r3, #8]
 3681 015a 3B68     		ldr	r3, [r7]
 3682 015c 9A68     		ldr	r2, [r3, #8]
 3683 015e 3B69     		ldr	r3, [r7, #16]
 3684 0160 DA60     		str	r2, [r3, #12]
 3685 0162 3B68     		ldr	r3, [r7]
 3686 0164 9B68     		ldr	r3, [r3, #8]
 3687 0166 3A69     		ldr	r2, [r7, #16]
 3688 0168 0432     		adds	r2, r2, #4
ARM GAS  /tmp/ccTFOe4z.s 			page 115


 3689 016a 5A60     		str	r2, [r3, #4]
 3690 016c 3B69     		ldr	r3, [r7, #16]
 3691 016e 1A1D     		adds	r2, r3, #4
 3692 0170 3B68     		ldr	r3, [r7]
 3693 0172 9A60     		str	r2, [r3, #8]
 3694 0174 3B69     		ldr	r3, [r7, #16]
 3695 0176 DA6A     		ldr	r2, [r3, #44]
 3696 0178 1346     		mov	r3, r2
 3697 017a 9B00     		lsls	r3, r3, #2
 3698 017c 1344     		add	r3, r3, r2
 3699 017e 9B00     		lsls	r3, r3, #2
 3700 0180 294A     		ldr	r2, .L234+40
 3701 0182 1A44     		add	r2, r2, r3
 3702 0184 3B69     		ldr	r3, [r7, #16]
 3703 0186 5A61     		str	r2, [r3, #20]
 3704 0188 3B69     		ldr	r3, [r7, #16]
 3705 018a DA6A     		ldr	r2, [r3, #44]
 3706 018c 2649     		ldr	r1, .L234+40
 3707 018e 1346     		mov	r3, r2
 3708 0190 9B00     		lsls	r3, r3, #2
 3709 0192 1344     		add	r3, r3, r2
 3710 0194 9B00     		lsls	r3, r3, #2
 3711 0196 0B44     		add	r3, r3, r1
 3712 0198 1B68     		ldr	r3, [r3]
 3713 019a 591C     		adds	r1, r3, #1
 3714 019c 2248     		ldr	r0, .L234+40
 3715 019e 1346     		mov	r3, r2
 3716 01a0 9B00     		lsls	r3, r3, #2
 3717 01a2 1344     		add	r3, r3, r2
 3718 01a4 9B00     		lsls	r3, r3, #2
 3719 01a6 0344     		add	r3, r3, r0
 3720 01a8 1960     		str	r1, [r3]
 3721              	.LBE19:
2870:Lib/FreeRTOS/Source/tasks.c **** 
2871:Lib/FreeRTOS/Source/tasks.c ****                     /* A task being unblocked cannot cause an immediate
2872:Lib/FreeRTOS/Source/tasks.c ****                      * context switch if preemption is turned off. */
2873:Lib/FreeRTOS/Source/tasks.c ****                     #if ( configUSE_PREEMPTION == 1 )
2874:Lib/FreeRTOS/Source/tasks.c ****                     {
2875:Lib/FreeRTOS/Source/tasks.c ****                         /* Preemption is on, but a context switch should
2876:Lib/FreeRTOS/Source/tasks.c ****                          * only be performed if the unblocked task's
2877:Lib/FreeRTOS/Source/tasks.c ****                          * priority is higher than the currently executing
2878:Lib/FreeRTOS/Source/tasks.c ****                          * task.
2879:Lib/FreeRTOS/Source/tasks.c ****                          * The case of equal priority tasks sharing
2880:Lib/FreeRTOS/Source/tasks.c ****                          * processing time (which happens when both
2881:Lib/FreeRTOS/Source/tasks.c ****                          * preemption and time slicing are on) is
2882:Lib/FreeRTOS/Source/tasks.c ****                          * handled below.*/
2883:Lib/FreeRTOS/Source/tasks.c ****                         if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 3722              		.loc 1 2883 34 is_stmt 1
 3723 01aa 3B69     		ldr	r3, [r7, #16]
 3724 01ac DA6A     		ldr	r2, [r3, #44]
 3725              		.loc 1 2883 61
 3726 01ae 1F4B     		ldr	r3, .L234+44
 3727 01b0 1B68     		ldr	r3, [r3]
 3728 01b2 DB6A     		ldr	r3, [r3, #44]
 3729              		.loc 1 2883 27
 3730 01b4 9A42     		cmp	r2, r3
 3731 01b6 7FF65CAF 		bls	.L230
ARM GAS  /tmp/ccTFOe4z.s 			page 116


2884:Lib/FreeRTOS/Source/tasks.c ****                         {
2885:Lib/FreeRTOS/Source/tasks.c ****                             xSwitchRequired = pdTRUE;
 3732              		.loc 1 2885 45
 3733 01ba 0123     		movs	r3, #1
 3734 01bc FB61     		str	r3, [r7, #28]
2819:Lib/FreeRTOS/Source/tasks.c ****                 {
 3735              		.loc 1 2819 19
 3736 01be 58E7     		b	.L230
 3737              	.L222:
2886:Lib/FreeRTOS/Source/tasks.c ****                         }
2887:Lib/FreeRTOS/Source/tasks.c ****                         else
2888:Lib/FreeRTOS/Source/tasks.c ****                         {
2889:Lib/FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
2890:Lib/FreeRTOS/Source/tasks.c ****                         }
2891:Lib/FreeRTOS/Source/tasks.c ****                     }
2892:Lib/FreeRTOS/Source/tasks.c ****                     #endif /* configUSE_PREEMPTION */
2893:Lib/FreeRTOS/Source/tasks.c ****                 }
2894:Lib/FreeRTOS/Source/tasks.c ****             }
2895:Lib/FreeRTOS/Source/tasks.c ****         }
2896:Lib/FreeRTOS/Source/tasks.c **** 
2897:Lib/FreeRTOS/Source/tasks.c ****         /* Tasks of equal priority to the currently running task will share
2898:Lib/FreeRTOS/Source/tasks.c ****          * processing time (time slice) if preemption is on, and the application
2899:Lib/FreeRTOS/Source/tasks.c ****          * writer has not explicitly turned time slicing off. */
2900:Lib/FreeRTOS/Source/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
2901:Lib/FreeRTOS/Source/tasks.c ****         {
2902:Lib/FreeRTOS/Source/tasks.c ****             if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( U
 3738              		.loc 1 2902 17
 3739 01c0 1A4B     		ldr	r3, .L234+44
 3740 01c2 1B68     		ldr	r3, [r3]
 3741 01c4 DA6A     		ldr	r2, [r3, #44]
 3742 01c6 1849     		ldr	r1, .L234+40
 3743 01c8 1346     		mov	r3, r2
 3744 01ca 9B00     		lsls	r3, r3, #2
 3745 01cc 1344     		add	r3, r3, r2
 3746 01ce 9B00     		lsls	r3, r3, #2
 3747 01d0 0B44     		add	r3, r3, r1
 3748 01d2 1B68     		ldr	r3, [r3]
 3749              		.loc 1 2902 15
 3750 01d4 012B     		cmp	r3, #1
 3751 01d6 01D9     		bls	.L231
2903:Lib/FreeRTOS/Source/tasks.c ****             {
2904:Lib/FreeRTOS/Source/tasks.c ****                 xSwitchRequired = pdTRUE;
 3752              		.loc 1 2904 33
 3753 01d8 0123     		movs	r3, #1
 3754 01da FB61     		str	r3, [r7, #28]
 3755              	.L231:
2905:Lib/FreeRTOS/Source/tasks.c ****             }
2906:Lib/FreeRTOS/Source/tasks.c ****             else
2907:Lib/FreeRTOS/Source/tasks.c ****             {
2908:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2909:Lib/FreeRTOS/Source/tasks.c ****             }
2910:Lib/FreeRTOS/Source/tasks.c ****         }
2911:Lib/FreeRTOS/Source/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
2912:Lib/FreeRTOS/Source/tasks.c **** 
2913:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2914:Lib/FreeRTOS/Source/tasks.c ****         {
2915:Lib/FreeRTOS/Source/tasks.c ****             /* Guard against the tick hook being called when the pended tick
ARM GAS  /tmp/ccTFOe4z.s 			page 117


2916:Lib/FreeRTOS/Source/tasks.c ****              * count is being unwound (when the scheduler is being unlocked). */
2917:Lib/FreeRTOS/Source/tasks.c ****             if( xPendedTicks == ( TickType_t ) 0 )
2918:Lib/FreeRTOS/Source/tasks.c ****             {
2919:Lib/FreeRTOS/Source/tasks.c ****                 vApplicationTickHook();
2920:Lib/FreeRTOS/Source/tasks.c ****             }
2921:Lib/FreeRTOS/Source/tasks.c ****             else
2922:Lib/FreeRTOS/Source/tasks.c ****             {
2923:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2924:Lib/FreeRTOS/Source/tasks.c ****             }
2925:Lib/FreeRTOS/Source/tasks.c ****         }
2926:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TICK_HOOK */
2927:Lib/FreeRTOS/Source/tasks.c **** 
2928:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_PREEMPTION == 1 )
2929:Lib/FreeRTOS/Source/tasks.c ****         {
2930:Lib/FreeRTOS/Source/tasks.c ****             if( xYieldPending != pdFALSE )
 3756              		.loc 1 2930 31
 3757 01dc 144B     		ldr	r3, .L234+48
 3758 01de 1B68     		ldr	r3, [r3]
 3759              		.loc 1 2930 15
 3760 01e0 002B     		cmp	r3, #0
 3761 01e2 07D0     		beq	.L232
2931:Lib/FreeRTOS/Source/tasks.c ****             {
2932:Lib/FreeRTOS/Source/tasks.c ****                 xSwitchRequired = pdTRUE;
 3762              		.loc 1 2932 33
 3763 01e4 0123     		movs	r3, #1
 3764 01e6 FB61     		str	r3, [r7, #28]
 3765 01e8 04E0     		b	.L232
 3766              	.L219:
 3767              	.LBE15:
2933:Lib/FreeRTOS/Source/tasks.c ****             }
2934:Lib/FreeRTOS/Source/tasks.c ****             else
2935:Lib/FreeRTOS/Source/tasks.c ****             {
2936:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
2937:Lib/FreeRTOS/Source/tasks.c ****             }
2938:Lib/FreeRTOS/Source/tasks.c ****         }
2939:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_PREEMPTION */
2940:Lib/FreeRTOS/Source/tasks.c ****     }
2941:Lib/FreeRTOS/Source/tasks.c ****     else
2942:Lib/FreeRTOS/Source/tasks.c ****     {
2943:Lib/FreeRTOS/Source/tasks.c ****         ++xPendedTicks;
 3768              		.loc 1 2943 9
 3769 01ea 124B     		ldr	r3, .L234+52
 3770 01ec 1B68     		ldr	r3, [r3]
 3771 01ee 0133     		adds	r3, r3, #1
 3772 01f0 104A     		ldr	r2, .L234+52
 3773 01f2 1360     		str	r3, [r2]
 3774              	.L232:
2944:Lib/FreeRTOS/Source/tasks.c **** 
2945:Lib/FreeRTOS/Source/tasks.c ****         /* The tick hook gets called at regular intervals, even if the
2946:Lib/FreeRTOS/Source/tasks.c ****          * scheduler is locked. */
2947:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICK_HOOK == 1 )
2948:Lib/FreeRTOS/Source/tasks.c ****         {
2949:Lib/FreeRTOS/Source/tasks.c ****             vApplicationTickHook();
2950:Lib/FreeRTOS/Source/tasks.c ****         }
2951:Lib/FreeRTOS/Source/tasks.c ****         #endif
2952:Lib/FreeRTOS/Source/tasks.c ****     }
2953:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 118


2954:Lib/FreeRTOS/Source/tasks.c ****     return xSwitchRequired;
 3775              		.loc 1 2954 12
 3776 01f4 FB69     		ldr	r3, [r7, #28]
2955:Lib/FreeRTOS/Source/tasks.c **** }
 3777              		.loc 1 2955 1
 3778 01f6 1846     		mov	r0, r3
 3779 01f8 2037     		adds	r7, r7, #32
 3780              		.cfi_def_cfa_offset 8
 3781 01fa BD46     		mov	sp, r7
 3782              		.cfi_def_cfa_register 13
 3783              		@ sp needed
 3784 01fc 80BD     		pop	{r7, pc}
 3785              	.L235:
 3786 01fe 00BF     		.align	2
 3787              	.L234:
 3788 0200 00000000 		.word	uxSchedulerSuspended
 3789 0204 00000000 		.word	xTickCount
 3790 0208 00000000 		.word	pxDelayedTaskList
 3791 020c 00000000 		.word	.LC0
 3792 0210 00000000 		.word	__func__.17
 3793 0214 04000000 		.word	.LC1
 3794 0218 00000000 		.word	pxOverflowDelayedTaskList
 3795 021c 00000000 		.word	xNumOfOverflows
 3796 0220 00000000 		.word	xNextTaskUnblockTime
 3797 0224 00000000 		.word	uxTopReadyPriority
 3798 0228 00000000 		.word	pxReadyTasksLists
 3799 022c 00000000 		.word	pxCurrentTCB
 3800 0230 00000000 		.word	xYieldPending
 3801 0234 00000000 		.word	xPendedTicks
 3802              		.cfi_endproc
 3803              	.LFE26:
 3805              		.section	.text.vTaskSwitchContext,"ax",%progbits
 3806              		.align	1
 3807              		.global	vTaskSwitchContext
 3808              		.syntax unified
 3809              		.thumb
 3810              		.thumb_func
 3812              	vTaskSwitchContext:
 3813              	.LFB27:
2956:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2957:Lib/FreeRTOS/Source/tasks.c **** 
2958:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2959:Lib/FreeRTOS/Source/tasks.c **** 
2960:Lib/FreeRTOS/Source/tasks.c ****     void vTaskSetApplicationTaskTag( TaskHandle_t xTask,
2961:Lib/FreeRTOS/Source/tasks.c ****                                      TaskHookFunction_t pxHookFunction )
2962:Lib/FreeRTOS/Source/tasks.c ****     {
2963:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * xTCB;
2964:Lib/FreeRTOS/Source/tasks.c **** 
2965:Lib/FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then it is the task hook of the calling task that is
2966:Lib/FreeRTOS/Source/tasks.c ****          * getting set. */
2967:Lib/FreeRTOS/Source/tasks.c ****         if( xTask == NULL )
2968:Lib/FreeRTOS/Source/tasks.c ****         {
2969:Lib/FreeRTOS/Source/tasks.c ****             xTCB = ( TCB_t * ) pxCurrentTCB;
2970:Lib/FreeRTOS/Source/tasks.c ****         }
2971:Lib/FreeRTOS/Source/tasks.c ****         else
2972:Lib/FreeRTOS/Source/tasks.c ****         {
2973:Lib/FreeRTOS/Source/tasks.c ****             xTCB = xTask;
ARM GAS  /tmp/ccTFOe4z.s 			page 119


2974:Lib/FreeRTOS/Source/tasks.c ****         }
2975:Lib/FreeRTOS/Source/tasks.c **** 
2976:Lib/FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2977:Lib/FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
2978:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
2979:Lib/FreeRTOS/Source/tasks.c ****         {
2980:Lib/FreeRTOS/Source/tasks.c ****             xTCB->pxTaskTag = pxHookFunction;
2981:Lib/FreeRTOS/Source/tasks.c ****         }
2982:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
2983:Lib/FreeRTOS/Source/tasks.c ****     }
2984:Lib/FreeRTOS/Source/tasks.c **** 
2985:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
2986:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2987:Lib/FreeRTOS/Source/tasks.c **** 
2988:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2989:Lib/FreeRTOS/Source/tasks.c **** 
2990:Lib/FreeRTOS/Source/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2991:Lib/FreeRTOS/Source/tasks.c ****     {
2992:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
2993:Lib/FreeRTOS/Source/tasks.c ****         TaskHookFunction_t xReturn;
2994:Lib/FreeRTOS/Source/tasks.c **** 
2995:Lib/FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
2996:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
2997:Lib/FreeRTOS/Source/tasks.c **** 
2998:Lib/FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
2999:Lib/FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
3000:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
3001:Lib/FreeRTOS/Source/tasks.c ****         {
3002:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pxTCB->pxTaskTag;
3003:Lib/FreeRTOS/Source/tasks.c ****         }
3004:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
3005:Lib/FreeRTOS/Source/tasks.c **** 
3006:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
3007:Lib/FreeRTOS/Source/tasks.c ****     }
3008:Lib/FreeRTOS/Source/tasks.c **** 
3009:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
3010:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3011:Lib/FreeRTOS/Source/tasks.c **** 
3012:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
3013:Lib/FreeRTOS/Source/tasks.c **** 
3014:Lib/FreeRTOS/Source/tasks.c ****     TaskHookFunction_t xTaskGetApplicationTaskTagFromISR( TaskHandle_t xTask )
3015:Lib/FreeRTOS/Source/tasks.c ****     {
3016:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3017:Lib/FreeRTOS/Source/tasks.c ****         TaskHookFunction_t xReturn;
3018:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
3019:Lib/FreeRTOS/Source/tasks.c **** 
3020:Lib/FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then set the calling task's hook. */
3021:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3022:Lib/FreeRTOS/Source/tasks.c **** 
3023:Lib/FreeRTOS/Source/tasks.c ****         /* Save the hook function in the TCB.  A critical section is required as
3024:Lib/FreeRTOS/Source/tasks.c ****          * the value can be accessed from an interrupt. */
3025:Lib/FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
3026:Lib/FreeRTOS/Source/tasks.c ****         {
3027:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pxTCB->pxTaskTag;
3028:Lib/FreeRTOS/Source/tasks.c ****         }
3029:Lib/FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
3030:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 120


3031:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
3032:Lib/FreeRTOS/Source/tasks.c ****     }
3033:Lib/FreeRTOS/Source/tasks.c **** 
3034:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
3035:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3036:Lib/FreeRTOS/Source/tasks.c **** 
3037:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
3038:Lib/FreeRTOS/Source/tasks.c **** 
3039:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask,
3040:Lib/FreeRTOS/Source/tasks.c ****                                              void * pvParameter )
3041:Lib/FreeRTOS/Source/tasks.c ****     {
3042:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * xTCB;
3043:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
3044:Lib/FreeRTOS/Source/tasks.c **** 
3045:Lib/FreeRTOS/Source/tasks.c ****         /* If xTask is NULL then we are calling our own task hook. */
3046:Lib/FreeRTOS/Source/tasks.c ****         if( xTask == NULL )
3047:Lib/FreeRTOS/Source/tasks.c ****         {
3048:Lib/FreeRTOS/Source/tasks.c ****             xTCB = pxCurrentTCB;
3049:Lib/FreeRTOS/Source/tasks.c ****         }
3050:Lib/FreeRTOS/Source/tasks.c ****         else
3051:Lib/FreeRTOS/Source/tasks.c ****         {
3052:Lib/FreeRTOS/Source/tasks.c ****             xTCB = xTask;
3053:Lib/FreeRTOS/Source/tasks.c ****         }
3054:Lib/FreeRTOS/Source/tasks.c **** 
3055:Lib/FreeRTOS/Source/tasks.c ****         if( xTCB->pxTaskTag != NULL )
3056:Lib/FreeRTOS/Source/tasks.c ****         {
3057:Lib/FreeRTOS/Source/tasks.c ****             xReturn = xTCB->pxTaskTag( pvParameter );
3058:Lib/FreeRTOS/Source/tasks.c ****         }
3059:Lib/FreeRTOS/Source/tasks.c ****         else
3060:Lib/FreeRTOS/Source/tasks.c ****         {
3061:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdFAIL;
3062:Lib/FreeRTOS/Source/tasks.c ****         }
3063:Lib/FreeRTOS/Source/tasks.c **** 
3064:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
3065:Lib/FreeRTOS/Source/tasks.c ****     }
3066:Lib/FreeRTOS/Source/tasks.c **** 
3067:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_APPLICATION_TASK_TAG */
3068:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3069:Lib/FreeRTOS/Source/tasks.c **** 
3070:Lib/FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
3071:Lib/FreeRTOS/Source/tasks.c **** {
 3814              		.loc 1 3071 1
 3815              		.cfi_startproc
 3816              		@ args = 0, pretend = 0, frame = 8
 3817              		@ frame_needed = 1, uses_anonymous_args = 0
 3818 0000 80B5     		push	{r7, lr}
 3819              		.cfi_def_cfa_offset 8
 3820              		.cfi_offset 7, -8
 3821              		.cfi_offset 14, -4
 3822 0002 82B0     		sub	sp, sp, #8
 3823              		.cfi_def_cfa_offset 16
 3824 0004 00AF     		add	r7, sp, #0
 3825              		.cfi_def_cfa_register 7
3072:Lib/FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
 3826              		.loc 1 3072 30
 3827 0006 324B     		ldr	r3, .L245
 3828 0008 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 121


 3829              		.loc 1 3072 7
 3830 000a 002B     		cmp	r3, #0
 3831 000c 03D0     		beq	.L237
3073:Lib/FreeRTOS/Source/tasks.c ****     {
3074:Lib/FreeRTOS/Source/tasks.c ****         /* The scheduler is currently suspended - do not allow a context
3075:Lib/FreeRTOS/Source/tasks.c ****          * switch. */
3076:Lib/FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
 3832              		.loc 1 3076 23
 3833 000e 314B     		ldr	r3, .L245+4
 3834 0010 0122     		movs	r2, #1
 3835 0012 1A60     		str	r2, [r3]
3077:Lib/FreeRTOS/Source/tasks.c ****     }
3078:Lib/FreeRTOS/Source/tasks.c ****     else
3079:Lib/FreeRTOS/Source/tasks.c ****     {
3080:Lib/FreeRTOS/Source/tasks.c ****         xYieldPending = pdFALSE;
3081:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_OUT();
3082:Lib/FreeRTOS/Source/tasks.c **** 
3083:Lib/FreeRTOS/Source/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3084:Lib/FreeRTOS/Source/tasks.c ****         {
3085:Lib/FreeRTOS/Source/tasks.c ****             #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
3086:Lib/FreeRTOS/Source/tasks.c ****                 portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
3087:Lib/FreeRTOS/Source/tasks.c ****             #else
3088:Lib/FreeRTOS/Source/tasks.c ****                 ulTotalRunTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COUNTER_VALUE();
3089:Lib/FreeRTOS/Source/tasks.c ****             #endif
3090:Lib/FreeRTOS/Source/tasks.c **** 
3091:Lib/FreeRTOS/Source/tasks.c ****             /* Add the amount of time the task has been running to the
3092:Lib/FreeRTOS/Source/tasks.c ****              * accumulated time so far.  The time the task started running was
3093:Lib/FreeRTOS/Source/tasks.c ****              * stored in ulTaskSwitchedInTime.  Note that there is no overflow
3094:Lib/FreeRTOS/Source/tasks.c ****              * protection here so count values are only valid until the timer
3095:Lib/FreeRTOS/Source/tasks.c ****              * overflows.  The guard against negative values is to protect
3096:Lib/FreeRTOS/Source/tasks.c ****              * against suspect run time stat counter implementations - which
3097:Lib/FreeRTOS/Source/tasks.c ****              * are provided by the application, not the kernel. */
3098:Lib/FreeRTOS/Source/tasks.c ****             if( ulTotalRunTime > ulTaskSwitchedInTime )
3099:Lib/FreeRTOS/Source/tasks.c ****             {
3100:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
3101:Lib/FreeRTOS/Source/tasks.c ****             }
3102:Lib/FreeRTOS/Source/tasks.c ****             else
3103:Lib/FreeRTOS/Source/tasks.c ****             {
3104:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
3105:Lib/FreeRTOS/Source/tasks.c ****             }
3106:Lib/FreeRTOS/Source/tasks.c **** 
3107:Lib/FreeRTOS/Source/tasks.c ****             ulTaskSwitchedInTime = ulTotalRunTime;
3108:Lib/FreeRTOS/Source/tasks.c ****         }
3109:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configGENERATE_RUN_TIME_STATS */
3110:Lib/FreeRTOS/Source/tasks.c **** 
3111:Lib/FreeRTOS/Source/tasks.c ****         /* Check for stack overflow, if configured. */
3112:Lib/FreeRTOS/Source/tasks.c ****         taskCHECK_FOR_STACK_OVERFLOW();
3113:Lib/FreeRTOS/Source/tasks.c **** 
3114:Lib/FreeRTOS/Source/tasks.c ****         /* Before the currently running task is switched out, save its errno. */
3115:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3116:Lib/FreeRTOS/Source/tasks.c ****         {
3117:Lib/FreeRTOS/Source/tasks.c ****             pxCurrentTCB->iTaskErrno = FreeRTOS_errno;
3118:Lib/FreeRTOS/Source/tasks.c ****         }
3119:Lib/FreeRTOS/Source/tasks.c ****         #endif
3120:Lib/FreeRTOS/Source/tasks.c **** 
3121:Lib/FreeRTOS/Source/tasks.c ****         /* Select a new task to run using either the generic C or port
3122:Lib/FreeRTOS/Source/tasks.c ****          * optimised asm code. */
ARM GAS  /tmp/ccTFOe4z.s 			page 122


3123:Lib/FreeRTOS/Source/tasks.c ****         taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with
3124:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
3125:Lib/FreeRTOS/Source/tasks.c **** 
3126:Lib/FreeRTOS/Source/tasks.c ****         /* After the new task is switched in, update the global errno. */
3127:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_POSIX_ERRNO == 1 )
3128:Lib/FreeRTOS/Source/tasks.c ****         {
3129:Lib/FreeRTOS/Source/tasks.c ****             FreeRTOS_errno = pxCurrentTCB->iTaskErrno;
3130:Lib/FreeRTOS/Source/tasks.c ****         }
3131:Lib/FreeRTOS/Source/tasks.c ****         #endif
3132:Lib/FreeRTOS/Source/tasks.c **** 
3133:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
3134:Lib/FreeRTOS/Source/tasks.c ****         {
3135:Lib/FreeRTOS/Source/tasks.c ****             /* Switch C-Runtime's TLS Block to point to the TLS
3136:Lib/FreeRTOS/Source/tasks.c ****              * Block specific to this task. */
3137:Lib/FreeRTOS/Source/tasks.c ****             configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
3138:Lib/FreeRTOS/Source/tasks.c ****         }
3139:Lib/FreeRTOS/Source/tasks.c ****         #endif
3140:Lib/FreeRTOS/Source/tasks.c ****     }
3141:Lib/FreeRTOS/Source/tasks.c **** }
 3836              		.loc 1 3141 1
 3837 0014 57E0     		b	.L244
 3838              	.L237:
3080:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_OUT();
 3839              		.loc 1 3080 23
 3840 0016 2F4B     		ldr	r3, .L245+4
 3841 0018 0022     		movs	r2, #0
 3842 001a 1A60     		str	r2, [r3]
3088:Lib/FreeRTOS/Source/tasks.c ****             #endif
 3843              		.loc 1 3088 66
 3844 001c FFF7FEFF 		bl	TIM4_Get_Value
 3845 0020 0346     		mov	r3, r0
3088:Lib/FreeRTOS/Source/tasks.c ****             #endif
 3846              		.loc 1 3088 32 discriminator 1
 3847 0022 2D4A     		ldr	r2, .L245+8
 3848 0024 1360     		str	r3, [r2]
3098:Lib/FreeRTOS/Source/tasks.c ****             {
 3849              		.loc 1 3098 32
 3850 0026 2C4B     		ldr	r3, .L245+8
 3851 0028 1A68     		ldr	r2, [r3]
 3852 002a 2C4B     		ldr	r3, .L245+12
 3853 002c 1B68     		ldr	r3, [r3]
3098:Lib/FreeRTOS/Source/tasks.c ****             {
 3854              		.loc 1 3098 15
 3855 002e 9A42     		cmp	r2, r3
 3856 0030 09D9     		bls	.L239
3100:Lib/FreeRTOS/Source/tasks.c ****             }
 3857              		.loc 1 3100 68
 3858 0032 294B     		ldr	r3, .L245+8
 3859 0034 1A68     		ldr	r2, [r3]
 3860 0036 294B     		ldr	r3, .L245+12
 3861 0038 1B68     		ldr	r3, [r3]
 3862 003a D11A     		subs	r1, r2, r3
3100:Lib/FreeRTOS/Source/tasks.c ****             }
 3863              		.loc 1 3100 29
 3864 003c 284B     		ldr	r3, .L245+16
 3865 003e 1B68     		ldr	r3, [r3]
 3866 0040 5A6D     		ldr	r2, [r3, #84]
ARM GAS  /tmp/ccTFOe4z.s 			page 123


3100:Lib/FreeRTOS/Source/tasks.c ****             }
 3867              		.loc 1 3100 48
 3868 0042 0A44     		add	r2, r2, r1
 3869 0044 5A65     		str	r2, [r3, #84]
 3870              	.L239:
3107:Lib/FreeRTOS/Source/tasks.c ****         }
 3871              		.loc 1 3107 34
 3872 0046 244B     		ldr	r3, .L245+8
 3873 0048 1B68     		ldr	r3, [r3]
 3874 004a 244A     		ldr	r2, .L245+12
 3875 004c 1360     		str	r3, [r2]
 3876              	.LBB20:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3877              		.loc 1 3123 9
 3878 004e 254B     		ldr	r3, .L245+20
 3879 0050 1B68     		ldr	r3, [r3]
 3880 0052 7B60     		str	r3, [r7, #4]
 3881 0054 0EE0     		b	.L240
 3882              	.L242:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3883              		.loc 1 3123 9 is_stmt 0 discriminator 5
 3884 0056 7B68     		ldr	r3, [r7, #4]
 3885 0058 002B     		cmp	r3, #0
 3886 005a 08D1     		bne	.L241
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3887              		.loc 1 3123 9 discriminator 2
 3888 005c FFF7FEFF 		bl	ulSetInterruptMask
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3889              		.loc 1 3123 9 discriminator 1
 3890 0060 214B     		ldr	r3, .L245+24
 3891 0062 224A     		ldr	r2, .L245+28
 3892 0064 40F63341 		movw	r1, #3123
 3893 0068 2148     		ldr	r0, .L245+32
 3894 006a FFF7FEFF 		bl	__assert_func
 3895              	.L241:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3896              		.loc 1 3123 9 discriminator 3
 3897 006e 7B68     		ldr	r3, [r7, #4]
 3898 0070 013B     		subs	r3, r3, #1
 3899 0072 7B60     		str	r3, [r7, #4]
 3900              	.L240:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3901              		.loc 1 3123 9 discriminator 4
 3902 0074 1F49     		ldr	r1, .L245+36
 3903 0076 7A68     		ldr	r2, [r7, #4]
 3904 0078 1346     		mov	r3, r2
 3905 007a 9B00     		lsls	r3, r3, #2
 3906 007c 1344     		add	r3, r3, r2
 3907 007e 9B00     		lsls	r3, r3, #2
 3908 0080 0B44     		add	r3, r3, r1
 3909 0082 1B68     		ldr	r3, [r3]
 3910 0084 002B     		cmp	r3, #0
 3911 0086 E6D0     		beq	.L242
 3912              	.LBB21:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3913              		.loc 1 3123 9 discriminator 6
 3914 0088 7A68     		ldr	r2, [r7, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 124


 3915 008a 1346     		mov	r3, r2
 3916 008c 9B00     		lsls	r3, r3, #2
 3917 008e 1344     		add	r3, r3, r2
 3918 0090 9B00     		lsls	r3, r3, #2
 3919 0092 184A     		ldr	r2, .L245+36
 3920 0094 1344     		add	r3, r3, r2
 3921 0096 3B60     		str	r3, [r7]
 3922 0098 3B68     		ldr	r3, [r7]
 3923 009a 5B68     		ldr	r3, [r3, #4]
 3924 009c 5A68     		ldr	r2, [r3, #4]
 3925 009e 3B68     		ldr	r3, [r7]
 3926 00a0 5A60     		str	r2, [r3, #4]
 3927 00a2 3B68     		ldr	r3, [r7]
 3928 00a4 5A68     		ldr	r2, [r3, #4]
 3929 00a6 3B68     		ldr	r3, [r7]
 3930 00a8 0833     		adds	r3, r3, #8
 3931 00aa 9A42     		cmp	r2, r3
 3932 00ac 03D1     		bne	.L243
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3933              		.loc 1 3123 9 discriminator 7
 3934 00ae 3B68     		ldr	r3, [r7]
 3935 00b0 DA68     		ldr	r2, [r3, #12]
 3936 00b2 3B68     		ldr	r3, [r7]
 3937 00b4 5A60     		str	r2, [r3, #4]
 3938              	.L243:
3123:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_SWITCHED_IN();
 3939              		.loc 1 3123 9 discriminator 9
 3940 00b6 3B68     		ldr	r3, [r7]
 3941 00b8 5B68     		ldr	r3, [r3, #4]
 3942 00ba DB68     		ldr	r3, [r3, #12]
 3943 00bc 084A     		ldr	r2, .L245+16
 3944 00be 1360     		str	r3, [r2]
 3945              	.LBE21:
 3946 00c0 084A     		ldr	r2, .L245+20
 3947 00c2 7B68     		ldr	r3, [r7, #4]
 3948 00c4 1360     		str	r3, [r2]
 3949              	.L244:
 3950              	.LBE20:
 3951              		.loc 1 3141 1 is_stmt 1
 3952 00c6 00BF     		nop
 3953 00c8 0837     		adds	r7, r7, #8
 3954              		.cfi_def_cfa_offset 8
 3955 00ca BD46     		mov	sp, r7
 3956              		.cfi_def_cfa_register 13
 3957              		@ sp needed
 3958 00cc 80BD     		pop	{r7, pc}
 3959              	.L246:
 3960 00ce 00BF     		.align	2
 3961              	.L245:
 3962 00d0 00000000 		.word	uxSchedulerSuspended
 3963 00d4 00000000 		.word	xYieldPending
 3964 00d8 00000000 		.word	ulTotalRunTime
 3965 00dc 00000000 		.word	ulTaskSwitchedInTime
 3966 00e0 00000000 		.word	pxCurrentTCB
 3967 00e4 00000000 		.word	uxTopReadyPriority
 3968 00e8 00000000 		.word	.LC0
 3969 00ec 00000000 		.word	__func__.16
ARM GAS  /tmp/ccTFOe4z.s 			page 125


 3970 00f0 04000000 		.word	.LC1
 3971 00f4 00000000 		.word	pxReadyTasksLists
 3972              		.cfi_endproc
 3973              	.LFE27:
 3975              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 3976              		.align	1
 3977              		.global	vTaskPlaceOnEventList
 3978              		.syntax unified
 3979              		.thumb
 3980              		.thumb_func
 3982              	vTaskPlaceOnEventList:
 3983              	.LFB28:
3142:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3143:Lib/FreeRTOS/Source/tasks.c **** 
3144:Lib/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( List_t * const pxEventList,
3145:Lib/FreeRTOS/Source/tasks.c ****                             const TickType_t xTicksToWait )
3146:Lib/FreeRTOS/Source/tasks.c **** {
 3984              		.loc 1 3146 1
 3985              		.cfi_startproc
 3986              		@ args = 0, pretend = 0, frame = 8
 3987              		@ frame_needed = 1, uses_anonymous_args = 0
 3988 0000 80B5     		push	{r7, lr}
 3989              		.cfi_def_cfa_offset 8
 3990              		.cfi_offset 7, -8
 3991              		.cfi_offset 14, -4
 3992 0002 82B0     		sub	sp, sp, #8
 3993              		.cfi_def_cfa_offset 16
 3994 0004 00AF     		add	r7, sp, #0
 3995              		.cfi_def_cfa_register 7
 3996 0006 7860     		str	r0, [r7, #4]
 3997 0008 3960     		str	r1, [r7]
3147:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 3998              		.loc 1 3147 5
 3999 000a 7B68     		ldr	r3, [r7, #4]
 4000 000c 002B     		cmp	r3, #0
 4001 000e 08D1     		bne	.L248
 4002              		.loc 1 3147 5 is_stmt 0 discriminator 1
 4003 0010 FFF7FEFF 		bl	ulSetInterruptMask
 4004 0014 0A4B     		ldr	r3, .L249
 4005 0016 0B4A     		ldr	r2, .L249+4
 4006 0018 40F64B41 		movw	r1, #3147
 4007 001c 0A48     		ldr	r0, .L249+8
 4008 001e FFF7FEFF 		bl	__assert_func
 4009              	.L248:
3148:Lib/FreeRTOS/Source/tasks.c **** 
3149:Lib/FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
3150:Lib/FreeRTOS/Source/tasks.c ****      * SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
3151:Lib/FreeRTOS/Source/tasks.c **** 
3152:Lib/FreeRTOS/Source/tasks.c ****     /* Place the event list item of the TCB in the appropriate event list.
3153:Lib/FreeRTOS/Source/tasks.c ****      * This is placed in the list in priority order so the highest priority task
3154:Lib/FreeRTOS/Source/tasks.c ****      * is the first to be woken by the event.
3155:Lib/FreeRTOS/Source/tasks.c ****      *
3156:Lib/FreeRTOS/Source/tasks.c ****      * Note: Lists are sorted in ascending order by ListItem_t.xItemValue.
3157:Lib/FreeRTOS/Source/tasks.c ****      * Normally, the xItemValue of a TCB's ListItem_t members is:
3158:Lib/FreeRTOS/Source/tasks.c ****      *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
3159:Lib/FreeRTOS/Source/tasks.c ****      * Therefore, the event list is sorted in descending priority order.
3160:Lib/FreeRTOS/Source/tasks.c ****      *
ARM GAS  /tmp/ccTFOe4z.s 			page 126


3161:Lib/FreeRTOS/Source/tasks.c ****      * The queue that contains the event list is locked, preventing
3162:Lib/FreeRTOS/Source/tasks.c ****      * simultaneous access from interrupts. */
3163:Lib/FreeRTOS/Source/tasks.c ****     vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4010              		.loc 1 3163 46 is_stmt 1
 4011 0022 0A4B     		ldr	r3, .L249+12
 4012 0024 1B68     		ldr	r3, [r3]
 4013              		.loc 1 3163 5
 4014 0026 1833     		adds	r3, r3, #24
 4015 0028 1946     		mov	r1, r3
 4016 002a 7868     		ldr	r0, [r7, #4]
 4017 002c FFF7FEFF 		bl	vListInsert
3164:Lib/FreeRTOS/Source/tasks.c **** 
3165:Lib/FreeRTOS/Source/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4018              		.loc 1 3165 5
 4019 0030 0121     		movs	r1, #1
 4020 0032 3868     		ldr	r0, [r7]
 4021 0034 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
3166:Lib/FreeRTOS/Source/tasks.c **** }
 4022              		.loc 1 3166 1
 4023 0038 00BF     		nop
 4024 003a 0837     		adds	r7, r7, #8
 4025              		.cfi_def_cfa_offset 8
 4026 003c BD46     		mov	sp, r7
 4027              		.cfi_def_cfa_register 13
 4028              		@ sp needed
 4029 003e 80BD     		pop	{r7, pc}
 4030              	.L250:
 4031              		.align	2
 4032              	.L249:
 4033 0040 00000000 		.word	.LC0
 4034 0044 00000000 		.word	__func__.15
 4035 0048 04000000 		.word	.LC1
 4036 004c 00000000 		.word	pxCurrentTCB
 4037              		.cfi_endproc
 4038              	.LFE28:
 4040              		.section	.text.vTaskPlaceOnUnorderedEventList,"ax",%progbits
 4041              		.align	1
 4042              		.global	vTaskPlaceOnUnorderedEventList
 4043              		.syntax unified
 4044              		.thumb
 4045              		.thumb_func
 4047              	vTaskPlaceOnUnorderedEventList:
 4048              	.LFB29:
3167:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3168:Lib/FreeRTOS/Source/tasks.c **** 
3169:Lib/FreeRTOS/Source/tasks.c **** void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
3170:Lib/FreeRTOS/Source/tasks.c ****                                      const TickType_t xItemValue,
3171:Lib/FreeRTOS/Source/tasks.c ****                                      const TickType_t xTicksToWait )
3172:Lib/FreeRTOS/Source/tasks.c **** {
 4049              		.loc 1 3172 1
 4050              		.cfi_startproc
 4051              		@ args = 0, pretend = 0, frame = 24
 4052              		@ frame_needed = 1, uses_anonymous_args = 0
 4053 0000 80B5     		push	{r7, lr}
 4054              		.cfi_def_cfa_offset 8
 4055              		.cfi_offset 7, -8
 4056              		.cfi_offset 14, -4
ARM GAS  /tmp/ccTFOe4z.s 			page 127


 4057 0002 86B0     		sub	sp, sp, #24
 4058              		.cfi_def_cfa_offset 32
 4059 0004 00AF     		add	r7, sp, #0
 4060              		.cfi_def_cfa_register 7
 4061 0006 F860     		str	r0, [r7, #12]
 4062 0008 B960     		str	r1, [r7, #8]
 4063 000a 7A60     		str	r2, [r7, #4]
3173:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxEventList );
 4064              		.loc 1 3173 5
 4065 000c FB68     		ldr	r3, [r7, #12]
 4066 000e 002B     		cmp	r3, #0
 4067 0010 08D1     		bne	.L252
 4068              		.loc 1 3173 5 is_stmt 0 discriminator 1
 4069 0012 FFF7FEFF 		bl	ulSetInterruptMask
 4070 0016 214B     		ldr	r3, .L254
 4071 0018 214A     		ldr	r2, .L254+4
 4072 001a 40F66541 		movw	r1, #3173
 4073 001e 2148     		ldr	r0, .L254+8
 4074 0020 FFF7FEFF 		bl	__assert_func
 4075              	.L252:
3174:Lib/FreeRTOS/Source/tasks.c **** 
3175:Lib/FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3176:Lib/FreeRTOS/Source/tasks.c ****      * the event groups implementation. */
3177:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 4076              		.loc 1 3177 5 is_stmt 1
 4077 0024 204B     		ldr	r3, .L254+12
 4078 0026 1B68     		ldr	r3, [r3]
 4079 0028 002B     		cmp	r3, #0
 4080 002a 08D1     		bne	.L253
 4081              		.loc 1 3177 5 is_stmt 0 discriminator 1
 4082 002c FFF7FEFF 		bl	ulSetInterruptMask
 4083 0030 1A4B     		ldr	r3, .L254
 4084 0032 1B4A     		ldr	r2, .L254+4
 4085 0034 40F66941 		movw	r1, #3177
 4086 0038 1A48     		ldr	r0, .L254+8
 4087 003a FFF7FEFF 		bl	__assert_func
 4088              	.L253:
3178:Lib/FreeRTOS/Source/tasks.c **** 
3179:Lib/FreeRTOS/Source/tasks.c ****     /* Store the item value in the event list item.  It is safe to access the
3180:Lib/FreeRTOS/Source/tasks.c ****      * event list item here as interrupts won't access the event list item of a
3181:Lib/FreeRTOS/Source/tasks.c ****      * task that is not in the Blocked state. */
3182:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VA
 4089              		.loc 1 3182 5 is_stmt 1
 4090 003e 1B4B     		ldr	r3, .L254+16
 4091 0040 1B68     		ldr	r3, [r3]
 4092 0042 BA68     		ldr	r2, [r7, #8]
 4093 0044 42F00042 		orr	r2, r2, #-2147483648
 4094 0048 9A61     		str	r2, [r3, #24]
 4095              	.LBB22:
3183:Lib/FreeRTOS/Source/tasks.c **** 
3184:Lib/FreeRTOS/Source/tasks.c ****     /* Place the event list item of the TCB at the end of the appropriate event
3185:Lib/FreeRTOS/Source/tasks.c ****      * list.  It is safe to access the event list here because it is part of an
3186:Lib/FreeRTOS/Source/tasks.c ****      * event group implementation - and interrupts don't access event groups
3187:Lib/FreeRTOS/Source/tasks.c ****      * directly (instead they access them indirectly by pending function calls to
3188:Lib/FreeRTOS/Source/tasks.c ****      * the task level). */
3189:Lib/FreeRTOS/Source/tasks.c ****     listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4096              		.loc 1 3189 5
ARM GAS  /tmp/ccTFOe4z.s 			page 128


 4097 004a FB68     		ldr	r3, [r7, #12]
 4098 004c 5B68     		ldr	r3, [r3, #4]
 4099 004e 7B61     		str	r3, [r7, #20]
 4100 0050 164B     		ldr	r3, .L254+16
 4101 0052 1B68     		ldr	r3, [r3]
 4102 0054 7A69     		ldr	r2, [r7, #20]
 4103 0056 DA61     		str	r2, [r3, #28]
 4104 0058 144B     		ldr	r3, .L254+16
 4105 005a 1B68     		ldr	r3, [r3]
 4106 005c 7A69     		ldr	r2, [r7, #20]
 4107 005e 9268     		ldr	r2, [r2, #8]
 4108 0060 1A62     		str	r2, [r3, #32]
 4109 0062 124B     		ldr	r3, .L254+16
 4110 0064 1A68     		ldr	r2, [r3]
 4111 0066 7B69     		ldr	r3, [r7, #20]
 4112 0068 9B68     		ldr	r3, [r3, #8]
 4113 006a 1832     		adds	r2, r2, #24
 4114 006c 5A60     		str	r2, [r3, #4]
 4115 006e 0F4B     		ldr	r3, .L254+16
 4116 0070 1B68     		ldr	r3, [r3]
 4117 0072 03F11802 		add	r2, r3, #24
 4118 0076 7B69     		ldr	r3, [r7, #20]
 4119 0078 9A60     		str	r2, [r3, #8]
 4120 007a 0C4B     		ldr	r3, .L254+16
 4121 007c 1B68     		ldr	r3, [r3]
 4122 007e FA68     		ldr	r2, [r7, #12]
 4123 0080 9A62     		str	r2, [r3, #40]
 4124 0082 FB68     		ldr	r3, [r7, #12]
 4125 0084 1B68     		ldr	r3, [r3]
 4126 0086 5A1C     		adds	r2, r3, #1
 4127 0088 FB68     		ldr	r3, [r7, #12]
 4128 008a 1A60     		str	r2, [r3]
 4129              	.LBE22:
3190:Lib/FreeRTOS/Source/tasks.c **** 
3191:Lib/FreeRTOS/Source/tasks.c ****     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 4130              		.loc 1 3191 5
 4131 008c 0121     		movs	r1, #1
 4132 008e 7868     		ldr	r0, [r7, #4]
 4133 0090 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
3192:Lib/FreeRTOS/Source/tasks.c **** }
 4134              		.loc 1 3192 1
 4135 0094 00BF     		nop
 4136 0096 1837     		adds	r7, r7, #24
 4137              		.cfi_def_cfa_offset 8
 4138 0098 BD46     		mov	sp, r7
 4139              		.cfi_def_cfa_register 13
 4140              		@ sp needed
 4141 009a 80BD     		pop	{r7, pc}
 4142              	.L255:
 4143              		.align	2
 4144              	.L254:
 4145 009c 00000000 		.word	.LC0
 4146 00a0 00000000 		.word	__func__.14
 4147 00a4 04000000 		.word	.LC1
 4148 00a8 00000000 		.word	uxSchedulerSuspended
 4149 00ac 00000000 		.word	pxCurrentTCB
 4150              		.cfi_endproc
ARM GAS  /tmp/ccTFOe4z.s 			page 129


 4151              	.LFE29:
 4153              		.section	.text.vTaskPlaceOnEventListRestricted,"ax",%progbits
 4154              		.align	1
 4155              		.global	vTaskPlaceOnEventListRestricted
 4156              		.syntax unified
 4157              		.thumb
 4158              		.thumb_func
 4160              	vTaskPlaceOnEventListRestricted:
 4161              	.LFB30:
3193:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3194:Lib/FreeRTOS/Source/tasks.c **** 
3195:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TIMERS == 1 )
3196:Lib/FreeRTOS/Source/tasks.c **** 
3197:Lib/FreeRTOS/Source/tasks.c ****     void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
3198:Lib/FreeRTOS/Source/tasks.c ****                                           TickType_t xTicksToWait,
3199:Lib/FreeRTOS/Source/tasks.c ****                                           const BaseType_t xWaitIndefinitely )
3200:Lib/FreeRTOS/Source/tasks.c ****     {
 4162              		.loc 1 3200 5
 4163              		.cfi_startproc
 4164              		@ args = 0, pretend = 0, frame = 24
 4165              		@ frame_needed = 1, uses_anonymous_args = 0
 4166 0000 80B5     		push	{r7, lr}
 4167              		.cfi_def_cfa_offset 8
 4168              		.cfi_offset 7, -8
 4169              		.cfi_offset 14, -4
 4170 0002 86B0     		sub	sp, sp, #24
 4171              		.cfi_def_cfa_offset 32
 4172 0004 00AF     		add	r7, sp, #0
 4173              		.cfi_def_cfa_register 7
 4174 0006 F860     		str	r0, [r7, #12]
 4175 0008 B960     		str	r1, [r7, #8]
 4176 000a 7A60     		str	r2, [r7, #4]
3201:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( pxEventList );
 4177              		.loc 1 3201 9
 4178 000c FB68     		ldr	r3, [r7, #12]
 4179 000e 002B     		cmp	r3, #0
 4180 0010 08D1     		bne	.L257
 4181              		.loc 1 3201 9 is_stmt 0 discriminator 1
 4182 0012 FFF7FEFF 		bl	ulSetInterruptMask
 4183 0016 1B4B     		ldr	r3, .L259
 4184 0018 1B4A     		ldr	r2, .L259+4
 4185 001a 40F68141 		movw	r1, #3201
 4186 001e 1B48     		ldr	r0, .L259+8
 4187 0020 FFF7FEFF 		bl	__assert_func
 4188              	.L257:
 4189              	.LBB23:
3202:Lib/FreeRTOS/Source/tasks.c **** 
3203:Lib/FreeRTOS/Source/tasks.c ****         /* This function should not be called by application code hence the
3204:Lib/FreeRTOS/Source/tasks.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
3205:Lib/FreeRTOS/Source/tasks.c ****          * designed for use by kernel code, and has special calling requirements -
3206:Lib/FreeRTOS/Source/tasks.c ****          * it should be called with the scheduler suspended. */
3207:Lib/FreeRTOS/Source/tasks.c **** 
3208:Lib/FreeRTOS/Source/tasks.c **** 
3209:Lib/FreeRTOS/Source/tasks.c ****         /* Place the event list item of the TCB in the appropriate event list.
3210:Lib/FreeRTOS/Source/tasks.c ****          * In this case it is assume that this is the only task that is going to
3211:Lib/FreeRTOS/Source/tasks.c ****          * be waiting on this event list, so the faster vListInsertEnd() function
3212:Lib/FreeRTOS/Source/tasks.c ****          * can be used in place of vListInsert. */
ARM GAS  /tmp/ccTFOe4z.s 			page 130


3213:Lib/FreeRTOS/Source/tasks.c ****         listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 4190              		.loc 1 3213 9 is_stmt 1
 4191 0024 FB68     		ldr	r3, [r7, #12]
 4192 0026 5B68     		ldr	r3, [r3, #4]
 4193 0028 7B61     		str	r3, [r7, #20]
 4194 002a 194B     		ldr	r3, .L259+12
 4195 002c 1B68     		ldr	r3, [r3]
 4196 002e 7A69     		ldr	r2, [r7, #20]
 4197 0030 DA61     		str	r2, [r3, #28]
 4198 0032 174B     		ldr	r3, .L259+12
 4199 0034 1B68     		ldr	r3, [r3]
 4200 0036 7A69     		ldr	r2, [r7, #20]
 4201 0038 9268     		ldr	r2, [r2, #8]
 4202 003a 1A62     		str	r2, [r3, #32]
 4203 003c 144B     		ldr	r3, .L259+12
 4204 003e 1A68     		ldr	r2, [r3]
 4205 0040 7B69     		ldr	r3, [r7, #20]
 4206 0042 9B68     		ldr	r3, [r3, #8]
 4207 0044 1832     		adds	r2, r2, #24
 4208 0046 5A60     		str	r2, [r3, #4]
 4209 0048 114B     		ldr	r3, .L259+12
 4210 004a 1B68     		ldr	r3, [r3]
 4211 004c 03F11802 		add	r2, r3, #24
 4212 0050 7B69     		ldr	r3, [r7, #20]
 4213 0052 9A60     		str	r2, [r3, #8]
 4214 0054 0E4B     		ldr	r3, .L259+12
 4215 0056 1B68     		ldr	r3, [r3]
 4216 0058 FA68     		ldr	r2, [r7, #12]
 4217 005a 9A62     		str	r2, [r3, #40]
 4218 005c FB68     		ldr	r3, [r7, #12]
 4219 005e 1B68     		ldr	r3, [r3]
 4220 0060 5A1C     		adds	r2, r3, #1
 4221 0062 FB68     		ldr	r3, [r7, #12]
 4222 0064 1A60     		str	r2, [r3]
 4223              	.LBE23:
3214:Lib/FreeRTOS/Source/tasks.c **** 
3215:Lib/FreeRTOS/Source/tasks.c ****         /* If the task should block indefinitely then set the block time to a
3216:Lib/FreeRTOS/Source/tasks.c ****          * value that will be recognised as an indefinite delay inside the
3217:Lib/FreeRTOS/Source/tasks.c ****          * prvAddCurrentTaskToDelayedList() function. */
3218:Lib/FreeRTOS/Source/tasks.c ****         if( xWaitIndefinitely != pdFALSE )
 4224              		.loc 1 3218 11
 4225 0066 7B68     		ldr	r3, [r7, #4]
 4226 0068 002B     		cmp	r3, #0
 4227 006a 02D0     		beq	.L258
3219:Lib/FreeRTOS/Source/tasks.c ****         {
3220:Lib/FreeRTOS/Source/tasks.c ****             xTicksToWait = portMAX_DELAY;
 4228              		.loc 1 3220 26
 4229 006c 4FF0FF33 		mov	r3, #-1
 4230 0070 BB60     		str	r3, [r7, #8]
 4231              	.L258:
3221:Lib/FreeRTOS/Source/tasks.c ****         }
3222:Lib/FreeRTOS/Source/tasks.c **** 
3223:Lib/FreeRTOS/Source/tasks.c ****         traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
3224:Lib/FreeRTOS/Source/tasks.c ****         prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 4232              		.loc 1 3224 9
 4233 0072 7968     		ldr	r1, [r7, #4]
 4234 0074 B868     		ldr	r0, [r7, #8]
ARM GAS  /tmp/ccTFOe4z.s 			page 131


 4235 0076 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
3225:Lib/FreeRTOS/Source/tasks.c ****     }
 4236              		.loc 1 3225 5
 4237 007a 00BF     		nop
 4238 007c 1837     		adds	r7, r7, #24
 4239              		.cfi_def_cfa_offset 8
 4240 007e BD46     		mov	sp, r7
 4241              		.cfi_def_cfa_register 13
 4242              		@ sp needed
 4243 0080 80BD     		pop	{r7, pc}
 4244              	.L260:
 4245 0082 00BF     		.align	2
 4246              	.L259:
 4247 0084 00000000 		.word	.LC0
 4248 0088 00000000 		.word	__func__.13
 4249 008c 04000000 		.word	.LC1
 4250 0090 00000000 		.word	pxCurrentTCB
 4251              		.cfi_endproc
 4252              	.LFE30:
 4254              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 4255              		.align	1
 4256              		.global	xTaskRemoveFromEventList
 4257              		.syntax unified
 4258              		.thumb
 4259              		.thumb_func
 4261              	xTaskRemoveFromEventList:
 4262              	.LFB31:
3226:Lib/FreeRTOS/Source/tasks.c **** 
3227:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
3228:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3229:Lib/FreeRTOS/Source/tasks.c **** 
3230:Lib/FreeRTOS/Source/tasks.c **** BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
3231:Lib/FreeRTOS/Source/tasks.c **** {
 4263              		.loc 1 3231 1
 4264              		.cfi_startproc
 4265              		@ args = 0, pretend = 0, frame = 32
 4266              		@ frame_needed = 1, uses_anonymous_args = 0
 4267 0000 80B5     		push	{r7, lr}
 4268              		.cfi_def_cfa_offset 8
 4269              		.cfi_offset 7, -8
 4270              		.cfi_offset 14, -4
 4271 0002 88B0     		sub	sp, sp, #32
 4272              		.cfi_def_cfa_offset 40
 4273 0004 00AF     		add	r7, sp, #0
 4274              		.cfi_def_cfa_register 7
 4275 0006 7860     		str	r0, [r7, #4]
3232:Lib/FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
3233:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
3234:Lib/FreeRTOS/Source/tasks.c **** 
3235:Lib/FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
3236:Lib/FreeRTOS/Source/tasks.c ****      * called from a critical section within an ISR. */
3237:Lib/FreeRTOS/Source/tasks.c **** 
3238:Lib/FreeRTOS/Source/tasks.c ****     /* The event list is sorted in priority order, so the first in the list can
3239:Lib/FreeRTOS/Source/tasks.c ****      * be removed as it is known to be the highest priority.  Remove the TCB from
3240:Lib/FreeRTOS/Source/tasks.c ****      * the delayed list, and add it to the ready list.
3241:Lib/FreeRTOS/Source/tasks.c ****      *
3242:Lib/FreeRTOS/Source/tasks.c ****      * If an event is for a queue that is locked then this function will never
ARM GAS  /tmp/ccTFOe4z.s 			page 132


3243:Lib/FreeRTOS/Source/tasks.c ****      * get called - the lock count on the queue will get modified instead.  This
3244:Lib/FreeRTOS/Source/tasks.c ****      * means exclusive access to the event list is guaranteed here.
3245:Lib/FreeRTOS/Source/tasks.c ****      *
3246:Lib/FreeRTOS/Source/tasks.c ****      * This function assumes that a check has already been made to ensure that
3247:Lib/FreeRTOS/Source/tasks.c ****      * pxEventList is not empty. */
3248:Lib/FreeRTOS/Source/tasks.c ****     pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as th
 4276              		.loc 1 3248 22
 4277 0008 7B68     		ldr	r3, [r7, #4]
 4278 000a DB68     		ldr	r3, [r3, #12]
 4279              		.loc 1 3248 20
 4280 000c DB68     		ldr	r3, [r3, #12]
 4281 000e BB61     		str	r3, [r7, #24]
3249:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
 4282              		.loc 1 3249 5
 4283 0010 BB69     		ldr	r3, [r7, #24]
 4284 0012 002B     		cmp	r3, #0
 4285 0014 08D1     		bne	.L262
 4286              		.loc 1 3249 5 is_stmt 0 discriminator 1
 4287 0016 FFF7FEFF 		bl	ulSetInterruptMask
 4288 001a 5D4B     		ldr	r3, .L271
 4289 001c 5D4A     		ldr	r2, .L271+4
 4290 001e 40F6B141 		movw	r1, #3249
 4291 0022 5D48     		ldr	r0, .L271+8
 4292 0024 FFF7FEFF 		bl	__assert_func
 4293              	.L262:
 4294              	.LBB24:
3250:Lib/FreeRTOS/Source/tasks.c ****     listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 4295              		.loc 1 3250 5 is_stmt 1
 4296 0028 BB69     		ldr	r3, [r7, #24]
 4297 002a 9B6A     		ldr	r3, [r3, #40]
 4298 002c 7B61     		str	r3, [r7, #20]
 4299 002e BB69     		ldr	r3, [r7, #24]
 4300 0030 DB69     		ldr	r3, [r3, #28]
 4301 0032 BA69     		ldr	r2, [r7, #24]
 4302 0034 126A     		ldr	r2, [r2, #32]
 4303 0036 9A60     		str	r2, [r3, #8]
 4304 0038 BB69     		ldr	r3, [r7, #24]
 4305 003a 1B6A     		ldr	r3, [r3, #32]
 4306 003c BA69     		ldr	r2, [r7, #24]
 4307 003e D269     		ldr	r2, [r2, #28]
 4308 0040 5A60     		str	r2, [r3, #4]
 4309 0042 7B69     		ldr	r3, [r7, #20]
 4310 0044 5A68     		ldr	r2, [r3, #4]
 4311 0046 BB69     		ldr	r3, [r7, #24]
 4312 0048 1833     		adds	r3, r3, #24
 4313 004a 9A42     		cmp	r2, r3
 4314 004c 03D1     		bne	.L263
 4315              		.loc 1 3250 5 is_stmt 0 discriminator 1
 4316 004e BB69     		ldr	r3, [r7, #24]
 4317 0050 1A6A     		ldr	r2, [r3, #32]
 4318 0052 7B69     		ldr	r3, [r7, #20]
 4319 0054 5A60     		str	r2, [r3, #4]
 4320              	.L263:
 4321              		.loc 1 3250 5 discriminator 3
 4322 0056 BB69     		ldr	r3, [r7, #24]
 4323 0058 0022     		movs	r2, #0
 4324 005a 9A62     		str	r2, [r3, #40]
ARM GAS  /tmp/ccTFOe4z.s 			page 133


 4325 005c 7B69     		ldr	r3, [r7, #20]
 4326 005e 1B68     		ldr	r3, [r3]
 4327 0060 5A1E     		subs	r2, r3, #1
 4328 0062 7B69     		ldr	r3, [r7, #20]
 4329 0064 1A60     		str	r2, [r3]
 4330              	.LBE24:
3251:Lib/FreeRTOS/Source/tasks.c **** 
3252:Lib/FreeRTOS/Source/tasks.c ****     if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 4331              		.loc 1 3252 30 is_stmt 1
 4332 0066 4D4B     		ldr	r3, .L271+12
 4333 0068 1B68     		ldr	r3, [r3]
 4334              		.loc 1 3252 7
 4335 006a 002B     		cmp	r3, #0
 4336 006c 5FD1     		bne	.L264
 4337              	.LBB25:
3253:Lib/FreeRTOS/Source/tasks.c ****     {
3254:Lib/FreeRTOS/Source/tasks.c ****         listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 4338              		.loc 1 3254 9
 4339 006e BB69     		ldr	r3, [r7, #24]
 4340 0070 5B69     		ldr	r3, [r3, #20]
 4341 0072 FB60     		str	r3, [r7, #12]
 4342 0074 BB69     		ldr	r3, [r7, #24]
 4343 0076 9B68     		ldr	r3, [r3, #8]
 4344 0078 BA69     		ldr	r2, [r7, #24]
 4345 007a D268     		ldr	r2, [r2, #12]
 4346 007c 9A60     		str	r2, [r3, #8]
 4347 007e BB69     		ldr	r3, [r7, #24]
 4348 0080 DB68     		ldr	r3, [r3, #12]
 4349 0082 BA69     		ldr	r2, [r7, #24]
 4350 0084 9268     		ldr	r2, [r2, #8]
 4351 0086 5A60     		str	r2, [r3, #4]
 4352 0088 FB68     		ldr	r3, [r7, #12]
 4353 008a 5A68     		ldr	r2, [r3, #4]
 4354 008c BB69     		ldr	r3, [r7, #24]
 4355 008e 0433     		adds	r3, r3, #4
 4356 0090 9A42     		cmp	r2, r3
 4357 0092 03D1     		bne	.L265
 4358              		.loc 1 3254 9 is_stmt 0 discriminator 1
 4359 0094 BB69     		ldr	r3, [r7, #24]
 4360 0096 DA68     		ldr	r2, [r3, #12]
 4361 0098 FB68     		ldr	r3, [r7, #12]
 4362 009a 5A60     		str	r2, [r3, #4]
 4363              	.L265:
 4364              		.loc 1 3254 9 discriminator 3
 4365 009c BB69     		ldr	r3, [r7, #24]
 4366 009e 0022     		movs	r2, #0
 4367 00a0 5A61     		str	r2, [r3, #20]
 4368 00a2 FB68     		ldr	r3, [r7, #12]
 4369 00a4 1B68     		ldr	r3, [r3]
 4370 00a6 5A1E     		subs	r2, r3, #1
 4371 00a8 FB68     		ldr	r3, [r7, #12]
 4372 00aa 1A60     		str	r2, [r3]
 4373              	.LBE25:
3255:Lib/FreeRTOS/Source/tasks.c ****         prvAddTaskToReadyList( pxUnblockedTCB );
 4374              		.loc 1 3255 9 is_stmt 1
 4375 00ac BB69     		ldr	r3, [r7, #24]
 4376 00ae DA6A     		ldr	r2, [r3, #44]
ARM GAS  /tmp/ccTFOe4z.s 			page 134


 4377 00b0 3B4B     		ldr	r3, .L271+16
 4378 00b2 1B68     		ldr	r3, [r3]
 4379 00b4 9A42     		cmp	r2, r3
 4380 00b6 03D9     		bls	.L266
 4381              		.loc 1 3255 9 is_stmt 0 discriminator 1
 4382 00b8 BB69     		ldr	r3, [r7, #24]
 4383 00ba DB6A     		ldr	r3, [r3, #44]
 4384 00bc 384A     		ldr	r2, .L271+16
 4385 00be 1360     		str	r3, [r2]
 4386              	.L266:
 4387              	.LBB26:
 4388              		.loc 1 3255 9 discriminator 3
 4389 00c0 BB69     		ldr	r3, [r7, #24]
 4390 00c2 DA6A     		ldr	r2, [r3, #44]
 4391 00c4 3749     		ldr	r1, .L271+20
 4392 00c6 1346     		mov	r3, r2
 4393 00c8 9B00     		lsls	r3, r3, #2
 4394 00ca 1344     		add	r3, r3, r2
 4395 00cc 9B00     		lsls	r3, r3, #2
 4396 00ce 0B44     		add	r3, r3, r1
 4397 00d0 0433     		adds	r3, r3, #4
 4398 00d2 1B68     		ldr	r3, [r3]
 4399 00d4 BB60     		str	r3, [r7, #8]
 4400 00d6 BB69     		ldr	r3, [r7, #24]
 4401 00d8 BA68     		ldr	r2, [r7, #8]
 4402 00da 9A60     		str	r2, [r3, #8]
 4403 00dc BB68     		ldr	r3, [r7, #8]
 4404 00de 9A68     		ldr	r2, [r3, #8]
 4405 00e0 BB69     		ldr	r3, [r7, #24]
 4406 00e2 DA60     		str	r2, [r3, #12]
 4407 00e4 BB68     		ldr	r3, [r7, #8]
 4408 00e6 9B68     		ldr	r3, [r3, #8]
 4409 00e8 BA69     		ldr	r2, [r7, #24]
 4410 00ea 0432     		adds	r2, r2, #4
 4411 00ec 5A60     		str	r2, [r3, #4]
 4412 00ee BB69     		ldr	r3, [r7, #24]
 4413 00f0 1A1D     		adds	r2, r3, #4
 4414 00f2 BB68     		ldr	r3, [r7, #8]
 4415 00f4 9A60     		str	r2, [r3, #8]
 4416 00f6 BB69     		ldr	r3, [r7, #24]
 4417 00f8 DA6A     		ldr	r2, [r3, #44]
 4418 00fa 1346     		mov	r3, r2
 4419 00fc 9B00     		lsls	r3, r3, #2
 4420 00fe 1344     		add	r3, r3, r2
 4421 0100 9B00     		lsls	r3, r3, #2
 4422 0102 284A     		ldr	r2, .L271+20
 4423 0104 1A44     		add	r2, r2, r3
 4424 0106 BB69     		ldr	r3, [r7, #24]
 4425 0108 5A61     		str	r2, [r3, #20]
 4426 010a BB69     		ldr	r3, [r7, #24]
 4427 010c DA6A     		ldr	r2, [r3, #44]
 4428 010e 2549     		ldr	r1, .L271+20
 4429 0110 1346     		mov	r3, r2
 4430 0112 9B00     		lsls	r3, r3, #2
 4431 0114 1344     		add	r3, r3, r2
 4432 0116 9B00     		lsls	r3, r3, #2
 4433 0118 0B44     		add	r3, r3, r1
ARM GAS  /tmp/ccTFOe4z.s 			page 135


 4434 011a 1B68     		ldr	r3, [r3]
 4435 011c 591C     		adds	r1, r3, #1
 4436 011e 2148     		ldr	r0, .L271+20
 4437 0120 1346     		mov	r3, r2
 4438 0122 9B00     		lsls	r3, r3, #2
 4439 0124 1344     		add	r3, r3, r2
 4440 0126 9B00     		lsls	r3, r3, #2
 4441 0128 0344     		add	r3, r3, r0
 4442 012a 1960     		str	r1, [r3]
 4443              	.LBE26:
 4444 012c 1BE0     		b	.L267
 4445              	.L264:
 4446              	.LBB27:
3256:Lib/FreeRTOS/Source/tasks.c **** 
3257:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3258:Lib/FreeRTOS/Source/tasks.c ****         {
3259:Lib/FreeRTOS/Source/tasks.c ****             /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3260:Lib/FreeRTOS/Source/tasks.c ****              * might be set to the blocked task's time out time.  If the task is
3261:Lib/FreeRTOS/Source/tasks.c ****              * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3262:Lib/FreeRTOS/Source/tasks.c ****              * normally left unchanged, because it is automatically reset to a new
3263:Lib/FreeRTOS/Source/tasks.c ****              * value when the tick count equals xNextTaskUnblockTime.  However if
3264:Lib/FreeRTOS/Source/tasks.c ****              * tickless idling is used it might be more important to enter sleep mode
3265:Lib/FreeRTOS/Source/tasks.c ****              * at the earliest possible time - so reset xNextTaskUnblockTime here to
3266:Lib/FreeRTOS/Source/tasks.c ****              * ensure it is updated at the earliest possible time. */
3267:Lib/FreeRTOS/Source/tasks.c ****             prvResetNextTaskUnblockTime();
3268:Lib/FreeRTOS/Source/tasks.c ****         }
3269:Lib/FreeRTOS/Source/tasks.c ****         #endif
3270:Lib/FreeRTOS/Source/tasks.c ****     }
3271:Lib/FreeRTOS/Source/tasks.c ****     else
3272:Lib/FreeRTOS/Source/tasks.c ****     {
3273:Lib/FreeRTOS/Source/tasks.c ****         /* The delayed and ready lists cannot be accessed, so hold this task
3274:Lib/FreeRTOS/Source/tasks.c ****          * pending until the scheduler is resumed. */
3275:Lib/FreeRTOS/Source/tasks.c ****         listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 4447              		.loc 1 3275 9 is_stmt 1
 4448 012e 1E4B     		ldr	r3, .L271+24
 4449 0130 5B68     		ldr	r3, [r3, #4]
 4450 0132 3B61     		str	r3, [r7, #16]
 4451 0134 BB69     		ldr	r3, [r7, #24]
 4452 0136 3A69     		ldr	r2, [r7, #16]
 4453 0138 DA61     		str	r2, [r3, #28]
 4454 013a 3B69     		ldr	r3, [r7, #16]
 4455 013c 9A68     		ldr	r2, [r3, #8]
 4456 013e BB69     		ldr	r3, [r7, #24]
 4457 0140 1A62     		str	r2, [r3, #32]
 4458 0142 3B69     		ldr	r3, [r7, #16]
 4459 0144 9B68     		ldr	r3, [r3, #8]
 4460 0146 BA69     		ldr	r2, [r7, #24]
 4461 0148 1832     		adds	r2, r2, #24
 4462 014a 5A60     		str	r2, [r3, #4]
 4463 014c BB69     		ldr	r3, [r7, #24]
 4464 014e 03F11802 		add	r2, r3, #24
 4465 0152 3B69     		ldr	r3, [r7, #16]
 4466 0154 9A60     		str	r2, [r3, #8]
 4467 0156 BB69     		ldr	r3, [r7, #24]
 4468 0158 134A     		ldr	r2, .L271+24
 4469 015a 9A62     		str	r2, [r3, #40]
 4470 015c 124B     		ldr	r3, .L271+24
ARM GAS  /tmp/ccTFOe4z.s 			page 136


 4471 015e 1B68     		ldr	r3, [r3]
 4472 0160 0133     		adds	r3, r3, #1
 4473 0162 114A     		ldr	r2, .L271+24
 4474 0164 1360     		str	r3, [r2]
 4475              	.L267:
 4476              	.LBE27:
3276:Lib/FreeRTOS/Source/tasks.c ****     }
3277:Lib/FreeRTOS/Source/tasks.c **** 
3278:Lib/FreeRTOS/Source/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4477              		.loc 1 3278 23
 4478 0166 BB69     		ldr	r3, [r7, #24]
 4479 0168 DA6A     		ldr	r2, [r3, #44]
 4480              		.loc 1 3278 50
 4481 016a 104B     		ldr	r3, .L271+28
 4482 016c 1B68     		ldr	r3, [r3]
 4483 016e DB6A     		ldr	r3, [r3, #44]
 4484              		.loc 1 3278 7
 4485 0170 9A42     		cmp	r2, r3
 4486 0172 05D9     		bls	.L268
3279:Lib/FreeRTOS/Source/tasks.c ****     {
3280:Lib/FreeRTOS/Source/tasks.c ****         /* Return true if the task removed from the event list has a higher
3281:Lib/FreeRTOS/Source/tasks.c ****          * priority than the calling task.  This allows the calling task to know if
3282:Lib/FreeRTOS/Source/tasks.c ****          * it should force a context switch now. */
3283:Lib/FreeRTOS/Source/tasks.c ****         xReturn = pdTRUE;
 4487              		.loc 1 3283 17
 4488 0174 0123     		movs	r3, #1
 4489 0176 FB61     		str	r3, [r7, #28]
3284:Lib/FreeRTOS/Source/tasks.c **** 
3285:Lib/FreeRTOS/Source/tasks.c ****         /* Mark that a yield is pending in case the user is not using the
3286:Lib/FreeRTOS/Source/tasks.c ****          * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
3287:Lib/FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
 4490              		.loc 1 3287 23
 4491 0178 0D4B     		ldr	r3, .L271+32
 4492 017a 0122     		movs	r2, #1
 4493 017c 1A60     		str	r2, [r3]
 4494 017e 01E0     		b	.L269
 4495              	.L268:
3288:Lib/FreeRTOS/Source/tasks.c ****     }
3289:Lib/FreeRTOS/Source/tasks.c ****     else
3290:Lib/FreeRTOS/Source/tasks.c ****     {
3291:Lib/FreeRTOS/Source/tasks.c ****         xReturn = pdFALSE;
 4496              		.loc 1 3291 17
 4497 0180 0023     		movs	r3, #0
 4498 0182 FB61     		str	r3, [r7, #28]
 4499              	.L269:
3292:Lib/FreeRTOS/Source/tasks.c ****     }
3293:Lib/FreeRTOS/Source/tasks.c **** 
3294:Lib/FreeRTOS/Source/tasks.c ****     return xReturn;
 4500              		.loc 1 3294 12
 4501 0184 FB69     		ldr	r3, [r7, #28]
3295:Lib/FreeRTOS/Source/tasks.c **** }
 4502              		.loc 1 3295 1
 4503 0186 1846     		mov	r0, r3
 4504 0188 2037     		adds	r7, r7, #32
 4505              		.cfi_def_cfa_offset 8
 4506 018a BD46     		mov	sp, r7
 4507              		.cfi_def_cfa_register 13
ARM GAS  /tmp/ccTFOe4z.s 			page 137


 4508              		@ sp needed
 4509 018c 80BD     		pop	{r7, pc}
 4510              	.L272:
 4511 018e 00BF     		.align	2
 4512              	.L271:
 4513 0190 00000000 		.word	.LC0
 4514 0194 00000000 		.word	__func__.12
 4515 0198 04000000 		.word	.LC1
 4516 019c 00000000 		.word	uxSchedulerSuspended
 4517 01a0 00000000 		.word	uxTopReadyPriority
 4518 01a4 00000000 		.word	pxReadyTasksLists
 4519 01a8 00000000 		.word	xPendingReadyList
 4520 01ac 00000000 		.word	pxCurrentTCB
 4521 01b0 00000000 		.word	xYieldPending
 4522              		.cfi_endproc
 4523              	.LFE31:
 4525              		.section	.text.vTaskRemoveFromUnorderedEventList,"ax",%progbits
 4526              		.align	1
 4527              		.global	vTaskRemoveFromUnorderedEventList
 4528              		.syntax unified
 4529              		.thumb
 4530              		.thumb_func
 4532              	vTaskRemoveFromUnorderedEventList:
 4533              	.LFB32:
3296:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3297:Lib/FreeRTOS/Source/tasks.c **** 
3298:Lib/FreeRTOS/Source/tasks.c **** void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
3299:Lib/FreeRTOS/Source/tasks.c ****                                         const TickType_t xItemValue )
3300:Lib/FreeRTOS/Source/tasks.c **** {
 4534              		.loc 1 3300 1
 4535              		.cfi_startproc
 4536              		@ args = 0, pretend = 0, frame = 24
 4537              		@ frame_needed = 1, uses_anonymous_args = 0
 4538 0000 80B5     		push	{r7, lr}
 4539              		.cfi_def_cfa_offset 8
 4540              		.cfi_offset 7, -8
 4541              		.cfi_offset 14, -4
 4542 0002 86B0     		sub	sp, sp, #24
 4543              		.cfi_def_cfa_offset 32
 4544 0004 00AF     		add	r7, sp, #0
 4545              		.cfi_def_cfa_register 7
 4546 0006 7860     		str	r0, [r7, #4]
 4547 0008 3960     		str	r1, [r7]
3301:Lib/FreeRTOS/Source/tasks.c ****     TCB_t * pxUnblockedTCB;
3302:Lib/FreeRTOS/Source/tasks.c **** 
3303:Lib/FreeRTOS/Source/tasks.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
3304:Lib/FreeRTOS/Source/tasks.c ****      * the event flags implementation. */
3305:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 4548              		.loc 1 3305 5
 4549 000a 564B     		ldr	r3, .L281
 4550 000c 1B68     		ldr	r3, [r3]
 4551 000e 002B     		cmp	r3, #0
 4552 0010 08D1     		bne	.L274
 4553              		.loc 1 3305 5 is_stmt 0 discriminator 1
 4554 0012 FFF7FEFF 		bl	ulSetInterruptMask
 4555 0016 544B     		ldr	r3, .L281+4
 4556 0018 544A     		ldr	r2, .L281+8
ARM GAS  /tmp/ccTFOe4z.s 			page 138


 4557 001a 40F6E941 		movw	r1, #3305
 4558 001e 5448     		ldr	r0, .L281+12
 4559 0020 FFF7FEFF 		bl	__assert_func
 4560              	.L274:
3306:Lib/FreeRTOS/Source/tasks.c **** 
3307:Lib/FreeRTOS/Source/tasks.c ****     /* Store the new item value in the event list. */
3308:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 4561              		.loc 1 3308 5 is_stmt 1
 4562 0024 3B68     		ldr	r3, [r7]
 4563 0026 43F00042 		orr	r2, r3, #-2147483648
 4564 002a 7B68     		ldr	r3, [r7, #4]
 4565 002c 1A60     		str	r2, [r3]
3309:Lib/FreeRTOS/Source/tasks.c **** 
3310:Lib/FreeRTOS/Source/tasks.c ****     /* Remove the event list form the event flag.  Interrupts do not access
3311:Lib/FreeRTOS/Source/tasks.c ****      * event flags. */
3312:Lib/FreeRTOS/Source/tasks.c ****     pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as th
 4566              		.loc 1 3312 20
 4567 002e 7B68     		ldr	r3, [r7, #4]
 4568 0030 DB68     		ldr	r3, [r3, #12]
 4569 0032 7B61     		str	r3, [r7, #20]
3313:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxUnblockedTCB );
 4570              		.loc 1 3313 5
 4571 0034 7B69     		ldr	r3, [r7, #20]
 4572 0036 002B     		cmp	r3, #0
 4573 0038 08D1     		bne	.L275
 4574              		.loc 1 3313 5 is_stmt 0 discriminator 1
 4575 003a FFF7FEFF 		bl	ulSetInterruptMask
 4576 003e 4A4B     		ldr	r3, .L281+4
 4577 0040 4A4A     		ldr	r2, .L281+8
 4578 0042 40F6F141 		movw	r1, #3313
 4579 0046 4A48     		ldr	r0, .L281+12
 4580 0048 FFF7FEFF 		bl	__assert_func
 4581              	.L275:
 4582              	.LBB28:
3314:Lib/FreeRTOS/Source/tasks.c ****     listREMOVE_ITEM( pxEventListItem );
 4583              		.loc 1 3314 5 is_stmt 1
 4584 004c 7B68     		ldr	r3, [r7, #4]
 4585 004e 1B69     		ldr	r3, [r3, #16]
 4586 0050 3B61     		str	r3, [r7, #16]
 4587 0052 7B68     		ldr	r3, [r7, #4]
 4588 0054 5B68     		ldr	r3, [r3, #4]
 4589 0056 7A68     		ldr	r2, [r7, #4]
 4590 0058 9268     		ldr	r2, [r2, #8]
 4591 005a 9A60     		str	r2, [r3, #8]
 4592 005c 7B68     		ldr	r3, [r7, #4]
 4593 005e 9B68     		ldr	r3, [r3, #8]
 4594 0060 7A68     		ldr	r2, [r7, #4]
 4595 0062 5268     		ldr	r2, [r2, #4]
 4596 0064 5A60     		str	r2, [r3, #4]
 4597 0066 3B69     		ldr	r3, [r7, #16]
 4598 0068 5B68     		ldr	r3, [r3, #4]
 4599 006a 7A68     		ldr	r2, [r7, #4]
 4600 006c 9A42     		cmp	r2, r3
 4601 006e 03D1     		bne	.L276
 4602              		.loc 1 3314 5 is_stmt 0 discriminator 1
 4603 0070 7B68     		ldr	r3, [r7, #4]
 4604 0072 9A68     		ldr	r2, [r3, #8]
ARM GAS  /tmp/ccTFOe4z.s 			page 139


 4605 0074 3B69     		ldr	r3, [r7, #16]
 4606 0076 5A60     		str	r2, [r3, #4]
 4607              	.L276:
 4608              		.loc 1 3314 5 discriminator 3
 4609 0078 7B68     		ldr	r3, [r7, #4]
 4610 007a 0022     		movs	r2, #0
 4611 007c 1A61     		str	r2, [r3, #16]
 4612 007e 3B69     		ldr	r3, [r7, #16]
 4613 0080 1B68     		ldr	r3, [r3]
 4614 0082 5A1E     		subs	r2, r3, #1
 4615 0084 3B69     		ldr	r3, [r7, #16]
 4616 0086 1A60     		str	r2, [r3]
 4617              	.LBE28:
 4618              	.LBB29:
3315:Lib/FreeRTOS/Source/tasks.c **** 
3316:Lib/FreeRTOS/Source/tasks.c ****     #if ( configUSE_TICKLESS_IDLE != 0 )
3317:Lib/FreeRTOS/Source/tasks.c ****     {
3318:Lib/FreeRTOS/Source/tasks.c ****         /* If a task is blocked on a kernel object then xNextTaskUnblockTime
3319:Lib/FreeRTOS/Source/tasks.c ****          * might be set to the blocked task's time out time.  If the task is
3320:Lib/FreeRTOS/Source/tasks.c ****          * unblocked for a reason other than a timeout xNextTaskUnblockTime is
3321:Lib/FreeRTOS/Source/tasks.c ****          * normally left unchanged, because it is automatically reset to a new
3322:Lib/FreeRTOS/Source/tasks.c ****          * value when the tick count equals xNextTaskUnblockTime.  However if
3323:Lib/FreeRTOS/Source/tasks.c ****          * tickless idling is used it might be more important to enter sleep mode
3324:Lib/FreeRTOS/Source/tasks.c ****          * at the earliest possible time - so reset xNextTaskUnblockTime here to
3325:Lib/FreeRTOS/Source/tasks.c ****          * ensure it is updated at the earliest possible time. */
3326:Lib/FreeRTOS/Source/tasks.c ****         prvResetNextTaskUnblockTime();
3327:Lib/FreeRTOS/Source/tasks.c ****     }
3328:Lib/FreeRTOS/Source/tasks.c ****     #endif
3329:Lib/FreeRTOS/Source/tasks.c **** 
3330:Lib/FreeRTOS/Source/tasks.c ****     /* Remove the task from the delayed list and add it to the ready list.  The
3331:Lib/FreeRTOS/Source/tasks.c ****      * scheduler is suspended so interrupts will not be accessing the ready
3332:Lib/FreeRTOS/Source/tasks.c ****      * lists. */
3333:Lib/FreeRTOS/Source/tasks.c ****     listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 4619              		.loc 1 3333 5 is_stmt 1
 4620 0088 7B69     		ldr	r3, [r7, #20]
 4621 008a 5B69     		ldr	r3, [r3, #20]
 4622 008c FB60     		str	r3, [r7, #12]
 4623 008e 7B69     		ldr	r3, [r7, #20]
 4624 0090 9B68     		ldr	r3, [r3, #8]
 4625 0092 7A69     		ldr	r2, [r7, #20]
 4626 0094 D268     		ldr	r2, [r2, #12]
 4627 0096 9A60     		str	r2, [r3, #8]
 4628 0098 7B69     		ldr	r3, [r7, #20]
 4629 009a DB68     		ldr	r3, [r3, #12]
 4630 009c 7A69     		ldr	r2, [r7, #20]
 4631 009e 9268     		ldr	r2, [r2, #8]
 4632 00a0 5A60     		str	r2, [r3, #4]
 4633 00a2 FB68     		ldr	r3, [r7, #12]
 4634 00a4 5A68     		ldr	r2, [r3, #4]
 4635 00a6 7B69     		ldr	r3, [r7, #20]
 4636 00a8 0433     		adds	r3, r3, #4
 4637 00aa 9A42     		cmp	r2, r3
 4638 00ac 03D1     		bne	.L277
 4639              		.loc 1 3333 5 is_stmt 0 discriminator 1
 4640 00ae 7B69     		ldr	r3, [r7, #20]
 4641 00b0 DA68     		ldr	r2, [r3, #12]
 4642 00b2 FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 140


 4643 00b4 5A60     		str	r2, [r3, #4]
 4644              	.L277:
 4645              		.loc 1 3333 5 discriminator 3
 4646 00b6 7B69     		ldr	r3, [r7, #20]
 4647 00b8 0022     		movs	r2, #0
 4648 00ba 5A61     		str	r2, [r3, #20]
 4649 00bc FB68     		ldr	r3, [r7, #12]
 4650 00be 1B68     		ldr	r3, [r3]
 4651 00c0 5A1E     		subs	r2, r3, #1
 4652 00c2 FB68     		ldr	r3, [r7, #12]
 4653 00c4 1A60     		str	r2, [r3]
 4654              	.LBE29:
3334:Lib/FreeRTOS/Source/tasks.c ****     prvAddTaskToReadyList( pxUnblockedTCB );
 4655              		.loc 1 3334 5 is_stmt 1
 4656 00c6 7B69     		ldr	r3, [r7, #20]
 4657 00c8 DA6A     		ldr	r2, [r3, #44]
 4658 00ca 2A4B     		ldr	r3, .L281+16
 4659 00cc 1B68     		ldr	r3, [r3]
 4660 00ce 9A42     		cmp	r2, r3
 4661 00d0 03D9     		bls	.L278
 4662              		.loc 1 3334 5 is_stmt 0 discriminator 1
 4663 00d2 7B69     		ldr	r3, [r7, #20]
 4664 00d4 DB6A     		ldr	r3, [r3, #44]
 4665 00d6 274A     		ldr	r2, .L281+16
 4666 00d8 1360     		str	r3, [r2]
 4667              	.L278:
 4668              	.LBB30:
 4669              		.loc 1 3334 5 discriminator 3
 4670 00da 7B69     		ldr	r3, [r7, #20]
 4671 00dc DA6A     		ldr	r2, [r3, #44]
 4672 00de 2649     		ldr	r1, .L281+20
 4673 00e0 1346     		mov	r3, r2
 4674 00e2 9B00     		lsls	r3, r3, #2
 4675 00e4 1344     		add	r3, r3, r2
 4676 00e6 9B00     		lsls	r3, r3, #2
 4677 00e8 0B44     		add	r3, r3, r1
 4678 00ea 0433     		adds	r3, r3, #4
 4679 00ec 1B68     		ldr	r3, [r3]
 4680 00ee BB60     		str	r3, [r7, #8]
 4681 00f0 7B69     		ldr	r3, [r7, #20]
 4682 00f2 BA68     		ldr	r2, [r7, #8]
 4683 00f4 9A60     		str	r2, [r3, #8]
 4684 00f6 BB68     		ldr	r3, [r7, #8]
 4685 00f8 9A68     		ldr	r2, [r3, #8]
 4686 00fa 7B69     		ldr	r3, [r7, #20]
 4687 00fc DA60     		str	r2, [r3, #12]
 4688 00fe BB68     		ldr	r3, [r7, #8]
 4689 0100 9B68     		ldr	r3, [r3, #8]
 4690 0102 7A69     		ldr	r2, [r7, #20]
 4691 0104 0432     		adds	r2, r2, #4
 4692 0106 5A60     		str	r2, [r3, #4]
 4693 0108 7B69     		ldr	r3, [r7, #20]
 4694 010a 1A1D     		adds	r2, r3, #4
 4695 010c BB68     		ldr	r3, [r7, #8]
 4696 010e 9A60     		str	r2, [r3, #8]
 4697 0110 7B69     		ldr	r3, [r7, #20]
 4698 0112 DA6A     		ldr	r2, [r3, #44]
ARM GAS  /tmp/ccTFOe4z.s 			page 141


 4699 0114 1346     		mov	r3, r2
 4700 0116 9B00     		lsls	r3, r3, #2
 4701 0118 1344     		add	r3, r3, r2
 4702 011a 9B00     		lsls	r3, r3, #2
 4703 011c 164A     		ldr	r2, .L281+20
 4704 011e 1A44     		add	r2, r2, r3
 4705 0120 7B69     		ldr	r3, [r7, #20]
 4706 0122 5A61     		str	r2, [r3, #20]
 4707 0124 7B69     		ldr	r3, [r7, #20]
 4708 0126 DA6A     		ldr	r2, [r3, #44]
 4709 0128 1349     		ldr	r1, .L281+20
 4710 012a 1346     		mov	r3, r2
 4711 012c 9B00     		lsls	r3, r3, #2
 4712 012e 1344     		add	r3, r3, r2
 4713 0130 9B00     		lsls	r3, r3, #2
 4714 0132 0B44     		add	r3, r3, r1
 4715 0134 1B68     		ldr	r3, [r3]
 4716 0136 591C     		adds	r1, r3, #1
 4717 0138 0F48     		ldr	r0, .L281+20
 4718 013a 1346     		mov	r3, r2
 4719 013c 9B00     		lsls	r3, r3, #2
 4720 013e 1344     		add	r3, r3, r2
 4721 0140 9B00     		lsls	r3, r3, #2
 4722 0142 0344     		add	r3, r3, r0
 4723 0144 1960     		str	r1, [r3]
 4724              	.LBE30:
3335:Lib/FreeRTOS/Source/tasks.c **** 
3336:Lib/FreeRTOS/Source/tasks.c ****     if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 4725              		.loc 1 3336 23 is_stmt 1
 4726 0146 7B69     		ldr	r3, [r7, #20]
 4727 0148 DA6A     		ldr	r2, [r3, #44]
 4728              		.loc 1 3336 50
 4729 014a 0C4B     		ldr	r3, .L281+24
 4730 014c 1B68     		ldr	r3, [r3]
 4731 014e DB6A     		ldr	r3, [r3, #44]
 4732              		.loc 1 3336 7
 4733 0150 9A42     		cmp	r2, r3
 4734 0152 02D9     		bls	.L280
3337:Lib/FreeRTOS/Source/tasks.c ****     {
3338:Lib/FreeRTOS/Source/tasks.c ****         /* The unblocked task has a priority above that of the calling task, so
3339:Lib/FreeRTOS/Source/tasks.c ****          * a context switch is required.  This function is called with the
3340:Lib/FreeRTOS/Source/tasks.c ****          * scheduler suspended so xYieldPending is set so the context switch
3341:Lib/FreeRTOS/Source/tasks.c ****          * occurs immediately that the scheduler is resumed (unsuspended). */
3342:Lib/FreeRTOS/Source/tasks.c ****         xYieldPending = pdTRUE;
 4735              		.loc 1 3342 23
 4736 0154 0A4B     		ldr	r3, .L281+28
 4737 0156 0122     		movs	r2, #1
 4738 0158 1A60     		str	r2, [r3]
 4739              	.L280:
3343:Lib/FreeRTOS/Source/tasks.c ****     }
3344:Lib/FreeRTOS/Source/tasks.c **** }
 4740              		.loc 1 3344 1
 4741 015a 00BF     		nop
 4742 015c 1837     		adds	r7, r7, #24
 4743              		.cfi_def_cfa_offset 8
 4744 015e BD46     		mov	sp, r7
 4745              		.cfi_def_cfa_register 13
ARM GAS  /tmp/ccTFOe4z.s 			page 142


 4746              		@ sp needed
 4747 0160 80BD     		pop	{r7, pc}
 4748              	.L282:
 4749 0162 00BF     		.align	2
 4750              	.L281:
 4751 0164 00000000 		.word	uxSchedulerSuspended
 4752 0168 00000000 		.word	.LC0
 4753 016c 00000000 		.word	__func__.11
 4754 0170 04000000 		.word	.LC1
 4755 0174 00000000 		.word	uxTopReadyPriority
 4756 0178 00000000 		.word	pxReadyTasksLists
 4757 017c 00000000 		.word	pxCurrentTCB
 4758 0180 00000000 		.word	xYieldPending
 4759              		.cfi_endproc
 4760              	.LFE32:
 4762              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 4763              		.align	1
 4764              		.global	vTaskSetTimeOutState
 4765              		.syntax unified
 4766              		.thumb
 4767              		.thumb_func
 4769              	vTaskSetTimeOutState:
 4770              	.LFB33:
3345:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3346:Lib/FreeRTOS/Source/tasks.c **** 
3347:Lib/FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
3348:Lib/FreeRTOS/Source/tasks.c **** {
 4771              		.loc 1 3348 1
 4772              		.cfi_startproc
 4773              		@ args = 0, pretend = 0, frame = 8
 4774              		@ frame_needed = 1, uses_anonymous_args = 0
 4775 0000 80B5     		push	{r7, lr}
 4776              		.cfi_def_cfa_offset 8
 4777              		.cfi_offset 7, -8
 4778              		.cfi_offset 14, -4
 4779 0002 82B0     		sub	sp, sp, #8
 4780              		.cfi_def_cfa_offset 16
 4781 0004 00AF     		add	r7, sp, #0
 4782              		.cfi_def_cfa_register 7
 4783 0006 7860     		str	r0, [r7, #4]
3349:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
 4784              		.loc 1 3349 5
 4785 0008 7B68     		ldr	r3, [r7, #4]
 4786 000a 002B     		cmp	r3, #0
 4787 000c 08D1     		bne	.L284
 4788              		.loc 1 3349 5 is_stmt 0 discriminator 1
 4789 000e FFF7FEFF 		bl	ulSetInterruptMask
 4790 0012 0B4B     		ldr	r3, .L285
 4791 0014 0B4A     		ldr	r2, .L285+4
 4792 0016 40F61551 		movw	r1, #3349
 4793 001a 0B48     		ldr	r0, .L285+8
 4794 001c FFF7FEFF 		bl	__assert_func
 4795              	.L284:
3350:Lib/FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 4796              		.loc 1 3350 5 is_stmt 1
 4797 0020 FFF7FEFF 		bl	vPortEnterCritical
3351:Lib/FreeRTOS/Source/tasks.c ****     {
ARM GAS  /tmp/ccTFOe4z.s 			page 143


3352:Lib/FreeRTOS/Source/tasks.c ****         pxTimeOut->xOverflowCount = xNumOfOverflows;
 4798              		.loc 1 3352 35
 4799 0024 094B     		ldr	r3, .L285+12
 4800 0026 1A68     		ldr	r2, [r3]
 4801 0028 7B68     		ldr	r3, [r7, #4]
 4802 002a 1A60     		str	r2, [r3]
3353:Lib/FreeRTOS/Source/tasks.c ****         pxTimeOut->xTimeOnEntering = xTickCount;
 4803              		.loc 1 3353 36
 4804 002c 084B     		ldr	r3, .L285+16
 4805 002e 1A68     		ldr	r2, [r3]
 4806 0030 7B68     		ldr	r3, [r7, #4]
 4807 0032 5A60     		str	r2, [r3, #4]
3354:Lib/FreeRTOS/Source/tasks.c ****     }
3355:Lib/FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
 4808              		.loc 1 3355 5
 4809 0034 FFF7FEFF 		bl	vPortExitCritical
3356:Lib/FreeRTOS/Source/tasks.c **** }
 4810              		.loc 1 3356 1
 4811 0038 00BF     		nop
 4812 003a 0837     		adds	r7, r7, #8
 4813              		.cfi_def_cfa_offset 8
 4814 003c BD46     		mov	sp, r7
 4815              		.cfi_def_cfa_register 13
 4816              		@ sp needed
 4817 003e 80BD     		pop	{r7, pc}
 4818              	.L286:
 4819              		.align	2
 4820              	.L285:
 4821 0040 00000000 		.word	.LC0
 4822 0044 00000000 		.word	__func__.10
 4823 0048 04000000 		.word	.LC1
 4824 004c 00000000 		.word	xNumOfOverflows
 4825 0050 00000000 		.word	xTickCount
 4826              		.cfi_endproc
 4827              	.LFE33:
 4829              		.section	.text.vTaskInternalSetTimeOutState,"ax",%progbits
 4830              		.align	1
 4831              		.global	vTaskInternalSetTimeOutState
 4832              		.syntax unified
 4833              		.thumb
 4834              		.thumb_func
 4836              	vTaskInternalSetTimeOutState:
 4837              	.LFB34:
3357:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3358:Lib/FreeRTOS/Source/tasks.c **** 
3359:Lib/FreeRTOS/Source/tasks.c **** void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
3360:Lib/FreeRTOS/Source/tasks.c **** {
 4838              		.loc 1 3360 1
 4839              		.cfi_startproc
 4840              		@ args = 0, pretend = 0, frame = 8
 4841              		@ frame_needed = 1, uses_anonymous_args = 0
 4842              		@ link register save eliminated.
 4843 0000 80B4     		push	{r7}
 4844              		.cfi_def_cfa_offset 4
 4845              		.cfi_offset 7, -4
 4846 0002 83B0     		sub	sp, sp, #12
 4847              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccTFOe4z.s 			page 144


 4848 0004 00AF     		add	r7, sp, #0
 4849              		.cfi_def_cfa_register 7
 4850 0006 7860     		str	r0, [r7, #4]
3361:Lib/FreeRTOS/Source/tasks.c ****     /* For internal use only as it does not use a critical section. */
3362:Lib/FreeRTOS/Source/tasks.c ****     pxTimeOut->xOverflowCount = xNumOfOverflows;
 4851              		.loc 1 3362 31
 4852 0008 064B     		ldr	r3, .L288
 4853 000a 1A68     		ldr	r2, [r3]
 4854 000c 7B68     		ldr	r3, [r7, #4]
 4855 000e 1A60     		str	r2, [r3]
3363:Lib/FreeRTOS/Source/tasks.c ****     pxTimeOut->xTimeOnEntering = xTickCount;
 4856              		.loc 1 3363 32
 4857 0010 054B     		ldr	r3, .L288+4
 4858 0012 1A68     		ldr	r2, [r3]
 4859 0014 7B68     		ldr	r3, [r7, #4]
 4860 0016 5A60     		str	r2, [r3, #4]
3364:Lib/FreeRTOS/Source/tasks.c **** }
 4861              		.loc 1 3364 1
 4862 0018 00BF     		nop
 4863 001a 0C37     		adds	r7, r7, #12
 4864              		.cfi_def_cfa_offset 4
 4865 001c BD46     		mov	sp, r7
 4866              		.cfi_def_cfa_register 13
 4867              		@ sp needed
 4868 001e 5DF8047B 		ldr	r7, [sp], #4
 4869              		.cfi_restore 7
 4870              		.cfi_def_cfa_offset 0
 4871 0022 7047     		bx	lr
 4872              	.L289:
 4873              		.align	2
 4874              	.L288:
 4875 0024 00000000 		.word	xNumOfOverflows
 4876 0028 00000000 		.word	xTickCount
 4877              		.cfi_endproc
 4878              	.LFE34:
 4880              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 4881              		.align	1
 4882              		.global	xTaskCheckForTimeOut
 4883              		.syntax unified
 4884              		.thumb
 4885              		.thumb_func
 4887              	xTaskCheckForTimeOut:
 4888              	.LFB35:
3365:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3366:Lib/FreeRTOS/Source/tasks.c **** 
3367:Lib/FreeRTOS/Source/tasks.c **** BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
3368:Lib/FreeRTOS/Source/tasks.c ****                                  TickType_t * const pxTicksToWait )
3369:Lib/FreeRTOS/Source/tasks.c **** {
 4889              		.loc 1 3369 1
 4890              		.cfi_startproc
 4891              		@ args = 0, pretend = 0, frame = 24
 4892              		@ frame_needed = 1, uses_anonymous_args = 0
 4893 0000 80B5     		push	{r7, lr}
 4894              		.cfi_def_cfa_offset 8
 4895              		.cfi_offset 7, -8
 4896              		.cfi_offset 14, -4
 4897 0002 86B0     		sub	sp, sp, #24
ARM GAS  /tmp/ccTFOe4z.s 			page 145


 4898              		.cfi_def_cfa_offset 32
 4899 0004 00AF     		add	r7, sp, #0
 4900              		.cfi_def_cfa_register 7
 4901 0006 7860     		str	r0, [r7, #4]
 4902 0008 3960     		str	r1, [r7]
3370:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xReturn;
3371:Lib/FreeRTOS/Source/tasks.c **** 
3372:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxTimeOut );
 4903              		.loc 1 3372 5
 4904 000a 7B68     		ldr	r3, [r7, #4]
 4905 000c 002B     		cmp	r3, #0
 4906 000e 08D1     		bne	.L291
 4907              		.loc 1 3372 5 is_stmt 0 discriminator 1
 4908 0010 FFF7FEFF 		bl	ulSetInterruptMask
 4909 0014 294B     		ldr	r3, .L298
 4910 0016 2A4A     		ldr	r2, .L298+4
 4911 0018 40F62C51 		movw	r1, #3372
 4912 001c 2948     		ldr	r0, .L298+8
 4913 001e FFF7FEFF 		bl	__assert_func
 4914              	.L291:
3373:Lib/FreeRTOS/Source/tasks.c ****     configASSERT( pxTicksToWait );
 4915              		.loc 1 3373 5 is_stmt 1
 4916 0022 3B68     		ldr	r3, [r7]
 4917 0024 002B     		cmp	r3, #0
 4918 0026 08D1     		bne	.L292
 4919              		.loc 1 3373 5 is_stmt 0 discriminator 1
 4920 0028 FFF7FEFF 		bl	ulSetInterruptMask
 4921 002c 234B     		ldr	r3, .L298
 4922 002e 244A     		ldr	r2, .L298+4
 4923 0030 40F62D51 		movw	r1, #3373
 4924 0034 2348     		ldr	r0, .L298+8
 4925 0036 FFF7FEFF 		bl	__assert_func
 4926              	.L292:
3374:Lib/FreeRTOS/Source/tasks.c **** 
3375:Lib/FreeRTOS/Source/tasks.c ****     taskENTER_CRITICAL();
 4927              		.loc 1 3375 5 is_stmt 1
 4928 003a FFF7FEFF 		bl	vPortEnterCritical
 4929              	.LBB31:
3376:Lib/FreeRTOS/Source/tasks.c ****     {
3377:Lib/FreeRTOS/Source/tasks.c ****         /* Minor optimisation.  The tick count cannot change in this block. */
3378:Lib/FreeRTOS/Source/tasks.c ****         const TickType_t xConstTickCount = xTickCount;
 4930              		.loc 1 3378 26
 4931 003e 224B     		ldr	r3, .L298+12
 4932 0040 1B68     		ldr	r3, [r3]
 4933 0042 3B61     		str	r3, [r7, #16]
3379:Lib/FreeRTOS/Source/tasks.c ****         const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 4934              		.loc 1 3379 68
 4935 0044 7B68     		ldr	r3, [r7, #4]
 4936 0046 5B68     		ldr	r3, [r3, #4]
 4937              		.loc 1 3379 26
 4938 0048 3A69     		ldr	r2, [r7, #16]
 4939 004a D31A     		subs	r3, r2, r3
 4940 004c FB60     		str	r3, [r7, #12]
3380:Lib/FreeRTOS/Source/tasks.c **** 
3381:Lib/FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_xTaskAbortDelay == 1 )
3382:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
3383:Lib/FreeRTOS/Source/tasks.c ****             {
ARM GAS  /tmp/ccTFOe4z.s 			page 146


3384:Lib/FreeRTOS/Source/tasks.c ****                 /* The delay was aborted, which is not the same as a time out,
3385:Lib/FreeRTOS/Source/tasks.c ****                  * but has the same result. */
3386:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucDelayAborted = pdFALSE;
3387:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
3388:Lib/FreeRTOS/Source/tasks.c ****             }
3389:Lib/FreeRTOS/Source/tasks.c ****             else
3390:Lib/FreeRTOS/Source/tasks.c ****         #endif
3391:Lib/FreeRTOS/Source/tasks.c **** 
3392:Lib/FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
3393:Lib/FreeRTOS/Source/tasks.c ****             if( *pxTicksToWait == portMAX_DELAY )
 4941              		.loc 1 3393 17
 4942 004e 3B68     		ldr	r3, [r7]
 4943 0050 1B68     		ldr	r3, [r3]
 4944              		.loc 1 3393 15
 4945 0052 B3F1FF3F 		cmp	r3, #-1
 4946 0056 02D1     		bne	.L293
3394:Lib/FreeRTOS/Source/tasks.c ****             {
3395:Lib/FreeRTOS/Source/tasks.c ****                 /* If INCLUDE_vTaskSuspend is set to 1 and the block time
3396:Lib/FreeRTOS/Source/tasks.c ****                  * specified is the maximum block time then the task should block
3397:Lib/FreeRTOS/Source/tasks.c ****                  * indefinitely, and therefore never time out. */
3398:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdFALSE;
 4947              		.loc 1 3398 25
 4948 0058 0023     		movs	r3, #0
 4949 005a 7B61     		str	r3, [r7, #20]
 4950 005c 26E0     		b	.L294
 4951              	.L293:
3399:Lib/FreeRTOS/Source/tasks.c ****             }
3400:Lib/FreeRTOS/Source/tasks.c ****             else
3401:Lib/FreeRTOS/Source/tasks.c ****         #endif
3402:Lib/FreeRTOS/Source/tasks.c **** 
3403:Lib/FreeRTOS/Source/tasks.c ****         if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTi
 4952              		.loc 1 3403 43
 4953 005e 7B68     		ldr	r3, [r7, #4]
 4954 0060 1A68     		ldr	r2, [r3]
 4955              		.loc 1 3403 31
 4956 0062 1A4B     		ldr	r3, .L298+16
 4957 0064 1B68     		ldr	r3, [r3]
 4958              		.loc 1 3403 11
 4959 0066 9A42     		cmp	r2, r3
 4960 0068 0AD0     		beq	.L295
 4961              		.loc 1 3403 95 discriminator 1
 4962 006a 7B68     		ldr	r3, [r7, #4]
 4963 006c 5B68     		ldr	r3, [r3, #4]
 4964              		.loc 1 3403 62 discriminator 1
 4965 006e 3A69     		ldr	r2, [r7, #16]
 4966 0070 9A42     		cmp	r2, r3
 4967 0072 05D3     		bcc	.L295
3404:Lib/FreeRTOS/Source/tasks.c ****         {
3405:Lib/FreeRTOS/Source/tasks.c ****             /* The tick count is greater than the time at which
3406:Lib/FreeRTOS/Source/tasks.c ****              * vTaskSetTimeout() was called, but has also overflowed since
3407:Lib/FreeRTOS/Source/tasks.c ****              * vTaskSetTimeOut() was called.  It must have wrapped all the way
3408:Lib/FreeRTOS/Source/tasks.c ****              * around and gone past again. This passed since vTaskSetTimeout()
3409:Lib/FreeRTOS/Source/tasks.c ****              * was called. */
3410:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
 4968              		.loc 1 3410 21
 4969 0074 0123     		movs	r3, #1
 4970 0076 7B61     		str	r3, [r7, #20]
ARM GAS  /tmp/ccTFOe4z.s 			page 147


3411:Lib/FreeRTOS/Source/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
 4971              		.loc 1 3411 28
 4972 0078 3B68     		ldr	r3, [r7]
 4973 007a 0022     		movs	r2, #0
 4974 007c 1A60     		str	r2, [r3]
 4975 007e 15E0     		b	.L294
 4976              	.L295:
3412:Lib/FreeRTOS/Source/tasks.c ****         }
3413:Lib/FreeRTOS/Source/tasks.c ****         else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant wi
 4977              		.loc 1 3413 33
 4978 0080 3B68     		ldr	r3, [r7]
 4979 0082 1B68     		ldr	r3, [r3]
 4980              		.loc 1 3413 16
 4981 0084 FA68     		ldr	r2, [r7, #12]
 4982 0086 9A42     		cmp	r2, r3
 4983 0088 0BD2     		bcs	.L296
3414:Lib/FreeRTOS/Source/tasks.c ****         {
3415:Lib/FreeRTOS/Source/tasks.c ****             /* Not a genuine timeout. Adjust parameters for time remaining. */
3416:Lib/FreeRTOS/Source/tasks.c ****             *pxTicksToWait -= xElapsedTime;
 4984              		.loc 1 3416 13
 4985 008a 3B68     		ldr	r3, [r7]
 4986 008c 1A68     		ldr	r2, [r3]
 4987              		.loc 1 3416 28
 4988 008e FB68     		ldr	r3, [r7, #12]
 4989 0090 D21A     		subs	r2, r2, r3
 4990 0092 3B68     		ldr	r3, [r7]
 4991 0094 1A60     		str	r2, [r3]
3417:Lib/FreeRTOS/Source/tasks.c ****             vTaskInternalSetTimeOutState( pxTimeOut );
 4992              		.loc 1 3417 13
 4993 0096 7868     		ldr	r0, [r7, #4]
 4994 0098 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
3418:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdFALSE;
 4995              		.loc 1 3418 21
 4996 009c 0023     		movs	r3, #0
 4997 009e 7B61     		str	r3, [r7, #20]
 4998 00a0 04E0     		b	.L294
 4999              	.L296:
3419:Lib/FreeRTOS/Source/tasks.c ****         }
3420:Lib/FreeRTOS/Source/tasks.c ****         else
3421:Lib/FreeRTOS/Source/tasks.c ****         {
3422:Lib/FreeRTOS/Source/tasks.c ****             *pxTicksToWait = ( TickType_t ) 0;
 5000              		.loc 1 3422 28
 5001 00a2 3B68     		ldr	r3, [r7]
 5002 00a4 0022     		movs	r2, #0
 5003 00a6 1A60     		str	r2, [r3]
3423:Lib/FreeRTOS/Source/tasks.c ****             xReturn = pdTRUE;
 5004              		.loc 1 3423 21
 5005 00a8 0123     		movs	r3, #1
 5006 00aa 7B61     		str	r3, [r7, #20]
 5007              	.L294:
 5008              	.LBE31:
3424:Lib/FreeRTOS/Source/tasks.c ****         }
3425:Lib/FreeRTOS/Source/tasks.c ****     }
3426:Lib/FreeRTOS/Source/tasks.c ****     taskEXIT_CRITICAL();
 5009              		.loc 1 3426 5
 5010 00ac FFF7FEFF 		bl	vPortExitCritical
3427:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 148


3428:Lib/FreeRTOS/Source/tasks.c ****     return xReturn;
 5011              		.loc 1 3428 12
 5012 00b0 7B69     		ldr	r3, [r7, #20]
3429:Lib/FreeRTOS/Source/tasks.c **** }
 5013              		.loc 1 3429 1
 5014 00b2 1846     		mov	r0, r3
 5015 00b4 1837     		adds	r7, r7, #24
 5016              		.cfi_def_cfa_offset 8
 5017 00b6 BD46     		mov	sp, r7
 5018              		.cfi_def_cfa_register 13
 5019              		@ sp needed
 5020 00b8 80BD     		pop	{r7, pc}
 5021              	.L299:
 5022 00ba 00BF     		.align	2
 5023              	.L298:
 5024 00bc 00000000 		.word	.LC0
 5025 00c0 00000000 		.word	__func__.9
 5026 00c4 04000000 		.word	.LC1
 5027 00c8 00000000 		.word	xTickCount
 5028 00cc 00000000 		.word	xNumOfOverflows
 5029              		.cfi_endproc
 5030              	.LFE35:
 5032              		.section	.text.vTaskMissedYield,"ax",%progbits
 5033              		.align	1
 5034              		.global	vTaskMissedYield
 5035              		.syntax unified
 5036              		.thumb
 5037              		.thumb_func
 5039              	vTaskMissedYield:
 5040              	.LFB36:
3430:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3431:Lib/FreeRTOS/Source/tasks.c **** 
3432:Lib/FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
3433:Lib/FreeRTOS/Source/tasks.c **** {
 5041              		.loc 1 3433 1
 5042              		.cfi_startproc
 5043              		@ args = 0, pretend = 0, frame = 0
 5044              		@ frame_needed = 1, uses_anonymous_args = 0
 5045              		@ link register save eliminated.
 5046 0000 80B4     		push	{r7}
 5047              		.cfi_def_cfa_offset 4
 5048              		.cfi_offset 7, -4
 5049 0002 00AF     		add	r7, sp, #0
 5050              		.cfi_def_cfa_register 7
3434:Lib/FreeRTOS/Source/tasks.c ****     xYieldPending = pdTRUE;
 5051              		.loc 1 3434 19
 5052 0004 034B     		ldr	r3, .L301
 5053 0006 0122     		movs	r2, #1
 5054 0008 1A60     		str	r2, [r3]
3435:Lib/FreeRTOS/Source/tasks.c **** }
 5055              		.loc 1 3435 1
 5056 000a 00BF     		nop
 5057 000c BD46     		mov	sp, r7
 5058              		.cfi_def_cfa_register 13
 5059              		@ sp needed
 5060 000e 5DF8047B 		ldr	r7, [sp], #4
 5061              		.cfi_restore 7
ARM GAS  /tmp/ccTFOe4z.s 			page 149


 5062              		.cfi_def_cfa_offset 0
 5063 0012 7047     		bx	lr
 5064              	.L302:
 5065              		.align	2
 5066              	.L301:
 5067 0014 00000000 		.word	xYieldPending
 5068              		.cfi_endproc
 5069              	.LFE36:
 5071              		.section	.text.uxTaskGetTaskNumber,"ax",%progbits
 5072              		.align	1
 5073              		.global	uxTaskGetTaskNumber
 5074              		.syntax unified
 5075              		.thumb
 5076              		.thumb_func
 5078              	uxTaskGetTaskNumber:
 5079              	.LFB37:
3436:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3437:Lib/FreeRTOS/Source/tasks.c **** 
3438:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3439:Lib/FreeRTOS/Source/tasks.c **** 
3440:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
3441:Lib/FreeRTOS/Source/tasks.c ****     {
 5080              		.loc 1 3441 5
 5081              		.cfi_startproc
 5082              		@ args = 0, pretend = 0, frame = 16
 5083              		@ frame_needed = 1, uses_anonymous_args = 0
 5084              		@ link register save eliminated.
 5085 0000 80B4     		push	{r7}
 5086              		.cfi_def_cfa_offset 4
 5087              		.cfi_offset 7, -4
 5088 0002 85B0     		sub	sp, sp, #20
 5089              		.cfi_def_cfa_offset 24
 5090 0004 00AF     		add	r7, sp, #0
 5091              		.cfi_def_cfa_register 7
 5092 0006 7860     		str	r0, [r7, #4]
3442:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
3443:Lib/FreeRTOS/Source/tasks.c ****         TCB_t const * pxTCB;
3444:Lib/FreeRTOS/Source/tasks.c **** 
3445:Lib/FreeRTOS/Source/tasks.c ****         if( xTask != NULL )
 5093              		.loc 1 3445 11
 5094 0008 7B68     		ldr	r3, [r7, #4]
 5095 000a 002B     		cmp	r3, #0
 5096 000c 05D0     		beq	.L304
3446:Lib/FreeRTOS/Source/tasks.c ****         {
3447:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = xTask;
 5097              		.loc 1 3447 19
 5098 000e 7B68     		ldr	r3, [r7, #4]
 5099 0010 BB60     		str	r3, [r7, #8]
3448:Lib/FreeRTOS/Source/tasks.c ****             uxReturn = pxTCB->uxTaskNumber;
 5100              		.loc 1 3448 22
 5101 0012 BB68     		ldr	r3, [r7, #8]
 5102 0014 9B6C     		ldr	r3, [r3, #72]
 5103 0016 FB60     		str	r3, [r7, #12]
 5104 0018 01E0     		b	.L305
 5105              	.L304:
3449:Lib/FreeRTOS/Source/tasks.c ****         }
3450:Lib/FreeRTOS/Source/tasks.c ****         else
ARM GAS  /tmp/ccTFOe4z.s 			page 150


3451:Lib/FreeRTOS/Source/tasks.c ****         {
3452:Lib/FreeRTOS/Source/tasks.c ****             uxReturn = 0U;
 5106              		.loc 1 3452 22
 5107 001a 0023     		movs	r3, #0
 5108 001c FB60     		str	r3, [r7, #12]
 5109              	.L305:
3453:Lib/FreeRTOS/Source/tasks.c ****         }
3454:Lib/FreeRTOS/Source/tasks.c **** 
3455:Lib/FreeRTOS/Source/tasks.c ****         return uxReturn;
 5110              		.loc 1 3455 16
 5111 001e FB68     		ldr	r3, [r7, #12]
3456:Lib/FreeRTOS/Source/tasks.c ****     }
 5112              		.loc 1 3456 5
 5113 0020 1846     		mov	r0, r3
 5114 0022 1437     		adds	r7, r7, #20
 5115              		.cfi_def_cfa_offset 4
 5116 0024 BD46     		mov	sp, r7
 5117              		.cfi_def_cfa_register 13
 5118              		@ sp needed
 5119 0026 5DF8047B 		ldr	r7, [sp], #4
 5120              		.cfi_restore 7
 5121              		.cfi_def_cfa_offset 0
 5122 002a 7047     		bx	lr
 5123              		.cfi_endproc
 5124              	.LFE37:
 5126              		.section	.text.vTaskSetTaskNumber,"ax",%progbits
 5127              		.align	1
 5128              		.global	vTaskSetTaskNumber
 5129              		.syntax unified
 5130              		.thumb
 5131              		.thumb_func
 5133              	vTaskSetTaskNumber:
 5134              	.LFB38:
3457:Lib/FreeRTOS/Source/tasks.c **** 
3458:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3459:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3460:Lib/FreeRTOS/Source/tasks.c **** 
3461:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3462:Lib/FreeRTOS/Source/tasks.c **** 
3463:Lib/FreeRTOS/Source/tasks.c ****     void vTaskSetTaskNumber( TaskHandle_t xTask,
3464:Lib/FreeRTOS/Source/tasks.c ****                              const UBaseType_t uxHandle )
3465:Lib/FreeRTOS/Source/tasks.c ****     {
 5135              		.loc 1 3465 5
 5136              		.cfi_startproc
 5137              		@ args = 0, pretend = 0, frame = 16
 5138              		@ frame_needed = 1, uses_anonymous_args = 0
 5139              		@ link register save eliminated.
 5140 0000 80B4     		push	{r7}
 5141              		.cfi_def_cfa_offset 4
 5142              		.cfi_offset 7, -4
 5143 0002 85B0     		sub	sp, sp, #20
 5144              		.cfi_def_cfa_offset 24
 5145 0004 00AF     		add	r7, sp, #0
 5146              		.cfi_def_cfa_register 7
 5147 0006 7860     		str	r0, [r7, #4]
 5148 0008 3960     		str	r1, [r7]
3466:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
ARM GAS  /tmp/ccTFOe4z.s 			page 151


3467:Lib/FreeRTOS/Source/tasks.c **** 
3468:Lib/FreeRTOS/Source/tasks.c ****         if( xTask != NULL )
 5149              		.loc 1 3468 11
 5150 000a 7B68     		ldr	r3, [r7, #4]
 5151 000c 002B     		cmp	r3, #0
 5152 000e 04D0     		beq	.L309
3469:Lib/FreeRTOS/Source/tasks.c ****         {
3470:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = xTask;
 5153              		.loc 1 3470 19
 5154 0010 7B68     		ldr	r3, [r7, #4]
 5155 0012 FB60     		str	r3, [r7, #12]
3471:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->uxTaskNumber = uxHandle;
 5156              		.loc 1 3471 33
 5157 0014 FB68     		ldr	r3, [r7, #12]
 5158 0016 3A68     		ldr	r2, [r7]
 5159 0018 9A64     		str	r2, [r3, #72]
 5160              	.L309:
3472:Lib/FreeRTOS/Source/tasks.c ****         }
3473:Lib/FreeRTOS/Source/tasks.c ****     }
 5161              		.loc 1 3473 5
 5162 001a 00BF     		nop
 5163 001c 1437     		adds	r7, r7, #20
 5164              		.cfi_def_cfa_offset 4
 5165 001e BD46     		mov	sp, r7
 5166              		.cfi_def_cfa_register 13
 5167              		@ sp needed
 5168 0020 5DF8047B 		ldr	r7, [sp], #4
 5169              		.cfi_restore 7
 5170              		.cfi_def_cfa_offset 0
 5171 0024 7047     		bx	lr
 5172              		.cfi_endproc
 5173              	.LFE38:
 5175              		.section	.text.prvIdleTask,"ax",%progbits
 5176              		.align	1
 5177              		.syntax unified
 5178              		.thumb
 5179              		.thumb_func
 5181              	prvIdleTask:
 5182              	.LFB39:
3474:Lib/FreeRTOS/Source/tasks.c **** 
3475:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3476:Lib/FreeRTOS/Source/tasks.c **** 
3477:Lib/FreeRTOS/Source/tasks.c **** /*
3478:Lib/FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
3479:Lib/FreeRTOS/Source/tasks.c ****  * The Idle task.
3480:Lib/FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
3481:Lib/FreeRTOS/Source/tasks.c ****  *
3482:Lib/FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
3483:Lib/FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
3484:Lib/FreeRTOS/Source/tasks.c ****  *
3485:Lib/FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
3486:Lib/FreeRTOS/Source/tasks.c ****  *
3487:Lib/FreeRTOS/Source/tasks.c ****  */
3488:Lib/FreeRTOS/Source/tasks.c **** 
3489:Lib/FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
3490:Lib/FreeRTOS/Source/tasks.c **** {
 5183              		.loc 1 3490 1
ARM GAS  /tmp/ccTFOe4z.s 			page 152


 5184              		.cfi_startproc
 5185              		@ args = 0, pretend = 0, frame = 8
 5186              		@ frame_needed = 1, uses_anonymous_args = 0
 5187 0000 80B5     		push	{r7, lr}
 5188              		.cfi_def_cfa_offset 8
 5189              		.cfi_offset 7, -8
 5190              		.cfi_offset 14, -4
 5191 0002 82B0     		sub	sp, sp, #8
 5192              		.cfi_def_cfa_offset 16
 5193 0004 00AF     		add	r7, sp, #0
 5194              		.cfi_def_cfa_register 7
 5195 0006 7860     		str	r0, [r7, #4]
 5196              	.L312:
3491:Lib/FreeRTOS/Source/tasks.c ****     /* Stop warnings. */
3492:Lib/FreeRTOS/Source/tasks.c ****     ( void ) pvParameters;
3493:Lib/FreeRTOS/Source/tasks.c **** 
3494:Lib/FreeRTOS/Source/tasks.c ****     /** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
3495:Lib/FreeRTOS/Source/tasks.c ****      * SCHEDULER IS STARTED. **/
3496:Lib/FreeRTOS/Source/tasks.c **** 
3497:Lib/FreeRTOS/Source/tasks.c ****     /* In case a task that has a secure context deletes itself, in which case
3498:Lib/FreeRTOS/Source/tasks.c ****      * the idle task is responsible for deleting the task's secure context, if
3499:Lib/FreeRTOS/Source/tasks.c ****      * any. */
3500:Lib/FreeRTOS/Source/tasks.c ****     portALLOCATE_SECURE_CONTEXT( configMINIMAL_SECURE_STACK_SIZE );
3501:Lib/FreeRTOS/Source/tasks.c **** 
3502:Lib/FreeRTOS/Source/tasks.c ****     for( ; ; )
3503:Lib/FreeRTOS/Source/tasks.c ****     {
3504:Lib/FreeRTOS/Source/tasks.c ****         /* See if any tasks have deleted themselves - if so then the idle task
3505:Lib/FreeRTOS/Source/tasks.c ****          * is responsible for freeing the deleted task's TCB and stack. */
3506:Lib/FreeRTOS/Source/tasks.c ****         prvCheckTasksWaitingTermination();
 5197              		.loc 1 3506 9
 5198 0008 FFF7FEFF 		bl	prvCheckTasksWaitingTermination
3507:Lib/FreeRTOS/Source/tasks.c **** 
3508:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_PREEMPTION == 0 )
3509:Lib/FreeRTOS/Source/tasks.c ****         {
3510:Lib/FreeRTOS/Source/tasks.c ****             /* If we are not using preemption we keep forcing a task switch to
3511:Lib/FreeRTOS/Source/tasks.c ****              * see if any other task has become available.  If we are using
3512:Lib/FreeRTOS/Source/tasks.c ****              * preemption we don't need to do this as any task becoming available
3513:Lib/FreeRTOS/Source/tasks.c ****              * will automatically get the processor anyway. */
3514:Lib/FreeRTOS/Source/tasks.c ****             taskYIELD();
3515:Lib/FreeRTOS/Source/tasks.c ****         }
3516:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_PREEMPTION */
3517:Lib/FreeRTOS/Source/tasks.c **** 
3518:Lib/FreeRTOS/Source/tasks.c ****         #if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
3519:Lib/FreeRTOS/Source/tasks.c ****         {
3520:Lib/FreeRTOS/Source/tasks.c ****             /* When using preemption tasks of equal priority will be
3521:Lib/FreeRTOS/Source/tasks.c ****              * timesliced.  If a task that is sharing the idle priority is ready
3522:Lib/FreeRTOS/Source/tasks.c ****              * to run then the idle task should yield before the end of the
3523:Lib/FreeRTOS/Source/tasks.c ****              * timeslice.
3524:Lib/FreeRTOS/Source/tasks.c ****              *
3525:Lib/FreeRTOS/Source/tasks.c ****              * A critical region is not required here as we are just reading from
3526:Lib/FreeRTOS/Source/tasks.c ****              * the list, and an occasional incorrect value will not matter.  If
3527:Lib/FreeRTOS/Source/tasks.c ****              * the ready list at the idle priority contains more than one task
3528:Lib/FreeRTOS/Source/tasks.c ****              * then a task other than the idle task is ready to execute. */
3529:Lib/FreeRTOS/Source/tasks.c ****             if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType
 5199              		.loc 1 3529 17
 5200 000c 034B     		ldr	r3, .L313
 5201 000e 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 153


 5202              		.loc 1 3529 15
 5203 0010 012B     		cmp	r3, #1
 5204 0012 F9D9     		bls	.L312
3530:Lib/FreeRTOS/Source/tasks.c ****             {
3531:Lib/FreeRTOS/Source/tasks.c ****                 taskYIELD();
 5205              		.loc 1 3531 17
 5206 0014 FFF7FEFF 		bl	vPortYield
3506:Lib/FreeRTOS/Source/tasks.c **** 
 5207              		.loc 1 3506 9
 5208 0018 F6E7     		b	.L312
 5209              	.L314:
 5210 001a 00BF     		.align	2
 5211              	.L313:
 5212 001c 00000000 		.word	pxReadyTasksLists
 5213              		.cfi_endproc
 5214              	.LFE39:
 5216              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 5217              		.align	1
 5218              		.syntax unified
 5219              		.thumb
 5220              		.thumb_func
 5222              	prvInitialiseTaskLists:
 5223              	.LFB40:
3532:Lib/FreeRTOS/Source/tasks.c ****             }
3533:Lib/FreeRTOS/Source/tasks.c ****             else
3534:Lib/FreeRTOS/Source/tasks.c ****             {
3535:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
3536:Lib/FreeRTOS/Source/tasks.c ****             }
3537:Lib/FreeRTOS/Source/tasks.c ****         }
3538:Lib/FreeRTOS/Source/tasks.c ****         #endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
3539:Lib/FreeRTOS/Source/tasks.c **** 
3540:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_IDLE_HOOK == 1 )
3541:Lib/FreeRTOS/Source/tasks.c ****         {
3542:Lib/FreeRTOS/Source/tasks.c ****             /* Call the user defined function from within the idle task. */
3543:Lib/FreeRTOS/Source/tasks.c ****             vApplicationIdleHook();
3544:Lib/FreeRTOS/Source/tasks.c ****         }
3545:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_IDLE_HOOK */
3546:Lib/FreeRTOS/Source/tasks.c **** 
3547:Lib/FreeRTOS/Source/tasks.c ****         /* This conditional compilation should use inequality to 0, not equality
3548:Lib/FreeRTOS/Source/tasks.c ****          * to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
3549:Lib/FreeRTOS/Source/tasks.c ****          * user defined low power mode  implementations require
3550:Lib/FreeRTOS/Source/tasks.c ****          * configUSE_TICKLESS_IDLE to be set to a value other than 1. */
3551:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_TICKLESS_IDLE != 0 )
3552:Lib/FreeRTOS/Source/tasks.c ****         {
3553:Lib/FreeRTOS/Source/tasks.c ****             TickType_t xExpectedIdleTime;
3554:Lib/FreeRTOS/Source/tasks.c **** 
3555:Lib/FreeRTOS/Source/tasks.c ****             /* It is not desirable to suspend then resume the scheduler on
3556:Lib/FreeRTOS/Source/tasks.c ****              * each iteration of the idle task.  Therefore, a preliminary
3557:Lib/FreeRTOS/Source/tasks.c ****              * test of the expected idle time is performed without the
3558:Lib/FreeRTOS/Source/tasks.c ****              * scheduler suspended.  The result here is not necessarily
3559:Lib/FreeRTOS/Source/tasks.c ****              * valid. */
3560:Lib/FreeRTOS/Source/tasks.c ****             xExpectedIdleTime = prvGetExpectedIdleTime();
3561:Lib/FreeRTOS/Source/tasks.c **** 
3562:Lib/FreeRTOS/Source/tasks.c ****             if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3563:Lib/FreeRTOS/Source/tasks.c ****             {
3564:Lib/FreeRTOS/Source/tasks.c ****                 vTaskSuspendAll();
3565:Lib/FreeRTOS/Source/tasks.c ****                 {
ARM GAS  /tmp/ccTFOe4z.s 			page 154


3566:Lib/FreeRTOS/Source/tasks.c ****                     /* Now the scheduler is suspended, the expected idle
3567:Lib/FreeRTOS/Source/tasks.c ****                      * time can be sampled again, and this time its value can
3568:Lib/FreeRTOS/Source/tasks.c ****                      * be used. */
3569:Lib/FreeRTOS/Source/tasks.c ****                     configASSERT( xNextTaskUnblockTime >= xTickCount );
3570:Lib/FreeRTOS/Source/tasks.c ****                     xExpectedIdleTime = prvGetExpectedIdleTime();
3571:Lib/FreeRTOS/Source/tasks.c **** 
3572:Lib/FreeRTOS/Source/tasks.c ****                     /* Define the following macro to set xExpectedIdleTime to 0
3573:Lib/FreeRTOS/Source/tasks.c ****                      * if the application does not want
3574:Lib/FreeRTOS/Source/tasks.c ****                      * portSUPPRESS_TICKS_AND_SLEEP() to be called. */
3575:Lib/FreeRTOS/Source/tasks.c ****                     configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
3576:Lib/FreeRTOS/Source/tasks.c **** 
3577:Lib/FreeRTOS/Source/tasks.c ****                     if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
3578:Lib/FreeRTOS/Source/tasks.c ****                     {
3579:Lib/FreeRTOS/Source/tasks.c ****                         traceLOW_POWER_IDLE_BEGIN();
3580:Lib/FreeRTOS/Source/tasks.c ****                         portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
3581:Lib/FreeRTOS/Source/tasks.c ****                         traceLOW_POWER_IDLE_END();
3582:Lib/FreeRTOS/Source/tasks.c ****                     }
3583:Lib/FreeRTOS/Source/tasks.c ****                     else
3584:Lib/FreeRTOS/Source/tasks.c ****                     {
3585:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
3586:Lib/FreeRTOS/Source/tasks.c ****                     }
3587:Lib/FreeRTOS/Source/tasks.c ****                 }
3588:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) xTaskResumeAll();
3589:Lib/FreeRTOS/Source/tasks.c ****             }
3590:Lib/FreeRTOS/Source/tasks.c ****             else
3591:Lib/FreeRTOS/Source/tasks.c ****             {
3592:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
3593:Lib/FreeRTOS/Source/tasks.c ****             }
3594:Lib/FreeRTOS/Source/tasks.c ****         }
3595:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configUSE_TICKLESS_IDLE */
3596:Lib/FreeRTOS/Source/tasks.c ****     }
3597:Lib/FreeRTOS/Source/tasks.c **** }
3598:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3599:Lib/FreeRTOS/Source/tasks.c **** 
3600:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TICKLESS_IDLE != 0 )
3601:Lib/FreeRTOS/Source/tasks.c **** 
3602:Lib/FreeRTOS/Source/tasks.c ****     eSleepModeStatus eTaskConfirmSleepModeStatus( void )
3603:Lib/FreeRTOS/Source/tasks.c ****     {
3604:Lib/FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
3605:Lib/FreeRTOS/Source/tasks.c ****             /* The idle task exists in addition to the application tasks. */
3606:Lib/FreeRTOS/Source/tasks.c ****             const UBaseType_t uxNonApplicationTasks = 1;
3607:Lib/FreeRTOS/Source/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
3608:Lib/FreeRTOS/Source/tasks.c **** 
3609:Lib/FreeRTOS/Source/tasks.c ****         eSleepModeStatus eReturn = eStandardSleep;
3610:Lib/FreeRTOS/Source/tasks.c **** 
3611:Lib/FreeRTOS/Source/tasks.c ****         /* This function must be called from a critical section. */
3612:Lib/FreeRTOS/Source/tasks.c **** 
3613:Lib/FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
3614:Lib/FreeRTOS/Source/tasks.c ****         {
3615:Lib/FreeRTOS/Source/tasks.c ****             /* A task was made ready while the scheduler was suspended. */
3616:Lib/FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3617:Lib/FreeRTOS/Source/tasks.c ****         }
3618:Lib/FreeRTOS/Source/tasks.c ****         else if( xYieldPending != pdFALSE )
3619:Lib/FreeRTOS/Source/tasks.c ****         {
3620:Lib/FreeRTOS/Source/tasks.c ****             /* A yield was pended while the scheduler was suspended. */
3621:Lib/FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3622:Lib/FreeRTOS/Source/tasks.c ****         }
ARM GAS  /tmp/ccTFOe4z.s 			page 155


3623:Lib/FreeRTOS/Source/tasks.c ****         else if( xPendedTicks != 0 )
3624:Lib/FreeRTOS/Source/tasks.c ****         {
3625:Lib/FreeRTOS/Source/tasks.c ****             /* A tick interrupt has already occurred but was held pending
3626:Lib/FreeRTOS/Source/tasks.c ****              * because the scheduler is suspended. */
3627:Lib/FreeRTOS/Source/tasks.c ****             eReturn = eAbortSleep;
3628:Lib/FreeRTOS/Source/tasks.c ****         }
3629:Lib/FreeRTOS/Source/tasks.c **** 
3630:Lib/FreeRTOS/Source/tasks.c ****         #if ( INCLUDE_vTaskSuspend == 1 )
3631:Lib/FreeRTOS/Source/tasks.c ****             else if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - u
3632:Lib/FreeRTOS/Source/tasks.c ****             {
3633:Lib/FreeRTOS/Source/tasks.c ****                 /* If all the tasks are in the suspended list (which might mean they
3634:Lib/FreeRTOS/Source/tasks.c ****                  * have an infinite block time rather than actually being suspended)
3635:Lib/FreeRTOS/Source/tasks.c ****                  * then it is safe to turn all clocks off and just wait for external
3636:Lib/FreeRTOS/Source/tasks.c ****                  * interrupts. */
3637:Lib/FreeRTOS/Source/tasks.c ****                 eReturn = eNoTasksWaitingTimeout;
3638:Lib/FreeRTOS/Source/tasks.c ****             }
3639:Lib/FreeRTOS/Source/tasks.c ****         #endif /* INCLUDE_vTaskSuspend */
3640:Lib/FreeRTOS/Source/tasks.c ****         else
3641:Lib/FreeRTOS/Source/tasks.c ****         {
3642:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
3643:Lib/FreeRTOS/Source/tasks.c ****         }
3644:Lib/FreeRTOS/Source/tasks.c **** 
3645:Lib/FreeRTOS/Source/tasks.c ****         return eReturn;
3646:Lib/FreeRTOS/Source/tasks.c ****     }
3647:Lib/FreeRTOS/Source/tasks.c **** 
3648:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TICKLESS_IDLE */
3649:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3650:Lib/FreeRTOS/Source/tasks.c **** 
3651:Lib/FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3652:Lib/FreeRTOS/Source/tasks.c **** 
3653:Lib/FreeRTOS/Source/tasks.c ****     void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet,
3654:Lib/FreeRTOS/Source/tasks.c ****                                             BaseType_t xIndex,
3655:Lib/FreeRTOS/Source/tasks.c ****                                             void * pvValue )
3656:Lib/FreeRTOS/Source/tasks.c ****     {
3657:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3658:Lib/FreeRTOS/Source/tasks.c **** 
3659:Lib/FreeRTOS/Source/tasks.c ****         if( ( xIndex >= 0 ) &&
3660:Lib/FreeRTOS/Source/tasks.c ****             ( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
3661:Lib/FreeRTOS/Source/tasks.c ****         {
3662:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToSet );
3663:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB != NULL );
3664:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
3665:Lib/FreeRTOS/Source/tasks.c ****         }
3666:Lib/FreeRTOS/Source/tasks.c ****     }
3667:Lib/FreeRTOS/Source/tasks.c **** 
3668:Lib/FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3669:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3670:Lib/FreeRTOS/Source/tasks.c **** 
3671:Lib/FreeRTOS/Source/tasks.c **** #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
3672:Lib/FreeRTOS/Source/tasks.c **** 
3673:Lib/FreeRTOS/Source/tasks.c ****     void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery,
3674:Lib/FreeRTOS/Source/tasks.c ****                                                BaseType_t xIndex )
3675:Lib/FreeRTOS/Source/tasks.c ****     {
3676:Lib/FreeRTOS/Source/tasks.c ****         void * pvReturn = NULL;
3677:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3678:Lib/FreeRTOS/Source/tasks.c **** 
3679:Lib/FreeRTOS/Source/tasks.c ****         if( ( xIndex >= 0 ) &&
ARM GAS  /tmp/ccTFOe4z.s 			page 156


3680:Lib/FreeRTOS/Source/tasks.c ****             ( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS ) )
3681:Lib/FreeRTOS/Source/tasks.c ****         {
3682:Lib/FreeRTOS/Source/tasks.c ****             pxTCB = prvGetTCBFromHandle( xTaskToQuery );
3683:Lib/FreeRTOS/Source/tasks.c ****             pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
3684:Lib/FreeRTOS/Source/tasks.c ****         }
3685:Lib/FreeRTOS/Source/tasks.c ****         else
3686:Lib/FreeRTOS/Source/tasks.c ****         {
3687:Lib/FreeRTOS/Source/tasks.c ****             pvReturn = NULL;
3688:Lib/FreeRTOS/Source/tasks.c ****         }
3689:Lib/FreeRTOS/Source/tasks.c **** 
3690:Lib/FreeRTOS/Source/tasks.c ****         return pvReturn;
3691:Lib/FreeRTOS/Source/tasks.c ****     }
3692:Lib/FreeRTOS/Source/tasks.c **** 
3693:Lib/FreeRTOS/Source/tasks.c **** #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
3694:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3695:Lib/FreeRTOS/Source/tasks.c **** 
3696:Lib/FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
3697:Lib/FreeRTOS/Source/tasks.c **** 
3698:Lib/FreeRTOS/Source/tasks.c ****     void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify,
3699:Lib/FreeRTOS/Source/tasks.c ****                                   const MemoryRegion_t * const xRegions )
3700:Lib/FreeRTOS/Source/tasks.c ****     {
3701:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3702:Lib/FreeRTOS/Source/tasks.c **** 
3703:Lib/FreeRTOS/Source/tasks.c ****         /* If null is passed in here then we are modifying the MPU settings of
3704:Lib/FreeRTOS/Source/tasks.c ****          * the calling task. */
3705:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTaskToModify );
3706:Lib/FreeRTOS/Source/tasks.c **** 
3707:Lib/FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
3708:Lib/FreeRTOS/Source/tasks.c ****     }
3709:Lib/FreeRTOS/Source/tasks.c **** 
3710:Lib/FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
3711:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3712:Lib/FreeRTOS/Source/tasks.c **** 
3713:Lib/FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
3714:Lib/FreeRTOS/Source/tasks.c **** {
 5224              		.loc 1 3714 1
 5225              		.cfi_startproc
 5226              		@ args = 0, pretend = 0, frame = 8
 5227              		@ frame_needed = 1, uses_anonymous_args = 0
 5228 0000 80B5     		push	{r7, lr}
 5229              		.cfi_def_cfa_offset 8
 5230              		.cfi_offset 7, -8
 5231              		.cfi_offset 14, -4
 5232 0002 82B0     		sub	sp, sp, #8
 5233              		.cfi_def_cfa_offset 16
 5234 0004 00AF     		add	r7, sp, #0
 5235              		.cfi_def_cfa_register 7
3715:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxPriority;
3716:Lib/FreeRTOS/Source/tasks.c **** 
3717:Lib/FreeRTOS/Source/tasks.c ****     for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPrio
 5236              		.loc 1 3717 21
 5237 0006 0023     		movs	r3, #0
 5238 0008 7B60     		str	r3, [r7, #4]
 5239              		.loc 1 3717 5
 5240 000a 0CE0     		b	.L316
 5241              	.L317:
3718:Lib/FreeRTOS/Source/tasks.c ****     {
ARM GAS  /tmp/ccTFOe4z.s 			page 157


3719:Lib/FreeRTOS/Source/tasks.c ****         vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 5242              		.loc 1 3719 9
 5243 000c 7A68     		ldr	r2, [r7, #4]
 5244 000e 1346     		mov	r3, r2
 5245 0010 9B00     		lsls	r3, r3, #2
 5246 0012 1344     		add	r3, r3, r2
 5247 0014 9B00     		lsls	r3, r3, #2
 5248 0016 124A     		ldr	r2, .L318
 5249 0018 1344     		add	r3, r3, r2
 5250 001a 1846     		mov	r0, r3
 5251 001c FFF7FEFF 		bl	vListInitialise
3717:Lib/FreeRTOS/Source/tasks.c ****     {
 5252              		.loc 1 3717 104 discriminator 3
 5253 0020 7B68     		ldr	r3, [r7, #4]
 5254 0022 0133     		adds	r3, r3, #1
 5255 0024 7B60     		str	r3, [r7, #4]
 5256              	.L316:
3717:Lib/FreeRTOS/Source/tasks.c ****     {
 5257              		.loc 1 3717 54 discriminator 1
 5258 0026 7B68     		ldr	r3, [r7, #4]
 5259 0028 372B     		cmp	r3, #55
 5260 002a EFD9     		bls	.L317
3720:Lib/FreeRTOS/Source/tasks.c ****     }
3721:Lib/FreeRTOS/Source/tasks.c **** 
3722:Lib/FreeRTOS/Source/tasks.c ****     vListInitialise( &xDelayedTaskList1 );
 5261              		.loc 1 3722 5
 5262 002c 0D48     		ldr	r0, .L318+4
 5263 002e FFF7FEFF 		bl	vListInitialise
3723:Lib/FreeRTOS/Source/tasks.c ****     vListInitialise( &xDelayedTaskList2 );
 5264              		.loc 1 3723 5
 5265 0032 0D48     		ldr	r0, .L318+8
 5266 0034 FFF7FEFF 		bl	vListInitialise
3724:Lib/FreeRTOS/Source/tasks.c ****     vListInitialise( &xPendingReadyList );
 5267              		.loc 1 3724 5
 5268 0038 0C48     		ldr	r0, .L318+12
 5269 003a FFF7FEFF 		bl	vListInitialise
3725:Lib/FreeRTOS/Source/tasks.c **** 
3726:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3727:Lib/FreeRTOS/Source/tasks.c ****     {
3728:Lib/FreeRTOS/Source/tasks.c ****         vListInitialise( &xTasksWaitingTermination );
 5270              		.loc 1 3728 9
 5271 003e 0C48     		ldr	r0, .L318+16
 5272 0040 FFF7FEFF 		bl	vListInitialise
3729:Lib/FreeRTOS/Source/tasks.c ****     }
3730:Lib/FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3731:Lib/FreeRTOS/Source/tasks.c **** 
3732:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
3733:Lib/FreeRTOS/Source/tasks.c ****     {
3734:Lib/FreeRTOS/Source/tasks.c ****         vListInitialise( &xSuspendedTaskList );
 5273              		.loc 1 3734 9
 5274 0044 0B48     		ldr	r0, .L318+20
 5275 0046 FFF7FEFF 		bl	vListInitialise
3735:Lib/FreeRTOS/Source/tasks.c ****     }
3736:Lib/FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskSuspend */
3737:Lib/FreeRTOS/Source/tasks.c **** 
3738:Lib/FreeRTOS/Source/tasks.c ****     /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
3739:Lib/FreeRTOS/Source/tasks.c ****      * using list2. */
ARM GAS  /tmp/ccTFOe4z.s 			page 158


3740:Lib/FreeRTOS/Source/tasks.c ****     pxDelayedTaskList = &xDelayedTaskList1;
 5276              		.loc 1 3740 23
 5277 004a 0B4B     		ldr	r3, .L318+24
 5278 004c 054A     		ldr	r2, .L318+4
 5279 004e 1A60     		str	r2, [r3]
3741:Lib/FreeRTOS/Source/tasks.c ****     pxOverflowDelayedTaskList = &xDelayedTaskList2;
 5280              		.loc 1 3741 31
 5281 0050 0A4B     		ldr	r3, .L318+28
 5282 0052 054A     		ldr	r2, .L318+8
 5283 0054 1A60     		str	r2, [r3]
3742:Lib/FreeRTOS/Source/tasks.c **** }
 5284              		.loc 1 3742 1
 5285 0056 00BF     		nop
 5286 0058 0837     		adds	r7, r7, #8
 5287              		.cfi_def_cfa_offset 8
 5288 005a BD46     		mov	sp, r7
 5289              		.cfi_def_cfa_register 13
 5290              		@ sp needed
 5291 005c 80BD     		pop	{r7, pc}
 5292              	.L319:
 5293 005e 00BF     		.align	2
 5294              	.L318:
 5295 0060 00000000 		.word	pxReadyTasksLists
 5296 0064 00000000 		.word	xDelayedTaskList1
 5297 0068 00000000 		.word	xDelayedTaskList2
 5298 006c 00000000 		.word	xPendingReadyList
 5299 0070 00000000 		.word	xTasksWaitingTermination
 5300 0074 00000000 		.word	xSuspendedTaskList
 5301 0078 00000000 		.word	pxDelayedTaskList
 5302 007c 00000000 		.word	pxOverflowDelayedTaskList
 5303              		.cfi_endproc
 5304              	.LFE40:
 5306              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 5307              		.align	1
 5308              		.syntax unified
 5309              		.thumb
 5310              		.thumb_func
 5312              	prvCheckTasksWaitingTermination:
 5313              	.LFB41:
3743:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3744:Lib/FreeRTOS/Source/tasks.c **** 
3745:Lib/FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
3746:Lib/FreeRTOS/Source/tasks.c **** {
 5314              		.loc 1 3746 1
 5315              		.cfi_startproc
 5316              		@ args = 0, pretend = 0, frame = 8
 5317              		@ frame_needed = 1, uses_anonymous_args = 0
 5318 0000 80B5     		push	{r7, lr}
 5319              		.cfi_def_cfa_offset 8
 5320              		.cfi_offset 7, -8
 5321              		.cfi_offset 14, -4
 5322 0002 82B0     		sub	sp, sp, #8
 5323              		.cfi_def_cfa_offset 16
 5324 0004 00AF     		add	r7, sp, #0
 5325              		.cfi_def_cfa_register 7
 5326              	.LBB32:
3747:Lib/FreeRTOS/Source/tasks.c ****     /** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
ARM GAS  /tmp/ccTFOe4z.s 			page 159


3748:Lib/FreeRTOS/Source/tasks.c **** 
3749:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskDelete == 1 )
3750:Lib/FreeRTOS/Source/tasks.c ****     {
3751:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3752:Lib/FreeRTOS/Source/tasks.c **** 
3753:Lib/FreeRTOS/Source/tasks.c ****         /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
3754:Lib/FreeRTOS/Source/tasks.c ****          * being called too often in the idle task. */
3755:Lib/FreeRTOS/Source/tasks.c ****         while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 5327              		.loc 1 3755 14
 5328 0006 19E0     		b	.L321
 5329              	.L322:
3756:Lib/FreeRTOS/Source/tasks.c ****         {
3757:Lib/FreeRTOS/Source/tasks.c ****             taskENTER_CRITICAL();
 5330              		.loc 1 3757 13
 5331 0008 FFF7FEFF 		bl	vPortEnterCritical
3758:Lib/FreeRTOS/Source/tasks.c ****             {
3759:Lib/FreeRTOS/Source/tasks.c ****                 pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079
 5332              		.loc 1 3759 25
 5333 000c 104B     		ldr	r3, .L323
 5334 000e DB68     		ldr	r3, [r3, #12]
 5335              		.loc 1 3759 23
 5336 0010 DB68     		ldr	r3, [r3, #12]
 5337 0012 7B60     		str	r3, [r7, #4]
3760:Lib/FreeRTOS/Source/tasks.c ****                 ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5338              		.loc 1 3760 26
 5339 0014 7B68     		ldr	r3, [r7, #4]
 5340 0016 0433     		adds	r3, r3, #4
 5341 0018 1846     		mov	r0, r3
 5342 001a FFF7FEFF 		bl	uxListRemove
3761:Lib/FreeRTOS/Source/tasks.c ****                 --uxCurrentNumberOfTasks;
 5343              		.loc 1 3761 17
 5344 001e 0D4B     		ldr	r3, .L323+4
 5345 0020 1B68     		ldr	r3, [r3]
 5346 0022 013B     		subs	r3, r3, #1
 5347 0024 0B4A     		ldr	r2, .L323+4
 5348 0026 1360     		str	r3, [r2]
3762:Lib/FreeRTOS/Source/tasks.c ****                 --uxDeletedTasksWaitingCleanUp;
 5349              		.loc 1 3762 17
 5350 0028 0B4B     		ldr	r3, .L323+8
 5351 002a 1B68     		ldr	r3, [r3]
 5352 002c 013B     		subs	r3, r3, #1
 5353 002e 0A4A     		ldr	r2, .L323+8
 5354 0030 1360     		str	r3, [r2]
3763:Lib/FreeRTOS/Source/tasks.c ****             }
3764:Lib/FreeRTOS/Source/tasks.c ****             taskEXIT_CRITICAL();
 5355              		.loc 1 3764 13
 5356 0032 FFF7FEFF 		bl	vPortExitCritical
3765:Lib/FreeRTOS/Source/tasks.c **** 
3766:Lib/FreeRTOS/Source/tasks.c ****             prvDeleteTCB( pxTCB );
 5357              		.loc 1 3766 13
 5358 0036 7868     		ldr	r0, [r7, #4]
 5359 0038 FFF7FEFF 		bl	prvDeleteTCB
 5360              	.L321:
3755:Lib/FreeRTOS/Source/tasks.c ****         {
 5361              		.loc 1 3755 45
 5362 003c 064B     		ldr	r3, .L323+8
 5363 003e 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 160


 5364 0040 002B     		cmp	r3, #0
 5365 0042 E1D1     		bne	.L322
 5366              	.LBE32:
3767:Lib/FreeRTOS/Source/tasks.c ****         }
3768:Lib/FreeRTOS/Source/tasks.c ****     }
3769:Lib/FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskDelete */
3770:Lib/FreeRTOS/Source/tasks.c **** }
 5367              		.loc 1 3770 1
 5368 0044 00BF     		nop
 5369 0046 00BF     		nop
 5370 0048 0837     		adds	r7, r7, #8
 5371              		.cfi_def_cfa_offset 8
 5372 004a BD46     		mov	sp, r7
 5373              		.cfi_def_cfa_register 13
 5374              		@ sp needed
 5375 004c 80BD     		pop	{r7, pc}
 5376              	.L324:
 5377 004e 00BF     		.align	2
 5378              	.L323:
 5379 0050 00000000 		.word	xTasksWaitingTermination
 5380 0054 00000000 		.word	uxCurrentNumberOfTasks
 5381 0058 00000000 		.word	uxDeletedTasksWaitingCleanUp
 5382              		.cfi_endproc
 5383              	.LFE41:
 5385              		.section	.text.vTaskGetInfo,"ax",%progbits
 5386              		.align	1
 5387              		.global	vTaskGetInfo
 5388              		.syntax unified
 5389              		.thumb
 5390              		.thumb_func
 5392              	vTaskGetInfo:
 5393              	.LFB42:
3771:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3772:Lib/FreeRTOS/Source/tasks.c **** 
3773:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3774:Lib/FreeRTOS/Source/tasks.c **** 
3775:Lib/FreeRTOS/Source/tasks.c ****     void vTaskGetInfo( TaskHandle_t xTask,
3776:Lib/FreeRTOS/Source/tasks.c ****                        TaskStatus_t * pxTaskStatus,
3777:Lib/FreeRTOS/Source/tasks.c ****                        BaseType_t xGetFreeStackSpace,
3778:Lib/FreeRTOS/Source/tasks.c ****                        eTaskState eState )
3779:Lib/FreeRTOS/Source/tasks.c ****     {
 5394              		.loc 1 3779 5
 5395              		.cfi_startproc
 5396              		@ args = 0, pretend = 0, frame = 24
 5397              		@ frame_needed = 1, uses_anonymous_args = 0
 5398 0000 80B5     		push	{r7, lr}
 5399              		.cfi_def_cfa_offset 8
 5400              		.cfi_offset 7, -8
 5401              		.cfi_offset 14, -4
 5402 0002 86B0     		sub	sp, sp, #24
 5403              		.cfi_def_cfa_offset 32
 5404 0004 00AF     		add	r7, sp, #0
 5405              		.cfi_def_cfa_register 7
 5406 0006 F860     		str	r0, [r7, #12]
 5407 0008 B960     		str	r1, [r7, #8]
 5408 000a 7A60     		str	r2, [r7, #4]
 5409 000c FB70     		strb	r3, [r7, #3]
ARM GAS  /tmp/ccTFOe4z.s 			page 161


3780:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3781:Lib/FreeRTOS/Source/tasks.c **** 
3782:Lib/FreeRTOS/Source/tasks.c ****         /* xTask is NULL then get the state of the calling task. */
3783:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
 5410              		.loc 1 3783 17
 5411 000e FB68     		ldr	r3, [r7, #12]
 5412 0010 002B     		cmp	r3, #0
 5413 0012 02D1     		bne	.L326
 5414              		.loc 1 3783 17 is_stmt 0 discriminator 1
 5415 0014 324B     		ldr	r3, .L337
 5416 0016 1B68     		ldr	r3, [r3]
 5417 0018 00E0     		b	.L327
 5418              	.L326:
 5419              		.loc 1 3783 17 discriminator 2
 5420 001a FB68     		ldr	r3, [r7, #12]
 5421              	.L327:
 5422              		.loc 1 3783 15 is_stmt 1 discriminator 4
 5423 001c 7B61     		str	r3, [r7, #20]
3784:Lib/FreeRTOS/Source/tasks.c **** 
3785:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 5424              		.loc 1 3785 31
 5425 001e BB68     		ldr	r3, [r7, #8]
 5426 0020 7A69     		ldr	r2, [r7, #20]
 5427 0022 1A60     		str	r2, [r3]
3786:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
 5428              		.loc 1 3786 53
 5429 0024 7B69     		ldr	r3, [r7, #20]
 5430 0026 03F13402 		add	r2, r3, #52
 5431              		.loc 1 3786 34
 5432 002a BB68     		ldr	r3, [r7, #8]
 5433 002c 5A60     		str	r2, [r3, #4]
3787:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 5434              		.loc 1 3787 48
 5435 002e 7B69     		ldr	r3, [r7, #20]
 5436 0030 DA6A     		ldr	r2, [r3, #44]
 5437              		.loc 1 3787 41
 5438 0032 BB68     		ldr	r3, [r7, #8]
 5439 0034 1A61     		str	r2, [r3, #16]
3788:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatus->pxStackBase = pxTCB->pxStack;
 5440              		.loc 1 3788 42
 5441 0036 7B69     		ldr	r3, [r7, #20]
 5442 0038 1A6B     		ldr	r2, [r3, #48]
 5443              		.loc 1 3788 35
 5444 003a BB68     		ldr	r3, [r7, #8]
 5445 003c DA61     		str	r2, [r3, #28]
3789:Lib/FreeRTOS/Source/tasks.c ****         #if ( ( portSTACK_GROWTH > 0 ) && ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
3790:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->pxTopOfStack = pxTCB->pxTopOfStack;
3791:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->pxEndOfStack = pxTCB->pxEndOfStack;
3792:Lib/FreeRTOS/Source/tasks.c ****         #endif
3793:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 5446              		.loc 1 3793 42
 5447 003e 7B69     		ldr	r3, [r7, #20]
 5448 0040 5A6C     		ldr	r2, [r3, #68]
 5449              		.loc 1 3793 35
 5450 0042 BB68     		ldr	r3, [r7, #8]
 5451 0044 9A60     		str	r2, [r3, #8]
3794:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 162


3795:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_MUTEXES == 1 )
3796:Lib/FreeRTOS/Source/tasks.c ****         {
3797:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 5452              		.loc 1 3797 49
 5453 0046 7B69     		ldr	r3, [r7, #20]
 5454 0048 DA6C     		ldr	r2, [r3, #76]
 5455              		.loc 1 3797 42
 5456 004a BB68     		ldr	r3, [r7, #8]
 5457 004c 5A61     		str	r2, [r3, #20]
3798:Lib/FreeRTOS/Source/tasks.c ****         }
3799:Lib/FreeRTOS/Source/tasks.c ****         #else
3800:Lib/FreeRTOS/Source/tasks.c ****         {
3801:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->uxBasePriority = 0;
3802:Lib/FreeRTOS/Source/tasks.c ****         }
3803:Lib/FreeRTOS/Source/tasks.c ****         #endif
3804:Lib/FreeRTOS/Source/tasks.c **** 
3805:Lib/FreeRTOS/Source/tasks.c ****         #if ( configGENERATE_RUN_TIME_STATS == 1 )
3806:Lib/FreeRTOS/Source/tasks.c ****         {
3807:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
 5458              		.loc 1 3807 51
 5459 004e 7B69     		ldr	r3, [r7, #20]
 5460 0050 5A6D     		ldr	r2, [r3, #84]
 5461              		.loc 1 3807 44
 5462 0052 BB68     		ldr	r3, [r7, #8]
 5463 0054 9A61     		str	r2, [r3, #24]
3808:Lib/FreeRTOS/Source/tasks.c ****         }
3809:Lib/FreeRTOS/Source/tasks.c ****         #else
3810:Lib/FreeRTOS/Source/tasks.c ****         {
3811:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
3812:Lib/FreeRTOS/Source/tasks.c ****         }
3813:Lib/FreeRTOS/Source/tasks.c ****         #endif
3814:Lib/FreeRTOS/Source/tasks.c **** 
3815:Lib/FreeRTOS/Source/tasks.c ****         /* Obtaining the task state is a little fiddly, so is only done if the
3816:Lib/FreeRTOS/Source/tasks.c ****          * value of eState passed into this function is eInvalid - otherwise the
3817:Lib/FreeRTOS/Source/tasks.c ****          * state is just set to whatever is passed in. */
3818:Lib/FreeRTOS/Source/tasks.c ****         if( eState != eInvalid )
 5464              		.loc 1 3818 11
 5465 0056 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5466 0058 052B     		cmp	r3, #5
 5467 005a 26D0     		beq	.L328
3819:Lib/FreeRTOS/Source/tasks.c ****         {
3820:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB == pxCurrentTCB )
 5468              		.loc 1 3820 23
 5469 005c 204B     		ldr	r3, .L337
 5470 005e 1B68     		ldr	r3, [r3]
 5471              		.loc 1 3820 15
 5472 0060 7A69     		ldr	r2, [r7, #20]
 5473 0062 9A42     		cmp	r2, r3
 5474 0064 03D1     		bne	.L329
3821:Lib/FreeRTOS/Source/tasks.c ****             {
3822:Lib/FreeRTOS/Source/tasks.c ****                 pxTaskStatus->eCurrentState = eRunning;
 5475              		.loc 1 3822 45
 5476 0066 BB68     		ldr	r3, [r7, #8]
 5477 0068 0022     		movs	r2, #0
 5478 006a 1A73     		strb	r2, [r3, #12]
 5479 006c 24E0     		b	.L330
 5480              	.L329:
ARM GAS  /tmp/ccTFOe4z.s 			page 163


3823:Lib/FreeRTOS/Source/tasks.c ****             }
3824:Lib/FreeRTOS/Source/tasks.c ****             else
3825:Lib/FreeRTOS/Source/tasks.c ****             {
3826:Lib/FreeRTOS/Source/tasks.c ****                 pxTaskStatus->eCurrentState = eState;
 5481              		.loc 1 3826 45
 5482 006e BB68     		ldr	r3, [r7, #8]
 5483 0070 FA78     		ldrb	r2, [r7, #3]
 5484 0072 1A73     		strb	r2, [r3, #12]
3827:Lib/FreeRTOS/Source/tasks.c **** 
3828:Lib/FreeRTOS/Source/tasks.c ****                 #if ( INCLUDE_vTaskSuspend == 1 )
3829:Lib/FreeRTOS/Source/tasks.c ****                 {
3830:Lib/FreeRTOS/Source/tasks.c ****                     /* If the task is in the suspended list then there is a
3831:Lib/FreeRTOS/Source/tasks.c ****                      *  chance it is actually just blocked indefinitely - so really
3832:Lib/FreeRTOS/Source/tasks.c ****                      *  it should be reported as being in the Blocked state. */
3833:Lib/FreeRTOS/Source/tasks.c ****                     if( eState == eSuspended )
 5485              		.loc 1 3833 23
 5486 0074 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 5487 0076 032B     		cmp	r3, #3
 5488 0078 0AD1     		bne	.L331
3834:Lib/FreeRTOS/Source/tasks.c ****                     {
3835:Lib/FreeRTOS/Source/tasks.c ****                         vTaskSuspendAll();
 5489              		.loc 1 3835 25
 5490 007a FFF7FEFF 		bl	vTaskSuspendAll
3836:Lib/FreeRTOS/Source/tasks.c ****                         {
3837:Lib/FreeRTOS/Source/tasks.c ****                             if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5491              		.loc 1 3837 33
 5492 007e 7B69     		ldr	r3, [r7, #20]
 5493 0080 9B6A     		ldr	r3, [r3, #40]
 5494              		.loc 1 3837 31
 5495 0082 002B     		cmp	r3, #0
 5496 0084 02D0     		beq	.L332
3838:Lib/FreeRTOS/Source/tasks.c ****                             {
3839:Lib/FreeRTOS/Source/tasks.c ****                                 pxTaskStatus->eCurrentState = eBlocked;
 5497              		.loc 1 3839 61
 5498 0086 BB68     		ldr	r3, [r7, #8]
 5499 0088 0222     		movs	r2, #2
 5500 008a 1A73     		strb	r2, [r3, #12]
 5501              	.L332:
3840:Lib/FreeRTOS/Source/tasks.c ****                             }
3841:Lib/FreeRTOS/Source/tasks.c ****                         }
3842:Lib/FreeRTOS/Source/tasks.c ****                         ( void ) xTaskResumeAll();
 5502              		.loc 1 3842 34
 5503 008c FFF7FEFF 		bl	xTaskResumeAll
 5504              	.L331:
3843:Lib/FreeRTOS/Source/tasks.c ****                     }
3844:Lib/FreeRTOS/Source/tasks.c ****                 }
3845:Lib/FreeRTOS/Source/tasks.c ****                 #endif /* INCLUDE_vTaskSuspend */
3846:Lib/FreeRTOS/Source/tasks.c **** 
3847:Lib/FreeRTOS/Source/tasks.c ****                 /* Tasks can be in pending ready list and other state list at the
3848:Lib/FreeRTOS/Source/tasks.c ****                  * same time. These tasks are in ready state no matter what state
3849:Lib/FreeRTOS/Source/tasks.c ****                  * list the task is in. */
3850:Lib/FreeRTOS/Source/tasks.c ****                 taskENTER_CRITICAL();
 5505              		.loc 1 3850 17
 5506 0090 FFF7FEFF 		bl	vPortEnterCritical
3851:Lib/FreeRTOS/Source/tasks.c ****                 {
3852:Lib/FreeRTOS/Source/tasks.c ****                     if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) !
 5507              		.loc 1 3852 25
ARM GAS  /tmp/ccTFOe4z.s 			page 164


 5508 0094 7B69     		ldr	r3, [r7, #20]
 5509 0096 9B6A     		ldr	r3, [r3, #40]
 5510              		.loc 1 3852 23
 5511 0098 124A     		ldr	r2, .L337+4
 5512 009a 9342     		cmp	r3, r2
 5513 009c 02D1     		bne	.L333
3853:Lib/FreeRTOS/Source/tasks.c ****                     {
3854:Lib/FreeRTOS/Source/tasks.c ****                         pxTaskStatus->eCurrentState = eReady;
 5514              		.loc 1 3854 53
 5515 009e BB68     		ldr	r3, [r7, #8]
 5516 00a0 0122     		movs	r2, #1
 5517 00a2 1A73     		strb	r2, [r3, #12]
 5518              	.L333:
3855:Lib/FreeRTOS/Source/tasks.c ****                     }
3856:Lib/FreeRTOS/Source/tasks.c ****                 }
3857:Lib/FreeRTOS/Source/tasks.c ****                 taskEXIT_CRITICAL();
 5519              		.loc 1 3857 17
 5520 00a4 FFF7FEFF 		bl	vPortExitCritical
 5521 00a8 06E0     		b	.L330
 5522              	.L328:
3858:Lib/FreeRTOS/Source/tasks.c ****             }
3859:Lib/FreeRTOS/Source/tasks.c ****         }
3860:Lib/FreeRTOS/Source/tasks.c ****         else
3861:Lib/FreeRTOS/Source/tasks.c ****         {
3862:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 5523              		.loc 1 3862 43
 5524 00aa 7869     		ldr	r0, [r7, #20]
 5525 00ac FFF7FEFF 		bl	eTaskGetState
 5526 00b0 0346     		mov	r3, r0
 5527 00b2 1A46     		mov	r2, r3
 5528              		.loc 1 3862 41 discriminator 1
 5529 00b4 BB68     		ldr	r3, [r7, #8]
 5530 00b6 1A73     		strb	r2, [r3, #12]
 5531              	.L330:
3863:Lib/FreeRTOS/Source/tasks.c ****         }
3864:Lib/FreeRTOS/Source/tasks.c **** 
3865:Lib/FreeRTOS/Source/tasks.c ****         /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
3866:Lib/FreeRTOS/Source/tasks.c ****          * parameter is provided to allow it to be skipped. */
3867:Lib/FreeRTOS/Source/tasks.c ****         if( xGetFreeStackSpace != pdFALSE )
 5532              		.loc 1 3867 11
 5533 00b8 7B68     		ldr	r3, [r7, #4]
 5534 00ba 002B     		cmp	r3, #0
 5535 00bc 09D0     		beq	.L334
3868:Lib/FreeRTOS/Source/tasks.c ****         {
3869:Lib/FreeRTOS/Source/tasks.c ****             #if ( portSTACK_GROWTH > 0 )
3870:Lib/FreeRTOS/Source/tasks.c ****             {
3871:Lib/FreeRTOS/Source/tasks.c ****                 pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTC
3872:Lib/FreeRTOS/Source/tasks.c ****             }
3873:Lib/FreeRTOS/Source/tasks.c ****             #else
3874:Lib/FreeRTOS/Source/tasks.c ****             {
3875:Lib/FreeRTOS/Source/tasks.c ****                 pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTC
 5536              		.loc 1 3875 101
 5537 00be 7B69     		ldr	r3, [r7, #20]
 5538 00c0 1B6B     		ldr	r3, [r3, #48]
 5539              		.loc 1 3875 54
 5540 00c2 1846     		mov	r0, r3
 5541 00c4 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
ARM GAS  /tmp/ccTFOe4z.s 			page 165


 5542 00c8 0346     		mov	r3, r0
 5543 00ca 1A46     		mov	r2, r3
 5544              		.loc 1 3875 52 discriminator 1
 5545 00cc BB68     		ldr	r3, [r7, #8]
 5546 00ce 1A84     		strh	r2, [r3, #32]	@ movhi
3876:Lib/FreeRTOS/Source/tasks.c ****             }
3877:Lib/FreeRTOS/Source/tasks.c ****             #endif
3878:Lib/FreeRTOS/Source/tasks.c ****         }
3879:Lib/FreeRTOS/Source/tasks.c ****         else
3880:Lib/FreeRTOS/Source/tasks.c ****         {
3881:Lib/FreeRTOS/Source/tasks.c ****             pxTaskStatus->usStackHighWaterMark = 0;
3882:Lib/FreeRTOS/Source/tasks.c ****         }
3883:Lib/FreeRTOS/Source/tasks.c ****     }
 5547              		.loc 1 3883 5
 5548 00d0 02E0     		b	.L336
 5549              	.L334:
3881:Lib/FreeRTOS/Source/tasks.c ****         }
 5550              		.loc 1 3881 48
 5551 00d2 BB68     		ldr	r3, [r7, #8]
 5552 00d4 0022     		movs	r2, #0
 5553 00d6 1A84     		strh	r2, [r3, #32]	@ movhi
 5554              	.L336:
 5555              		.loc 1 3883 5
 5556 00d8 00BF     		nop
 5557 00da 1837     		adds	r7, r7, #24
 5558              		.cfi_def_cfa_offset 8
 5559 00dc BD46     		mov	sp, r7
 5560              		.cfi_def_cfa_register 13
 5561              		@ sp needed
 5562 00de 80BD     		pop	{r7, pc}
 5563              	.L338:
 5564              		.align	2
 5565              	.L337:
 5566 00e0 00000000 		.word	pxCurrentTCB
 5567 00e4 00000000 		.word	xPendingReadyList
 5568              		.cfi_endproc
 5569              	.LFE42:
 5571              		.section	.text.prvListTasksWithinSingleList,"ax",%progbits
 5572              		.align	1
 5573              		.syntax unified
 5574              		.thumb
 5575              		.thumb_func
 5577              	prvListTasksWithinSingleList:
 5578              	.LFB43:
3884:Lib/FreeRTOS/Source/tasks.c **** 
3885:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3886:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3887:Lib/FreeRTOS/Source/tasks.c **** 
3888:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
3889:Lib/FreeRTOS/Source/tasks.c **** 
3890:Lib/FreeRTOS/Source/tasks.c ****     static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
3891:Lib/FreeRTOS/Source/tasks.c ****                                                      List_t * pxList,
3892:Lib/FreeRTOS/Source/tasks.c ****                                                      eTaskState eState )
3893:Lib/FreeRTOS/Source/tasks.c ****     {
 5579              		.loc 1 3893 5
 5580              		.cfi_startproc
 5581              		@ args = 0, pretend = 0, frame = 40
ARM GAS  /tmp/ccTFOe4z.s 			page 166


 5582              		@ frame_needed = 1, uses_anonymous_args = 0
 5583 0000 80B5     		push	{r7, lr}
 5584              		.cfi_def_cfa_offset 8
 5585              		.cfi_offset 7, -8
 5586              		.cfi_offset 14, -4
 5587 0002 8AB0     		sub	sp, sp, #40
 5588              		.cfi_def_cfa_offset 48
 5589 0004 00AF     		add	r7, sp, #0
 5590              		.cfi_def_cfa_register 7
 5591 0006 F860     		str	r0, [r7, #12]
 5592 0008 B960     		str	r1, [r7, #8]
 5593 000a 1346     		mov	r3, r2
 5594 000c FB71     		strb	r3, [r7, #7]
3894:Lib/FreeRTOS/Source/tasks.c ****         configLIST_VOLATILE TCB_t * pxNextTCB;
3895:Lib/FreeRTOS/Source/tasks.c ****         configLIST_VOLATILE TCB_t * pxFirstTCB;
3896:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxTask = 0;
 5595              		.loc 1 3896 21
 5596 000e 0023     		movs	r3, #0
 5597 0010 7B62     		str	r3, [r7, #36]
3897:Lib/FreeRTOS/Source/tasks.c **** 
3898:Lib/FreeRTOS/Source/tasks.c ****         if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 5598              		.loc 1 3898 13
 5599 0012 BB68     		ldr	r3, [r7, #8]
 5600 0014 1B68     		ldr	r3, [r3]
 5601              		.loc 1 3898 11
 5602 0016 002B     		cmp	r3, #0
 5603 0018 3DD0     		beq	.L340
 5604              	.LBB33:
3899:Lib/FreeRTOS/Source/tasks.c ****         {
3900:Lib/FreeRTOS/Source/tasks.c ****             listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this
 5605              		.loc 1 3900 13
 5606 001a BB68     		ldr	r3, [r7, #8]
 5607 001c 3B62     		str	r3, [r7, #32]
 5608 001e 3B6A     		ldr	r3, [r7, #32]
 5609 0020 5B68     		ldr	r3, [r3, #4]
 5610 0022 5A68     		ldr	r2, [r3, #4]
 5611 0024 3B6A     		ldr	r3, [r7, #32]
 5612 0026 5A60     		str	r2, [r3, #4]
 5613 0028 3B6A     		ldr	r3, [r7, #32]
 5614 002a 5A68     		ldr	r2, [r3, #4]
 5615 002c 3B6A     		ldr	r3, [r7, #32]
 5616 002e 0833     		adds	r3, r3, #8
 5617 0030 9A42     		cmp	r2, r3
 5618 0032 03D1     		bne	.L341
 5619              		.loc 1 3900 13 is_stmt 0 discriminator 1
 5620 0034 3B6A     		ldr	r3, [r7, #32]
 5621 0036 DA68     		ldr	r2, [r3, #12]
 5622 0038 3B6A     		ldr	r3, [r7, #32]
 5623 003a 5A60     		str	r2, [r3, #4]
 5624              	.L341:
 5625              		.loc 1 3900 13 discriminator 3
 5626 003c 3B6A     		ldr	r3, [r7, #32]
 5627 003e 5B68     		ldr	r3, [r3, #4]
 5628 0040 DB68     		ldr	r3, [r3, #12]
 5629 0042 FB61     		str	r3, [r7, #28]
 5630              	.L343:
 5631              	.LBE33:
ARM GAS  /tmp/ccTFOe4z.s 			page 167


 5632              	.LBB34:
3901:Lib/FreeRTOS/Source/tasks.c **** 
3902:Lib/FreeRTOS/Source/tasks.c ****             /* Populate an TaskStatus_t structure within the
3903:Lib/FreeRTOS/Source/tasks.c ****              * pxTaskStatusArray array for each task that is referenced from
3904:Lib/FreeRTOS/Source/tasks.c ****              * pxList.  See the definition of TaskStatus_t in task.h for the
3905:Lib/FreeRTOS/Source/tasks.c ****              * meaning of each TaskStatus_t structure member. */
3906:Lib/FreeRTOS/Source/tasks.c ****             do
3907:Lib/FreeRTOS/Source/tasks.c ****             {
3908:Lib/FreeRTOS/Source/tasks.c ****                 listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as t
 5633              		.loc 1 3908 17 is_stmt 1
 5634 0044 BB68     		ldr	r3, [r7, #8]
 5635 0046 BB61     		str	r3, [r7, #24]
 5636 0048 BB69     		ldr	r3, [r7, #24]
 5637 004a 5B68     		ldr	r3, [r3, #4]
 5638 004c 5A68     		ldr	r2, [r3, #4]
 5639 004e BB69     		ldr	r3, [r7, #24]
 5640 0050 5A60     		str	r2, [r3, #4]
 5641 0052 BB69     		ldr	r3, [r7, #24]
 5642 0054 5A68     		ldr	r2, [r3, #4]
 5643 0056 BB69     		ldr	r3, [r7, #24]
 5644 0058 0833     		adds	r3, r3, #8
 5645 005a 9A42     		cmp	r2, r3
 5646 005c 03D1     		bne	.L342
 5647              		.loc 1 3908 17 is_stmt 0 discriminator 1
 5648 005e BB69     		ldr	r3, [r7, #24]
 5649 0060 DA68     		ldr	r2, [r3, #12]
 5650 0062 BB69     		ldr	r3, [r7, #24]
 5651 0064 5A60     		str	r2, [r3, #4]
 5652              	.L342:
 5653              		.loc 1 3908 17 discriminator 3
 5654 0066 BB69     		ldr	r3, [r7, #24]
 5655 0068 5B68     		ldr	r3, [r3, #4]
 5656 006a DB68     		ldr	r3, [r3, #12]
 5657 006c 7B61     		str	r3, [r7, #20]
 5658              	.LBE34:
3909:Lib/FreeRTOS/Source/tasks.c ****                 vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE,
 5659              		.loc 1 3909 79 is_stmt 1
 5660 006e 7A6A     		ldr	r2, [r7, #36]
 5661 0070 1346     		mov	r3, r2
 5662 0072 DB00     		lsls	r3, r3, #3
 5663 0074 1344     		add	r3, r3, r2
 5664 0076 9B00     		lsls	r3, r3, #2
 5665 0078 1A46     		mov	r2, r3
 5666              		.loc 1 3909 17
 5667 007a FB68     		ldr	r3, [r7, #12]
 5668 007c 9918     		adds	r1, r3, r2
 5669 007e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 5670 0080 0122     		movs	r2, #1
 5671 0082 7869     		ldr	r0, [r7, #20]
 5672 0084 FFF7FEFF 		bl	vTaskGetInfo
3910:Lib/FreeRTOS/Source/tasks.c ****                 uxTask++;
 5673              		.loc 1 3910 23
 5674 0088 7B6A     		ldr	r3, [r7, #36]
 5675 008a 0133     		adds	r3, r3, #1
 5676 008c 7B62     		str	r3, [r7, #36]
3911:Lib/FreeRTOS/Source/tasks.c ****             } while( pxNextTCB != pxFirstTCB );
 5677              		.loc 1 3911 32
ARM GAS  /tmp/ccTFOe4z.s 			page 168


 5678 008e 7A69     		ldr	r2, [r7, #20]
 5679 0090 FB69     		ldr	r3, [r7, #28]
 5680 0092 9A42     		cmp	r2, r3
 5681 0094 D6D1     		bne	.L343
 5682              	.L340:
3912:Lib/FreeRTOS/Source/tasks.c ****         }
3913:Lib/FreeRTOS/Source/tasks.c ****         else
3914:Lib/FreeRTOS/Source/tasks.c ****         {
3915:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
3916:Lib/FreeRTOS/Source/tasks.c ****         }
3917:Lib/FreeRTOS/Source/tasks.c **** 
3918:Lib/FreeRTOS/Source/tasks.c ****         return uxTask;
 5683              		.loc 1 3918 16
 5684 0096 7B6A     		ldr	r3, [r7, #36]
3919:Lib/FreeRTOS/Source/tasks.c ****     }
 5685              		.loc 1 3919 5
 5686 0098 1846     		mov	r0, r3
 5687 009a 2837     		adds	r7, r7, #40
 5688              		.cfi_def_cfa_offset 8
 5689 009c BD46     		mov	sp, r7
 5690              		.cfi_def_cfa_register 13
 5691              		@ sp needed
 5692 009e 80BD     		pop	{r7, pc}
 5693              		.cfi_endproc
 5694              	.LFE43:
 5696              		.section	.text.prvTaskCheckFreeStackSpace,"ax",%progbits
 5697              		.align	1
 5698              		.syntax unified
 5699              		.thumb
 5700              		.thumb_func
 5702              	prvTaskCheckFreeStackSpace:
 5703              	.LFB44:
3920:Lib/FreeRTOS/Source/tasks.c **** 
3921:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TRACE_FACILITY */
3922:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3923:Lib/FreeRTOS/Source/tasks.c **** 
3924:Lib/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUD
3925:Lib/FreeRTOS/Source/tasks.c **** 
3926:Lib/FreeRTOS/Source/tasks.c ****     static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3927:Lib/FreeRTOS/Source/tasks.c ****     {
 5704              		.loc 1 3927 5
 5705              		.cfi_startproc
 5706              		@ args = 0, pretend = 0, frame = 16
 5707              		@ frame_needed = 1, uses_anonymous_args = 0
 5708              		@ link register save eliminated.
 5709 0000 80B4     		push	{r7}
 5710              		.cfi_def_cfa_offset 4
 5711              		.cfi_offset 7, -4
 5712 0002 85B0     		sub	sp, sp, #20
 5713              		.cfi_def_cfa_offset 24
 5714 0004 00AF     		add	r7, sp, #0
 5715              		.cfi_def_cfa_register 7
 5716 0006 7860     		str	r0, [r7, #4]
3928:Lib/FreeRTOS/Source/tasks.c ****         uint32_t ulCount = 0U;
 5717              		.loc 1 3928 18
 5718 0008 0023     		movs	r3, #0
 5719 000a FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 169


3929:Lib/FreeRTOS/Source/tasks.c **** 
3930:Lib/FreeRTOS/Source/tasks.c ****         while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 5720              		.loc 1 3930 14
 5721 000c 05E0     		b	.L346
 5722              	.L347:
3931:Lib/FreeRTOS/Source/tasks.c ****         {
3932:Lib/FreeRTOS/Source/tasks.c ****             pucStackByte -= portSTACK_GROWTH;
 5723              		.loc 1 3932 26
 5724 000e 7B68     		ldr	r3, [r7, #4]
 5725 0010 0133     		adds	r3, r3, #1
 5726 0012 7B60     		str	r3, [r7, #4]
3933:Lib/FreeRTOS/Source/tasks.c ****             ulCount++;
 5727              		.loc 1 3933 20
 5728 0014 FB68     		ldr	r3, [r7, #12]
 5729 0016 0133     		adds	r3, r3, #1
 5730 0018 FB60     		str	r3, [r7, #12]
 5731              	.L346:
3930:Lib/FreeRTOS/Source/tasks.c ****         {
 5732              		.loc 1 3930 16
 5733 001a 7B68     		ldr	r3, [r7, #4]
 5734 001c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
3930:Lib/FreeRTOS/Source/tasks.c ****         {
 5735              		.loc 1 3930 30
 5736 001e A52B     		cmp	r3, #165
 5737 0020 F5D0     		beq	.L347
3934:Lib/FreeRTOS/Source/tasks.c ****         }
3935:Lib/FreeRTOS/Source/tasks.c **** 
3936:Lib/FreeRTOS/Source/tasks.c ****         ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on sma
 5738              		.loc 1 3936 17
 5739 0022 FB68     		ldr	r3, [r7, #12]
 5740 0024 9B08     		lsrs	r3, r3, #2
 5741 0026 FB60     		str	r3, [r7, #12]
3937:Lib/FreeRTOS/Source/tasks.c **** 
3938:Lib/FreeRTOS/Source/tasks.c ****         return ( configSTACK_DEPTH_TYPE ) ulCount;
 5742              		.loc 1 3938 16
 5743 0028 FB68     		ldr	r3, [r7, #12]
 5744 002a 9BB2     		uxth	r3, r3
3939:Lib/FreeRTOS/Source/tasks.c ****     }
 5745              		.loc 1 3939 5
 5746 002c 1846     		mov	r0, r3
 5747 002e 1437     		adds	r7, r7, #20
 5748              		.cfi_def_cfa_offset 4
 5749 0030 BD46     		mov	sp, r7
 5750              		.cfi_def_cfa_register 13
 5751              		@ sp needed
 5752 0032 5DF8047B 		ldr	r7, [sp], #4
 5753              		.cfi_restore 7
 5754              		.cfi_def_cfa_offset 0
 5755 0036 7047     		bx	lr
 5756              		.cfi_endproc
 5757              	.LFE44:
 5759              		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 5760              		.align	1
 5761              		.global	uxTaskGetStackHighWaterMark
 5762              		.syntax unified
 5763              		.thumb
 5764              		.thumb_func
ARM GAS  /tmp/ccTFOe4z.s 			page 170


 5766              	uxTaskGetStackHighWaterMark:
 5767              	.LFB45:
3940:Lib/FreeRTOS/Source/tasks.c **** 
3941:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( 
3942:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3943:Lib/FreeRTOS/Source/tasks.c **** 
3944:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 )
3945:Lib/FreeRTOS/Source/tasks.c **** 
3946:Lib/FreeRTOS/Source/tasks.c **** /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are the
3947:Lib/FreeRTOS/Source/tasks.c ****  * same except for their return type.  Using configSTACK_DEPTH_TYPE allows the
3948:Lib/FreeRTOS/Source/tasks.c ****  * user to determine the return type.  It gets around the problem of the value
3949:Lib/FreeRTOS/Source/tasks.c ****  * overflowing on 8-bit types without breaking backward compatibility for
3950:Lib/FreeRTOS/Source/tasks.c ****  * applications that expect an 8-bit return type. */
3951:Lib/FreeRTOS/Source/tasks.c ****     configSTACK_DEPTH_TYPE uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )
3952:Lib/FreeRTOS/Source/tasks.c ****     {
3953:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3954:Lib/FreeRTOS/Source/tasks.c ****         uint8_t * pucEndOfStack;
3955:Lib/FreeRTOS/Source/tasks.c ****         configSTACK_DEPTH_TYPE uxReturn;
3956:Lib/FreeRTOS/Source/tasks.c **** 
3957:Lib/FreeRTOS/Source/tasks.c ****         /* uxTaskGetStackHighWaterMark() and uxTaskGetStackHighWaterMark2() are
3958:Lib/FreeRTOS/Source/tasks.c ****          * the same except for their return type.  Using configSTACK_DEPTH_TYPE
3959:Lib/FreeRTOS/Source/tasks.c ****          * allows the user to determine the return type.  It gets around the
3960:Lib/FreeRTOS/Source/tasks.c ****          * problem of the value overflowing on 8-bit types without breaking
3961:Lib/FreeRTOS/Source/tasks.c ****          * backward compatibility for applications that expect an 8-bit return
3962:Lib/FreeRTOS/Source/tasks.c ****          * type. */
3963:Lib/FreeRTOS/Source/tasks.c **** 
3964:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
3965:Lib/FreeRTOS/Source/tasks.c **** 
3966:Lib/FreeRTOS/Source/tasks.c ****         #if portSTACK_GROWTH < 0
3967:Lib/FreeRTOS/Source/tasks.c ****         {
3968:Lib/FreeRTOS/Source/tasks.c ****             pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3969:Lib/FreeRTOS/Source/tasks.c ****         }
3970:Lib/FreeRTOS/Source/tasks.c ****         #else
3971:Lib/FreeRTOS/Source/tasks.c ****         {
3972:Lib/FreeRTOS/Source/tasks.c ****             pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
3973:Lib/FreeRTOS/Source/tasks.c ****         }
3974:Lib/FreeRTOS/Source/tasks.c ****         #endif
3975:Lib/FreeRTOS/Source/tasks.c **** 
3976:Lib/FreeRTOS/Source/tasks.c ****         uxReturn = prvTaskCheckFreeStackSpace( pucEndOfStack );
3977:Lib/FreeRTOS/Source/tasks.c **** 
3978:Lib/FreeRTOS/Source/tasks.c ****         return uxReturn;
3979:Lib/FreeRTOS/Source/tasks.c ****     }
3980:Lib/FreeRTOS/Source/tasks.c **** 
3981:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark2 */
3982:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
3983:Lib/FreeRTOS/Source/tasks.c **** 
3984:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3985:Lib/FreeRTOS/Source/tasks.c **** 
3986:Lib/FreeRTOS/Source/tasks.c ****     UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3987:Lib/FreeRTOS/Source/tasks.c ****     {
 5768              		.loc 1 3987 5
 5769              		.cfi_startproc
 5770              		@ args = 0, pretend = 0, frame = 24
 5771              		@ frame_needed = 1, uses_anonymous_args = 0
 5772 0000 80B5     		push	{r7, lr}
 5773              		.cfi_def_cfa_offset 8
 5774              		.cfi_offset 7, -8
ARM GAS  /tmp/ccTFOe4z.s 			page 171


 5775              		.cfi_offset 14, -4
 5776 0002 86B0     		sub	sp, sp, #24
 5777              		.cfi_def_cfa_offset 32
 5778 0004 00AF     		add	r7, sp, #0
 5779              		.cfi_def_cfa_register 7
 5780 0006 7860     		str	r0, [r7, #4]
3988:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
3989:Lib/FreeRTOS/Source/tasks.c ****         uint8_t * pucEndOfStack;
3990:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxReturn;
3991:Lib/FreeRTOS/Source/tasks.c **** 
3992:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
 5781              		.loc 1 3992 17
 5782 0008 7B68     		ldr	r3, [r7, #4]
 5783 000a 002B     		cmp	r3, #0
 5784 000c 02D1     		bne	.L350
 5785              		.loc 1 3992 17 is_stmt 0 discriminator 1
 5786 000e 094B     		ldr	r3, .L353
 5787 0010 1B68     		ldr	r3, [r3]
 5788 0012 00E0     		b	.L351
 5789              	.L350:
 5790              		.loc 1 3992 17 discriminator 2
 5791 0014 7B68     		ldr	r3, [r7, #4]
 5792              	.L351:
 5793              		.loc 1 3992 15 is_stmt 1 discriminator 4
 5794 0016 7B61     		str	r3, [r7, #20]
3993:Lib/FreeRTOS/Source/tasks.c **** 
3994:Lib/FreeRTOS/Source/tasks.c ****         #if portSTACK_GROWTH < 0
3995:Lib/FreeRTOS/Source/tasks.c ****         {
3996:Lib/FreeRTOS/Source/tasks.c ****             pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 5795              		.loc 1 3996 27
 5796 0018 7B69     		ldr	r3, [r7, #20]
 5797 001a 1B6B     		ldr	r3, [r3, #48]
 5798 001c 3B61     		str	r3, [r7, #16]
3997:Lib/FreeRTOS/Source/tasks.c ****         }
3998:Lib/FreeRTOS/Source/tasks.c ****         #else
3999:Lib/FreeRTOS/Source/tasks.c ****         {
4000:Lib/FreeRTOS/Source/tasks.c ****             pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
4001:Lib/FreeRTOS/Source/tasks.c ****         }
4002:Lib/FreeRTOS/Source/tasks.c ****         #endif
4003:Lib/FreeRTOS/Source/tasks.c **** 
4004:Lib/FreeRTOS/Source/tasks.c ****         uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 5799              		.loc 1 4004 36
 5800 001e 3869     		ldr	r0, [r7, #16]
 5801 0020 FFF7FEFF 		bl	prvTaskCheckFreeStackSpace
 5802 0024 0346     		mov	r3, r0
 5803              		.loc 1 4004 18 discriminator 1
 5804 0026 FB60     		str	r3, [r7, #12]
4005:Lib/FreeRTOS/Source/tasks.c **** 
4006:Lib/FreeRTOS/Source/tasks.c ****         return uxReturn;
 5805              		.loc 1 4006 16
 5806 0028 FB68     		ldr	r3, [r7, #12]
4007:Lib/FreeRTOS/Source/tasks.c ****     }
 5807              		.loc 1 4007 5
 5808 002a 1846     		mov	r0, r3
 5809 002c 1837     		adds	r7, r7, #24
 5810              		.cfi_def_cfa_offset 8
 5811 002e BD46     		mov	sp, r7
ARM GAS  /tmp/ccTFOe4z.s 			page 172


 5812              		.cfi_def_cfa_register 13
 5813              		@ sp needed
 5814 0030 80BD     		pop	{r7, pc}
 5815              	.L354:
 5816 0032 00BF     		.align	2
 5817              	.L353:
 5818 0034 00000000 		.word	pxCurrentTCB
 5819              		.cfi_endproc
 5820              	.LFE45:
 5822              		.section	.text.prvDeleteTCB,"ax",%progbits
 5823              		.align	1
 5824              		.syntax unified
 5825              		.thumb
 5826              		.thumb_func
 5828              	prvDeleteTCB:
 5829              	.LFB46:
4008:Lib/FreeRTOS/Source/tasks.c **** 
4009:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
4010:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4011:Lib/FreeRTOS/Source/tasks.c **** 
4012:Lib/FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
4013:Lib/FreeRTOS/Source/tasks.c **** 
4014:Lib/FreeRTOS/Source/tasks.c ****     static void prvDeleteTCB( TCB_t * pxTCB )
4015:Lib/FreeRTOS/Source/tasks.c ****     {
 5830              		.loc 1 4015 5
 5831              		.cfi_startproc
 5832              		@ args = 0, pretend = 0, frame = 8
 5833              		@ frame_needed = 1, uses_anonymous_args = 0
 5834              		@ link register save eliminated.
 5835 0000 80B4     		push	{r7}
 5836              		.cfi_def_cfa_offset 4
 5837              		.cfi_offset 7, -4
 5838 0002 83B0     		sub	sp, sp, #12
 5839              		.cfi_def_cfa_offset 16
 5840 0004 00AF     		add	r7, sp, #0
 5841              		.cfi_def_cfa_register 7
 5842 0006 7860     		str	r0, [r7, #4]
4016:Lib/FreeRTOS/Source/tasks.c ****         /* This call is required specifically for the TriCore port.  It must be
4017:Lib/FreeRTOS/Source/tasks.c ****          * above the vPortFree() calls.  The call is also used by ports/demos that
4018:Lib/FreeRTOS/Source/tasks.c ****          * want to allocate and clean RAM statically. */
4019:Lib/FreeRTOS/Source/tasks.c ****         portCLEAN_UP_TCB( pxTCB );
4020:Lib/FreeRTOS/Source/tasks.c **** 
4021:Lib/FreeRTOS/Source/tasks.c ****         #if ( configUSE_C_RUNTIME_TLS_SUPPORT == 1 )
4022:Lib/FreeRTOS/Source/tasks.c ****         {
4023:Lib/FreeRTOS/Source/tasks.c ****             /* Free up the memory allocated for the task's TLS Block. */
4024:Lib/FreeRTOS/Source/tasks.c ****             configDEINIT_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
4025:Lib/FreeRTOS/Source/tasks.c ****         }
4026:Lib/FreeRTOS/Source/tasks.c ****         #endif
4027:Lib/FreeRTOS/Source/tasks.c **** 
4028:Lib/FreeRTOS/Source/tasks.c ****         #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 )
4029:Lib/FreeRTOS/Source/tasks.c ****         {
4030:Lib/FreeRTOS/Source/tasks.c ****             /* The task can only have been allocated dynamically - free both
4031:Lib/FreeRTOS/Source/tasks.c ****              * the stack and TCB. */
4032:Lib/FreeRTOS/Source/tasks.c ****             vPortFreeStack( pxTCB->pxStack );
4033:Lib/FreeRTOS/Source/tasks.c ****             vPortFree( pxTCB );
4034:Lib/FreeRTOS/Source/tasks.c ****         }
4035:Lib/FreeRTOS/Source/tasks.c ****         #elif ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been
ARM GAS  /tmp/ccTFOe4z.s 			page 173


4036:Lib/FreeRTOS/Source/tasks.c ****         {
4037:Lib/FreeRTOS/Source/tasks.c ****             /* The task could have been allocated statically or dynamically, so
4038:Lib/FreeRTOS/Source/tasks.c ****              * check what was statically allocated before trying to free the
4039:Lib/FreeRTOS/Source/tasks.c ****              * memory. */
4040:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
4041:Lib/FreeRTOS/Source/tasks.c ****             {
4042:Lib/FreeRTOS/Source/tasks.c ****                 /* Both the stack and TCB were allocated dynamically, so both
4043:Lib/FreeRTOS/Source/tasks.c ****                  * must be freed. */
4044:Lib/FreeRTOS/Source/tasks.c ****                 vPortFreeStack( pxTCB->pxStack );
4045:Lib/FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB );
4046:Lib/FreeRTOS/Source/tasks.c ****             }
4047:Lib/FreeRTOS/Source/tasks.c ****             else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
4048:Lib/FreeRTOS/Source/tasks.c ****             {
4049:Lib/FreeRTOS/Source/tasks.c ****                 /* Only the stack was statically allocated, so the TCB is the
4050:Lib/FreeRTOS/Source/tasks.c ****                  * only memory that must be freed. */
4051:Lib/FreeRTOS/Source/tasks.c ****                 vPortFree( pxTCB );
4052:Lib/FreeRTOS/Source/tasks.c ****             }
4053:Lib/FreeRTOS/Source/tasks.c ****             else
4054:Lib/FreeRTOS/Source/tasks.c ****             {
4055:Lib/FreeRTOS/Source/tasks.c ****                 /* Neither the stack nor the TCB were allocated dynamically, so
4056:Lib/FreeRTOS/Source/tasks.c ****                  * nothing needs to be freed. */
4057:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB
4058:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4059:Lib/FreeRTOS/Source/tasks.c ****             }
4060:Lib/FreeRTOS/Source/tasks.c ****         }
4061:Lib/FreeRTOS/Source/tasks.c ****         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
4062:Lib/FreeRTOS/Source/tasks.c ****     }
 5843              		.loc 1 4062 5
 5844 0008 00BF     		nop
 5845 000a 0C37     		adds	r7, r7, #12
 5846              		.cfi_def_cfa_offset 4
 5847 000c BD46     		mov	sp, r7
 5848              		.cfi_def_cfa_register 13
 5849              		@ sp needed
 5850 000e 5DF8047B 		ldr	r7, [sp], #4
 5851              		.cfi_restore 7
 5852              		.cfi_def_cfa_offset 0
 5853 0012 7047     		bx	lr
 5854              		.cfi_endproc
 5855              	.LFE46:
 5857              		.section	.text.prvResetNextTaskUnblockTime,"ax",%progbits
 5858              		.align	1
 5859              		.syntax unified
 5860              		.thumb
 5861              		.thumb_func
 5863              	prvResetNextTaskUnblockTime:
 5864              	.LFB47:
4063:Lib/FreeRTOS/Source/tasks.c **** 
4064:Lib/FreeRTOS/Source/tasks.c **** #endif /* INCLUDE_vTaskDelete */
4065:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4066:Lib/FreeRTOS/Source/tasks.c **** 
4067:Lib/FreeRTOS/Source/tasks.c **** static void prvResetNextTaskUnblockTime( void )
4068:Lib/FreeRTOS/Source/tasks.c **** {
 5865              		.loc 1 4068 1
 5866              		.cfi_startproc
 5867              		@ args = 0, pretend = 0, frame = 0
 5868              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  /tmp/ccTFOe4z.s 			page 174


 5869              		@ link register save eliminated.
 5870 0000 80B4     		push	{r7}
 5871              		.cfi_def_cfa_offset 4
 5872              		.cfi_offset 7, -4
 5873 0002 00AF     		add	r7, sp, #0
 5874              		.cfi_def_cfa_register 7
4069:Lib/FreeRTOS/Source/tasks.c ****     if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5875              		.loc 1 4069 9
 5876 0004 0A4B     		ldr	r3, .L360
 5877 0006 1B68     		ldr	r3, [r3]
 5878 0008 1B68     		ldr	r3, [r3]
 5879              		.loc 1 4069 7
 5880 000a 002B     		cmp	r3, #0
 5881 000c 04D1     		bne	.L357
4070:Lib/FreeRTOS/Source/tasks.c ****     {
4071:Lib/FreeRTOS/Source/tasks.c ****         /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
4072:Lib/FreeRTOS/Source/tasks.c ****          * the maximum possible value so it is  extremely unlikely that the
4073:Lib/FreeRTOS/Source/tasks.c ****          * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
4074:Lib/FreeRTOS/Source/tasks.c ****          * there is an item in the delayed list. */
4075:Lib/FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = portMAX_DELAY;
 5882              		.loc 1 4075 30
 5883 000e 094B     		ldr	r3, .L360+4
 5884 0010 4FF0FF32 		mov	r2, #-1
 5885 0014 1A60     		str	r2, [r3]
4076:Lib/FreeRTOS/Source/tasks.c ****     }
4077:Lib/FreeRTOS/Source/tasks.c ****     else
4078:Lib/FreeRTOS/Source/tasks.c ****     {
4079:Lib/FreeRTOS/Source/tasks.c ****         /* The new current delayed list is not empty, get the value of
4080:Lib/FreeRTOS/Source/tasks.c ****          * the item at the head of the delayed list.  This is the time at
4081:Lib/FreeRTOS/Source/tasks.c ****          * which the task at the head of the delayed list should be removed
4082:Lib/FreeRTOS/Source/tasks.c ****          * from the Blocked state. */
4083:Lib/FreeRTOS/Source/tasks.c ****         xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
4084:Lib/FreeRTOS/Source/tasks.c ****     }
4085:Lib/FreeRTOS/Source/tasks.c **** }
 5886              		.loc 1 4085 1
 5887 0016 05E0     		b	.L359
 5888              	.L357:
4083:Lib/FreeRTOS/Source/tasks.c ****     }
 5889              		.loc 1 4083 32
 5890 0018 054B     		ldr	r3, .L360
 5891 001a 1B68     		ldr	r3, [r3]
 5892 001c DB68     		ldr	r3, [r3, #12]
 5893 001e 1B68     		ldr	r3, [r3]
4083:Lib/FreeRTOS/Source/tasks.c ****     }
 5894              		.loc 1 4083 30
 5895 0020 044A     		ldr	r2, .L360+4
 5896 0022 1360     		str	r3, [r2]
 5897              	.L359:
 5898              		.loc 1 4085 1
 5899 0024 00BF     		nop
 5900 0026 BD46     		mov	sp, r7
 5901              		.cfi_def_cfa_register 13
 5902              		@ sp needed
 5903 0028 5DF8047B 		ldr	r7, [sp], #4
 5904              		.cfi_restore 7
 5905              		.cfi_def_cfa_offset 0
 5906 002c 7047     		bx	lr
ARM GAS  /tmp/ccTFOe4z.s 			page 175


 5907              	.L361:
 5908 002e 00BF     		.align	2
 5909              	.L360:
 5910 0030 00000000 		.word	pxDelayedTaskList
 5911 0034 00000000 		.word	xNextTaskUnblockTime
 5912              		.cfi_endproc
 5913              	.LFE47:
 5915              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 5916              		.align	1
 5917              		.global	xTaskGetCurrentTaskHandle
 5918              		.syntax unified
 5919              		.thumb
 5920              		.thumb_func
 5922              	xTaskGetCurrentTaskHandle:
 5923              	.LFB48:
4086:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4087:Lib/FreeRTOS/Source/tasks.c **** 
4088:Lib/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
4089:Lib/FreeRTOS/Source/tasks.c **** 
4090:Lib/FreeRTOS/Source/tasks.c ****     TaskHandle_t xTaskGetCurrentTaskHandle( void )
4091:Lib/FreeRTOS/Source/tasks.c ****     {
 5924              		.loc 1 4091 5
 5925              		.cfi_startproc
 5926              		@ args = 0, pretend = 0, frame = 8
 5927              		@ frame_needed = 1, uses_anonymous_args = 0
 5928              		@ link register save eliminated.
 5929 0000 80B4     		push	{r7}
 5930              		.cfi_def_cfa_offset 4
 5931              		.cfi_offset 7, -4
 5932 0002 83B0     		sub	sp, sp, #12
 5933              		.cfi_def_cfa_offset 16
 5934 0004 00AF     		add	r7, sp, #0
 5935              		.cfi_def_cfa_register 7
4092:Lib/FreeRTOS/Source/tasks.c ****         TaskHandle_t xReturn;
4093:Lib/FreeRTOS/Source/tasks.c **** 
4094:Lib/FreeRTOS/Source/tasks.c ****         /* A critical section is not required as this is not called from
4095:Lib/FreeRTOS/Source/tasks.c ****          * an interrupt and the current TCB will always be the same for any
4096:Lib/FreeRTOS/Source/tasks.c ****          * individual execution thread. */
4097:Lib/FreeRTOS/Source/tasks.c ****         xReturn = pxCurrentTCB;
 5936              		.loc 1 4097 17
 5937 0006 054B     		ldr	r3, .L364
 5938 0008 1B68     		ldr	r3, [r3]
 5939 000a 7B60     		str	r3, [r7, #4]
4098:Lib/FreeRTOS/Source/tasks.c **** 
4099:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 5940              		.loc 1 4099 16
 5941 000c 7B68     		ldr	r3, [r7, #4]
4100:Lib/FreeRTOS/Source/tasks.c ****     }
 5942              		.loc 1 4100 5
 5943 000e 1846     		mov	r0, r3
 5944 0010 0C37     		adds	r7, r7, #12
 5945              		.cfi_def_cfa_offset 4
 5946 0012 BD46     		mov	sp, r7
 5947              		.cfi_def_cfa_register 13
 5948              		@ sp needed
 5949 0014 5DF8047B 		ldr	r7, [sp], #4
 5950              		.cfi_restore 7
ARM GAS  /tmp/ccTFOe4z.s 			page 176


 5951              		.cfi_def_cfa_offset 0
 5952 0018 7047     		bx	lr
 5953              	.L365:
 5954 001a 00BF     		.align	2
 5955              	.L364:
 5956 001c 00000000 		.word	pxCurrentTCB
 5957              		.cfi_endproc
 5958              	.LFE48:
 5960              		.section	.text.xTaskGetSchedulerState,"ax",%progbits
 5961              		.align	1
 5962              		.global	xTaskGetSchedulerState
 5963              		.syntax unified
 5964              		.thumb
 5965              		.thumb_func
 5967              	xTaskGetSchedulerState:
 5968              	.LFB49:
4101:Lib/FreeRTOS/Source/tasks.c **** 
4102:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
4103:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4104:Lib/FreeRTOS/Source/tasks.c **** 
4105:Lib/FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
4106:Lib/FreeRTOS/Source/tasks.c **** 
4107:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGetSchedulerState( void )
4108:Lib/FreeRTOS/Source/tasks.c ****     {
 5969              		.loc 1 4108 5
 5970              		.cfi_startproc
 5971              		@ args = 0, pretend = 0, frame = 8
 5972              		@ frame_needed = 1, uses_anonymous_args = 0
 5973              		@ link register save eliminated.
 5974 0000 80B4     		push	{r7}
 5975              		.cfi_def_cfa_offset 4
 5976              		.cfi_offset 7, -4
 5977 0002 83B0     		sub	sp, sp, #12
 5978              		.cfi_def_cfa_offset 16
 5979 0004 00AF     		add	r7, sp, #0
 5980              		.cfi_def_cfa_register 7
4109:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
4110:Lib/FreeRTOS/Source/tasks.c **** 
4111:Lib/FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning == pdFALSE )
 5981              		.loc 1 4111 31
 5982 0006 0B4B     		ldr	r3, .L371
 5983 0008 1B68     		ldr	r3, [r3]
 5984              		.loc 1 4111 11
 5985 000a 002B     		cmp	r3, #0
 5986 000c 02D1     		bne	.L367
4112:Lib/FreeRTOS/Source/tasks.c ****         {
4113:Lib/FreeRTOS/Source/tasks.c ****             xReturn = taskSCHEDULER_NOT_STARTED;
 5987              		.loc 1 4113 21
 5988 000e 0123     		movs	r3, #1
 5989 0010 7B60     		str	r3, [r7, #4]
 5990 0012 08E0     		b	.L368
 5991              	.L367:
4114:Lib/FreeRTOS/Source/tasks.c ****         }
4115:Lib/FreeRTOS/Source/tasks.c ****         else
4116:Lib/FreeRTOS/Source/tasks.c ****         {
4117:Lib/FreeRTOS/Source/tasks.c ****             if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5992              		.loc 1 4117 38
ARM GAS  /tmp/ccTFOe4z.s 			page 177


 5993 0014 084B     		ldr	r3, .L371+4
 5994 0016 1B68     		ldr	r3, [r3]
 5995              		.loc 1 4117 15
 5996 0018 002B     		cmp	r3, #0
 5997 001a 02D1     		bne	.L369
4118:Lib/FreeRTOS/Source/tasks.c ****             {
4119:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = taskSCHEDULER_RUNNING;
 5998              		.loc 1 4119 25
 5999 001c 0223     		movs	r3, #2
 6000 001e 7B60     		str	r3, [r7, #4]
 6001 0020 01E0     		b	.L368
 6002              	.L369:
4120:Lib/FreeRTOS/Source/tasks.c ****             }
4121:Lib/FreeRTOS/Source/tasks.c ****             else
4122:Lib/FreeRTOS/Source/tasks.c ****             {
4123:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = taskSCHEDULER_SUSPENDED;
 6003              		.loc 1 4123 25
 6004 0022 0023     		movs	r3, #0
 6005 0024 7B60     		str	r3, [r7, #4]
 6006              	.L368:
4124:Lib/FreeRTOS/Source/tasks.c ****             }
4125:Lib/FreeRTOS/Source/tasks.c ****         }
4126:Lib/FreeRTOS/Source/tasks.c **** 
4127:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 6007              		.loc 1 4127 16
 6008 0026 7B68     		ldr	r3, [r7, #4]
4128:Lib/FreeRTOS/Source/tasks.c ****     }
 6009              		.loc 1 4128 5
 6010 0028 1846     		mov	r0, r3
 6011 002a 0C37     		adds	r7, r7, #12
 6012              		.cfi_def_cfa_offset 4
 6013 002c BD46     		mov	sp, r7
 6014              		.cfi_def_cfa_register 13
 6015              		@ sp needed
 6016 002e 5DF8047B 		ldr	r7, [sp], #4
 6017              		.cfi_restore 7
 6018              		.cfi_def_cfa_offset 0
 6019 0032 7047     		bx	lr
 6020              	.L372:
 6021              		.align	2
 6022              	.L371:
 6023 0034 00000000 		.word	xSchedulerRunning
 6024 0038 00000000 		.word	uxSchedulerSuspended
 6025              		.cfi_endproc
 6026              	.LFE49:
 6028              		.section	.text.xTaskPriorityInherit,"ax",%progbits
 6029              		.align	1
 6030              		.global	xTaskPriorityInherit
 6031              		.syntax unified
 6032              		.thumb
 6033              		.thumb_func
 6035              	xTaskPriorityInherit:
 6036              	.LFB50:
4129:Lib/FreeRTOS/Source/tasks.c **** 
4130:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
4131:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4132:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 178


4133:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4134:Lib/FreeRTOS/Source/tasks.c **** 
4135:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
4136:Lib/FreeRTOS/Source/tasks.c ****     {
 6037              		.loc 1 4136 5
 6038              		.cfi_startproc
 6039              		@ args = 0, pretend = 0, frame = 24
 6040              		@ frame_needed = 1, uses_anonymous_args = 0
 6041 0000 80B5     		push	{r7, lr}
 6042              		.cfi_def_cfa_offset 8
 6043              		.cfi_offset 7, -8
 6044              		.cfi_offset 14, -4
 6045 0002 86B0     		sub	sp, sp, #24
 6046              		.cfi_def_cfa_offset 32
 6047 0004 00AF     		add	r7, sp, #0
 6048              		.cfi_def_cfa_register 7
 6049 0006 7860     		str	r0, [r7, #4]
4137:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 6050              		.loc 1 4137 23
 6051 0008 7B68     		ldr	r3, [r7, #4]
 6052 000a 3B61     		str	r3, [r7, #16]
4138:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
 6053              		.loc 1 4138 20
 6054 000c 0023     		movs	r3, #0
 6055 000e 7B61     		str	r3, [r7, #20]
4139:Lib/FreeRTOS/Source/tasks.c **** 
4140:Lib/FreeRTOS/Source/tasks.c ****         /* If the mutex was given back by an interrupt while the queue was
4141:Lib/FreeRTOS/Source/tasks.c ****          * locked then the mutex holder might now be NULL.  _RB_ Is this still
4142:Lib/FreeRTOS/Source/tasks.c ****          * needed as interrupts can no longer use mutexes? */
4143:Lib/FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
 6056              		.loc 1 4143 11
 6057 0010 7B68     		ldr	r3, [r7, #4]
 6058 0012 002B     		cmp	r3, #0
 6059 0014 79D0     		beq	.L374
4144:Lib/FreeRTOS/Source/tasks.c ****         {
4145:Lib/FreeRTOS/Source/tasks.c ****             /* If the holder of the mutex has a priority below the priority of
4146:Lib/FreeRTOS/Source/tasks.c ****              * the task attempting to obtain the mutex then it will temporarily
4147:Lib/FreeRTOS/Source/tasks.c ****              * inherit the priority of the task attempting to obtain the mutex. */
4148:Lib/FreeRTOS/Source/tasks.c ****             if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 6060              		.loc 1 4148 33
 6061 0016 3B69     		ldr	r3, [r7, #16]
 6062 0018 DA6A     		ldr	r2, [r3, #44]
 6063              		.loc 1 4148 60
 6064 001a 3E4B     		ldr	r3, .L381
 6065 001c 1B68     		ldr	r3, [r3]
 6066 001e DB6A     		ldr	r3, [r3, #44]
 6067              		.loc 1 4148 15
 6068 0020 9A42     		cmp	r2, r3
 6069 0022 69D2     		bcs	.L375
4149:Lib/FreeRTOS/Source/tasks.c ****             {
4150:Lib/FreeRTOS/Source/tasks.c ****                 /* Adjust the mutex holder state to account for its new
4151:Lib/FreeRTOS/Source/tasks.c ****                  * priority.  Only reset the event list item value if the value is
4152:Lib/FreeRTOS/Source/tasks.c ****                  * not being used for anything else. */
4153:Lib/FreeRTOS/Source/tasks.c ****                 if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_
 6070              		.loc 1 4153 23
 6071 0024 3B69     		ldr	r3, [r7, #16]
 6072 0026 9B69     		ldr	r3, [r3, #24]
ARM GAS  /tmp/ccTFOe4z.s 			page 179


 6073              		.loc 1 4153 19
 6074 0028 002B     		cmp	r3, #0
 6075 002a 06DB     		blt	.L376
4154:Lib/FreeRTOS/Source/tasks.c ****                 {
4155:Lib/FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) 
 6076              		.loc 1 4155 21
 6077 002c 394B     		ldr	r3, .L381
 6078 002e 1B68     		ldr	r3, [r3]
 6079 0030 DB6A     		ldr	r3, [r3, #44]
 6080 0032 C3F13802 		rsb	r2, r3, #56
 6081 0036 3B69     		ldr	r3, [r7, #16]
 6082 0038 9A61     		str	r2, [r3, #24]
 6083              	.L376:
4156:Lib/FreeRTOS/Source/tasks.c ****                 }
4157:Lib/FreeRTOS/Source/tasks.c ****                 else
4158:Lib/FreeRTOS/Source/tasks.c ****                 {
4159:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4160:Lib/FreeRTOS/Source/tasks.c ****                 }
4161:Lib/FreeRTOS/Source/tasks.c **** 
4162:Lib/FreeRTOS/Source/tasks.c ****                 /* If the task being modified is in the ready state it will need
4163:Lib/FreeRTOS/Source/tasks.c ****                  * to be moved into a new list. */
4164:Lib/FreeRTOS/Source/tasks.c ****                 if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] )
 6084              		.loc 1 4164 21
 6085 003a 3B69     		ldr	r3, [r7, #16]
 6086 003c 5969     		ldr	r1, [r3, #20]
 6087 003e 3B69     		ldr	r3, [r7, #16]
 6088 0040 DA6A     		ldr	r2, [r3, #44]
 6089 0042 1346     		mov	r3, r2
 6090 0044 9B00     		lsls	r3, r3, #2
 6091 0046 1344     		add	r3, r3, r2
 6092 0048 9B00     		lsls	r3, r3, #2
 6093 004a 334A     		ldr	r2, .L381+4
 6094 004c 1344     		add	r3, r3, r2
 6095              		.loc 1 4164 19
 6096 004e 9942     		cmp	r1, r3
 6097 0050 4AD1     		bne	.L377
4165:Lib/FreeRTOS/Source/tasks.c ****                 {
4166:Lib/FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 
 6098              		.loc 1 4166 25
 6099 0052 3B69     		ldr	r3, [r7, #16]
 6100 0054 0433     		adds	r3, r3, #4
 6101 0056 1846     		mov	r0, r3
 6102 0058 FFF7FEFF 		bl	uxListRemove
4167:Lib/FreeRTOS/Source/tasks.c ****                     {
4168:Lib/FreeRTOS/Source/tasks.c ****                         /* It is known that the task is in its ready list so
4169:Lib/FreeRTOS/Source/tasks.c ****                          * there is no need to check again and the port level
4170:Lib/FreeRTOS/Source/tasks.c ****                          * reset macro can be called directly. */
4171:Lib/FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority 
4172:Lib/FreeRTOS/Source/tasks.c ****                     }
4173:Lib/FreeRTOS/Source/tasks.c ****                     else
4174:Lib/FreeRTOS/Source/tasks.c ****                     {
4175:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4176:Lib/FreeRTOS/Source/tasks.c ****                     }
4177:Lib/FreeRTOS/Source/tasks.c **** 
4178:Lib/FreeRTOS/Source/tasks.c ****                     /* Inherit the priority before being moved into the new list. */
4179:Lib/FreeRTOS/Source/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 6103              		.loc 1 4179 64
ARM GAS  /tmp/ccTFOe4z.s 			page 180


 6104 005c 2D4B     		ldr	r3, .L381
 6105 005e 1B68     		ldr	r3, [r3]
 6106 0060 DA6A     		ldr	r2, [r3, #44]
 6107              		.loc 1 4179 50
 6108 0062 3B69     		ldr	r3, [r7, #16]
 6109 0064 DA62     		str	r2, [r3, #44]
4180:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxMutexHolderTCB );
 6110              		.loc 1 4180 21
 6111 0066 3B69     		ldr	r3, [r7, #16]
 6112 0068 DA6A     		ldr	r2, [r3, #44]
 6113 006a 2C4B     		ldr	r3, .L381+8
 6114 006c 1B68     		ldr	r3, [r3]
 6115 006e 9A42     		cmp	r2, r3
 6116 0070 03D9     		bls	.L378
 6117              		.loc 1 4180 21 is_stmt 0 discriminator 1
 6118 0072 3B69     		ldr	r3, [r7, #16]
 6119 0074 DB6A     		ldr	r3, [r3, #44]
 6120 0076 294A     		ldr	r2, .L381+8
 6121 0078 1360     		str	r3, [r2]
 6122              	.L378:
 6123              	.LBB35:
 6124              		.loc 1 4180 21 discriminator 3
 6125 007a 3B69     		ldr	r3, [r7, #16]
 6126 007c DA6A     		ldr	r2, [r3, #44]
 6127 007e 2649     		ldr	r1, .L381+4
 6128 0080 1346     		mov	r3, r2
 6129 0082 9B00     		lsls	r3, r3, #2
 6130 0084 1344     		add	r3, r3, r2
 6131 0086 9B00     		lsls	r3, r3, #2
 6132 0088 0B44     		add	r3, r3, r1
 6133 008a 0433     		adds	r3, r3, #4
 6134 008c 1B68     		ldr	r3, [r3]
 6135 008e FB60     		str	r3, [r7, #12]
 6136 0090 3B69     		ldr	r3, [r7, #16]
 6137 0092 FA68     		ldr	r2, [r7, #12]
 6138 0094 9A60     		str	r2, [r3, #8]
 6139 0096 FB68     		ldr	r3, [r7, #12]
 6140 0098 9A68     		ldr	r2, [r3, #8]
 6141 009a 3B69     		ldr	r3, [r7, #16]
 6142 009c DA60     		str	r2, [r3, #12]
 6143 009e FB68     		ldr	r3, [r7, #12]
 6144 00a0 9B68     		ldr	r3, [r3, #8]
 6145 00a2 3A69     		ldr	r2, [r7, #16]
 6146 00a4 0432     		adds	r2, r2, #4
 6147 00a6 5A60     		str	r2, [r3, #4]
 6148 00a8 3B69     		ldr	r3, [r7, #16]
 6149 00aa 1A1D     		adds	r2, r3, #4
 6150 00ac FB68     		ldr	r3, [r7, #12]
 6151 00ae 9A60     		str	r2, [r3, #8]
 6152 00b0 3B69     		ldr	r3, [r7, #16]
 6153 00b2 DA6A     		ldr	r2, [r3, #44]
 6154 00b4 1346     		mov	r3, r2
 6155 00b6 9B00     		lsls	r3, r3, #2
 6156 00b8 1344     		add	r3, r3, r2
 6157 00ba 9B00     		lsls	r3, r3, #2
 6158 00bc 164A     		ldr	r2, .L381+4
 6159 00be 1A44     		add	r2, r2, r3
ARM GAS  /tmp/ccTFOe4z.s 			page 181


 6160 00c0 3B69     		ldr	r3, [r7, #16]
 6161 00c2 5A61     		str	r2, [r3, #20]
 6162 00c4 3B69     		ldr	r3, [r7, #16]
 6163 00c6 DA6A     		ldr	r2, [r3, #44]
 6164 00c8 1349     		ldr	r1, .L381+4
 6165 00ca 1346     		mov	r3, r2
 6166 00cc 9B00     		lsls	r3, r3, #2
 6167 00ce 1344     		add	r3, r3, r2
 6168 00d0 9B00     		lsls	r3, r3, #2
 6169 00d2 0B44     		add	r3, r3, r1
 6170 00d4 1B68     		ldr	r3, [r3]
 6171 00d6 591C     		adds	r1, r3, #1
 6172 00d8 0F48     		ldr	r0, .L381+4
 6173 00da 1346     		mov	r3, r2
 6174 00dc 9B00     		lsls	r3, r3, #2
 6175 00de 1344     		add	r3, r3, r2
 6176 00e0 9B00     		lsls	r3, r3, #2
 6177 00e2 0344     		add	r3, r3, r0
 6178 00e4 1960     		str	r1, [r3]
 6179              	.LBE35:
 6180 00e6 04E0     		b	.L379
 6181              	.L377:
4181:Lib/FreeRTOS/Source/tasks.c ****                 }
4182:Lib/FreeRTOS/Source/tasks.c ****                 else
4183:Lib/FreeRTOS/Source/tasks.c ****                 {
4184:Lib/FreeRTOS/Source/tasks.c ****                     /* Just inherit the priority. */
4185:Lib/FreeRTOS/Source/tasks.c ****                     pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 6182              		.loc 1 4185 64 is_stmt 1
 6183 00e8 0A4B     		ldr	r3, .L381
 6184 00ea 1B68     		ldr	r3, [r3]
 6185 00ec DA6A     		ldr	r2, [r3, #44]
 6186              		.loc 1 4185 50
 6187 00ee 3B69     		ldr	r3, [r7, #16]
 6188 00f0 DA62     		str	r2, [r3, #44]
 6189              	.L379:
4186:Lib/FreeRTOS/Source/tasks.c ****                 }
4187:Lib/FreeRTOS/Source/tasks.c **** 
4188:Lib/FreeRTOS/Source/tasks.c ****                 traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
4189:Lib/FreeRTOS/Source/tasks.c **** 
4190:Lib/FreeRTOS/Source/tasks.c ****                 /* Inheritance occurred. */
4191:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
 6190              		.loc 1 4191 25
 6191 00f2 0123     		movs	r3, #1
 6192 00f4 7B61     		str	r3, [r7, #20]
 6193 00f6 08E0     		b	.L374
 6194              	.L375:
4192:Lib/FreeRTOS/Source/tasks.c ****             }
4193:Lib/FreeRTOS/Source/tasks.c ****             else
4194:Lib/FreeRTOS/Source/tasks.c ****             {
4195:Lib/FreeRTOS/Source/tasks.c ****                 if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 6195              		.loc 1 4195 37
 6196 00f8 3B69     		ldr	r3, [r7, #16]
 6197 00fa DA6C     		ldr	r2, [r3, #76]
 6198              		.loc 1 4195 68
 6199 00fc 054B     		ldr	r3, .L381
 6200 00fe 1B68     		ldr	r3, [r3]
 6201 0100 DB6A     		ldr	r3, [r3, #44]
ARM GAS  /tmp/ccTFOe4z.s 			page 182


 6202              		.loc 1 4195 19
 6203 0102 9A42     		cmp	r2, r3
 6204 0104 01D2     		bcs	.L374
4196:Lib/FreeRTOS/Source/tasks.c ****                 {
4197:Lib/FreeRTOS/Source/tasks.c ****                     /* The base priority of the mutex holder is lower than the
4198:Lib/FreeRTOS/Source/tasks.c ****                      * priority of the task attempting to take the mutex, but the
4199:Lib/FreeRTOS/Source/tasks.c ****                      * current priority of the mutex holder is not lower than the
4200:Lib/FreeRTOS/Source/tasks.c ****                      * priority of the task attempting to take the mutex.
4201:Lib/FreeRTOS/Source/tasks.c ****                      * Therefore the mutex holder must have already inherited a
4202:Lib/FreeRTOS/Source/tasks.c ****                      * priority, but inheritance would have occurred if that had
4203:Lib/FreeRTOS/Source/tasks.c ****                      * not been the case. */
4204:Lib/FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
 6205              		.loc 1 4204 29
 6206 0106 0123     		movs	r3, #1
 6207 0108 7B61     		str	r3, [r7, #20]
 6208              	.L374:
4205:Lib/FreeRTOS/Source/tasks.c ****                 }
4206:Lib/FreeRTOS/Source/tasks.c ****                 else
4207:Lib/FreeRTOS/Source/tasks.c ****                 {
4208:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4209:Lib/FreeRTOS/Source/tasks.c ****                 }
4210:Lib/FreeRTOS/Source/tasks.c ****             }
4211:Lib/FreeRTOS/Source/tasks.c ****         }
4212:Lib/FreeRTOS/Source/tasks.c ****         else
4213:Lib/FreeRTOS/Source/tasks.c ****         {
4214:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4215:Lib/FreeRTOS/Source/tasks.c ****         }
4216:Lib/FreeRTOS/Source/tasks.c **** 
4217:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 6209              		.loc 1 4217 16
 6210 010a 7B69     		ldr	r3, [r7, #20]
4218:Lib/FreeRTOS/Source/tasks.c ****     }
 6211              		.loc 1 4218 5
 6212 010c 1846     		mov	r0, r3
 6213 010e 1837     		adds	r7, r7, #24
 6214              		.cfi_def_cfa_offset 8
 6215 0110 BD46     		mov	sp, r7
 6216              		.cfi_def_cfa_register 13
 6217              		@ sp needed
 6218 0112 80BD     		pop	{r7, pc}
 6219              	.L382:
 6220              		.align	2
 6221              	.L381:
 6222 0114 00000000 		.word	pxCurrentTCB
 6223 0118 00000000 		.word	pxReadyTasksLists
 6224 011c 00000000 		.word	uxTopReadyPriority
 6225              		.cfi_endproc
 6226              	.LFE50:
 6228              		.section	.text.xTaskPriorityDisinherit,"ax",%progbits
 6229              		.align	1
 6230              		.global	xTaskPriorityDisinherit
 6231              		.syntax unified
 6232              		.thumb
 6233              		.thumb_func
 6235              	xTaskPriorityDisinherit:
 6236              	.LFB51:
4219:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 183


4220:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4221:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4222:Lib/FreeRTOS/Source/tasks.c **** 
4223:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4224:Lib/FreeRTOS/Source/tasks.c **** 
4225:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
4226:Lib/FreeRTOS/Source/tasks.c ****     {
 6237              		.loc 1 4226 5
 6238              		.cfi_startproc
 6239              		@ args = 0, pretend = 0, frame = 24
 6240              		@ frame_needed = 1, uses_anonymous_args = 0
 6241 0000 80B5     		push	{r7, lr}
 6242              		.cfi_def_cfa_offset 8
 6243              		.cfi_offset 7, -8
 6244              		.cfi_offset 14, -4
 6245 0002 86B0     		sub	sp, sp, #24
 6246              		.cfi_def_cfa_offset 32
 6247 0004 00AF     		add	r7, sp, #0
 6248              		.cfi_def_cfa_register 7
 6249 0006 7860     		str	r0, [r7, #4]
4227:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 6250              		.loc 1 4227 23
 6251 0008 7B68     		ldr	r3, [r7, #4]
 6252 000a 3B61     		str	r3, [r7, #16]
4228:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdFALSE;
 6253              		.loc 1 4228 20
 6254 000c 0023     		movs	r3, #0
 6255 000e 7B61     		str	r3, [r7, #20]
4229:Lib/FreeRTOS/Source/tasks.c **** 
4230:Lib/FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
 6256              		.loc 1 4230 11
 6257 0010 7B68     		ldr	r3, [r7, #4]
 6258 0012 002B     		cmp	r3, #0
 6259 0014 7AD0     		beq	.L384
4231:Lib/FreeRTOS/Source/tasks.c ****         {
4232:Lib/FreeRTOS/Source/tasks.c ****             /* A task can only have an inherited priority if it holds the mutex.
4233:Lib/FreeRTOS/Source/tasks.c ****              * If the mutex is held by a task then it cannot be given from an
4234:Lib/FreeRTOS/Source/tasks.c ****              * interrupt, and if a mutex is given by the holding task then it must
4235:Lib/FreeRTOS/Source/tasks.c ****              * be the running state task. */
4236:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB == pxCurrentTCB );
 6260              		.loc 1 4236 13
 6261 0016 404B     		ldr	r3, .L389
 6262 0018 1B68     		ldr	r3, [r3]
 6263 001a 3A69     		ldr	r2, [r7, #16]
 6264 001c 9A42     		cmp	r2, r3
 6265 001e 08D0     		beq	.L385
 6266              		.loc 1 4236 13 is_stmt 0 discriminator 1
 6267 0020 FFF7FEFF 		bl	ulSetInterruptMask
 6268 0024 3D4B     		ldr	r3, .L389+4
 6269 0026 3E4A     		ldr	r2, .L389+8
 6270 0028 41F28C01 		movw	r1, #4236
 6271 002c 3D48     		ldr	r0, .L389+12
 6272 002e FFF7FEFF 		bl	__assert_func
 6273              	.L385:
4237:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
 6274              		.loc 1 4237 13 is_stmt 1
 6275 0032 3B69     		ldr	r3, [r7, #16]
ARM GAS  /tmp/ccTFOe4z.s 			page 184


 6276 0034 1B6D     		ldr	r3, [r3, #80]
 6277 0036 002B     		cmp	r3, #0
 6278 0038 08D1     		bne	.L386
 6279              		.loc 1 4237 13 is_stmt 0 discriminator 1
 6280 003a FFF7FEFF 		bl	ulSetInterruptMask
 6281 003e 374B     		ldr	r3, .L389+4
 6282 0040 374A     		ldr	r2, .L389+8
 6283 0042 41F28D01 		movw	r1, #4237
 6284 0046 3748     		ldr	r0, .L389+12
 6285 0048 FFF7FEFF 		bl	__assert_func
 6286              	.L386:
4238:Lib/FreeRTOS/Source/tasks.c ****             ( pxTCB->uxMutexesHeld )--;
 6287              		.loc 1 4238 20 is_stmt 1
 6288 004c 3B69     		ldr	r3, [r7, #16]
 6289 004e 1B6D     		ldr	r3, [r3, #80]
 6290              		.loc 1 4238 37
 6291 0050 5A1E     		subs	r2, r3, #1
 6292 0052 3B69     		ldr	r3, [r7, #16]
 6293 0054 1A65     		str	r2, [r3, #80]
4239:Lib/FreeRTOS/Source/tasks.c **** 
4240:Lib/FreeRTOS/Source/tasks.c ****             /* Has the holder of the mutex inherited the priority of another
4241:Lib/FreeRTOS/Source/tasks.c ****              * task? */
4242:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 6294              		.loc 1 4242 22
 6295 0056 3B69     		ldr	r3, [r7, #16]
 6296 0058 DA6A     		ldr	r2, [r3, #44]
 6297              		.loc 1 4242 43
 6298 005a 3B69     		ldr	r3, [r7, #16]
 6299 005c DB6C     		ldr	r3, [r3, #76]
 6300              		.loc 1 4242 15
 6301 005e 9A42     		cmp	r2, r3
 6302 0060 54D0     		beq	.L384
4243:Lib/FreeRTOS/Source/tasks.c ****             {
4244:Lib/FreeRTOS/Source/tasks.c ****                 /* Only disinherit if no other mutexes are held. */
4245:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 6303              		.loc 1 4245 26
 6304 0062 3B69     		ldr	r3, [r7, #16]
 6305 0064 1B6D     		ldr	r3, [r3, #80]
 6306              		.loc 1 4245 19
 6307 0066 002B     		cmp	r3, #0
 6308 0068 50D1     		bne	.L384
4246:Lib/FreeRTOS/Source/tasks.c ****                 {
4247:Lib/FreeRTOS/Source/tasks.c ****                     /* A task can only have an inherited priority if it holds
4248:Lib/FreeRTOS/Source/tasks.c ****                      * the mutex.  If the mutex is held by a task then it cannot be
4249:Lib/FreeRTOS/Source/tasks.c ****                      * given from an interrupt, and if a mutex is given by the
4250:Lib/FreeRTOS/Source/tasks.c ****                      * holding task then it must be the running state task.  Remove
4251:Lib/FreeRTOS/Source/tasks.c ****                      * the holding task from the ready list. */
4252:Lib/FreeRTOS/Source/tasks.c ****                     if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 6309              		.loc 1 4252 25
 6310 006a 3B69     		ldr	r3, [r7, #16]
 6311 006c 0433     		adds	r3, r3, #4
 6312 006e 1846     		mov	r0, r3
 6313 0070 FFF7FEFF 		bl	uxListRemove
4253:Lib/FreeRTOS/Source/tasks.c ****                     {
4254:Lib/FreeRTOS/Source/tasks.c ****                         portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4255:Lib/FreeRTOS/Source/tasks.c ****                     }
4256:Lib/FreeRTOS/Source/tasks.c ****                     else
ARM GAS  /tmp/ccTFOe4z.s 			page 185


4257:Lib/FreeRTOS/Source/tasks.c ****                     {
4258:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4259:Lib/FreeRTOS/Source/tasks.c ****                     }
4260:Lib/FreeRTOS/Source/tasks.c **** 
4261:Lib/FreeRTOS/Source/tasks.c ****                     /* Disinherit the priority before adding the task into the
4262:Lib/FreeRTOS/Source/tasks.c ****                      * new  ready list. */
4263:Lib/FreeRTOS/Source/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
4264:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->uxPriority = pxTCB->uxBasePriority;
 6314              		.loc 1 4264 46
 6315 0074 3B69     		ldr	r3, [r7, #16]
 6316 0076 DA6C     		ldr	r2, [r3, #76]
 6317              		.loc 1 4264 39
 6318 0078 3B69     		ldr	r3, [r7, #16]
 6319 007a DA62     		str	r2, [r3, #44]
4265:Lib/FreeRTOS/Source/tasks.c **** 
4266:Lib/FreeRTOS/Source/tasks.c ****                     /* Reset the event list item value.  It cannot be in use for
4267:Lib/FreeRTOS/Source/tasks.c ****                      * any other purpose if this task is running, and it must be
4268:Lib/FreeRTOS/Source/tasks.c ****                      * running to give back the mutex. */
4269:Lib/FreeRTOS/Source/tasks.c ****                     listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_P
 6320              		.loc 1 4269 21
 6321 007c 3B69     		ldr	r3, [r7, #16]
 6322 007e DB6A     		ldr	r3, [r3, #44]
 6323 0080 C3F13802 		rsb	r2, r3, #56
 6324 0084 3B69     		ldr	r3, [r7, #16]
 6325 0086 9A61     		str	r2, [r3, #24]
4270:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 6326              		.loc 1 4270 21
 6327 0088 3B69     		ldr	r3, [r7, #16]
 6328 008a DA6A     		ldr	r2, [r3, #44]
 6329 008c 264B     		ldr	r3, .L389+16
 6330 008e 1B68     		ldr	r3, [r3]
 6331 0090 9A42     		cmp	r2, r3
 6332 0092 03D9     		bls	.L387
 6333              		.loc 1 4270 21 is_stmt 0 discriminator 1
 6334 0094 3B69     		ldr	r3, [r7, #16]
 6335 0096 DB6A     		ldr	r3, [r3, #44]
 6336 0098 234A     		ldr	r2, .L389+16
 6337 009a 1360     		str	r3, [r2]
 6338              	.L387:
 6339              	.LBB36:
 6340              		.loc 1 4270 21 discriminator 3
 6341 009c 3B69     		ldr	r3, [r7, #16]
 6342 009e DA6A     		ldr	r2, [r3, #44]
 6343 00a0 2249     		ldr	r1, .L389+20
 6344 00a2 1346     		mov	r3, r2
 6345 00a4 9B00     		lsls	r3, r3, #2
 6346 00a6 1344     		add	r3, r3, r2
 6347 00a8 9B00     		lsls	r3, r3, #2
 6348 00aa 0B44     		add	r3, r3, r1
 6349 00ac 0433     		adds	r3, r3, #4
 6350 00ae 1B68     		ldr	r3, [r3]
 6351 00b0 FB60     		str	r3, [r7, #12]
 6352 00b2 3B69     		ldr	r3, [r7, #16]
 6353 00b4 FA68     		ldr	r2, [r7, #12]
 6354 00b6 9A60     		str	r2, [r3, #8]
 6355 00b8 FB68     		ldr	r3, [r7, #12]
 6356 00ba 9A68     		ldr	r2, [r3, #8]
ARM GAS  /tmp/ccTFOe4z.s 			page 186


 6357 00bc 3B69     		ldr	r3, [r7, #16]
 6358 00be DA60     		str	r2, [r3, #12]
 6359 00c0 FB68     		ldr	r3, [r7, #12]
 6360 00c2 9B68     		ldr	r3, [r3, #8]
 6361 00c4 3A69     		ldr	r2, [r7, #16]
 6362 00c6 0432     		adds	r2, r2, #4
 6363 00c8 5A60     		str	r2, [r3, #4]
 6364 00ca 3B69     		ldr	r3, [r7, #16]
 6365 00cc 1A1D     		adds	r2, r3, #4
 6366 00ce FB68     		ldr	r3, [r7, #12]
 6367 00d0 9A60     		str	r2, [r3, #8]
 6368 00d2 3B69     		ldr	r3, [r7, #16]
 6369 00d4 DA6A     		ldr	r2, [r3, #44]
 6370 00d6 1346     		mov	r3, r2
 6371 00d8 9B00     		lsls	r3, r3, #2
 6372 00da 1344     		add	r3, r3, r2
 6373 00dc 9B00     		lsls	r3, r3, #2
 6374 00de 134A     		ldr	r2, .L389+20
 6375 00e0 1A44     		add	r2, r2, r3
 6376 00e2 3B69     		ldr	r3, [r7, #16]
 6377 00e4 5A61     		str	r2, [r3, #20]
 6378 00e6 3B69     		ldr	r3, [r7, #16]
 6379 00e8 DA6A     		ldr	r2, [r3, #44]
 6380 00ea 1049     		ldr	r1, .L389+20
 6381 00ec 1346     		mov	r3, r2
 6382 00ee 9B00     		lsls	r3, r3, #2
 6383 00f0 1344     		add	r3, r3, r2
 6384 00f2 9B00     		lsls	r3, r3, #2
 6385 00f4 0B44     		add	r3, r3, r1
 6386 00f6 1B68     		ldr	r3, [r3]
 6387 00f8 591C     		adds	r1, r3, #1
 6388 00fa 0C48     		ldr	r0, .L389+20
 6389 00fc 1346     		mov	r3, r2
 6390 00fe 9B00     		lsls	r3, r3, #2
 6391 0100 1344     		add	r3, r3, r2
 6392 0102 9B00     		lsls	r3, r3, #2
 6393 0104 0344     		add	r3, r3, r0
 6394 0106 1960     		str	r1, [r3]
 6395              	.LBE36:
4271:Lib/FreeRTOS/Source/tasks.c **** 
4272:Lib/FreeRTOS/Source/tasks.c ****                     /* Return true to indicate that a context switch is required.
4273:Lib/FreeRTOS/Source/tasks.c ****                      * This is only actually required in the corner case whereby
4274:Lib/FreeRTOS/Source/tasks.c ****                      * multiple mutexes were held and the mutexes were given back
4275:Lib/FreeRTOS/Source/tasks.c ****                      * in an order different to that in which they were taken.
4276:Lib/FreeRTOS/Source/tasks.c ****                      * If a context switch did not occur when the first mutex was
4277:Lib/FreeRTOS/Source/tasks.c ****                      * returned, even if a task was waiting on it, then a context
4278:Lib/FreeRTOS/Source/tasks.c ****                      * switch should occur when the last mutex is returned whether
4279:Lib/FreeRTOS/Source/tasks.c ****                      * a task is waiting on it or not. */
4280:Lib/FreeRTOS/Source/tasks.c ****                     xReturn = pdTRUE;
 6396              		.loc 1 4280 29 is_stmt 1
 6397 0108 0123     		movs	r3, #1
 6398 010a 7B61     		str	r3, [r7, #20]
 6399              	.L384:
4281:Lib/FreeRTOS/Source/tasks.c ****                 }
4282:Lib/FreeRTOS/Source/tasks.c ****                 else
4283:Lib/FreeRTOS/Source/tasks.c ****                 {
4284:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccTFOe4z.s 			page 187


4285:Lib/FreeRTOS/Source/tasks.c ****                 }
4286:Lib/FreeRTOS/Source/tasks.c ****             }
4287:Lib/FreeRTOS/Source/tasks.c ****             else
4288:Lib/FreeRTOS/Source/tasks.c ****             {
4289:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4290:Lib/FreeRTOS/Source/tasks.c ****             }
4291:Lib/FreeRTOS/Source/tasks.c ****         }
4292:Lib/FreeRTOS/Source/tasks.c ****         else
4293:Lib/FreeRTOS/Source/tasks.c ****         {
4294:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4295:Lib/FreeRTOS/Source/tasks.c ****         }
4296:Lib/FreeRTOS/Source/tasks.c **** 
4297:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 6400              		.loc 1 4297 16
 6401 010c 7B69     		ldr	r3, [r7, #20]
4298:Lib/FreeRTOS/Source/tasks.c ****     }
 6402              		.loc 1 4298 5
 6403 010e 1846     		mov	r0, r3
 6404 0110 1837     		adds	r7, r7, #24
 6405              		.cfi_def_cfa_offset 8
 6406 0112 BD46     		mov	sp, r7
 6407              		.cfi_def_cfa_register 13
 6408              		@ sp needed
 6409 0114 80BD     		pop	{r7, pc}
 6410              	.L390:
 6411 0116 00BF     		.align	2
 6412              	.L389:
 6413 0118 00000000 		.word	pxCurrentTCB
 6414 011c 00000000 		.word	.LC0
 6415 0120 00000000 		.word	__func__.8
 6416 0124 04000000 		.word	.LC1
 6417 0128 00000000 		.word	uxTopReadyPriority
 6418 012c 00000000 		.word	pxReadyTasksLists
 6419              		.cfi_endproc
 6420              	.LFE51:
 6422              		.section	.text.vTaskPriorityDisinheritAfterTimeout,"ax",%progbits
 6423              		.align	1
 6424              		.global	vTaskPriorityDisinheritAfterTimeout
 6425              		.syntax unified
 6426              		.thumb
 6427              		.thumb_func
 6429              	vTaskPriorityDisinheritAfterTimeout:
 6430              	.LFB52:
4299:Lib/FreeRTOS/Source/tasks.c **** 
4300:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4301:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4302:Lib/FreeRTOS/Source/tasks.c **** 
4303:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4304:Lib/FreeRTOS/Source/tasks.c **** 
4305:Lib/FreeRTOS/Source/tasks.c ****     void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder,
4306:Lib/FreeRTOS/Source/tasks.c ****                                               UBaseType_t uxHighestPriorityWaitingTask )
4307:Lib/FreeRTOS/Source/tasks.c ****     {
 6431              		.loc 1 4307 5
 6432              		.cfi_startproc
 6433              		@ args = 0, pretend = 0, frame = 32
 6434              		@ frame_needed = 1, uses_anonymous_args = 0
 6435 0000 80B5     		push	{r7, lr}
ARM GAS  /tmp/ccTFOe4z.s 			page 188


 6436              		.cfi_def_cfa_offset 8
 6437              		.cfi_offset 7, -8
 6438              		.cfi_offset 14, -4
 6439 0002 88B0     		sub	sp, sp, #32
 6440              		.cfi_def_cfa_offset 40
 6441 0004 00AF     		add	r7, sp, #0
 6442              		.cfi_def_cfa_register 7
 6443 0006 7860     		str	r0, [r7, #4]
 6444 0008 3960     		str	r1, [r7]
4308:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * const pxTCB = pxMutexHolder;
 6445              		.loc 1 4308 23
 6446 000a 7B68     		ldr	r3, [r7, #4]
 6447 000c BB61     		str	r3, [r7, #24]
4309:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
4310:Lib/FreeRTOS/Source/tasks.c ****         const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 6448              		.loc 1 4310 27
 6449 000e 0123     		movs	r3, #1
 6450 0010 7B61     		str	r3, [r7, #20]
4311:Lib/FreeRTOS/Source/tasks.c **** 
4312:Lib/FreeRTOS/Source/tasks.c ****         if( pxMutexHolder != NULL )
 6451              		.loc 1 4312 11
 6452 0012 7B68     		ldr	r3, [r7, #4]
 6453 0014 002B     		cmp	r3, #0
 6454 0016 00F08F80 		beq	.L399
4313:Lib/FreeRTOS/Source/tasks.c ****         {
4314:Lib/FreeRTOS/Source/tasks.c ****             /* If pxMutexHolder is not NULL then the holder must hold at least
4315:Lib/FreeRTOS/Source/tasks.c ****              * one mutex. */
4316:Lib/FreeRTOS/Source/tasks.c ****             configASSERT( pxTCB->uxMutexesHeld );
 6455              		.loc 1 4316 13
 6456 001a BB69     		ldr	r3, [r7, #24]
 6457 001c 1B6D     		ldr	r3, [r3, #80]
 6458 001e 002B     		cmp	r3, #0
 6459 0020 08D1     		bne	.L393
 6460              		.loc 1 4316 13 is_stmt 0 discriminator 1
 6461 0022 FFF7FEFF 		bl	ulSetInterruptMask
 6462 0026 464B     		ldr	r3, .L400
 6463 0028 464A     		ldr	r2, .L400+4
 6464 002a 41F2DC01 		movw	r1, #4316
 6465 002e 4648     		ldr	r0, .L400+8
 6466 0030 FFF7FEFF 		bl	__assert_func
 6467              	.L393:
4317:Lib/FreeRTOS/Source/tasks.c **** 
4318:Lib/FreeRTOS/Source/tasks.c ****             /* Determine the priority to which the priority of the task that
4319:Lib/FreeRTOS/Source/tasks.c ****              * holds the mutex should be set.  This will be the greater of the
4320:Lib/FreeRTOS/Source/tasks.c ****              * holding task's base priority and the priority of the highest
4321:Lib/FreeRTOS/Source/tasks.c ****              * priority task that is waiting to obtain the mutex. */
4322:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 6468              		.loc 1 4322 22 is_stmt 1
 6469 0034 BB69     		ldr	r3, [r7, #24]
 6470 0036 DB6C     		ldr	r3, [r3, #76]
 6471              		.loc 1 4322 15
 6472 0038 3A68     		ldr	r2, [r7]
 6473 003a 9A42     		cmp	r2, r3
 6474 003c 02D9     		bls	.L394
4323:Lib/FreeRTOS/Source/tasks.c ****             {
4324:Lib/FreeRTOS/Source/tasks.c ****                 uxPriorityToUse = uxHighestPriorityWaitingTask;
 6475              		.loc 1 4324 33
ARM GAS  /tmp/ccTFOe4z.s 			page 189


 6476 003e 3B68     		ldr	r3, [r7]
 6477 0040 FB61     		str	r3, [r7, #28]
 6478 0042 02E0     		b	.L395
 6479              	.L394:
4325:Lib/FreeRTOS/Source/tasks.c ****             }
4326:Lib/FreeRTOS/Source/tasks.c ****             else
4327:Lib/FreeRTOS/Source/tasks.c ****             {
4328:Lib/FreeRTOS/Source/tasks.c ****                 uxPriorityToUse = pxTCB->uxBasePriority;
 6480              		.loc 1 4328 33
 6481 0044 BB69     		ldr	r3, [r7, #24]
 6482 0046 DB6C     		ldr	r3, [r3, #76]
 6483 0048 FB61     		str	r3, [r7, #28]
 6484              	.L395:
4329:Lib/FreeRTOS/Source/tasks.c ****             }
4330:Lib/FreeRTOS/Source/tasks.c **** 
4331:Lib/FreeRTOS/Source/tasks.c ****             /* Does the priority need to change? */
4332:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->uxPriority != uxPriorityToUse )
 6485              		.loc 1 4332 22
 6486 004a BB69     		ldr	r3, [r7, #24]
 6487 004c DB6A     		ldr	r3, [r3, #44]
 6488              		.loc 1 4332 15
 6489 004e FA69     		ldr	r2, [r7, #28]
 6490 0050 9A42     		cmp	r2, r3
 6491 0052 71D0     		beq	.L399
4333:Lib/FreeRTOS/Source/tasks.c ****             {
4334:Lib/FreeRTOS/Source/tasks.c ****                 /* Only disinherit if no other mutexes are held.  This is a
4335:Lib/FreeRTOS/Source/tasks.c ****                  * simplification in the priority inheritance implementation.  If
4336:Lib/FreeRTOS/Source/tasks.c ****                  * the task that holds the mutex is also holding other mutexes then
4337:Lib/FreeRTOS/Source/tasks.c ****                  * the other mutexes may have caused the priority inheritance. */
4338:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 6492              		.loc 1 4338 26
 6493 0054 BB69     		ldr	r3, [r7, #24]
 6494 0056 1B6D     		ldr	r3, [r3, #80]
 6495              		.loc 1 4338 19
 6496 0058 7A69     		ldr	r2, [r7, #20]
 6497 005a 9A42     		cmp	r2, r3
 6498 005c 6CD1     		bne	.L399
4339:Lib/FreeRTOS/Source/tasks.c ****                 {
4340:Lib/FreeRTOS/Source/tasks.c ****                     /* If a task has timed out because it already holds the
4341:Lib/FreeRTOS/Source/tasks.c ****                      * mutex it was trying to obtain then it cannot of inherited
4342:Lib/FreeRTOS/Source/tasks.c ****                      * its own priority. */
4343:Lib/FreeRTOS/Source/tasks.c ****                     configASSERT( pxTCB != pxCurrentTCB );
 6499              		.loc 1 4343 21
 6500 005e 3B4B     		ldr	r3, .L400+12
 6501 0060 1B68     		ldr	r3, [r3]
 6502 0062 BA69     		ldr	r2, [r7, #24]
 6503 0064 9A42     		cmp	r2, r3
 6504 0066 08D1     		bne	.L396
 6505              		.loc 1 4343 21 is_stmt 0 discriminator 1
 6506 0068 FFF7FEFF 		bl	ulSetInterruptMask
 6507 006c 344B     		ldr	r3, .L400
 6508 006e 354A     		ldr	r2, .L400+4
 6509 0070 41F2F701 		movw	r1, #4343
 6510 0074 3448     		ldr	r0, .L400+8
 6511 0076 FFF7FEFF 		bl	__assert_func
 6512              	.L396:
4344:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 190


4345:Lib/FreeRTOS/Source/tasks.c ****                     /* Disinherit the priority, remembering the previous
4346:Lib/FreeRTOS/Source/tasks.c ****                      * priority to facilitate determining the subject task's
4347:Lib/FreeRTOS/Source/tasks.c ****                      * state. */
4348:Lib/FreeRTOS/Source/tasks.c ****                     traceTASK_PRIORITY_DISINHERIT( pxTCB, uxPriorityToUse );
4349:Lib/FreeRTOS/Source/tasks.c ****                     uxPriorityUsedOnEntry = pxTCB->uxPriority;
 6513              		.loc 1 4349 43 is_stmt 1
 6514 007a BB69     		ldr	r3, [r7, #24]
 6515 007c DB6A     		ldr	r3, [r3, #44]
 6516 007e 3B61     		str	r3, [r7, #16]
4350:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->uxPriority = uxPriorityToUse;
 6517              		.loc 1 4350 39
 6518 0080 BB69     		ldr	r3, [r7, #24]
 6519 0082 FA69     		ldr	r2, [r7, #28]
 6520 0084 DA62     		str	r2, [r3, #44]
4351:Lib/FreeRTOS/Source/tasks.c **** 
4352:Lib/FreeRTOS/Source/tasks.c ****                     /* Only reset the event list item value if the value is not
4353:Lib/FreeRTOS/Source/tasks.c ****                      * being used for anything else. */
4354:Lib/FreeRTOS/Source/tasks.c ****                     if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_IT
 6521              		.loc 1 4354 27
 6522 0086 BB69     		ldr	r3, [r7, #24]
 6523 0088 9B69     		ldr	r3, [r3, #24]
 6524              		.loc 1 4354 23
 6525 008a 002B     		cmp	r3, #0
 6526 008c 04DB     		blt	.L397
4355:Lib/FreeRTOS/Source/tasks.c ****                     {
4356:Lib/FreeRTOS/Source/tasks.c ****                         listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configM
 6527              		.loc 1 4356 25
 6528 008e FB69     		ldr	r3, [r7, #28]
 6529 0090 C3F13802 		rsb	r2, r3, #56
 6530 0094 BB69     		ldr	r3, [r7, #24]
 6531 0096 9A61     		str	r2, [r3, #24]
 6532              	.L397:
4357:Lib/FreeRTOS/Source/tasks.c ****                     }
4358:Lib/FreeRTOS/Source/tasks.c ****                     else
4359:Lib/FreeRTOS/Source/tasks.c ****                     {
4360:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4361:Lib/FreeRTOS/Source/tasks.c ****                     }
4362:Lib/FreeRTOS/Source/tasks.c **** 
4363:Lib/FreeRTOS/Source/tasks.c ****                     /* If the running task is not the task that holds the mutex
4364:Lib/FreeRTOS/Source/tasks.c ****                      * then the task that holds the mutex could be in either the
4365:Lib/FreeRTOS/Source/tasks.c ****                      * Ready, Blocked or Suspended states.  Only remove the task
4366:Lib/FreeRTOS/Source/tasks.c ****                      * from its current state list if it is in the Ready state as
4367:Lib/FreeRTOS/Source/tasks.c ****                      * the task's priority is going to change and there is one
4368:Lib/FreeRTOS/Source/tasks.c ****                      * Ready list per priority. */
4369:Lib/FreeRTOS/Source/tasks.c ****                     if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &
 6533              		.loc 1 4369 25
 6534 0098 BB69     		ldr	r3, [r7, #24]
 6535 009a 5969     		ldr	r1, [r3, #20]
 6536 009c 3A69     		ldr	r2, [r7, #16]
 6537 009e 1346     		mov	r3, r2
 6538 00a0 9B00     		lsls	r3, r3, #2
 6539 00a2 1344     		add	r3, r3, r2
 6540 00a4 9B00     		lsls	r3, r3, #2
 6541 00a6 2A4A     		ldr	r2, .L400+16
 6542 00a8 1344     		add	r3, r3, r2
 6543              		.loc 1 4369 23
 6544 00aa 9942     		cmp	r1, r3
ARM GAS  /tmp/ccTFOe4z.s 			page 191


 6545 00ac 44D1     		bne	.L399
4370:Lib/FreeRTOS/Source/tasks.c ****                     {
4371:Lib/FreeRTOS/Source/tasks.c ****                         if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 6546              		.loc 1 4371 29
 6547 00ae BB69     		ldr	r3, [r7, #24]
 6548 00b0 0433     		adds	r3, r3, #4
 6549 00b2 1846     		mov	r0, r3
 6550 00b4 FFF7FEFF 		bl	uxListRemove
4372:Lib/FreeRTOS/Source/tasks.c ****                         {
4373:Lib/FreeRTOS/Source/tasks.c ****                             /* It is known that the task is in its ready list so
4374:Lib/FreeRTOS/Source/tasks.c ****                              * there is no need to check again and the port level
4375:Lib/FreeRTOS/Source/tasks.c ****                              * reset macro can be called directly. */
4376:Lib/FreeRTOS/Source/tasks.c ****                             portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
4377:Lib/FreeRTOS/Source/tasks.c ****                         }
4378:Lib/FreeRTOS/Source/tasks.c ****                         else
4379:Lib/FreeRTOS/Source/tasks.c ****                         {
4380:Lib/FreeRTOS/Source/tasks.c ****                             mtCOVERAGE_TEST_MARKER();
4381:Lib/FreeRTOS/Source/tasks.c ****                         }
4382:Lib/FreeRTOS/Source/tasks.c **** 
4383:Lib/FreeRTOS/Source/tasks.c ****                         prvAddTaskToReadyList( pxTCB );
 6551              		.loc 1 4383 25
 6552 00b8 BB69     		ldr	r3, [r7, #24]
 6553 00ba DA6A     		ldr	r2, [r3, #44]
 6554 00bc 254B     		ldr	r3, .L400+20
 6555 00be 1B68     		ldr	r3, [r3]
 6556 00c0 9A42     		cmp	r2, r3
 6557 00c2 03D9     		bls	.L398
 6558              		.loc 1 4383 25 is_stmt 0 discriminator 1
 6559 00c4 BB69     		ldr	r3, [r7, #24]
 6560 00c6 DB6A     		ldr	r3, [r3, #44]
 6561 00c8 224A     		ldr	r2, .L400+20
 6562 00ca 1360     		str	r3, [r2]
 6563              	.L398:
 6564              	.LBB37:
 6565              		.loc 1 4383 25 discriminator 3
 6566 00cc BB69     		ldr	r3, [r7, #24]
 6567 00ce DA6A     		ldr	r2, [r3, #44]
 6568 00d0 1F49     		ldr	r1, .L400+16
 6569 00d2 1346     		mov	r3, r2
 6570 00d4 9B00     		lsls	r3, r3, #2
 6571 00d6 1344     		add	r3, r3, r2
 6572 00d8 9B00     		lsls	r3, r3, #2
 6573 00da 0B44     		add	r3, r3, r1
 6574 00dc 0433     		adds	r3, r3, #4
 6575 00de 1B68     		ldr	r3, [r3]
 6576 00e0 FB60     		str	r3, [r7, #12]
 6577 00e2 BB69     		ldr	r3, [r7, #24]
 6578 00e4 FA68     		ldr	r2, [r7, #12]
 6579 00e6 9A60     		str	r2, [r3, #8]
 6580 00e8 FB68     		ldr	r3, [r7, #12]
 6581 00ea 9A68     		ldr	r2, [r3, #8]
 6582 00ec BB69     		ldr	r3, [r7, #24]
 6583 00ee DA60     		str	r2, [r3, #12]
 6584 00f0 FB68     		ldr	r3, [r7, #12]
 6585 00f2 9B68     		ldr	r3, [r3, #8]
 6586 00f4 BA69     		ldr	r2, [r7, #24]
 6587 00f6 0432     		adds	r2, r2, #4
ARM GAS  /tmp/ccTFOe4z.s 			page 192


 6588 00f8 5A60     		str	r2, [r3, #4]
 6589 00fa BB69     		ldr	r3, [r7, #24]
 6590 00fc 1A1D     		adds	r2, r3, #4
 6591 00fe FB68     		ldr	r3, [r7, #12]
 6592 0100 9A60     		str	r2, [r3, #8]
 6593 0102 BB69     		ldr	r3, [r7, #24]
 6594 0104 DA6A     		ldr	r2, [r3, #44]
 6595 0106 1346     		mov	r3, r2
 6596 0108 9B00     		lsls	r3, r3, #2
 6597 010a 1344     		add	r3, r3, r2
 6598 010c 9B00     		lsls	r3, r3, #2
 6599 010e 104A     		ldr	r2, .L400+16
 6600 0110 1A44     		add	r2, r2, r3
 6601 0112 BB69     		ldr	r3, [r7, #24]
 6602 0114 5A61     		str	r2, [r3, #20]
 6603 0116 BB69     		ldr	r3, [r7, #24]
 6604 0118 DA6A     		ldr	r2, [r3, #44]
 6605 011a 0D49     		ldr	r1, .L400+16
 6606 011c 1346     		mov	r3, r2
 6607 011e 9B00     		lsls	r3, r3, #2
 6608 0120 1344     		add	r3, r3, r2
 6609 0122 9B00     		lsls	r3, r3, #2
 6610 0124 0B44     		add	r3, r3, r1
 6611 0126 1B68     		ldr	r3, [r3]
 6612 0128 591C     		adds	r1, r3, #1
 6613 012a 0948     		ldr	r0, .L400+16
 6614 012c 1346     		mov	r3, r2
 6615 012e 9B00     		lsls	r3, r3, #2
 6616 0130 1344     		add	r3, r3, r2
 6617 0132 9B00     		lsls	r3, r3, #2
 6618 0134 0344     		add	r3, r3, r0
 6619 0136 1960     		str	r1, [r3]
 6620              	.L399:
 6621              	.LBE37:
4384:Lib/FreeRTOS/Source/tasks.c ****                     }
4385:Lib/FreeRTOS/Source/tasks.c ****                     else
4386:Lib/FreeRTOS/Source/tasks.c ****                     {
4387:Lib/FreeRTOS/Source/tasks.c ****                         mtCOVERAGE_TEST_MARKER();
4388:Lib/FreeRTOS/Source/tasks.c ****                     }
4389:Lib/FreeRTOS/Source/tasks.c ****                 }
4390:Lib/FreeRTOS/Source/tasks.c ****                 else
4391:Lib/FreeRTOS/Source/tasks.c ****                 {
4392:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4393:Lib/FreeRTOS/Source/tasks.c ****                 }
4394:Lib/FreeRTOS/Source/tasks.c ****             }
4395:Lib/FreeRTOS/Source/tasks.c ****             else
4396:Lib/FreeRTOS/Source/tasks.c ****             {
4397:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4398:Lib/FreeRTOS/Source/tasks.c ****             }
4399:Lib/FreeRTOS/Source/tasks.c ****         }
4400:Lib/FreeRTOS/Source/tasks.c ****         else
4401:Lib/FreeRTOS/Source/tasks.c ****         {
4402:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4403:Lib/FreeRTOS/Source/tasks.c ****         }
4404:Lib/FreeRTOS/Source/tasks.c ****     }
 6622              		.loc 1 4404 5 is_stmt 1
 6623 0138 00BF     		nop
ARM GAS  /tmp/ccTFOe4z.s 			page 193


 6624 013a 2037     		adds	r7, r7, #32
 6625              		.cfi_def_cfa_offset 8
 6626 013c BD46     		mov	sp, r7
 6627              		.cfi_def_cfa_register 13
 6628              		@ sp needed
 6629 013e 80BD     		pop	{r7, pc}
 6630              	.L401:
 6631              		.align	2
 6632              	.L400:
 6633 0140 00000000 		.word	.LC0
 6634 0144 00000000 		.word	__func__.7
 6635 0148 04000000 		.word	.LC1
 6636 014c 00000000 		.word	pxCurrentTCB
 6637 0150 00000000 		.word	pxReadyTasksLists
 6638 0154 00000000 		.word	uxTopReadyPriority
 6639              		.cfi_endproc
 6640              	.LFE52:
 6642              		.section	.text.uxTaskResetEventItemValue,"ax",%progbits
 6643              		.align	1
 6644              		.global	uxTaskResetEventItemValue
 6645              		.syntax unified
 6646              		.thumb
 6647              		.thumb_func
 6649              	uxTaskResetEventItemValue:
 6650              	.LFB53:
4405:Lib/FreeRTOS/Source/tasks.c **** 
4406:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4407:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4408:Lib/FreeRTOS/Source/tasks.c **** 
4409:Lib/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4410:Lib/FreeRTOS/Source/tasks.c **** 
4411:Lib/FreeRTOS/Source/tasks.c ****     void vTaskEnterCritical( void )
4412:Lib/FreeRTOS/Source/tasks.c ****     {
4413:Lib/FreeRTOS/Source/tasks.c ****         portDISABLE_INTERRUPTS();
4414:Lib/FreeRTOS/Source/tasks.c **** 
4415:Lib/FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4416:Lib/FreeRTOS/Source/tasks.c ****         {
4417:Lib/FreeRTOS/Source/tasks.c ****             ( pxCurrentTCB->uxCriticalNesting )++;
4418:Lib/FreeRTOS/Source/tasks.c **** 
4419:Lib/FreeRTOS/Source/tasks.c ****             /* This is not the interrupt safe version of the enter critical
4420:Lib/FreeRTOS/Source/tasks.c ****              * function so  assert() if it is being called from an interrupt
4421:Lib/FreeRTOS/Source/tasks.c ****              * context.  Only API functions that end in "FromISR" can be used in an
4422:Lib/FreeRTOS/Source/tasks.c ****              * interrupt.  Only assert if the critical nesting count is 1 to
4423:Lib/FreeRTOS/Source/tasks.c ****              * protect against recursive calls if the assert function also uses a
4424:Lib/FreeRTOS/Source/tasks.c ****              * critical section. */
4425:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting == 1 )
4426:Lib/FreeRTOS/Source/tasks.c ****             {
4427:Lib/FreeRTOS/Source/tasks.c ****                 portASSERT_IF_IN_ISR();
4428:Lib/FreeRTOS/Source/tasks.c ****             }
4429:Lib/FreeRTOS/Source/tasks.c ****         }
4430:Lib/FreeRTOS/Source/tasks.c ****         else
4431:Lib/FreeRTOS/Source/tasks.c ****         {
4432:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4433:Lib/FreeRTOS/Source/tasks.c ****         }
4434:Lib/FreeRTOS/Source/tasks.c ****     }
4435:Lib/FreeRTOS/Source/tasks.c **** 
4436:Lib/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
ARM GAS  /tmp/ccTFOe4z.s 			page 194


4437:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4438:Lib/FreeRTOS/Source/tasks.c **** 
4439:Lib/FreeRTOS/Source/tasks.c **** #if ( portCRITICAL_NESTING_IN_TCB == 1 )
4440:Lib/FreeRTOS/Source/tasks.c **** 
4441:Lib/FreeRTOS/Source/tasks.c ****     void vTaskExitCritical( void )
4442:Lib/FreeRTOS/Source/tasks.c ****     {
4443:Lib/FreeRTOS/Source/tasks.c ****         if( xSchedulerRunning != pdFALSE )
4444:Lib/FreeRTOS/Source/tasks.c ****         {
4445:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->uxCriticalNesting > 0U )
4446:Lib/FreeRTOS/Source/tasks.c ****             {
4447:Lib/FreeRTOS/Source/tasks.c ****                 ( pxCurrentTCB->uxCriticalNesting )--;
4448:Lib/FreeRTOS/Source/tasks.c **** 
4449:Lib/FreeRTOS/Source/tasks.c ****                 if( pxCurrentTCB->uxCriticalNesting == 0U )
4450:Lib/FreeRTOS/Source/tasks.c ****                 {
4451:Lib/FreeRTOS/Source/tasks.c ****                     portENABLE_INTERRUPTS();
4452:Lib/FreeRTOS/Source/tasks.c ****                 }
4453:Lib/FreeRTOS/Source/tasks.c ****                 else
4454:Lib/FreeRTOS/Source/tasks.c ****                 {
4455:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4456:Lib/FreeRTOS/Source/tasks.c ****                 }
4457:Lib/FreeRTOS/Source/tasks.c ****             }
4458:Lib/FreeRTOS/Source/tasks.c ****             else
4459:Lib/FreeRTOS/Source/tasks.c ****             {
4460:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4461:Lib/FreeRTOS/Source/tasks.c ****             }
4462:Lib/FreeRTOS/Source/tasks.c ****         }
4463:Lib/FreeRTOS/Source/tasks.c ****         else
4464:Lib/FreeRTOS/Source/tasks.c ****         {
4465:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4466:Lib/FreeRTOS/Source/tasks.c ****         }
4467:Lib/FreeRTOS/Source/tasks.c ****     }
4468:Lib/FreeRTOS/Source/tasks.c **** 
4469:Lib/FreeRTOS/Source/tasks.c **** #endif /* portCRITICAL_NESTING_IN_TCB */
4470:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4471:Lib/FreeRTOS/Source/tasks.c **** 
4472:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 )
4473:Lib/FreeRTOS/Source/tasks.c **** 
4474:Lib/FreeRTOS/Source/tasks.c ****     static char * prvWriteNameToBuffer( char * pcBuffer,
4475:Lib/FreeRTOS/Source/tasks.c ****                                         const char * pcTaskName )
4476:Lib/FreeRTOS/Source/tasks.c ****     {
4477:Lib/FreeRTOS/Source/tasks.c ****         size_t x;
4478:Lib/FreeRTOS/Source/tasks.c **** 
4479:Lib/FreeRTOS/Source/tasks.c ****         /* Start by copying the entire string. */
4480:Lib/FreeRTOS/Source/tasks.c ****         strcpy( pcBuffer, pcTaskName );
4481:Lib/FreeRTOS/Source/tasks.c **** 
4482:Lib/FreeRTOS/Source/tasks.c ****         /* Pad the end of the string with spaces to ensure columns line up when
4483:Lib/FreeRTOS/Source/tasks.c ****          * printed out. */
4484:Lib/FreeRTOS/Source/tasks.c ****         for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
4485:Lib/FreeRTOS/Source/tasks.c ****         {
4486:Lib/FreeRTOS/Source/tasks.c ****             pcBuffer[ x ] = ' ';
4487:Lib/FreeRTOS/Source/tasks.c ****         }
4488:Lib/FreeRTOS/Source/tasks.c **** 
4489:Lib/FreeRTOS/Source/tasks.c ****         /* Terminate. */
4490:Lib/FreeRTOS/Source/tasks.c ****         pcBuffer[ x ] = ( char ) 0x00;
4491:Lib/FreeRTOS/Source/tasks.c **** 
4492:Lib/FreeRTOS/Source/tasks.c ****         /* Return the new end of string. */
4493:Lib/FreeRTOS/Source/tasks.c ****         return &( pcBuffer[ x ] );
ARM GAS  /tmp/ccTFOe4z.s 			page 195


4494:Lib/FreeRTOS/Source/tasks.c ****     }
4495:Lib/FreeRTOS/Source/tasks.c **** 
4496:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
4497:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4498:Lib/FreeRTOS/Source/tasks.c **** 
4499:Lib/FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
4500:Lib/FreeRTOS/Source/tasks.c **** 
4501:Lib/FreeRTOS/Source/tasks.c ****     void vTaskList( char * pcWriteBuffer )
4502:Lib/FreeRTOS/Source/tasks.c ****     {
4503:Lib/FreeRTOS/Source/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4504:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxArraySize, x;
4505:Lib/FreeRTOS/Source/tasks.c ****         char cStatus;
4506:Lib/FreeRTOS/Source/tasks.c **** 
4507:Lib/FreeRTOS/Source/tasks.c ****         /*
4508:Lib/FreeRTOS/Source/tasks.c ****          * PLEASE NOTE:
4509:Lib/FreeRTOS/Source/tasks.c ****          *
4510:Lib/FreeRTOS/Source/tasks.c ****          * This function is provided for convenience only, and is used by many
4511:Lib/FreeRTOS/Source/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4512:Lib/FreeRTOS/Source/tasks.c ****          * scheduler.
4513:Lib/FreeRTOS/Source/tasks.c ****          *
4514:Lib/FreeRTOS/Source/tasks.c ****          * vTaskList() calls uxTaskGetSystemState(), then formats part of the
4515:Lib/FreeRTOS/Source/tasks.c ****          * uxTaskGetSystemState() output into a human readable table that
4516:Lib/FreeRTOS/Source/tasks.c ****          * displays task: names, states, priority, stack usage and task number.
4517:Lib/FreeRTOS/Source/tasks.c ****          * Stack usage specified as the number of unused StackType_t words stack can hold
4518:Lib/FreeRTOS/Source/tasks.c ****          * on top of stack - not the number of bytes.
4519:Lib/FreeRTOS/Source/tasks.c ****          *
4520:Lib/FreeRTOS/Source/tasks.c ****          * vTaskList() has a dependency on the sprintf() C library function that
4521:Lib/FreeRTOS/Source/tasks.c ****          * might bloat the code size, use a lot of stack, and provide different
4522:Lib/FreeRTOS/Source/tasks.c ****          * results on different platforms.  An alternative, tiny, third party,
4523:Lib/FreeRTOS/Source/tasks.c ****          * and limited functionality implementation of sprintf() is provided in
4524:Lib/FreeRTOS/Source/tasks.c ****          * many of the FreeRTOS/Demo sub-directories in a file called
4525:Lib/FreeRTOS/Source/tasks.c ****          * printf-stdarg.c (note printf-stdarg.c does not provide a full
4526:Lib/FreeRTOS/Source/tasks.c ****          * snprintf() implementation!).
4527:Lib/FreeRTOS/Source/tasks.c ****          *
4528:Lib/FreeRTOS/Source/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4529:Lib/FreeRTOS/Source/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
4530:Lib/FreeRTOS/Source/tasks.c ****          * through a call to vTaskList().
4531:Lib/FreeRTOS/Source/tasks.c ****          */
4532:Lib/FreeRTOS/Source/tasks.c **** 
4533:Lib/FreeRTOS/Source/tasks.c **** 
4534:Lib/FreeRTOS/Source/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4535:Lib/FreeRTOS/Source/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4536:Lib/FreeRTOS/Source/tasks.c **** 
4537:Lib/FreeRTOS/Source/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4538:Lib/FreeRTOS/Source/tasks.c ****          * function is executing. */
4539:Lib/FreeRTOS/Source/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4540:Lib/FreeRTOS/Source/tasks.c **** 
4541:Lib/FreeRTOS/Source/tasks.c ****         /* Allocate an array index for each task.  NOTE!  if
4542:Lib/FreeRTOS/Source/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4543:Lib/FreeRTOS/Source/tasks.c ****          * equate to NULL. */
4544:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4545:Lib/FreeRTOS/Source/tasks.c **** 
4546:Lib/FreeRTOS/Source/tasks.c ****         if( pxTaskStatusArray != NULL )
4547:Lib/FreeRTOS/Source/tasks.c ****         {
4548:Lib/FreeRTOS/Source/tasks.c ****             /* Generate the (binary) data. */
4549:Lib/FreeRTOS/Source/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
4550:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 196


4551:Lib/FreeRTOS/Source/tasks.c ****             /* Create a human readable table from the binary data. */
4552:Lib/FreeRTOS/Source/tasks.c ****             for( x = 0; x < uxArraySize; x++ )
4553:Lib/FreeRTOS/Source/tasks.c ****             {
4554:Lib/FreeRTOS/Source/tasks.c ****                 switch( pxTaskStatusArray[ x ].eCurrentState )
4555:Lib/FreeRTOS/Source/tasks.c ****                 {
4556:Lib/FreeRTOS/Source/tasks.c ****                     case eRunning:
4557:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = tskRUNNING_CHAR;
4558:Lib/FreeRTOS/Source/tasks.c ****                         break;
4559:Lib/FreeRTOS/Source/tasks.c **** 
4560:Lib/FreeRTOS/Source/tasks.c ****                     case eReady:
4561:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = tskREADY_CHAR;
4562:Lib/FreeRTOS/Source/tasks.c ****                         break;
4563:Lib/FreeRTOS/Source/tasks.c **** 
4564:Lib/FreeRTOS/Source/tasks.c ****                     case eBlocked:
4565:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = tskBLOCKED_CHAR;
4566:Lib/FreeRTOS/Source/tasks.c ****                         break;
4567:Lib/FreeRTOS/Source/tasks.c **** 
4568:Lib/FreeRTOS/Source/tasks.c ****                     case eSuspended:
4569:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = tskSUSPENDED_CHAR;
4570:Lib/FreeRTOS/Source/tasks.c ****                         break;
4571:Lib/FreeRTOS/Source/tasks.c **** 
4572:Lib/FreeRTOS/Source/tasks.c ****                     case eDeleted:
4573:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = tskDELETED_CHAR;
4574:Lib/FreeRTOS/Source/tasks.c ****                         break;
4575:Lib/FreeRTOS/Source/tasks.c **** 
4576:Lib/FreeRTOS/Source/tasks.c ****                     case eInvalid: /* Fall through. */
4577:Lib/FreeRTOS/Source/tasks.c ****                     default:       /* Should not get here, but it is included
4578:Lib/FreeRTOS/Source/tasks.c ****                                     * to prevent static checking errors. */
4579:Lib/FreeRTOS/Source/tasks.c ****                         cStatus = ( char ) 0x00;
4580:Lib/FreeRTOS/Source/tasks.c ****                         break;
4581:Lib/FreeRTOS/Source/tasks.c ****                 }
4582:Lib/FreeRTOS/Source/tasks.c **** 
4583:Lib/FreeRTOS/Source/tasks.c ****                 /* Write the task name to the string, padding with spaces so it
4584:Lib/FreeRTOS/Source/tasks.c ****                  * can be printed in tabular form more easily. */
4585:Lib/FreeRTOS/Source/tasks.c ****                 pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskN
4586:Lib/FreeRTOS/Source/tasks.c **** 
4587:Lib/FreeRTOS/Source/tasks.c ****                 /* Write the rest of the string. */
4588:Lib/FreeRTOS/Source/tasks.c ****                 sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskSta
4589:Lib/FreeRTOS/Source/tasks.c ****                 pcWriteBuffer += strlen( pcWriteBuffer );                                          
4590:Lib/FreeRTOS/Source/tasks.c ****             }
4591:Lib/FreeRTOS/Source/tasks.c **** 
4592:Lib/FreeRTOS/Source/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4593:Lib/FreeRTOS/Source/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4594:Lib/FreeRTOS/Source/tasks.c ****             vPortFree( pxTaskStatusArray );
4595:Lib/FreeRTOS/Source/tasks.c ****         }
4596:Lib/FreeRTOS/Source/tasks.c ****         else
4597:Lib/FreeRTOS/Source/tasks.c ****         {
4598:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4599:Lib/FreeRTOS/Source/tasks.c ****         }
4600:Lib/FreeRTOS/Source/tasks.c ****     }
4601:Lib/FreeRTOS/Source/tasks.c **** 
4602:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
4603:Lib/FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
4604:Lib/FreeRTOS/Source/tasks.c **** 
4605:Lib/FreeRTOS/Source/tasks.c **** #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( c
4606:Lib/FreeRTOS/Source/tasks.c **** 
4607:Lib/FreeRTOS/Source/tasks.c ****     void vTaskGetRunTimeStats( char * pcWriteBuffer )
ARM GAS  /tmp/ccTFOe4z.s 			page 197


4608:Lib/FreeRTOS/Source/tasks.c ****     {
4609:Lib/FreeRTOS/Source/tasks.c ****         TaskStatus_t * pxTaskStatusArray;
4610:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxArraySize, x;
4611:Lib/FreeRTOS/Source/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulTotalTime, ulStatsAsPercentage;
4612:Lib/FreeRTOS/Source/tasks.c **** 
4613:Lib/FreeRTOS/Source/tasks.c ****         /*
4614:Lib/FreeRTOS/Source/tasks.c ****          * PLEASE NOTE:
4615:Lib/FreeRTOS/Source/tasks.c ****          *
4616:Lib/FreeRTOS/Source/tasks.c ****          * This function is provided for convenience only, and is used by many
4617:Lib/FreeRTOS/Source/tasks.c ****          * of the demo applications.  Do not consider it to be part of the
4618:Lib/FreeRTOS/Source/tasks.c ****          * scheduler.
4619:Lib/FreeRTOS/Source/tasks.c ****          *
4620:Lib/FreeRTOS/Source/tasks.c ****          * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
4621:Lib/FreeRTOS/Source/tasks.c ****          * of the uxTaskGetSystemState() output into a human readable table that
4622:Lib/FreeRTOS/Source/tasks.c ****          * displays the amount of time each task has spent in the Running state
4623:Lib/FreeRTOS/Source/tasks.c ****          * in both absolute and percentage terms.
4624:Lib/FreeRTOS/Source/tasks.c ****          *
4625:Lib/FreeRTOS/Source/tasks.c ****          * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
4626:Lib/FreeRTOS/Source/tasks.c ****          * function that might bloat the code size, use a lot of stack, and
4627:Lib/FreeRTOS/Source/tasks.c ****          * provide different results on different platforms.  An alternative,
4628:Lib/FreeRTOS/Source/tasks.c ****          * tiny, third party, and limited functionality implementation of
4629:Lib/FreeRTOS/Source/tasks.c ****          * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
4630:Lib/FreeRTOS/Source/tasks.c ****          * a file called printf-stdarg.c (note printf-stdarg.c does not provide
4631:Lib/FreeRTOS/Source/tasks.c ****          * a full snprintf() implementation!).
4632:Lib/FreeRTOS/Source/tasks.c ****          *
4633:Lib/FreeRTOS/Source/tasks.c ****          * It is recommended that production systems call uxTaskGetSystemState()
4634:Lib/FreeRTOS/Source/tasks.c ****          * directly to get access to raw stats data, rather than indirectly
4635:Lib/FreeRTOS/Source/tasks.c ****          * through a call to vTaskGetRunTimeStats().
4636:Lib/FreeRTOS/Source/tasks.c ****          */
4637:Lib/FreeRTOS/Source/tasks.c **** 
4638:Lib/FreeRTOS/Source/tasks.c ****         /* Make sure the write buffer does not contain a string. */
4639:Lib/FreeRTOS/Source/tasks.c ****         *pcWriteBuffer = ( char ) 0x00;
4640:Lib/FreeRTOS/Source/tasks.c **** 
4641:Lib/FreeRTOS/Source/tasks.c ****         /* Take a snapshot of the number of tasks in case it changes while this
4642:Lib/FreeRTOS/Source/tasks.c ****          * function is executing. */
4643:Lib/FreeRTOS/Source/tasks.c ****         uxArraySize = uxCurrentNumberOfTasks;
4644:Lib/FreeRTOS/Source/tasks.c **** 
4645:Lib/FreeRTOS/Source/tasks.c ****         /* Allocate an array index for each task.  NOTE!  If
4646:Lib/FreeRTOS/Source/tasks.c ****          * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
4647:Lib/FreeRTOS/Source/tasks.c ****          * equate to NULL. */
4648:Lib/FreeRTOS/Source/tasks.c ****         pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint
4649:Lib/FreeRTOS/Source/tasks.c **** 
4650:Lib/FreeRTOS/Source/tasks.c ****         if( pxTaskStatusArray != NULL )
4651:Lib/FreeRTOS/Source/tasks.c ****         {
4652:Lib/FreeRTOS/Source/tasks.c ****             /* Generate the (binary) data. */
4653:Lib/FreeRTOS/Source/tasks.c ****             uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
4654:Lib/FreeRTOS/Source/tasks.c **** 
4655:Lib/FreeRTOS/Source/tasks.c ****             /* For percentage calculations. */
4656:Lib/FreeRTOS/Source/tasks.c ****             ulTotalTime /= 100UL;
4657:Lib/FreeRTOS/Source/tasks.c **** 
4658:Lib/FreeRTOS/Source/tasks.c ****             /* Avoid divide by zero errors. */
4659:Lib/FreeRTOS/Source/tasks.c ****             if( ulTotalTime > 0UL )
4660:Lib/FreeRTOS/Source/tasks.c ****             {
4661:Lib/FreeRTOS/Source/tasks.c ****                 /* Create a human readable table from the binary data. */
4662:Lib/FreeRTOS/Source/tasks.c ****                 for( x = 0; x < uxArraySize; x++ )
4663:Lib/FreeRTOS/Source/tasks.c ****                 {
4664:Lib/FreeRTOS/Source/tasks.c ****                     /* What percentage of the total run time has the task used?
ARM GAS  /tmp/ccTFOe4z.s 			page 198


4665:Lib/FreeRTOS/Source/tasks.c ****                      * This will always be rounded down to the nearest integer.
4666:Lib/FreeRTOS/Source/tasks.c ****                      * ulTotalRunTime has already been divided by 100. */
4667:Lib/FreeRTOS/Source/tasks.c ****                     ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
4668:Lib/FreeRTOS/Source/tasks.c **** 
4669:Lib/FreeRTOS/Source/tasks.c ****                     /* Write the task name to the string, padding with
4670:Lib/FreeRTOS/Source/tasks.c ****                      * spaces so it can be printed in tabular form more
4671:Lib/FreeRTOS/Source/tasks.c ****                      * easily. */
4672:Lib/FreeRTOS/Source/tasks.c ****                     pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcT
4673:Lib/FreeRTOS/Source/tasks.c **** 
4674:Lib/FreeRTOS/Source/tasks.c ****                     if( ulStatsAsPercentage > 0UL )
4675:Lib/FreeRTOS/Source/tasks.c ****                     {
4676:Lib/FreeRTOS/Source/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4677:Lib/FreeRTOS/Source/tasks.c ****                         {
4678:Lib/FreeRTOS/Source/tasks.c ****                             sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ul
4679:Lib/FreeRTOS/Source/tasks.c ****                         }
4680:Lib/FreeRTOS/Source/tasks.c ****                         #else
4681:Lib/FreeRTOS/Source/tasks.c ****                         {
4682:Lib/FreeRTOS/Source/tasks.c ****                             /* sizeof( int ) == sizeof( long ) so a smaller
4683:Lib/FreeRTOS/Source/tasks.c ****                              * printf() library can be used. */
4684:Lib/FreeRTOS/Source/tasks.c ****                             sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStat
4685:Lib/FreeRTOS/Source/tasks.c ****                         }
4686:Lib/FreeRTOS/Source/tasks.c ****                         #endif
4687:Lib/FreeRTOS/Source/tasks.c ****                     }
4688:Lib/FreeRTOS/Source/tasks.c ****                     else
4689:Lib/FreeRTOS/Source/tasks.c ****                     {
4690:Lib/FreeRTOS/Source/tasks.c ****                         /* If the percentage is zero here then the task has
4691:Lib/FreeRTOS/Source/tasks.c ****                          * consumed less than 1% of the total run time. */
4692:Lib/FreeRTOS/Source/tasks.c ****                         #ifdef portLU_PRINTF_SPECIFIER_REQUIRED
4693:Lib/FreeRTOS/Source/tasks.c ****                         {
4694:Lib/FreeRTOS/Source/tasks.c ****                             sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulR
4695:Lib/FreeRTOS/Source/tasks.c ****                         }
4696:Lib/FreeRTOS/Source/tasks.c ****                         #else
4697:Lib/FreeRTOS/Source/tasks.c ****                         {
4698:Lib/FreeRTOS/Source/tasks.c ****                             /* sizeof( int ) == sizeof( long ) so a smaller
4699:Lib/FreeRTOS/Source/tasks.c ****                              * printf() library can be used. */
4700:Lib/FreeRTOS/Source/tasks.c ****                             sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStat
4701:Lib/FreeRTOS/Source/tasks.c ****                         }
4702:Lib/FreeRTOS/Source/tasks.c ****                         #endif
4703:Lib/FreeRTOS/Source/tasks.c ****                     }
4704:Lib/FreeRTOS/Source/tasks.c **** 
4705:Lib/FreeRTOS/Source/tasks.c ****                     pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok o
4706:Lib/FreeRTOS/Source/tasks.c ****                 }
4707:Lib/FreeRTOS/Source/tasks.c ****             }
4708:Lib/FreeRTOS/Source/tasks.c ****             else
4709:Lib/FreeRTOS/Source/tasks.c ****             {
4710:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4711:Lib/FreeRTOS/Source/tasks.c ****             }
4712:Lib/FreeRTOS/Source/tasks.c **** 
4713:Lib/FreeRTOS/Source/tasks.c ****             /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
4714:Lib/FreeRTOS/Source/tasks.c ****              * is 0 then vPortFree() will be #defined to nothing. */
4715:Lib/FreeRTOS/Source/tasks.c ****             vPortFree( pxTaskStatusArray );
4716:Lib/FreeRTOS/Source/tasks.c ****         }
4717:Lib/FreeRTOS/Source/tasks.c ****         else
4718:Lib/FreeRTOS/Source/tasks.c ****         {
4719:Lib/FreeRTOS/Source/tasks.c ****             mtCOVERAGE_TEST_MARKER();
4720:Lib/FreeRTOS/Source/tasks.c ****         }
4721:Lib/FreeRTOS/Source/tasks.c ****     }
ARM GAS  /tmp/ccTFOe4z.s 			page 199


4722:Lib/FreeRTOS/Source/tasks.c **** 
4723:Lib/FreeRTOS/Source/tasks.c **** #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) 
4724:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4725:Lib/FreeRTOS/Source/tasks.c **** 
4726:Lib/FreeRTOS/Source/tasks.c **** TickType_t uxTaskResetEventItemValue( void )
4727:Lib/FreeRTOS/Source/tasks.c **** {
 6651              		.loc 1 4727 1
 6652              		.cfi_startproc
 6653              		@ args = 0, pretend = 0, frame = 8
 6654              		@ frame_needed = 1, uses_anonymous_args = 0
 6655              		@ link register save eliminated.
 6656 0000 80B4     		push	{r7}
 6657              		.cfi_def_cfa_offset 4
 6658              		.cfi_offset 7, -4
 6659 0002 83B0     		sub	sp, sp, #12
 6660              		.cfi_def_cfa_offset 16
 6661 0004 00AF     		add	r7, sp, #0
 6662              		.cfi_def_cfa_register 7
4728:Lib/FreeRTOS/Source/tasks.c ****     TickType_t uxReturn;
4729:Lib/FreeRTOS/Source/tasks.c **** 
4730:Lib/FreeRTOS/Source/tasks.c ****     uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 6663              		.loc 1 4730 16
 6664 0006 094B     		ldr	r3, .L404
 6665 0008 1B68     		ldr	r3, [r3]
 6666              		.loc 1 4730 14
 6667 000a 9B69     		ldr	r3, [r3, #24]
 6668 000c 7B60     		str	r3, [r7, #4]
4731:Lib/FreeRTOS/Source/tasks.c **** 
4732:Lib/FreeRTOS/Source/tasks.c ****     /* Reset the event list item to its normal value - so it can be used with
4733:Lib/FreeRTOS/Source/tasks.c ****      * queues and semaphores. */
4734:Lib/FreeRTOS/Source/tasks.c ****     listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITI
 6669              		.loc 1 4734 5
 6670 000e 074B     		ldr	r3, .L404
 6671 0010 1B68     		ldr	r3, [r3]
 6672 0012 DA6A     		ldr	r2, [r3, #44]
 6673 0014 054B     		ldr	r3, .L404
 6674 0016 1B68     		ldr	r3, [r3]
 6675 0018 C2F13802 		rsb	r2, r2, #56
 6676 001c 9A61     		str	r2, [r3, #24]
4735:Lib/FreeRTOS/Source/tasks.c **** 
4736:Lib/FreeRTOS/Source/tasks.c ****     return uxReturn;
 6677              		.loc 1 4736 12
 6678 001e 7B68     		ldr	r3, [r7, #4]
4737:Lib/FreeRTOS/Source/tasks.c **** }
 6679              		.loc 1 4737 1
 6680 0020 1846     		mov	r0, r3
 6681 0022 0C37     		adds	r7, r7, #12
 6682              		.cfi_def_cfa_offset 4
 6683 0024 BD46     		mov	sp, r7
 6684              		.cfi_def_cfa_register 13
 6685              		@ sp needed
 6686 0026 5DF8047B 		ldr	r7, [sp], #4
 6687              		.cfi_restore 7
 6688              		.cfi_def_cfa_offset 0
 6689 002a 7047     		bx	lr
 6690              	.L405:
 6691              		.align	2
ARM GAS  /tmp/ccTFOe4z.s 			page 200


 6692              	.L404:
 6693 002c 00000000 		.word	pxCurrentTCB
 6694              		.cfi_endproc
 6695              	.LFE53:
 6697              		.section	.text.pvTaskIncrementMutexHeldCount,"ax",%progbits
 6698              		.align	1
 6699              		.global	pvTaskIncrementMutexHeldCount
 6700              		.syntax unified
 6701              		.thumb
 6702              		.thumb_func
 6704              	pvTaskIncrementMutexHeldCount:
 6705              	.LFB54:
4738:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4739:Lib/FreeRTOS/Source/tasks.c **** 
4740:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
4741:Lib/FreeRTOS/Source/tasks.c **** 
4742:Lib/FreeRTOS/Source/tasks.c ****     TaskHandle_t pvTaskIncrementMutexHeldCount( void )
4743:Lib/FreeRTOS/Source/tasks.c ****     {
 6706              		.loc 1 4743 5
 6707              		.cfi_startproc
 6708              		@ args = 0, pretend = 0, frame = 0
 6709              		@ frame_needed = 1, uses_anonymous_args = 0
 6710              		@ link register save eliminated.
 6711 0000 80B4     		push	{r7}
 6712              		.cfi_def_cfa_offset 4
 6713              		.cfi_offset 7, -4
 6714 0002 00AF     		add	r7, sp, #0
 6715              		.cfi_def_cfa_register 7
4744:Lib/FreeRTOS/Source/tasks.c ****         /* If xSemaphoreCreateMutex() is called before any tasks have been created
4745:Lib/FreeRTOS/Source/tasks.c ****          * then pxCurrentTCB will be NULL. */
4746:Lib/FreeRTOS/Source/tasks.c ****         if( pxCurrentTCB != NULL )
 6716              		.loc 1 4746 26
 6717 0004 074B     		ldr	r3, .L409
 6718 0006 1B68     		ldr	r3, [r3]
 6719              		.loc 1 4746 11
 6720 0008 002B     		cmp	r3, #0
 6721 000a 04D0     		beq	.L407
4747:Lib/FreeRTOS/Source/tasks.c ****         {
4748:Lib/FreeRTOS/Source/tasks.c ****             ( pxCurrentTCB->uxMutexesHeld )++;
 6722              		.loc 1 4748 27
 6723 000c 054B     		ldr	r3, .L409
 6724 000e 1B68     		ldr	r3, [r3]
 6725 0010 1A6D     		ldr	r2, [r3, #80]
 6726              		.loc 1 4748 44
 6727 0012 0132     		adds	r2, r2, #1
 6728 0014 1A65     		str	r2, [r3, #80]
 6729              	.L407:
4749:Lib/FreeRTOS/Source/tasks.c ****         }
4750:Lib/FreeRTOS/Source/tasks.c **** 
4751:Lib/FreeRTOS/Source/tasks.c ****         return pxCurrentTCB;
 6730              		.loc 1 4751 16
 6731 0016 034B     		ldr	r3, .L409
 6732 0018 1B68     		ldr	r3, [r3]
4752:Lib/FreeRTOS/Source/tasks.c ****     }
 6733              		.loc 1 4752 5
 6734 001a 1846     		mov	r0, r3
 6735 001c BD46     		mov	sp, r7
ARM GAS  /tmp/ccTFOe4z.s 			page 201


 6736              		.cfi_def_cfa_register 13
 6737              		@ sp needed
 6738 001e 5DF8047B 		ldr	r7, [sp], #4
 6739              		.cfi_restore 7
 6740              		.cfi_def_cfa_offset 0
 6741 0022 7047     		bx	lr
 6742              	.L410:
 6743              		.align	2
 6744              	.L409:
 6745 0024 00000000 		.word	pxCurrentTCB
 6746              		.cfi_endproc
 6747              	.LFE54:
 6749              		.section	.text.ulTaskGenericNotifyTake,"ax",%progbits
 6750              		.align	1
 6751              		.global	ulTaskGenericNotifyTake
 6752              		.syntax unified
 6753              		.thumb
 6754              		.thumb_func
 6756              	ulTaskGenericNotifyTake:
 6757              	.LFB55:
4753:Lib/FreeRTOS/Source/tasks.c **** 
4754:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_MUTEXES */
4755:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4756:Lib/FreeRTOS/Source/tasks.c **** 
4757:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4758:Lib/FreeRTOS/Source/tasks.c **** 
4759:Lib/FreeRTOS/Source/tasks.c ****     uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
4760:Lib/FreeRTOS/Source/tasks.c ****                                       BaseType_t xClearCountOnExit,
4761:Lib/FreeRTOS/Source/tasks.c ****                                       TickType_t xTicksToWait )
4762:Lib/FreeRTOS/Source/tasks.c ****     {
 6758              		.loc 1 4762 5
 6759              		.cfi_startproc
 6760              		@ args = 0, pretend = 0, frame = 24
 6761              		@ frame_needed = 1, uses_anonymous_args = 0
 6762 0000 80B5     		push	{r7, lr}
 6763              		.cfi_def_cfa_offset 8
 6764              		.cfi_offset 7, -8
 6765              		.cfi_offset 14, -4
 6766 0002 86B0     		sub	sp, sp, #24
 6767              		.cfi_def_cfa_offset 32
 6768 0004 00AF     		add	r7, sp, #0
 6769              		.cfi_def_cfa_register 7
 6770 0006 F860     		str	r0, [r7, #12]
 6771 0008 B960     		str	r1, [r7, #8]
 6772 000a 7A60     		str	r2, [r7, #4]
4763:Lib/FreeRTOS/Source/tasks.c ****         uint32_t ulReturn;
4764:Lib/FreeRTOS/Source/tasks.c **** 
4765:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 6773              		.loc 1 4765 9
 6774 000c FB68     		ldr	r3, [r7, #12]
 6775 000e 002B     		cmp	r3, #0
 6776 0010 08D0     		beq	.L412
 6777              		.loc 1 4765 9 is_stmt 0 discriminator 1
 6778 0012 FFF7FEFF 		bl	ulSetInterruptMask
 6779 0016 284B     		ldr	r3, .L417
 6780 0018 284A     		ldr	r2, .L417+4
 6781 001a 41F29D21 		movw	r1, #4765
ARM GAS  /tmp/ccTFOe4z.s 			page 202


 6782 001e 2848     		ldr	r0, .L417+8
 6783 0020 FFF7FEFF 		bl	__assert_func
 6784              	.L412:
4766:Lib/FreeRTOS/Source/tasks.c **** 
4767:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 6785              		.loc 1 4767 9 is_stmt 1
 6786 0024 FFF7FEFF 		bl	vPortEnterCritical
4768:Lib/FreeRTOS/Source/tasks.c ****         {
4769:Lib/FreeRTOS/Source/tasks.c ****             /* Only block if the notification count is not already non-zero. */
4770:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
 6787              		.loc 1 4770 29
 6788 0028 264B     		ldr	r3, .L417+12
 6789 002a 1B68     		ldr	r3, [r3]
 6790              		.loc 1 4770 46
 6791 002c FA68     		ldr	r2, [r7, #12]
 6792 002e 1632     		adds	r2, r2, #22
 6793 0030 53F82230 		ldr	r3, [r3, r2, lsl #2]
 6794              		.loc 1 4770 15
 6795 0034 002B     		cmp	r3, #0
 6796 0036 0FD1     		bne	.L413
4771:Lib/FreeRTOS/Source/tasks.c ****             {
4772:Lib/FreeRTOS/Source/tasks.c ****                 /* Mark this task as waiting for a notification. */
4773:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 6797              		.loc 1 4773 29
 6798 0038 224B     		ldr	r3, .L417+12
 6799 003a 1A68     		ldr	r2, [r3]
 6800              		.loc 1 4773 62
 6801 003c FB68     		ldr	r3, [r7, #12]
 6802 003e 1344     		add	r3, r3, r2
 6803 0040 5C33     		adds	r3, r3, #92
 6804 0042 0122     		movs	r2, #1
 6805 0044 1A70     		strb	r2, [r3]
4774:Lib/FreeRTOS/Source/tasks.c **** 
4775:Lib/FreeRTOS/Source/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
 6806              		.loc 1 4775 19
 6807 0046 7B68     		ldr	r3, [r7, #4]
 6808 0048 002B     		cmp	r3, #0
 6809 004a 05D0     		beq	.L413
4776:Lib/FreeRTOS/Source/tasks.c ****                 {
4777:Lib/FreeRTOS/Source/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 6810              		.loc 1 4777 21
 6811 004c 0121     		movs	r1, #1
 6812 004e 7868     		ldr	r0, [r7, #4]
 6813 0050 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4778:Lib/FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWait );
4779:Lib/FreeRTOS/Source/tasks.c **** 
4780:Lib/FreeRTOS/Source/tasks.c ****                     /* All ports are written to allow a yield in a critical
4781:Lib/FreeRTOS/Source/tasks.c ****                      * section (some will yield immediately, others wait until the
4782:Lib/FreeRTOS/Source/tasks.c ****                      * critical section exits) - but it is not something that
4783:Lib/FreeRTOS/Source/tasks.c ****                      * application code should ever do. */
4784:Lib/FreeRTOS/Source/tasks.c ****                     portYIELD_WITHIN_API();
 6814              		.loc 1 4784 21
 6815 0054 FFF7FEFF 		bl	vPortYield
 6816              	.L413:
4785:Lib/FreeRTOS/Source/tasks.c ****                 }
4786:Lib/FreeRTOS/Source/tasks.c ****                 else
4787:Lib/FreeRTOS/Source/tasks.c ****                 {
ARM GAS  /tmp/ccTFOe4z.s 			page 203


4788:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4789:Lib/FreeRTOS/Source/tasks.c ****                 }
4790:Lib/FreeRTOS/Source/tasks.c ****             }
4791:Lib/FreeRTOS/Source/tasks.c ****             else
4792:Lib/FreeRTOS/Source/tasks.c ****             {
4793:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4794:Lib/FreeRTOS/Source/tasks.c ****             }
4795:Lib/FreeRTOS/Source/tasks.c ****         }
4796:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 6817              		.loc 1 4796 9
 6818 0058 FFF7FEFF 		bl	vPortExitCritical
4797:Lib/FreeRTOS/Source/tasks.c **** 
4798:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 6819              		.loc 1 4798 9
 6820 005c FFF7FEFF 		bl	vPortEnterCritical
4799:Lib/FreeRTOS/Source/tasks.c ****         {
4800:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_TAKE( uxIndexToWait );
4801:Lib/FreeRTOS/Source/tasks.c ****             ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 6821              		.loc 1 4801 36
 6822 0060 184B     		ldr	r3, .L417+12
 6823 0062 1B68     		ldr	r3, [r3]
 6824              		.loc 1 4801 22
 6825 0064 FA68     		ldr	r2, [r7, #12]
 6826 0066 1632     		adds	r2, r2, #22
 6827 0068 53F82230 		ldr	r3, [r3, r2, lsl #2]
 6828 006c 7B61     		str	r3, [r7, #20]
4802:Lib/FreeRTOS/Source/tasks.c **** 
4803:Lib/FreeRTOS/Source/tasks.c ****             if( ulReturn != 0UL )
 6829              		.loc 1 4803 15
 6830 006e 7B69     		ldr	r3, [r7, #20]
 6831 0070 002B     		cmp	r3, #0
 6832 0072 12D0     		beq	.L414
4804:Lib/FreeRTOS/Source/tasks.c ****             {
4805:Lib/FreeRTOS/Source/tasks.c ****                 if( xClearCountOnExit != pdFALSE )
 6833              		.loc 1 4805 19
 6834 0074 BB68     		ldr	r3, [r7, #8]
 6835 0076 002B     		cmp	r3, #0
 6836 0078 07D0     		beq	.L415
4806:Lib/FreeRTOS/Source/tasks.c ****                 {
4807:Lib/FreeRTOS/Source/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
 6837              		.loc 1 4807 33
 6838 007a 124B     		ldr	r3, .L417+12
 6839 007c 1B68     		ldr	r3, [r3]
 6840              		.loc 1 4807 68
 6841 007e FA68     		ldr	r2, [r7, #12]
 6842 0080 1632     		adds	r2, r2, #22
 6843 0082 0021     		movs	r1, #0
 6844 0084 43F82210 		str	r1, [r3, r2, lsl #2]
 6845 0088 07E0     		b	.L414
 6846              	.L415:
4808:Lib/FreeRTOS/Source/tasks.c ****                 }
4809:Lib/FreeRTOS/Source/tasks.c ****                 else
4810:Lib/FreeRTOS/Source/tasks.c ****                 {
4811:Lib/FreeRTOS/Source/tasks.c ****                     pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
 6847              		.loc 1 4811 33
 6848 008a 0E4B     		ldr	r3, .L417+12
 6849 008c 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 204


 6850              		.loc 1 4811 79
 6851 008e 7A69     		ldr	r2, [r7, #20]
 6852 0090 511E     		subs	r1, r2, #1
 6853              		.loc 1 4811 68
 6854 0092 FA68     		ldr	r2, [r7, #12]
 6855 0094 1632     		adds	r2, r2, #22
 6856 0096 43F82210 		str	r1, [r3, r2, lsl #2]
 6857              	.L414:
4812:Lib/FreeRTOS/Source/tasks.c ****                 }
4813:Lib/FreeRTOS/Source/tasks.c ****             }
4814:Lib/FreeRTOS/Source/tasks.c ****             else
4815:Lib/FreeRTOS/Source/tasks.c ****             {
4816:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4817:Lib/FreeRTOS/Source/tasks.c ****             }
4818:Lib/FreeRTOS/Source/tasks.c **** 
4819:Lib/FreeRTOS/Source/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 6858              		.loc 1 4819 25
 6859 009a 0A4B     		ldr	r3, .L417+12
 6860 009c 1A68     		ldr	r2, [r3]
 6861              		.loc 1 4819 58
 6862 009e FB68     		ldr	r3, [r7, #12]
 6863 00a0 1344     		add	r3, r3, r2
 6864 00a2 5C33     		adds	r3, r3, #92
 6865 00a4 0022     		movs	r2, #0
 6866 00a6 1A70     		strb	r2, [r3]
4820:Lib/FreeRTOS/Source/tasks.c ****         }
4821:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 6867              		.loc 1 4821 9
 6868 00a8 FFF7FEFF 		bl	vPortExitCritical
4822:Lib/FreeRTOS/Source/tasks.c **** 
4823:Lib/FreeRTOS/Source/tasks.c ****         return ulReturn;
 6869              		.loc 1 4823 16
 6870 00ac 7B69     		ldr	r3, [r7, #20]
4824:Lib/FreeRTOS/Source/tasks.c ****     }
 6871              		.loc 1 4824 5
 6872 00ae 1846     		mov	r0, r3
 6873 00b0 1837     		adds	r7, r7, #24
 6874              		.cfi_def_cfa_offset 8
 6875 00b2 BD46     		mov	sp, r7
 6876              		.cfi_def_cfa_register 13
 6877              		@ sp needed
 6878 00b4 80BD     		pop	{r7, pc}
 6879              	.L418:
 6880 00b6 00BF     		.align	2
 6881              	.L417:
 6882 00b8 00000000 		.word	.LC0
 6883 00bc 00000000 		.word	__func__.6
 6884 00c0 04000000 		.word	.LC1
 6885 00c4 00000000 		.word	pxCurrentTCB
 6886              		.cfi_endproc
 6887              	.LFE55:
 6889              		.section	.text.xTaskGenericNotifyWait,"ax",%progbits
 6890              		.align	1
 6891              		.global	xTaskGenericNotifyWait
 6892              		.syntax unified
 6893              		.thumb
 6894              		.thumb_func
ARM GAS  /tmp/ccTFOe4z.s 			page 205


 6896              	xTaskGenericNotifyWait:
 6897              	.LFB56:
4825:Lib/FreeRTOS/Source/tasks.c **** 
4826:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4827:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4828:Lib/FreeRTOS/Source/tasks.c **** 
4829:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4830:Lib/FreeRTOS/Source/tasks.c **** 
4831:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
4832:Lib/FreeRTOS/Source/tasks.c ****                                        uint32_t ulBitsToClearOnEntry,
4833:Lib/FreeRTOS/Source/tasks.c ****                                        uint32_t ulBitsToClearOnExit,
4834:Lib/FreeRTOS/Source/tasks.c ****                                        uint32_t * pulNotificationValue,
4835:Lib/FreeRTOS/Source/tasks.c ****                                        TickType_t xTicksToWait )
4836:Lib/FreeRTOS/Source/tasks.c ****     {
 6898              		.loc 1 4836 5
 6899              		.cfi_startproc
 6900              		@ args = 4, pretend = 0, frame = 24
 6901              		@ frame_needed = 1, uses_anonymous_args = 0
 6902 0000 80B5     		push	{r7, lr}
 6903              		.cfi_def_cfa_offset 8
 6904              		.cfi_offset 7, -8
 6905              		.cfi_offset 14, -4
 6906 0002 86B0     		sub	sp, sp, #24
 6907              		.cfi_def_cfa_offset 32
 6908 0004 00AF     		add	r7, sp, #0
 6909              		.cfi_def_cfa_register 7
 6910 0006 F860     		str	r0, [r7, #12]
 6911 0008 B960     		str	r1, [r7, #8]
 6912 000a 7A60     		str	r2, [r7, #4]
 6913 000c 3B60     		str	r3, [r7]
4837:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
4838:Lib/FreeRTOS/Source/tasks.c **** 
4839:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 6914              		.loc 1 4839 9
 6915 000e FB68     		ldr	r3, [r7, #12]
 6916 0010 002B     		cmp	r3, #0
 6917 0012 08D0     		beq	.L420
 6918              		.loc 1 4839 9 is_stmt 0 discriminator 1
 6919 0014 FFF7FEFF 		bl	ulSetInterruptMask
 6920 0018 334B     		ldr	r3, .L426
 6921 001a 344A     		ldr	r2, .L426+4
 6922 001c 41F2E721 		movw	r1, #4839
 6923 0020 3348     		ldr	r0, .L426+8
 6924 0022 FFF7FEFF 		bl	__assert_func
 6925              	.L420:
4840:Lib/FreeRTOS/Source/tasks.c **** 
4841:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 6926              		.loc 1 4841 9 is_stmt 1
 6927 0026 FFF7FEFF 		bl	vPortEnterCritical
4842:Lib/FreeRTOS/Source/tasks.c ****         {
4843:Lib/FreeRTOS/Source/tasks.c ****             /* Only block if a notification is not already pending. */
4844:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 6928              		.loc 1 4844 29
 6929 002a 324B     		ldr	r3, .L426+12
 6930 002c 1A68     		ldr	r2, [r3]
 6931              		.loc 1 4844 44
 6932 002e FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 206


 6933 0030 1344     		add	r3, r3, r2
 6934 0032 5C33     		adds	r3, r3, #92
 6935 0034 1B78     		ldrb	r3, [r3]
 6936 0036 DBB2     		uxtb	r3, r3
 6937              		.loc 1 4844 15
 6938 0038 022B     		cmp	r3, #2
 6939 003a 1CD0     		beq	.L421
4845:Lib/FreeRTOS/Source/tasks.c ****             {
4846:Lib/FreeRTOS/Source/tasks.c ****                 /* Clear bits in the task's notification value as bits may get
4847:Lib/FreeRTOS/Source/tasks.c ****                  * set  by the notifying task or interrupt.  This can be used to
4848:Lib/FreeRTOS/Source/tasks.c ****                  * clear the value to zero. */
4849:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
 6940              		.loc 1 4849 29
 6941 003c 2D4B     		ldr	r3, .L426+12
 6942 003e 1B68     		ldr	r3, [r3]
 6943              		.loc 1 4849 46
 6944 0040 FA68     		ldr	r2, [r7, #12]
 6945 0042 1632     		adds	r2, r2, #22
 6946 0044 53F82210 		ldr	r1, [r3, r2, lsl #2]
 6947              		.loc 1 4849 67
 6948 0048 BA68     		ldr	r2, [r7, #8]
 6949 004a D243     		mvns	r2, r2
 6950              		.loc 1 4849 64
 6951 004c 1140     		ands	r1, r1, r2
 6952 004e FA68     		ldr	r2, [r7, #12]
 6953 0050 1632     		adds	r2, r2, #22
 6954 0052 43F82210 		str	r1, [r3, r2, lsl #2]
4850:Lib/FreeRTOS/Source/tasks.c **** 
4851:Lib/FreeRTOS/Source/tasks.c ****                 /* Mark this task as waiting for a notification. */
4852:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
 6955              		.loc 1 4852 29
 6956 0056 274B     		ldr	r3, .L426+12
 6957 0058 1A68     		ldr	r2, [r3]
 6958              		.loc 1 4852 62
 6959 005a FB68     		ldr	r3, [r7, #12]
 6960 005c 1344     		add	r3, r3, r2
 6961 005e 5C33     		adds	r3, r3, #92
 6962 0060 0122     		movs	r2, #1
 6963 0062 1A70     		strb	r2, [r3]
4853:Lib/FreeRTOS/Source/tasks.c **** 
4854:Lib/FreeRTOS/Source/tasks.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
 6964              		.loc 1 4854 19
 6965 0064 3B6A     		ldr	r3, [r7, #32]
 6966 0066 002B     		cmp	r3, #0
 6967 0068 05D0     		beq	.L421
4855:Lib/FreeRTOS/Source/tasks.c ****                 {
4856:Lib/FreeRTOS/Source/tasks.c ****                     prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 6968              		.loc 1 4856 21
 6969 006a 0121     		movs	r1, #1
 6970 006c 386A     		ldr	r0, [r7, #32]
 6971 006e FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
4857:Lib/FreeRTOS/Source/tasks.c ****                     traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWait );
4858:Lib/FreeRTOS/Source/tasks.c **** 
4859:Lib/FreeRTOS/Source/tasks.c ****                     /* All ports are written to allow a yield in a critical
4860:Lib/FreeRTOS/Source/tasks.c ****                      * section (some will yield immediately, others wait until the
4861:Lib/FreeRTOS/Source/tasks.c ****                      * critical section exits) - but it is not something that
4862:Lib/FreeRTOS/Source/tasks.c ****                      * application code should ever do. */
ARM GAS  /tmp/ccTFOe4z.s 			page 207


4863:Lib/FreeRTOS/Source/tasks.c ****                     portYIELD_WITHIN_API();
 6972              		.loc 1 4863 21
 6973 0072 FFF7FEFF 		bl	vPortYield
 6974              	.L421:
4864:Lib/FreeRTOS/Source/tasks.c ****                 }
4865:Lib/FreeRTOS/Source/tasks.c ****                 else
4866:Lib/FreeRTOS/Source/tasks.c ****                 {
4867:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
4868:Lib/FreeRTOS/Source/tasks.c ****                 }
4869:Lib/FreeRTOS/Source/tasks.c ****             }
4870:Lib/FreeRTOS/Source/tasks.c ****             else
4871:Lib/FreeRTOS/Source/tasks.c ****             {
4872:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
4873:Lib/FreeRTOS/Source/tasks.c ****             }
4874:Lib/FreeRTOS/Source/tasks.c ****         }
4875:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 6975              		.loc 1 4875 9
 6976 0076 FFF7FEFF 		bl	vPortExitCritical
4876:Lib/FreeRTOS/Source/tasks.c **** 
4877:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 6977              		.loc 1 4877 9
 6978 007a FFF7FEFF 		bl	vPortEnterCritical
4878:Lib/FreeRTOS/Source/tasks.c ****         {
4879:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_WAIT( uxIndexToWait );
4880:Lib/FreeRTOS/Source/tasks.c **** 
4881:Lib/FreeRTOS/Source/tasks.c ****             if( pulNotificationValue != NULL )
 6979              		.loc 1 4881 15
 6980 007e 3B68     		ldr	r3, [r7]
 6981 0080 002B     		cmp	r3, #0
 6982 0082 07D0     		beq	.L422
4882:Lib/FreeRTOS/Source/tasks.c ****             {
4883:Lib/FreeRTOS/Source/tasks.c ****                 /* Output the current notification value, which may or may not
4884:Lib/FreeRTOS/Source/tasks.c ****                  * have changed. */
4885:Lib/FreeRTOS/Source/tasks.c ****                 *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
 6983              		.loc 1 4885 53
 6984 0084 1B4B     		ldr	r3, .L426+12
 6985 0086 1B68     		ldr	r3, [r3]
 6986              		.loc 1 4885 70
 6987 0088 FA68     		ldr	r2, [r7, #12]
 6988 008a 1632     		adds	r2, r2, #22
 6989 008c 53F82220 		ldr	r2, [r3, r2, lsl #2]
 6990              		.loc 1 4885 39
 6991 0090 3B68     		ldr	r3, [r7]
 6992 0092 1A60     		str	r2, [r3]
 6993              	.L422:
4886:Lib/FreeRTOS/Source/tasks.c ****             }
4887:Lib/FreeRTOS/Source/tasks.c **** 
4888:Lib/FreeRTOS/Source/tasks.c ****             /* If ucNotifyValue is set then either the task never entered the
4889:Lib/FreeRTOS/Source/tasks.c ****              * blocked state (because a notification was already pending) or the
4890:Lib/FreeRTOS/Source/tasks.c ****              * task unblocked because of a notification.  Otherwise the task
4891:Lib/FreeRTOS/Source/tasks.c ****              * unblocked because of a timeout. */
4892:Lib/FreeRTOS/Source/tasks.c ****             if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
 6994              		.loc 1 4892 29
 6995 0094 174B     		ldr	r3, .L426+12
 6996 0096 1A68     		ldr	r2, [r3]
 6997              		.loc 1 4892 44
 6998 0098 FB68     		ldr	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 208


 6999 009a 1344     		add	r3, r3, r2
 7000 009c 5C33     		adds	r3, r3, #92
 7001 009e 1B78     		ldrb	r3, [r3]
 7002 00a0 DBB2     		uxtb	r3, r3
 7003              		.loc 1 4892 15
 7004 00a2 022B     		cmp	r3, #2
 7005 00a4 02D0     		beq	.L423
4893:Lib/FreeRTOS/Source/tasks.c ****             {
4894:Lib/FreeRTOS/Source/tasks.c ****                 /* A notification was not received. */
4895:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdFALSE;
 7006              		.loc 1 4895 25
 7007 00a6 0023     		movs	r3, #0
 7008 00a8 7B61     		str	r3, [r7, #20]
 7009 00aa 0EE0     		b	.L424
 7010              	.L423:
4896:Lib/FreeRTOS/Source/tasks.c ****             }
4897:Lib/FreeRTOS/Source/tasks.c ****             else
4898:Lib/FreeRTOS/Source/tasks.c ****             {
4899:Lib/FreeRTOS/Source/tasks.c ****                 /* A notification was already pending or a notification was
4900:Lib/FreeRTOS/Source/tasks.c ****                  * received while the task was waiting. */
4901:Lib/FreeRTOS/Source/tasks.c ****                 pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
 7011              		.loc 1 4901 29
 7012 00ac 114B     		ldr	r3, .L426+12
 7013 00ae 1B68     		ldr	r3, [r3]
 7014              		.loc 1 4901 46
 7015 00b0 FA68     		ldr	r2, [r7, #12]
 7016 00b2 1632     		adds	r2, r2, #22
 7017 00b4 53F82210 		ldr	r1, [r3, r2, lsl #2]
 7018              		.loc 1 4901 67
 7019 00b8 7A68     		ldr	r2, [r7, #4]
 7020 00ba D243     		mvns	r2, r2
 7021              		.loc 1 4901 64
 7022 00bc 1140     		ands	r1, r1, r2
 7023 00be FA68     		ldr	r2, [r7, #12]
 7024 00c0 1632     		adds	r2, r2, #22
 7025 00c2 43F82210 		str	r1, [r3, r2, lsl #2]
4902:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdTRUE;
 7026              		.loc 1 4902 25
 7027 00c6 0123     		movs	r3, #1
 7028 00c8 7B61     		str	r3, [r7, #20]
 7029              	.L424:
4903:Lib/FreeRTOS/Source/tasks.c ****             }
4904:Lib/FreeRTOS/Source/tasks.c **** 
4905:Lib/FreeRTOS/Source/tasks.c ****             pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
 7030              		.loc 1 4905 25
 7031 00ca 0A4B     		ldr	r3, .L426+12
 7032 00cc 1A68     		ldr	r2, [r3]
 7033              		.loc 1 4905 58
 7034 00ce FB68     		ldr	r3, [r7, #12]
 7035 00d0 1344     		add	r3, r3, r2
 7036 00d2 5C33     		adds	r3, r3, #92
 7037 00d4 0022     		movs	r2, #0
 7038 00d6 1A70     		strb	r2, [r3]
4906:Lib/FreeRTOS/Source/tasks.c ****         }
4907:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 7039              		.loc 1 4907 9
 7040 00d8 FFF7FEFF 		bl	vPortExitCritical
ARM GAS  /tmp/ccTFOe4z.s 			page 209


4908:Lib/FreeRTOS/Source/tasks.c **** 
4909:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 7041              		.loc 1 4909 16
 7042 00dc 7B69     		ldr	r3, [r7, #20]
4910:Lib/FreeRTOS/Source/tasks.c ****     }
 7043              		.loc 1 4910 5
 7044 00de 1846     		mov	r0, r3
 7045 00e0 1837     		adds	r7, r7, #24
 7046              		.cfi_def_cfa_offset 8
 7047 00e2 BD46     		mov	sp, r7
 7048              		.cfi_def_cfa_register 13
 7049              		@ sp needed
 7050 00e4 80BD     		pop	{r7, pc}
 7051              	.L427:
 7052 00e6 00BF     		.align	2
 7053              	.L426:
 7054 00e8 00000000 		.word	.LC0
 7055 00ec 00000000 		.word	__func__.5
 7056 00f0 04000000 		.word	.LC1
 7057 00f4 00000000 		.word	pxCurrentTCB
 7058              		.cfi_endproc
 7059              	.LFE56:
 7061              		.section	.text.xTaskGenericNotify,"ax",%progbits
 7062              		.align	1
 7063              		.global	xTaskGenericNotify
 7064              		.syntax unified
 7065              		.thumb
 7066              		.thumb_func
 7068              	xTaskGenericNotify:
 7069              	.LFB57:
4911:Lib/FreeRTOS/Source/tasks.c **** 
4912:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
4913:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
4914:Lib/FreeRTOS/Source/tasks.c **** 
4915:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
4916:Lib/FreeRTOS/Source/tasks.c **** 
4917:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
4918:Lib/FreeRTOS/Source/tasks.c ****                                    UBaseType_t uxIndexToNotify,
4919:Lib/FreeRTOS/Source/tasks.c ****                                    uint32_t ulValue,
4920:Lib/FreeRTOS/Source/tasks.c ****                                    eNotifyAction eAction,
4921:Lib/FreeRTOS/Source/tasks.c ****                                    uint32_t * pulPreviousNotificationValue )
4922:Lib/FreeRTOS/Source/tasks.c ****     {
 7070              		.loc 1 4922 5
 7071              		.cfi_startproc
 7072              		@ args = 4, pretend = 0, frame = 40
 7073              		@ frame_needed = 1, uses_anonymous_args = 0
 7074 0000 80B5     		push	{r7, lr}
 7075              		.cfi_def_cfa_offset 8
 7076              		.cfi_offset 7, -8
 7077              		.cfi_offset 14, -4
 7078 0002 8AB0     		sub	sp, sp, #40
 7079              		.cfi_def_cfa_offset 48
 7080 0004 00AF     		add	r7, sp, #0
 7081              		.cfi_def_cfa_register 7
 7082 0006 F860     		str	r0, [r7, #12]
 7083 0008 B960     		str	r1, [r7, #8]
 7084 000a 7A60     		str	r2, [r7, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 210


 7085 000c FB70     		strb	r3, [r7, #3]
4923:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
4924:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdPASS;
 7086              		.loc 1 4924 20
 7087 000e 0123     		movs	r3, #1
 7088 0010 7B62     		str	r3, [r7, #36]
4925:Lib/FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
4926:Lib/FreeRTOS/Source/tasks.c **** 
4927:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 7089              		.loc 1 4927 9
 7090 0012 BB68     		ldr	r3, [r7, #8]
 7091 0014 002B     		cmp	r3, #0
 7092 0016 08D0     		beq	.L429
 7093              		.loc 1 4927 9 is_stmt 0 discriminator 1
 7094 0018 FFF7FEFF 		bl	ulSetInterruptMask
 7095 001c 7D4B     		ldr	r3, .L450
 7096 001e 7E4A     		ldr	r2, .L450+4
 7097 0020 41F23F31 		movw	r1, #4927
 7098 0024 7D48     		ldr	r0, .L450+8
 7099 0026 FFF7FEFF 		bl	__assert_func
 7100              	.L429:
4928:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
 7101              		.loc 1 4928 9 is_stmt 1
 7102 002a FB68     		ldr	r3, [r7, #12]
 7103 002c 002B     		cmp	r3, #0
 7104 002e 08D1     		bne	.L430
 7105              		.loc 1 4928 9 is_stmt 0 discriminator 1
 7106 0030 FFF7FEFF 		bl	ulSetInterruptMask
 7107 0034 774B     		ldr	r3, .L450
 7108 0036 784A     		ldr	r2, .L450+4
 7109 0038 4FF49A51 		mov	r1, #4928
 7110 003c 7748     		ldr	r0, .L450+8
 7111 003e FFF7FEFF 		bl	__assert_func
 7112              	.L430:
4929:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
 7113              		.loc 1 4929 15 is_stmt 1
 7114 0042 FB68     		ldr	r3, [r7, #12]
 7115 0044 3B62     		str	r3, [r7, #32]
4930:Lib/FreeRTOS/Source/tasks.c **** 
4931:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 7116              		.loc 1 4931 9
 7117 0046 FFF7FEFF 		bl	vPortEnterCritical
4932:Lib/FreeRTOS/Source/tasks.c ****         {
4933:Lib/FreeRTOS/Source/tasks.c ****             if( pulPreviousNotificationValue != NULL )
 7118              		.loc 1 4933 15
 7119 004a 3B6B     		ldr	r3, [r7, #48]
 7120 004c 002B     		cmp	r3, #0
 7121 004e 06D0     		beq	.L431
4934:Lib/FreeRTOS/Source/tasks.c ****             {
4935:Lib/FreeRTOS/Source/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 7122              		.loc 1 4935 71
 7123 0050 3B6A     		ldr	r3, [r7, #32]
 7124 0052 BA68     		ldr	r2, [r7, #8]
 7125 0054 1632     		adds	r2, r2, #22
 7126 0056 53F82220 		ldr	r2, [r3, r2, lsl #2]
 7127              		.loc 1 4935 47
 7128 005a 3B6B     		ldr	r3, [r7, #48]
ARM GAS  /tmp/ccTFOe4z.s 			page 211


 7129 005c 1A60     		str	r2, [r3]
 7130              	.L431:
4936:Lib/FreeRTOS/Source/tasks.c ****             }
4937:Lib/FreeRTOS/Source/tasks.c **** 
4938:Lib/FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 7131              		.loc 1 4938 35
 7132 005e 3A6A     		ldr	r2, [r7, #32]
 7133 0060 BB68     		ldr	r3, [r7, #8]
 7134 0062 1344     		add	r3, r3, r2
 7135 0064 5C33     		adds	r3, r3, #92
 7136 0066 1B78     		ldrb	r3, [r3]
 7137 0068 FB77     		strb	r3, [r7, #31]
4939:Lib/FreeRTOS/Source/tasks.c **** 
4940:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 7138              		.loc 1 4940 53
 7139 006a 3A6A     		ldr	r2, [r7, #32]
 7140 006c BB68     		ldr	r3, [r7, #8]
 7141 006e 1344     		add	r3, r3, r2
 7142 0070 5C33     		adds	r3, r3, #92
 7143 0072 0222     		movs	r2, #2
 7144 0074 1A70     		strb	r2, [r3]
4941:Lib/FreeRTOS/Source/tasks.c **** 
4942:Lib/FreeRTOS/Source/tasks.c ****             switch( eAction )
 7145              		.loc 1 4942 13
 7146 0076 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 7147 0078 042B     		cmp	r3, #4
 7148 007a 3BD8     		bhi	.L432
 7149 007c 01A2     		adr	r2, .L434
 7150 007e 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 7151 0082 00BF     		.p2align 2
 7152              	.L434:
 7153 0084 0F010000 		.word	.L448+1
 7154 0088 99000000 		.word	.L437+1
 7155 008c B5000000 		.word	.L436+1
 7156 0090 CD000000 		.word	.L435+1
 7157 0094 DB000000 		.word	.L433+1
 7158              		.p2align 1
 7159              	.L437:
4943:Lib/FreeRTOS/Source/tasks.c ****             {
4944:Lib/FreeRTOS/Source/tasks.c ****                 case eSetBits:
4945:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 7160              		.loc 1 4945 43
 7161 0098 3B6A     		ldr	r3, [r7, #32]
 7162 009a BA68     		ldr	r2, [r7, #8]
 7163 009c 1632     		adds	r2, r2, #22
 7164 009e 53F82220 		ldr	r2, [r3, r2, lsl #2]
 7165              		.loc 1 4945 63
 7166 00a2 7B68     		ldr	r3, [r7, #4]
 7167 00a4 42EA0301 		orr	r1, r2, r3
 7168 00a8 3B6A     		ldr	r3, [r7, #32]
 7169 00aa BA68     		ldr	r2, [r7, #8]
 7170 00ac 1632     		adds	r2, r2, #22
 7171 00ae 43F82210 		str	r1, [r3, r2, lsl #2]
4946:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7172              		.loc 1 4946 21
 7173 00b2 2FE0     		b	.L439
 7174              	.L436:
ARM GAS  /tmp/ccTFOe4z.s 			page 212


4947:Lib/FreeRTOS/Source/tasks.c **** 
4948:Lib/FreeRTOS/Source/tasks.c ****                 case eIncrement:
4949:Lib/FreeRTOS/Source/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 7175              		.loc 1 4949 45
 7176 00b4 3B6A     		ldr	r3, [r7, #32]
 7177 00b6 BA68     		ldr	r2, [r7, #8]
 7178 00b8 1632     		adds	r2, r2, #22
 7179 00ba 53F82230 		ldr	r3, [r3, r2, lsl #2]
 7180              		.loc 1 4949 66
 7181 00be 591C     		adds	r1, r3, #1
 7182 00c0 3B6A     		ldr	r3, [r7, #32]
 7183 00c2 BA68     		ldr	r2, [r7, #8]
 7184 00c4 1632     		adds	r2, r2, #22
 7185 00c6 43F82210 		str	r1, [r3, r2, lsl #2]
4950:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7186              		.loc 1 4950 21
 7187 00ca 23E0     		b	.L439
 7188              	.L435:
4951:Lib/FreeRTOS/Source/tasks.c **** 
4952:Lib/FreeRTOS/Source/tasks.c ****                 case eSetValueWithOverwrite:
4953:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 7189              		.loc 1 4953 63
 7190 00cc 3B6A     		ldr	r3, [r7, #32]
 7191 00ce BA68     		ldr	r2, [r7, #8]
 7192 00d0 1632     		adds	r2, r2, #22
 7193 00d2 7968     		ldr	r1, [r7, #4]
 7194 00d4 43F82210 		str	r1, [r3, r2, lsl #2]
4954:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7195              		.loc 1 4954 21
 7196 00d8 1CE0     		b	.L439
 7197              	.L433:
4955:Lib/FreeRTOS/Source/tasks.c **** 
4956:Lib/FreeRTOS/Source/tasks.c ****                 case eSetValueWithoutOverwrite:
4957:Lib/FreeRTOS/Source/tasks.c **** 
4958:Lib/FreeRTOS/Source/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 7198              		.loc 1 4958 23
 7199 00da FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 7200 00dc 022B     		cmp	r3, #2
 7201 00de 06D0     		beq	.L440
4959:Lib/FreeRTOS/Source/tasks.c ****                     {
4960:Lib/FreeRTOS/Source/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 7202              		.loc 1 4960 67
 7203 00e0 3B6A     		ldr	r3, [r7, #32]
 7204 00e2 BA68     		ldr	r2, [r7, #8]
 7205 00e4 1632     		adds	r2, r2, #22
 7206 00e6 7968     		ldr	r1, [r7, #4]
 7207 00e8 43F82210 		str	r1, [r3, r2, lsl #2]
4961:Lib/FreeRTOS/Source/tasks.c ****                     }
4962:Lib/FreeRTOS/Source/tasks.c ****                     else
4963:Lib/FreeRTOS/Source/tasks.c ****                     {
4964:Lib/FreeRTOS/Source/tasks.c ****                         /* The value could not be written to the task. */
4965:Lib/FreeRTOS/Source/tasks.c ****                         xReturn = pdFAIL;
4966:Lib/FreeRTOS/Source/tasks.c ****                     }
4967:Lib/FreeRTOS/Source/tasks.c **** 
4968:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7208              		.loc 1 4968 21
 7209 00ec 12E0     		b	.L439
ARM GAS  /tmp/ccTFOe4z.s 			page 213


 7210              	.L440:
4965:Lib/FreeRTOS/Source/tasks.c ****                     }
 7211              		.loc 1 4965 33
 7212 00ee 0023     		movs	r3, #0
 7213 00f0 7B62     		str	r3, [r7, #36]
 7214              		.loc 1 4968 21
 7215 00f2 0FE0     		b	.L439
 7216              	.L432:
4969:Lib/FreeRTOS/Source/tasks.c **** 
4970:Lib/FreeRTOS/Source/tasks.c ****                 case eNoAction:
4971:Lib/FreeRTOS/Source/tasks.c **** 
4972:Lib/FreeRTOS/Source/tasks.c ****                     /* The task is being notified without its notify value being
4973:Lib/FreeRTOS/Source/tasks.c ****                      * updated. */
4974:Lib/FreeRTOS/Source/tasks.c ****                     break;
4975:Lib/FreeRTOS/Source/tasks.c **** 
4976:Lib/FreeRTOS/Source/tasks.c ****                 default:
4977:Lib/FreeRTOS/Source/tasks.c **** 
4978:Lib/FreeRTOS/Source/tasks.c ****                     /* Should not get here if all enums are handled.
4979:Lib/FreeRTOS/Source/tasks.c ****                      * Artificially force an assert by testing a value the
4980:Lib/FreeRTOS/Source/tasks.c ****                      * compiler can't assume is const. */
4981:Lib/FreeRTOS/Source/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
 7217              		.loc 1 4981 21
 7218 00f4 4A4B     		ldr	r3, .L450+12
 7219 00f6 1B68     		ldr	r3, [r3]
 7220 00f8 002B     		cmp	r3, #0
 7221 00fa 0AD0     		beq	.L449
 7222              		.loc 1 4981 21 is_stmt 0 discriminator 1
 7223 00fc FFF7FEFF 		bl	ulSetInterruptMask
 7224 0100 444B     		ldr	r3, .L450
 7225 0102 454A     		ldr	r2, .L450+4
 7226 0104 41F27531 		movw	r1, #4981
 7227 0108 4448     		ldr	r0, .L450+8
 7228 010a FFF7FEFF 		bl	__assert_func
 7229              	.L448:
4974:Lib/FreeRTOS/Source/tasks.c **** 
 7230              		.loc 1 4974 21 is_stmt 1
 7231 010e 00BF     		nop
 7232 0110 00E0     		b	.L439
 7233              	.L449:
4982:Lib/FreeRTOS/Source/tasks.c **** 
4983:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7234              		.loc 1 4983 21
 7235 0112 00BF     		nop
 7236              	.L439:
4984:Lib/FreeRTOS/Source/tasks.c ****             }
4985:Lib/FreeRTOS/Source/tasks.c **** 
4986:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY( uxIndexToNotify );
4987:Lib/FreeRTOS/Source/tasks.c **** 
4988:Lib/FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
4989:Lib/FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
4990:Lib/FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 7237              		.loc 1 4990 15
 7238 0114 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 7239 0116 012B     		cmp	r3, #1
 7240 0118 74D1     		bne	.L443
 7241              	.LBB38:
4991:Lib/FreeRTOS/Source/tasks.c ****             {
ARM GAS  /tmp/ccTFOe4z.s 			page 214


4992:Lib/FreeRTOS/Source/tasks.c ****                 listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 7242              		.loc 1 4992 17
 7243 011a 3B6A     		ldr	r3, [r7, #32]
 7244 011c 5B69     		ldr	r3, [r3, #20]
 7245 011e BB61     		str	r3, [r7, #24]
 7246 0120 3B6A     		ldr	r3, [r7, #32]
 7247 0122 9B68     		ldr	r3, [r3, #8]
 7248 0124 3A6A     		ldr	r2, [r7, #32]
 7249 0126 D268     		ldr	r2, [r2, #12]
 7250 0128 9A60     		str	r2, [r3, #8]
 7251 012a 3B6A     		ldr	r3, [r7, #32]
 7252 012c DB68     		ldr	r3, [r3, #12]
 7253 012e 3A6A     		ldr	r2, [r7, #32]
 7254 0130 9268     		ldr	r2, [r2, #8]
 7255 0132 5A60     		str	r2, [r3, #4]
 7256 0134 BB69     		ldr	r3, [r7, #24]
 7257 0136 5A68     		ldr	r2, [r3, #4]
 7258 0138 3B6A     		ldr	r3, [r7, #32]
 7259 013a 0433     		adds	r3, r3, #4
 7260 013c 9A42     		cmp	r2, r3
 7261 013e 03D1     		bne	.L444
 7262              		.loc 1 4992 17 is_stmt 0 discriminator 1
 7263 0140 3B6A     		ldr	r3, [r7, #32]
 7264 0142 DA68     		ldr	r2, [r3, #12]
 7265 0144 BB69     		ldr	r3, [r7, #24]
 7266 0146 5A60     		str	r2, [r3, #4]
 7267              	.L444:
 7268              		.loc 1 4992 17 discriminator 3
 7269 0148 3B6A     		ldr	r3, [r7, #32]
 7270 014a 0022     		movs	r2, #0
 7271 014c 5A61     		str	r2, [r3, #20]
 7272 014e BB69     		ldr	r3, [r7, #24]
 7273 0150 1B68     		ldr	r3, [r3]
 7274 0152 5A1E     		subs	r2, r3, #1
 7275 0154 BB69     		ldr	r3, [r7, #24]
 7276 0156 1A60     		str	r2, [r3]
 7277              	.LBE38:
4993:Lib/FreeRTOS/Source/tasks.c ****                 prvAddTaskToReadyList( pxTCB );
 7278              		.loc 1 4993 17 is_stmt 1
 7279 0158 3B6A     		ldr	r3, [r7, #32]
 7280 015a DA6A     		ldr	r2, [r3, #44]
 7281 015c 314B     		ldr	r3, .L450+16
 7282 015e 1B68     		ldr	r3, [r3]
 7283 0160 9A42     		cmp	r2, r3
 7284 0162 03D9     		bls	.L445
 7285              		.loc 1 4993 17 is_stmt 0 discriminator 1
 7286 0164 3B6A     		ldr	r3, [r7, #32]
 7287 0166 DB6A     		ldr	r3, [r3, #44]
 7288 0168 2E4A     		ldr	r2, .L450+16
 7289 016a 1360     		str	r3, [r2]
 7290              	.L445:
 7291              	.LBB39:
 7292              		.loc 1 4993 17 discriminator 3
 7293 016c 3B6A     		ldr	r3, [r7, #32]
 7294 016e DA6A     		ldr	r2, [r3, #44]
 7295 0170 2D49     		ldr	r1, .L450+20
 7296 0172 1346     		mov	r3, r2
ARM GAS  /tmp/ccTFOe4z.s 			page 215


 7297 0174 9B00     		lsls	r3, r3, #2
 7298 0176 1344     		add	r3, r3, r2
 7299 0178 9B00     		lsls	r3, r3, #2
 7300 017a 0B44     		add	r3, r3, r1
 7301 017c 0433     		adds	r3, r3, #4
 7302 017e 1B68     		ldr	r3, [r3]
 7303 0180 7B61     		str	r3, [r7, #20]
 7304 0182 3B6A     		ldr	r3, [r7, #32]
 7305 0184 7A69     		ldr	r2, [r7, #20]
 7306 0186 9A60     		str	r2, [r3, #8]
 7307 0188 7B69     		ldr	r3, [r7, #20]
 7308 018a 9A68     		ldr	r2, [r3, #8]
 7309 018c 3B6A     		ldr	r3, [r7, #32]
 7310 018e DA60     		str	r2, [r3, #12]
 7311 0190 7B69     		ldr	r3, [r7, #20]
 7312 0192 9B68     		ldr	r3, [r3, #8]
 7313 0194 3A6A     		ldr	r2, [r7, #32]
 7314 0196 0432     		adds	r2, r2, #4
 7315 0198 5A60     		str	r2, [r3, #4]
 7316 019a 3B6A     		ldr	r3, [r7, #32]
 7317 019c 1A1D     		adds	r2, r3, #4
 7318 019e 7B69     		ldr	r3, [r7, #20]
 7319 01a0 9A60     		str	r2, [r3, #8]
 7320 01a2 3B6A     		ldr	r3, [r7, #32]
 7321 01a4 DA6A     		ldr	r2, [r3, #44]
 7322 01a6 1346     		mov	r3, r2
 7323 01a8 9B00     		lsls	r3, r3, #2
 7324 01aa 1344     		add	r3, r3, r2
 7325 01ac 9B00     		lsls	r3, r3, #2
 7326 01ae 1E4A     		ldr	r2, .L450+20
 7327 01b0 1A44     		add	r2, r2, r3
 7328 01b2 3B6A     		ldr	r3, [r7, #32]
 7329 01b4 5A61     		str	r2, [r3, #20]
 7330 01b6 3B6A     		ldr	r3, [r7, #32]
 7331 01b8 DA6A     		ldr	r2, [r3, #44]
 7332 01ba 1B49     		ldr	r1, .L450+20
 7333 01bc 1346     		mov	r3, r2
 7334 01be 9B00     		lsls	r3, r3, #2
 7335 01c0 1344     		add	r3, r3, r2
 7336 01c2 9B00     		lsls	r3, r3, #2
 7337 01c4 0B44     		add	r3, r3, r1
 7338 01c6 1B68     		ldr	r3, [r3]
 7339 01c8 591C     		adds	r1, r3, #1
 7340 01ca 1748     		ldr	r0, .L450+20
 7341 01cc 1346     		mov	r3, r2
 7342 01ce 9B00     		lsls	r3, r3, #2
 7343 01d0 1344     		add	r3, r3, r2
 7344 01d2 9B00     		lsls	r3, r3, #2
 7345 01d4 0344     		add	r3, r3, r0
 7346 01d6 1960     		str	r1, [r3]
 7347              	.LBE39:
4994:Lib/FreeRTOS/Source/tasks.c **** 
4995:Lib/FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
4996:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 7348              		.loc 1 4996 17 is_stmt 1
 7349 01d8 3B6A     		ldr	r3, [r7, #32]
 7350 01da 9B6A     		ldr	r3, [r3, #40]
ARM GAS  /tmp/ccTFOe4z.s 			page 216


 7351 01dc 002B     		cmp	r3, #0
 7352 01de 08D0     		beq	.L446
 7353              		.loc 1 4996 17 is_stmt 0 discriminator 1
 7354 01e0 FFF7FEFF 		bl	ulSetInterruptMask
 7355 01e4 0B4B     		ldr	r3, .L450
 7356 01e6 0C4A     		ldr	r2, .L450+4
 7357 01e8 41F28431 		movw	r1, #4996
 7358 01ec 0B48     		ldr	r0, .L450+8
 7359 01ee FFF7FEFF 		bl	__assert_func
 7360              	.L446:
4997:Lib/FreeRTOS/Source/tasks.c **** 
4998:Lib/FreeRTOS/Source/tasks.c ****                 #if ( configUSE_TICKLESS_IDLE != 0 )
4999:Lib/FreeRTOS/Source/tasks.c ****                 {
5000:Lib/FreeRTOS/Source/tasks.c ****                     /* If a task is blocked waiting for a notification then
5001:Lib/FreeRTOS/Source/tasks.c ****                      * xNextTaskUnblockTime might be set to the blocked task's time
5002:Lib/FreeRTOS/Source/tasks.c ****                      * out time.  If the task is unblocked for a reason other than
5003:Lib/FreeRTOS/Source/tasks.c ****                      * a timeout xNextTaskUnblockTime is normally left unchanged,
5004:Lib/FreeRTOS/Source/tasks.c ****                      * because it will automatically get reset to a new value when
5005:Lib/FreeRTOS/Source/tasks.c ****                      * the tick count equals xNextTaskUnblockTime.  However if
5006:Lib/FreeRTOS/Source/tasks.c ****                      * tickless idling is used it might be more important to enter
5007:Lib/FreeRTOS/Source/tasks.c ****                      * sleep mode at the earliest possible time - so reset
5008:Lib/FreeRTOS/Source/tasks.c ****                      * xNextTaskUnblockTime here to ensure it is updated at the
5009:Lib/FreeRTOS/Source/tasks.c ****                      * earliest possible time. */
5010:Lib/FreeRTOS/Source/tasks.c ****                     prvResetNextTaskUnblockTime();
5011:Lib/FreeRTOS/Source/tasks.c ****                 }
5012:Lib/FreeRTOS/Source/tasks.c ****                 #endif
5013:Lib/FreeRTOS/Source/tasks.c **** 
5014:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 7361              		.loc 1 5014 26 is_stmt 1
 7362 01f2 3B6A     		ldr	r3, [r7, #32]
 7363 01f4 DA6A     		ldr	r2, [r3, #44]
 7364              		.loc 1 5014 53
 7365 01f6 0D4B     		ldr	r3, .L450+24
 7366 01f8 1B68     		ldr	r3, [r3]
 7367 01fa DB6A     		ldr	r3, [r3, #44]
 7368              		.loc 1 5014 19
 7369 01fc 9A42     		cmp	r2, r3
 7370 01fe 01D9     		bls	.L443
5015:Lib/FreeRTOS/Source/tasks.c ****                 {
5016:Lib/FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
5017:Lib/FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
5018:Lib/FreeRTOS/Source/tasks.c ****                     taskYIELD_IF_USING_PREEMPTION();
 7371              		.loc 1 5018 21
 7372 0200 FFF7FEFF 		bl	vPortYield
 7373              	.L443:
5019:Lib/FreeRTOS/Source/tasks.c ****                 }
5020:Lib/FreeRTOS/Source/tasks.c ****                 else
5021:Lib/FreeRTOS/Source/tasks.c ****                 {
5022:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5023:Lib/FreeRTOS/Source/tasks.c ****                 }
5024:Lib/FreeRTOS/Source/tasks.c ****             }
5025:Lib/FreeRTOS/Source/tasks.c ****             else
5026:Lib/FreeRTOS/Source/tasks.c ****             {
5027:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
5028:Lib/FreeRTOS/Source/tasks.c ****             }
5029:Lib/FreeRTOS/Source/tasks.c ****         }
5030:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
ARM GAS  /tmp/ccTFOe4z.s 			page 217


 7374              		.loc 1 5030 9
 7375 0204 FFF7FEFF 		bl	vPortExitCritical
5031:Lib/FreeRTOS/Source/tasks.c **** 
5032:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 7376              		.loc 1 5032 16
 7377 0208 7B6A     		ldr	r3, [r7, #36]
5033:Lib/FreeRTOS/Source/tasks.c ****     }
 7378              		.loc 1 5033 5
 7379 020a 1846     		mov	r0, r3
 7380 020c 2837     		adds	r7, r7, #40
 7381              		.cfi_def_cfa_offset 8
 7382 020e BD46     		mov	sp, r7
 7383              		.cfi_def_cfa_register 13
 7384              		@ sp needed
 7385 0210 80BD     		pop	{r7, pc}
 7386              	.L451:
 7387 0212 00BF     		.align	2
 7388              	.L450:
 7389 0214 00000000 		.word	.LC0
 7390 0218 00000000 		.word	__func__.4
 7391 021c 04000000 		.word	.LC1
 7392 0220 00000000 		.word	xTickCount
 7393 0224 00000000 		.word	uxTopReadyPriority
 7394 0228 00000000 		.word	pxReadyTasksLists
 7395 022c 00000000 		.word	pxCurrentTCB
 7396              		.cfi_endproc
 7397              	.LFE57:
 7399              		.section	.text.xTaskGenericNotifyFromISR,"ax",%progbits
 7400              		.align	1
 7401              		.global	xTaskGenericNotifyFromISR
 7402              		.syntax unified
 7403              		.thumb
 7404              		.thumb_func
 7406              	xTaskGenericNotifyFromISR:
 7407              	.LFB58:
5034:Lib/FreeRTOS/Source/tasks.c **** 
5035:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5036:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5037:Lib/FreeRTOS/Source/tasks.c **** 
5038:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5039:Lib/FreeRTOS/Source/tasks.c **** 
5040:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify,
5041:Lib/FreeRTOS/Source/tasks.c ****                                           UBaseType_t uxIndexToNotify,
5042:Lib/FreeRTOS/Source/tasks.c ****                                           uint32_t ulValue,
5043:Lib/FreeRTOS/Source/tasks.c ****                                           eNotifyAction eAction,
5044:Lib/FreeRTOS/Source/tasks.c ****                                           uint32_t * pulPreviousNotificationValue,
5045:Lib/FreeRTOS/Source/tasks.c ****                                           BaseType_t * pxHigherPriorityTaskWoken )
5046:Lib/FreeRTOS/Source/tasks.c ****     {
 7408              		.loc 1 5046 5
 7409              		.cfi_startproc
 7410              		@ args = 8, pretend = 0, frame = 48
 7411              		@ frame_needed = 1, uses_anonymous_args = 0
 7412 0000 80B5     		push	{r7, lr}
 7413              		.cfi_def_cfa_offset 8
 7414              		.cfi_offset 7, -8
 7415              		.cfi_offset 14, -4
 7416 0002 8CB0     		sub	sp, sp, #48
ARM GAS  /tmp/ccTFOe4z.s 			page 218


 7417              		.cfi_def_cfa_offset 56
 7418 0004 00AF     		add	r7, sp, #0
 7419              		.cfi_def_cfa_register 7
 7420 0006 F860     		str	r0, [r7, #12]
 7421 0008 B960     		str	r1, [r7, #8]
 7422 000a 7A60     		str	r2, [r7, #4]
 7423 000c FB70     		strb	r3, [r7, #3]
5047:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5048:Lib/FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
5049:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn = pdPASS;
 7424              		.loc 1 5049 20
 7425 000e 0123     		movs	r3, #1
 7426 0010 FB62     		str	r3, [r7, #44]
5050:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
5051:Lib/FreeRTOS/Source/tasks.c **** 
5052:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
 7427              		.loc 1 5052 9
 7428 0012 FB68     		ldr	r3, [r7, #12]
 7429 0014 002B     		cmp	r3, #0
 7430 0016 08D1     		bne	.L453
 7431              		.loc 1 5052 9 is_stmt 0 discriminator 1
 7432 0018 FFF7FEFF 		bl	ulSetInterruptMask
 7433 001c 954B     		ldr	r3, .L477
 7434 001e 964A     		ldr	r2, .L477+4
 7435 0020 41F2BC31 		movw	r1, #5052
 7436 0024 9548     		ldr	r0, .L477+8
 7437 0026 FFF7FEFF 		bl	__assert_func
 7438              	.L453:
5053:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 7439              		.loc 1 5053 9 is_stmt 1
 7440 002a BB68     		ldr	r3, [r7, #8]
 7441 002c 002B     		cmp	r3, #0
 7442 002e 08D0     		beq	.L454
 7443              		.loc 1 5053 9 is_stmt 0 discriminator 1
 7444 0030 FFF7FEFF 		bl	ulSetInterruptMask
 7445 0034 8F4B     		ldr	r3, .L477
 7446 0036 904A     		ldr	r2, .L477+4
 7447 0038 41F2BD31 		movw	r1, #5053
 7448 003c 8F48     		ldr	r0, .L477+8
 7449 003e FFF7FEFF 		bl	__assert_func
 7450              	.L454:
5054:Lib/FreeRTOS/Source/tasks.c **** 
5055:Lib/FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
5056:Lib/FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
5057:Lib/FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
5058:Lib/FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
5059:Lib/FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5060:Lib/FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
5061:Lib/FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5062:Lib/FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
5063:Lib/FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
5064:Lib/FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
5065:Lib/FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
5066:Lib/FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
5067:Lib/FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
5068:Lib/FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
5069:Lib/FreeRTOS/Source/tasks.c ****          * provided on the following link:
ARM GAS  /tmp/ccTFOe4z.s 			page 219


5070:Lib/FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
5071:Lib/FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 7451              		.loc 1 5071 9 is_stmt 1
 7452 0042 FFF7FEFF 		bl	vPortValidateInterruptPriority
5072:Lib/FreeRTOS/Source/tasks.c **** 
5073:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
 7453              		.loc 1 5073 15
 7454 0046 FB68     		ldr	r3, [r7, #12]
 7455 0048 BB62     		str	r3, [r7, #40]
5074:Lib/FreeRTOS/Source/tasks.c **** 
5075:Lib/FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 7456              		.loc 1 5075 34
 7457 004a FFF7FEFF 		bl	ulSetInterruptMask
 7458 004e 7862     		str	r0, [r7, #36]
5076:Lib/FreeRTOS/Source/tasks.c ****         {
5077:Lib/FreeRTOS/Source/tasks.c ****             if( pulPreviousNotificationValue != NULL )
 7459              		.loc 1 5077 15
 7460 0050 BB6B     		ldr	r3, [r7, #56]
 7461 0052 002B     		cmp	r3, #0
 7462 0054 06D0     		beq	.L455
5078:Lib/FreeRTOS/Source/tasks.c ****             {
5079:Lib/FreeRTOS/Source/tasks.c ****                 *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 7463              		.loc 1 5079 71
 7464 0056 BB6A     		ldr	r3, [r7, #40]
 7465 0058 BA68     		ldr	r2, [r7, #8]
 7466 005a 1632     		adds	r2, r2, #22
 7467 005c 53F82220 		ldr	r2, [r3, r2, lsl #2]
 7468              		.loc 1 5079 47
 7469 0060 BB6B     		ldr	r3, [r7, #56]
 7470 0062 1A60     		str	r2, [r3]
 7471              	.L455:
5080:Lib/FreeRTOS/Source/tasks.c ****             }
5081:Lib/FreeRTOS/Source/tasks.c **** 
5082:Lib/FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 7472              		.loc 1 5082 35
 7473 0064 BA6A     		ldr	r2, [r7, #40]
 7474 0066 BB68     		ldr	r3, [r7, #8]
 7475 0068 1344     		add	r3, r3, r2
 7476 006a 5C33     		adds	r3, r3, #92
 7477 006c 1B78     		ldrb	r3, [r3]
 7478 006e 87F82330 		strb	r3, [r7, #35]
5083:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 7479              		.loc 1 5083 53
 7480 0072 BA6A     		ldr	r2, [r7, #40]
 7481 0074 BB68     		ldr	r3, [r7, #8]
 7482 0076 1344     		add	r3, r3, r2
 7483 0078 5C33     		adds	r3, r3, #92
 7484 007a 0222     		movs	r2, #2
 7485 007c 1A70     		strb	r2, [r3]
5084:Lib/FreeRTOS/Source/tasks.c **** 
5085:Lib/FreeRTOS/Source/tasks.c ****             switch( eAction )
 7486              		.loc 1 5085 13
 7487 007e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 7488 0080 042B     		cmp	r3, #4
 7489 0082 3CD8     		bhi	.L456
 7490 0084 01A2     		adr	r2, .L458
 7491 0086 52F823F0 		ldr	pc, [r2, r3, lsl #2]
ARM GAS  /tmp/ccTFOe4z.s 			page 220


 7492 008a 00BF     		.p2align 2
 7493              	.L458:
 7494 008c 19010000 		.word	.L475+1
 7495 0090 A1000000 		.word	.L461+1
 7496 0094 BD000000 		.word	.L460+1
 7497 0098 D5000000 		.word	.L459+1
 7498 009c E3000000 		.word	.L457+1
 7499              		.p2align 1
 7500              	.L461:
5086:Lib/FreeRTOS/Source/tasks.c ****             {
5087:Lib/FreeRTOS/Source/tasks.c ****                 case eSetBits:
5088:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 7501              		.loc 1 5088 43
 7502 00a0 BB6A     		ldr	r3, [r7, #40]
 7503 00a2 BA68     		ldr	r2, [r7, #8]
 7504 00a4 1632     		adds	r2, r2, #22
 7505 00a6 53F82220 		ldr	r2, [r3, r2, lsl #2]
 7506              		.loc 1 5088 63
 7507 00aa 7B68     		ldr	r3, [r7, #4]
 7508 00ac 42EA0301 		orr	r1, r2, r3
 7509 00b0 BB6A     		ldr	r3, [r7, #40]
 7510 00b2 BA68     		ldr	r2, [r7, #8]
 7511 00b4 1632     		adds	r2, r2, #22
 7512 00b6 43F82210 		str	r1, [r3, r2, lsl #2]
5089:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7513              		.loc 1 5089 21
 7514 00ba 30E0     		b	.L463
 7515              	.L460:
5090:Lib/FreeRTOS/Source/tasks.c **** 
5091:Lib/FreeRTOS/Source/tasks.c ****                 case eIncrement:
5092:Lib/FreeRTOS/Source/tasks.c ****                     ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 7516              		.loc 1 5092 45
 7517 00bc BB6A     		ldr	r3, [r7, #40]
 7518 00be BA68     		ldr	r2, [r7, #8]
 7519 00c0 1632     		adds	r2, r2, #22
 7520 00c2 53F82230 		ldr	r3, [r3, r2, lsl #2]
 7521              		.loc 1 5092 66
 7522 00c6 591C     		adds	r1, r3, #1
 7523 00c8 BB6A     		ldr	r3, [r7, #40]
 7524 00ca BA68     		ldr	r2, [r7, #8]
 7525 00cc 1632     		adds	r2, r2, #22
 7526 00ce 43F82210 		str	r1, [r3, r2, lsl #2]
5093:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7527              		.loc 1 5093 21
 7528 00d2 24E0     		b	.L463
 7529              	.L459:
5094:Lib/FreeRTOS/Source/tasks.c **** 
5095:Lib/FreeRTOS/Source/tasks.c ****                 case eSetValueWithOverwrite:
5096:Lib/FreeRTOS/Source/tasks.c ****                     pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 7530              		.loc 1 5096 63
 7531 00d4 BB6A     		ldr	r3, [r7, #40]
 7532 00d6 BA68     		ldr	r2, [r7, #8]
 7533 00d8 1632     		adds	r2, r2, #22
 7534 00da 7968     		ldr	r1, [r7, #4]
 7535 00dc 43F82210 		str	r1, [r3, r2, lsl #2]
5097:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7536              		.loc 1 5097 21
ARM GAS  /tmp/ccTFOe4z.s 			page 221


 7537 00e0 1DE0     		b	.L463
 7538              	.L457:
5098:Lib/FreeRTOS/Source/tasks.c **** 
5099:Lib/FreeRTOS/Source/tasks.c ****                 case eSetValueWithoutOverwrite:
5100:Lib/FreeRTOS/Source/tasks.c **** 
5101:Lib/FreeRTOS/Source/tasks.c ****                     if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 7539              		.loc 1 5101 23
 7540 00e2 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 7541 00e6 022B     		cmp	r3, #2
 7542 00e8 06D0     		beq	.L464
5102:Lib/FreeRTOS/Source/tasks.c ****                     {
5103:Lib/FreeRTOS/Source/tasks.c ****                         pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 7543              		.loc 1 5103 67
 7544 00ea BB6A     		ldr	r3, [r7, #40]
 7545 00ec BA68     		ldr	r2, [r7, #8]
 7546 00ee 1632     		adds	r2, r2, #22
 7547 00f0 7968     		ldr	r1, [r7, #4]
 7548 00f2 43F82210 		str	r1, [r3, r2, lsl #2]
5104:Lib/FreeRTOS/Source/tasks.c ****                     }
5105:Lib/FreeRTOS/Source/tasks.c ****                     else
5106:Lib/FreeRTOS/Source/tasks.c ****                     {
5107:Lib/FreeRTOS/Source/tasks.c ****                         /* The value could not be written to the task. */
5108:Lib/FreeRTOS/Source/tasks.c ****                         xReturn = pdFAIL;
5109:Lib/FreeRTOS/Source/tasks.c ****                     }
5110:Lib/FreeRTOS/Source/tasks.c **** 
5111:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7549              		.loc 1 5111 21
 7550 00f6 12E0     		b	.L463
 7551              	.L464:
5108:Lib/FreeRTOS/Source/tasks.c ****                     }
 7552              		.loc 1 5108 33
 7553 00f8 0023     		movs	r3, #0
 7554 00fa FB62     		str	r3, [r7, #44]
 7555              		.loc 1 5111 21
 7556 00fc 0FE0     		b	.L463
 7557              	.L456:
5112:Lib/FreeRTOS/Source/tasks.c **** 
5113:Lib/FreeRTOS/Source/tasks.c ****                 case eNoAction:
5114:Lib/FreeRTOS/Source/tasks.c **** 
5115:Lib/FreeRTOS/Source/tasks.c ****                     /* The task is being notified without its notify value being
5116:Lib/FreeRTOS/Source/tasks.c ****                      * updated. */
5117:Lib/FreeRTOS/Source/tasks.c ****                     break;
5118:Lib/FreeRTOS/Source/tasks.c **** 
5119:Lib/FreeRTOS/Source/tasks.c ****                 default:
5120:Lib/FreeRTOS/Source/tasks.c **** 
5121:Lib/FreeRTOS/Source/tasks.c ****                     /* Should not get here if all enums are handled.
5122:Lib/FreeRTOS/Source/tasks.c ****                      * Artificially force an assert by testing a value the
5123:Lib/FreeRTOS/Source/tasks.c ****                      * compiler can't assume is const. */
5124:Lib/FreeRTOS/Source/tasks.c ****                     configASSERT( xTickCount == ( TickType_t ) 0 );
 7558              		.loc 1 5124 21
 7559 00fe 604B     		ldr	r3, .L477+12
 7560 0100 1B68     		ldr	r3, [r3]
 7561 0102 002B     		cmp	r3, #0
 7562 0104 0AD0     		beq	.L476
 7563              		.loc 1 5124 21 is_stmt 0 discriminator 1
 7564 0106 FFF7FEFF 		bl	ulSetInterruptMask
 7565 010a 5A4B     		ldr	r3, .L477
ARM GAS  /tmp/ccTFOe4z.s 			page 222


 7566 010c 5A4A     		ldr	r2, .L477+4
 7567 010e 41F20441 		movw	r1, #5124
 7568 0112 5A48     		ldr	r0, .L477+8
 7569 0114 FFF7FEFF 		bl	__assert_func
 7570              	.L475:
5117:Lib/FreeRTOS/Source/tasks.c **** 
 7571              		.loc 1 5117 21 is_stmt 1
 7572 0118 00BF     		nop
 7573 011a 00E0     		b	.L463
 7574              	.L476:
5125:Lib/FreeRTOS/Source/tasks.c ****                     break;
 7575              		.loc 1 5125 21
 7576 011c 00BF     		nop
 7577              	.L463:
5126:Lib/FreeRTOS/Source/tasks.c ****             }
5127:Lib/FreeRTOS/Source/tasks.c **** 
5128:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );
5129:Lib/FreeRTOS/Source/tasks.c **** 
5130:Lib/FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5131:Lib/FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
5132:Lib/FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 7578              		.loc 1 5132 15
 7579 011e 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 7580 0122 012B     		cmp	r3, #1
 7581 0124 40F09D80 		bne	.L467
5133:Lib/FreeRTOS/Source/tasks.c ****             {
5134:Lib/FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
5135:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 7582              		.loc 1 5135 17
 7583 0128 BB6A     		ldr	r3, [r7, #40]
 7584 012a 9B6A     		ldr	r3, [r3, #40]
 7585 012c 002B     		cmp	r3, #0
 7586 012e 08D0     		beq	.L468
 7587              		.loc 1 5135 17 is_stmt 0 discriminator 1
 7588 0130 FFF7FEFF 		bl	ulSetInterruptMask
 7589 0134 4F4B     		ldr	r3, .L477
 7590 0136 504A     		ldr	r2, .L477+4
 7591 0138 41F20F41 		movw	r1, #5135
 7592 013c 4F48     		ldr	r0, .L477+8
 7593 013e FFF7FEFF 		bl	__assert_func
 7594              	.L468:
5136:Lib/FreeRTOS/Source/tasks.c **** 
5137:Lib/FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 7595              		.loc 1 5137 42 is_stmt 1
 7596 0142 504B     		ldr	r3, .L477+16
 7597 0144 1B68     		ldr	r3, [r3]
 7598              		.loc 1 5137 19
 7599 0146 002B     		cmp	r3, #0
 7600 0148 5FD1     		bne	.L469
 7601              	.LBB40:
5138:Lib/FreeRTOS/Source/tasks.c ****                 {
5139:Lib/FreeRTOS/Source/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 7602              		.loc 1 5139 21
 7603 014a BB6A     		ldr	r3, [r7, #40]
 7604 014c 5B69     		ldr	r3, [r3, #20]
 7605 014e BB61     		str	r3, [r7, #24]
 7606 0150 BB6A     		ldr	r3, [r7, #40]
ARM GAS  /tmp/ccTFOe4z.s 			page 223


 7607 0152 9B68     		ldr	r3, [r3, #8]
 7608 0154 BA6A     		ldr	r2, [r7, #40]
 7609 0156 D268     		ldr	r2, [r2, #12]
 7610 0158 9A60     		str	r2, [r3, #8]
 7611 015a BB6A     		ldr	r3, [r7, #40]
 7612 015c DB68     		ldr	r3, [r3, #12]
 7613 015e BA6A     		ldr	r2, [r7, #40]
 7614 0160 9268     		ldr	r2, [r2, #8]
 7615 0162 5A60     		str	r2, [r3, #4]
 7616 0164 BB69     		ldr	r3, [r7, #24]
 7617 0166 5A68     		ldr	r2, [r3, #4]
 7618 0168 BB6A     		ldr	r3, [r7, #40]
 7619 016a 0433     		adds	r3, r3, #4
 7620 016c 9A42     		cmp	r2, r3
 7621 016e 03D1     		bne	.L470
 7622              		.loc 1 5139 21 is_stmt 0 discriminator 1
 7623 0170 BB6A     		ldr	r3, [r7, #40]
 7624 0172 DA68     		ldr	r2, [r3, #12]
 7625 0174 BB69     		ldr	r3, [r7, #24]
 7626 0176 5A60     		str	r2, [r3, #4]
 7627              	.L470:
 7628              		.loc 1 5139 21 discriminator 3
 7629 0178 BB6A     		ldr	r3, [r7, #40]
 7630 017a 0022     		movs	r2, #0
 7631 017c 5A61     		str	r2, [r3, #20]
 7632 017e BB69     		ldr	r3, [r7, #24]
 7633 0180 1B68     		ldr	r3, [r3]
 7634 0182 5A1E     		subs	r2, r3, #1
 7635 0184 BB69     		ldr	r3, [r7, #24]
 7636 0186 1A60     		str	r2, [r3]
 7637              	.LBE40:
5140:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 7638              		.loc 1 5140 21 is_stmt 1
 7639 0188 BB6A     		ldr	r3, [r7, #40]
 7640 018a DA6A     		ldr	r2, [r3, #44]
 7641 018c 3E4B     		ldr	r3, .L477+20
 7642 018e 1B68     		ldr	r3, [r3]
 7643 0190 9A42     		cmp	r2, r3
 7644 0192 03D9     		bls	.L471
 7645              		.loc 1 5140 21 is_stmt 0 discriminator 1
 7646 0194 BB6A     		ldr	r3, [r7, #40]
 7647 0196 DB6A     		ldr	r3, [r3, #44]
 7648 0198 3B4A     		ldr	r2, .L477+20
 7649 019a 1360     		str	r3, [r2]
 7650              	.L471:
 7651              	.LBB41:
 7652              		.loc 1 5140 21 discriminator 3
 7653 019c BB6A     		ldr	r3, [r7, #40]
 7654 019e DA6A     		ldr	r2, [r3, #44]
 7655 01a0 3A49     		ldr	r1, .L477+24
 7656 01a2 1346     		mov	r3, r2
 7657 01a4 9B00     		lsls	r3, r3, #2
 7658 01a6 1344     		add	r3, r3, r2
 7659 01a8 9B00     		lsls	r3, r3, #2
 7660 01aa 0B44     		add	r3, r3, r1
 7661 01ac 0433     		adds	r3, r3, #4
 7662 01ae 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccTFOe4z.s 			page 224


 7663 01b0 7B61     		str	r3, [r7, #20]
 7664 01b2 BB6A     		ldr	r3, [r7, #40]
 7665 01b4 7A69     		ldr	r2, [r7, #20]
 7666 01b6 9A60     		str	r2, [r3, #8]
 7667 01b8 7B69     		ldr	r3, [r7, #20]
 7668 01ba 9A68     		ldr	r2, [r3, #8]
 7669 01bc BB6A     		ldr	r3, [r7, #40]
 7670 01be DA60     		str	r2, [r3, #12]
 7671 01c0 7B69     		ldr	r3, [r7, #20]
 7672 01c2 9B68     		ldr	r3, [r3, #8]
 7673 01c4 BA6A     		ldr	r2, [r7, #40]
 7674 01c6 0432     		adds	r2, r2, #4
 7675 01c8 5A60     		str	r2, [r3, #4]
 7676 01ca BB6A     		ldr	r3, [r7, #40]
 7677 01cc 1A1D     		adds	r2, r3, #4
 7678 01ce 7B69     		ldr	r3, [r7, #20]
 7679 01d0 9A60     		str	r2, [r3, #8]
 7680 01d2 BB6A     		ldr	r3, [r7, #40]
 7681 01d4 DA6A     		ldr	r2, [r3, #44]
 7682 01d6 1346     		mov	r3, r2
 7683 01d8 9B00     		lsls	r3, r3, #2
 7684 01da 1344     		add	r3, r3, r2
 7685 01dc 9B00     		lsls	r3, r3, #2
 7686 01de 2B4A     		ldr	r2, .L477+24
 7687 01e0 1A44     		add	r2, r2, r3
 7688 01e2 BB6A     		ldr	r3, [r7, #40]
 7689 01e4 5A61     		str	r2, [r3, #20]
 7690 01e6 BB6A     		ldr	r3, [r7, #40]
 7691 01e8 DA6A     		ldr	r2, [r3, #44]
 7692 01ea 2849     		ldr	r1, .L477+24
 7693 01ec 1346     		mov	r3, r2
 7694 01ee 9B00     		lsls	r3, r3, #2
 7695 01f0 1344     		add	r3, r3, r2
 7696 01f2 9B00     		lsls	r3, r3, #2
 7697 01f4 0B44     		add	r3, r3, r1
 7698 01f6 1B68     		ldr	r3, [r3]
 7699 01f8 591C     		adds	r1, r3, #1
 7700 01fa 2448     		ldr	r0, .L477+24
 7701 01fc 1346     		mov	r3, r2
 7702 01fe 9B00     		lsls	r3, r3, #2
 7703 0200 1344     		add	r3, r3, r2
 7704 0202 9B00     		lsls	r3, r3, #2
 7705 0204 0344     		add	r3, r3, r0
 7706 0206 1960     		str	r1, [r3]
 7707              	.LBE41:
 7708 0208 1BE0     		b	.L472
 7709              	.L469:
 7710              	.LBB42:
5141:Lib/FreeRTOS/Source/tasks.c ****                 }
5142:Lib/FreeRTOS/Source/tasks.c ****                 else
5143:Lib/FreeRTOS/Source/tasks.c ****                 {
5144:Lib/FreeRTOS/Source/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5145:Lib/FreeRTOS/Source/tasks.c ****                      * this task pending until the scheduler is resumed. */
5146:Lib/FreeRTOS/Source/tasks.c ****                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 7711              		.loc 1 5146 21 is_stmt 1
 7712 020a 214B     		ldr	r3, .L477+28
 7713 020c 5B68     		ldr	r3, [r3, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 225


 7714 020e FB61     		str	r3, [r7, #28]
 7715 0210 BB6A     		ldr	r3, [r7, #40]
 7716 0212 FA69     		ldr	r2, [r7, #28]
 7717 0214 DA61     		str	r2, [r3, #28]
 7718 0216 FB69     		ldr	r3, [r7, #28]
 7719 0218 9A68     		ldr	r2, [r3, #8]
 7720 021a BB6A     		ldr	r3, [r7, #40]
 7721 021c 1A62     		str	r2, [r3, #32]
 7722 021e FB69     		ldr	r3, [r7, #28]
 7723 0220 9B68     		ldr	r3, [r3, #8]
 7724 0222 BA6A     		ldr	r2, [r7, #40]
 7725 0224 1832     		adds	r2, r2, #24
 7726 0226 5A60     		str	r2, [r3, #4]
 7727 0228 BB6A     		ldr	r3, [r7, #40]
 7728 022a 03F11802 		add	r2, r3, #24
 7729 022e FB69     		ldr	r3, [r7, #28]
 7730 0230 9A60     		str	r2, [r3, #8]
 7731 0232 BB6A     		ldr	r3, [r7, #40]
 7732 0234 164A     		ldr	r2, .L477+28
 7733 0236 9A62     		str	r2, [r3, #40]
 7734 0238 154B     		ldr	r3, .L477+28
 7735 023a 1B68     		ldr	r3, [r3]
 7736 023c 0133     		adds	r3, r3, #1
 7737 023e 144A     		ldr	r2, .L477+28
 7738 0240 1360     		str	r3, [r2]
 7739              	.L472:
 7740              	.LBE42:
5147:Lib/FreeRTOS/Source/tasks.c ****                 }
5148:Lib/FreeRTOS/Source/tasks.c **** 
5149:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 7741              		.loc 1 5149 26
 7742 0242 BB6A     		ldr	r3, [r7, #40]
 7743 0244 DA6A     		ldr	r2, [r3, #44]
 7744              		.loc 1 5149 53
 7745 0246 134B     		ldr	r3, .L477+32
 7746 0248 1B68     		ldr	r3, [r3]
 7747 024a DB6A     		ldr	r3, [r3, #44]
 7748              		.loc 1 5149 19
 7749 024c 9A42     		cmp	r2, r3
 7750 024e 08D9     		bls	.L467
5150:Lib/FreeRTOS/Source/tasks.c ****                 {
5151:Lib/FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
5152:Lib/FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
5153:Lib/FreeRTOS/Source/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
 7751              		.loc 1 5153 23
 7752 0250 FB6B     		ldr	r3, [r7, #60]
 7753 0252 002B     		cmp	r3, #0
 7754 0254 02D0     		beq	.L473
5154:Lib/FreeRTOS/Source/tasks.c ****                     {
5155:Lib/FreeRTOS/Source/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
 7755              		.loc 1 5155 52
 7756 0256 FB6B     		ldr	r3, [r7, #60]
 7757 0258 0122     		movs	r2, #1
 7758 025a 1A60     		str	r2, [r3]
 7759              	.L473:
5156:Lib/FreeRTOS/Source/tasks.c ****                     }
5157:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 226


5158:Lib/FreeRTOS/Source/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5159:Lib/FreeRTOS/Source/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter to an ISR
5160:Lib/FreeRTOS/Source/tasks.c ****                      * safe FreeRTOS function. */
5161:Lib/FreeRTOS/Source/tasks.c ****                     xYieldPending = pdTRUE;
 7760              		.loc 1 5161 35
 7761 025c 0E4B     		ldr	r3, .L477+36
 7762 025e 0122     		movs	r2, #1
 7763 0260 1A60     		str	r2, [r3]
 7764              	.L467:
5162:Lib/FreeRTOS/Source/tasks.c ****                 }
5163:Lib/FreeRTOS/Source/tasks.c ****                 else
5164:Lib/FreeRTOS/Source/tasks.c ****                 {
5165:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5166:Lib/FreeRTOS/Source/tasks.c ****                 }
5167:Lib/FreeRTOS/Source/tasks.c ****             }
5168:Lib/FreeRTOS/Source/tasks.c ****         }
5169:Lib/FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 7765              		.loc 1 5169 9
 7766 0262 786A     		ldr	r0, [r7, #36]
 7767 0264 FFF7FEFF 		bl	vClearInterruptMask
5170:Lib/FreeRTOS/Source/tasks.c **** 
5171:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 7768              		.loc 1 5171 16
 7769 0268 FB6A     		ldr	r3, [r7, #44]
5172:Lib/FreeRTOS/Source/tasks.c ****     }
 7770              		.loc 1 5172 5
 7771 026a 1846     		mov	r0, r3
 7772 026c 3037     		adds	r7, r7, #48
 7773              		.cfi_def_cfa_offset 8
 7774 026e BD46     		mov	sp, r7
 7775              		.cfi_def_cfa_register 13
 7776              		@ sp needed
 7777 0270 80BD     		pop	{r7, pc}
 7778              	.L478:
 7779 0272 00BF     		.align	2
 7780              	.L477:
 7781 0274 00000000 		.word	.LC0
 7782 0278 00000000 		.word	__func__.3
 7783 027c 04000000 		.word	.LC1
 7784 0280 00000000 		.word	xTickCount
 7785 0284 00000000 		.word	uxSchedulerSuspended
 7786 0288 00000000 		.word	uxTopReadyPriority
 7787 028c 00000000 		.word	pxReadyTasksLists
 7788 0290 00000000 		.word	xPendingReadyList
 7789 0294 00000000 		.word	pxCurrentTCB
 7790 0298 00000000 		.word	xYieldPending
 7791              		.cfi_endproc
 7792              	.LFE58:
 7794              		.section	.text.vTaskGenericNotifyGiveFromISR,"ax",%progbits
 7795              		.align	1
 7796              		.global	vTaskGenericNotifyGiveFromISR
 7797              		.syntax unified
 7798              		.thumb
 7799              		.thumb_func
 7801              	vTaskGenericNotifyGiveFromISR:
 7802              	.LFB59:
5173:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 227


5174:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5175:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5176:Lib/FreeRTOS/Source/tasks.c **** 
5177:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5178:Lib/FreeRTOS/Source/tasks.c **** 
5179:Lib/FreeRTOS/Source/tasks.c ****     void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
5180:Lib/FreeRTOS/Source/tasks.c ****                                         UBaseType_t uxIndexToNotify,
5181:Lib/FreeRTOS/Source/tasks.c ****                                         BaseType_t * pxHigherPriorityTaskWoken )
5182:Lib/FreeRTOS/Source/tasks.c ****     {
 7803              		.loc 1 5182 5
 7804              		.cfi_startproc
 7805              		@ args = 0, pretend = 0, frame = 40
 7806              		@ frame_needed = 1, uses_anonymous_args = 0
 7807 0000 80B5     		push	{r7, lr}
 7808              		.cfi_def_cfa_offset 8
 7809              		.cfi_offset 7, -8
 7810              		.cfi_offset 14, -4
 7811 0002 8AB0     		sub	sp, sp, #40
 7812              		.cfi_def_cfa_offset 48
 7813 0004 00AF     		add	r7, sp, #0
 7814              		.cfi_def_cfa_register 7
 7815 0006 F860     		str	r0, [r7, #12]
 7816 0008 B960     		str	r1, [r7, #8]
 7817 000a 7A60     		str	r2, [r7, #4]
5183:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5184:Lib/FreeRTOS/Source/tasks.c ****         uint8_t ucOriginalNotifyState;
5185:Lib/FreeRTOS/Source/tasks.c ****         UBaseType_t uxSavedInterruptStatus;
5186:Lib/FreeRTOS/Source/tasks.c **** 
5187:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( xTaskToNotify );
 7818              		.loc 1 5187 9
 7819 000c FB68     		ldr	r3, [r7, #12]
 7820 000e 002B     		cmp	r3, #0
 7821 0010 08D1     		bne	.L480
 7822              		.loc 1 5187 9 is_stmt 0 discriminator 1
 7823 0012 FFF7FEFF 		bl	ulSetInterruptMask
 7824 0016 6C4B     		ldr	r3, .L489
 7825 0018 6C4A     		ldr	r2, .L489+4
 7826 001a 41F24341 		movw	r1, #5187
 7827 001e 6C48     		ldr	r0, .L489+8
 7828 0020 FFF7FEFF 		bl	__assert_func
 7829              	.L480:
5188:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 7830              		.loc 1 5188 9 is_stmt 1
 7831 0024 BB68     		ldr	r3, [r7, #8]
 7832 0026 002B     		cmp	r3, #0
 7833 0028 08D0     		beq	.L481
 7834              		.loc 1 5188 9 is_stmt 0 discriminator 1
 7835 002a FFF7FEFF 		bl	ulSetInterruptMask
 7836 002e 664B     		ldr	r3, .L489
 7837 0030 664A     		ldr	r2, .L489+4
 7838 0032 41F24441 		movw	r1, #5188
 7839 0036 6648     		ldr	r0, .L489+8
 7840 0038 FFF7FEFF 		bl	__assert_func
 7841              	.L481:
5189:Lib/FreeRTOS/Source/tasks.c **** 
5190:Lib/FreeRTOS/Source/tasks.c ****         /* RTOS ports that support interrupt nesting have the concept of a
5191:Lib/FreeRTOS/Source/tasks.c ****          * maximum  system call (or maximum API call) interrupt priority.
ARM GAS  /tmp/ccTFOe4z.s 			page 228


5192:Lib/FreeRTOS/Source/tasks.c ****          * Interrupts that are  above the maximum system call priority are keep
5193:Lib/FreeRTOS/Source/tasks.c ****          * permanently enabled, even when the RTOS kernel is in a critical section,
5194:Lib/FreeRTOS/Source/tasks.c ****          * but cannot make any calls to FreeRTOS API functions.  If configASSERT()
5195:Lib/FreeRTOS/Source/tasks.c ****          * is defined in FreeRTOSConfig.h then
5196:Lib/FreeRTOS/Source/tasks.c ****          * portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
5197:Lib/FreeRTOS/Source/tasks.c ****          * failure if a FreeRTOS API function is called from an interrupt that has
5198:Lib/FreeRTOS/Source/tasks.c ****          * been assigned a priority above the configured maximum system call
5199:Lib/FreeRTOS/Source/tasks.c ****          * priority.  Only FreeRTOS functions that end in FromISR can be called
5200:Lib/FreeRTOS/Source/tasks.c ****          * from interrupts  that have been assigned a priority at or (logically)
5201:Lib/FreeRTOS/Source/tasks.c ****          * below the maximum system call interrupt priority.  FreeRTOS maintains a
5202:Lib/FreeRTOS/Source/tasks.c ****          * separate interrupt safe API to ensure interrupt entry is as fast and as
5203:Lib/FreeRTOS/Source/tasks.c ****          * simple as possible.  More information (albeit Cortex-M specific) is
5204:Lib/FreeRTOS/Source/tasks.c ****          * provided on the following link:
5205:Lib/FreeRTOS/Source/tasks.c ****          * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
5206:Lib/FreeRTOS/Source/tasks.c ****         portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 7842              		.loc 1 5206 9 is_stmt 1
 7843 003c FFF7FEFF 		bl	vPortValidateInterruptPriority
5207:Lib/FreeRTOS/Source/tasks.c **** 
5208:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = xTaskToNotify;
 7844              		.loc 1 5208 15
 7845 0040 FB68     		ldr	r3, [r7, #12]
 7846 0042 7B62     		str	r3, [r7, #36]
5209:Lib/FreeRTOS/Source/tasks.c **** 
5210:Lib/FreeRTOS/Source/tasks.c ****         uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 7847              		.loc 1 5210 34
 7848 0044 FFF7FEFF 		bl	ulSetInterruptMask
 7849 0048 3862     		str	r0, [r7, #32]
5211:Lib/FreeRTOS/Source/tasks.c ****         {
5212:Lib/FreeRTOS/Source/tasks.c ****             ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 7850              		.loc 1 5212 35
 7851 004a 7A6A     		ldr	r2, [r7, #36]
 7852 004c BB68     		ldr	r3, [r7, #8]
 7853 004e 1344     		add	r3, r3, r2
 7854 0050 5C33     		adds	r3, r3, #92
 7855 0052 1B78     		ldrb	r3, [r3]
 7856 0054 FB77     		strb	r3, [r7, #31]
5213:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 7857              		.loc 1 5213 53
 7858 0056 7A6A     		ldr	r2, [r7, #36]
 7859 0058 BB68     		ldr	r3, [r7, #8]
 7860 005a 1344     		add	r3, r3, r2
 7861 005c 5C33     		adds	r3, r3, #92
 7862 005e 0222     		movs	r2, #2
 7863 0060 1A70     		strb	r2, [r3]
5214:Lib/FreeRTOS/Source/tasks.c **** 
5215:Lib/FreeRTOS/Source/tasks.c ****             /* 'Giving' is equivalent to incrementing a count in a counting
5216:Lib/FreeRTOS/Source/tasks.c ****              * semaphore. */
5217:Lib/FreeRTOS/Source/tasks.c ****             ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 7864              		.loc 1 5217 37
 7865 0062 7B6A     		ldr	r3, [r7, #36]
 7866 0064 BA68     		ldr	r2, [r7, #8]
 7867 0066 1632     		adds	r2, r2, #22
 7868 0068 53F82230 		ldr	r3, [r3, r2, lsl #2]
 7869              		.loc 1 5217 58
 7870 006c 591C     		adds	r1, r3, #1
 7871 006e 7B6A     		ldr	r3, [r7, #36]
 7872 0070 BA68     		ldr	r2, [r7, #8]
ARM GAS  /tmp/ccTFOe4z.s 			page 229


 7873 0072 1632     		adds	r2, r2, #22
 7874 0074 43F82210 		str	r1, [r3, r2, lsl #2]
5218:Lib/FreeRTOS/Source/tasks.c **** 
5219:Lib/FreeRTOS/Source/tasks.c ****             traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );
5220:Lib/FreeRTOS/Source/tasks.c **** 
5221:Lib/FreeRTOS/Source/tasks.c ****             /* If the task is in the blocked state specifically to wait for a
5222:Lib/FreeRTOS/Source/tasks.c ****              * notification then unblock it now. */
5223:Lib/FreeRTOS/Source/tasks.c ****             if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 7875              		.loc 1 5223 15
 7876 0078 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 7877 007a 012B     		cmp	r3, #1
 7878 007c 40F09D80 		bne	.L482
5224:Lib/FreeRTOS/Source/tasks.c ****             {
5225:Lib/FreeRTOS/Source/tasks.c ****                 /* The task should not have been on an event list. */
5226:Lib/FreeRTOS/Source/tasks.c ****                 configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 7879              		.loc 1 5226 17
 7880 0080 7B6A     		ldr	r3, [r7, #36]
 7881 0082 9B6A     		ldr	r3, [r3, #40]
 7882 0084 002B     		cmp	r3, #0
 7883 0086 08D0     		beq	.L483
 7884              		.loc 1 5226 17 is_stmt 0 discriminator 1
 7885 0088 FFF7FEFF 		bl	ulSetInterruptMask
 7886 008c 4E4B     		ldr	r3, .L489
 7887 008e 4F4A     		ldr	r2, .L489+4
 7888 0090 41F26A41 		movw	r1, #5226
 7889 0094 4E48     		ldr	r0, .L489+8
 7890 0096 FFF7FEFF 		bl	__assert_func
 7891              	.L483:
5227:Lib/FreeRTOS/Source/tasks.c **** 
5228:Lib/FreeRTOS/Source/tasks.c ****                 if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 7892              		.loc 1 5228 42 is_stmt 1
 7893 009a 4E4B     		ldr	r3, .L489+12
 7894 009c 1B68     		ldr	r3, [r3]
 7895              		.loc 1 5228 19
 7896 009e 002B     		cmp	r3, #0
 7897 00a0 5FD1     		bne	.L484
 7898              	.LBB43:
5229:Lib/FreeRTOS/Source/tasks.c ****                 {
5230:Lib/FreeRTOS/Source/tasks.c ****                     listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 7899              		.loc 1 5230 21
 7900 00a2 7B6A     		ldr	r3, [r7, #36]
 7901 00a4 5B69     		ldr	r3, [r3, #20]
 7902 00a6 7B61     		str	r3, [r7, #20]
 7903 00a8 7B6A     		ldr	r3, [r7, #36]
 7904 00aa 9B68     		ldr	r3, [r3, #8]
 7905 00ac 7A6A     		ldr	r2, [r7, #36]
 7906 00ae D268     		ldr	r2, [r2, #12]
 7907 00b0 9A60     		str	r2, [r3, #8]
 7908 00b2 7B6A     		ldr	r3, [r7, #36]
 7909 00b4 DB68     		ldr	r3, [r3, #12]
 7910 00b6 7A6A     		ldr	r2, [r7, #36]
 7911 00b8 9268     		ldr	r2, [r2, #8]
 7912 00ba 5A60     		str	r2, [r3, #4]
 7913 00bc 7B69     		ldr	r3, [r7, #20]
 7914 00be 5A68     		ldr	r2, [r3, #4]
 7915 00c0 7B6A     		ldr	r3, [r7, #36]
 7916 00c2 0433     		adds	r3, r3, #4
ARM GAS  /tmp/ccTFOe4z.s 			page 230


 7917 00c4 9A42     		cmp	r2, r3
 7918 00c6 03D1     		bne	.L485
 7919              		.loc 1 5230 21 is_stmt 0 discriminator 1
 7920 00c8 7B6A     		ldr	r3, [r7, #36]
 7921 00ca DA68     		ldr	r2, [r3, #12]
 7922 00cc 7B69     		ldr	r3, [r7, #20]
 7923 00ce 5A60     		str	r2, [r3, #4]
 7924              	.L485:
 7925              		.loc 1 5230 21 discriminator 3
 7926 00d0 7B6A     		ldr	r3, [r7, #36]
 7927 00d2 0022     		movs	r2, #0
 7928 00d4 5A61     		str	r2, [r3, #20]
 7929 00d6 7B69     		ldr	r3, [r7, #20]
 7930 00d8 1B68     		ldr	r3, [r3]
 7931 00da 5A1E     		subs	r2, r3, #1
 7932 00dc 7B69     		ldr	r3, [r7, #20]
 7933 00de 1A60     		str	r2, [r3]
 7934              	.LBE43:
5231:Lib/FreeRTOS/Source/tasks.c ****                     prvAddTaskToReadyList( pxTCB );
 7935              		.loc 1 5231 21 is_stmt 1
 7936 00e0 7B6A     		ldr	r3, [r7, #36]
 7937 00e2 DA6A     		ldr	r2, [r3, #44]
 7938 00e4 3C4B     		ldr	r3, .L489+16
 7939 00e6 1B68     		ldr	r3, [r3]
 7940 00e8 9A42     		cmp	r2, r3
 7941 00ea 03D9     		bls	.L486
 7942              		.loc 1 5231 21 is_stmt 0 discriminator 1
 7943 00ec 7B6A     		ldr	r3, [r7, #36]
 7944 00ee DB6A     		ldr	r3, [r3, #44]
 7945 00f0 394A     		ldr	r2, .L489+16
 7946 00f2 1360     		str	r3, [r2]
 7947              	.L486:
 7948              	.LBB44:
 7949              		.loc 1 5231 21 discriminator 3
 7950 00f4 7B6A     		ldr	r3, [r7, #36]
 7951 00f6 DA6A     		ldr	r2, [r3, #44]
 7952 00f8 3849     		ldr	r1, .L489+20
 7953 00fa 1346     		mov	r3, r2
 7954 00fc 9B00     		lsls	r3, r3, #2
 7955 00fe 1344     		add	r3, r3, r2
 7956 0100 9B00     		lsls	r3, r3, #2
 7957 0102 0B44     		add	r3, r3, r1
 7958 0104 0433     		adds	r3, r3, #4
 7959 0106 1B68     		ldr	r3, [r3]
 7960 0108 3B61     		str	r3, [r7, #16]
 7961 010a 7B6A     		ldr	r3, [r7, #36]
 7962 010c 3A69     		ldr	r2, [r7, #16]
 7963 010e 9A60     		str	r2, [r3, #8]
 7964 0110 3B69     		ldr	r3, [r7, #16]
 7965 0112 9A68     		ldr	r2, [r3, #8]
 7966 0114 7B6A     		ldr	r3, [r7, #36]
 7967 0116 DA60     		str	r2, [r3, #12]
 7968 0118 3B69     		ldr	r3, [r7, #16]
 7969 011a 9B68     		ldr	r3, [r3, #8]
 7970 011c 7A6A     		ldr	r2, [r7, #36]
 7971 011e 0432     		adds	r2, r2, #4
 7972 0120 5A60     		str	r2, [r3, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 231


 7973 0122 7B6A     		ldr	r3, [r7, #36]
 7974 0124 1A1D     		adds	r2, r3, #4
 7975 0126 3B69     		ldr	r3, [r7, #16]
 7976 0128 9A60     		str	r2, [r3, #8]
 7977 012a 7B6A     		ldr	r3, [r7, #36]
 7978 012c DA6A     		ldr	r2, [r3, #44]
 7979 012e 1346     		mov	r3, r2
 7980 0130 9B00     		lsls	r3, r3, #2
 7981 0132 1344     		add	r3, r3, r2
 7982 0134 9B00     		lsls	r3, r3, #2
 7983 0136 294A     		ldr	r2, .L489+20
 7984 0138 1A44     		add	r2, r2, r3
 7985 013a 7B6A     		ldr	r3, [r7, #36]
 7986 013c 5A61     		str	r2, [r3, #20]
 7987 013e 7B6A     		ldr	r3, [r7, #36]
 7988 0140 DA6A     		ldr	r2, [r3, #44]
 7989 0142 2649     		ldr	r1, .L489+20
 7990 0144 1346     		mov	r3, r2
 7991 0146 9B00     		lsls	r3, r3, #2
 7992 0148 1344     		add	r3, r3, r2
 7993 014a 9B00     		lsls	r3, r3, #2
 7994 014c 0B44     		add	r3, r3, r1
 7995 014e 1B68     		ldr	r3, [r3]
 7996 0150 591C     		adds	r1, r3, #1
 7997 0152 2248     		ldr	r0, .L489+20
 7998 0154 1346     		mov	r3, r2
 7999 0156 9B00     		lsls	r3, r3, #2
 8000 0158 1344     		add	r3, r3, r2
 8001 015a 9B00     		lsls	r3, r3, #2
 8002 015c 0344     		add	r3, r3, r0
 8003 015e 1960     		str	r1, [r3]
 8004              	.LBE44:
 8005 0160 1BE0     		b	.L487
 8006              	.L484:
 8007              	.LBB45:
5232:Lib/FreeRTOS/Source/tasks.c ****                 }
5233:Lib/FreeRTOS/Source/tasks.c ****                 else
5234:Lib/FreeRTOS/Source/tasks.c ****                 {
5235:Lib/FreeRTOS/Source/tasks.c ****                     /* The delayed and ready lists cannot be accessed, so hold
5236:Lib/FreeRTOS/Source/tasks.c ****                      * this task pending until the scheduler is resumed. */
5237:Lib/FreeRTOS/Source/tasks.c ****                     listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 8008              		.loc 1 5237 21 is_stmt 1
 8009 0162 1F4B     		ldr	r3, .L489+24
 8010 0164 5B68     		ldr	r3, [r3, #4]
 8011 0166 BB61     		str	r3, [r7, #24]
 8012 0168 7B6A     		ldr	r3, [r7, #36]
 8013 016a BA69     		ldr	r2, [r7, #24]
 8014 016c DA61     		str	r2, [r3, #28]
 8015 016e BB69     		ldr	r3, [r7, #24]
 8016 0170 9A68     		ldr	r2, [r3, #8]
 8017 0172 7B6A     		ldr	r3, [r7, #36]
 8018 0174 1A62     		str	r2, [r3, #32]
 8019 0176 BB69     		ldr	r3, [r7, #24]
 8020 0178 9B68     		ldr	r3, [r3, #8]
 8021 017a 7A6A     		ldr	r2, [r7, #36]
 8022 017c 1832     		adds	r2, r2, #24
 8023 017e 5A60     		str	r2, [r3, #4]
ARM GAS  /tmp/ccTFOe4z.s 			page 232


 8024 0180 7B6A     		ldr	r3, [r7, #36]
 8025 0182 03F11802 		add	r2, r3, #24
 8026 0186 BB69     		ldr	r3, [r7, #24]
 8027 0188 9A60     		str	r2, [r3, #8]
 8028 018a 7B6A     		ldr	r3, [r7, #36]
 8029 018c 144A     		ldr	r2, .L489+24
 8030 018e 9A62     		str	r2, [r3, #40]
 8031 0190 134B     		ldr	r3, .L489+24
 8032 0192 1B68     		ldr	r3, [r3]
 8033 0194 0133     		adds	r3, r3, #1
 8034 0196 124A     		ldr	r2, .L489+24
 8035 0198 1360     		str	r3, [r2]
 8036              	.L487:
 8037              	.LBE45:
5238:Lib/FreeRTOS/Source/tasks.c ****                 }
5239:Lib/FreeRTOS/Source/tasks.c **** 
5240:Lib/FreeRTOS/Source/tasks.c ****                 if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8038              		.loc 1 5240 26
 8039 019a 7B6A     		ldr	r3, [r7, #36]
 8040 019c DA6A     		ldr	r2, [r3, #44]
 8041              		.loc 1 5240 53
 8042 019e 114B     		ldr	r3, .L489+28
 8043 01a0 1B68     		ldr	r3, [r3]
 8044 01a2 DB6A     		ldr	r3, [r3, #44]
 8045              		.loc 1 5240 19
 8046 01a4 9A42     		cmp	r2, r3
 8047 01a6 08D9     		bls	.L482
5241:Lib/FreeRTOS/Source/tasks.c ****                 {
5242:Lib/FreeRTOS/Source/tasks.c ****                     /* The notified task has a priority above the currently
5243:Lib/FreeRTOS/Source/tasks.c ****                      * executing task so a yield is required. */
5244:Lib/FreeRTOS/Source/tasks.c ****                     if( pxHigherPriorityTaskWoken != NULL )
 8048              		.loc 1 5244 23
 8049 01a8 7B68     		ldr	r3, [r7, #4]
 8050 01aa 002B     		cmp	r3, #0
 8051 01ac 02D0     		beq	.L488
5245:Lib/FreeRTOS/Source/tasks.c ****                     {
5246:Lib/FreeRTOS/Source/tasks.c ****                         *pxHigherPriorityTaskWoken = pdTRUE;
 8052              		.loc 1 5246 52
 8053 01ae 7B68     		ldr	r3, [r7, #4]
 8054 01b0 0122     		movs	r2, #1
 8055 01b2 1A60     		str	r2, [r3]
 8056              	.L488:
5247:Lib/FreeRTOS/Source/tasks.c ****                     }
5248:Lib/FreeRTOS/Source/tasks.c **** 
5249:Lib/FreeRTOS/Source/tasks.c ****                     /* Mark that a yield is pending in case the user is not
5250:Lib/FreeRTOS/Source/tasks.c ****                      * using the "xHigherPriorityTaskWoken" parameter in an ISR
5251:Lib/FreeRTOS/Source/tasks.c ****                      * safe FreeRTOS function. */
5252:Lib/FreeRTOS/Source/tasks.c ****                     xYieldPending = pdTRUE;
 8057              		.loc 1 5252 35
 8058 01b4 0C4B     		ldr	r3, .L489+32
 8059 01b6 0122     		movs	r2, #1
 8060 01b8 1A60     		str	r2, [r3]
 8061              	.L482:
5253:Lib/FreeRTOS/Source/tasks.c ****                 }
5254:Lib/FreeRTOS/Source/tasks.c ****                 else
5255:Lib/FreeRTOS/Source/tasks.c ****                 {
5256:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
ARM GAS  /tmp/ccTFOe4z.s 			page 233


5257:Lib/FreeRTOS/Source/tasks.c ****                 }
5258:Lib/FreeRTOS/Source/tasks.c ****             }
5259:Lib/FreeRTOS/Source/tasks.c ****         }
5260:Lib/FreeRTOS/Source/tasks.c ****         portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8062              		.loc 1 5260 9
 8063 01ba 386A     		ldr	r0, [r7, #32]
 8064 01bc FFF7FEFF 		bl	vClearInterruptMask
5261:Lib/FreeRTOS/Source/tasks.c ****     }
 8065              		.loc 1 5261 5
 8066 01c0 00BF     		nop
 8067 01c2 2837     		adds	r7, r7, #40
 8068              		.cfi_def_cfa_offset 8
 8069 01c4 BD46     		mov	sp, r7
 8070              		.cfi_def_cfa_register 13
 8071              		@ sp needed
 8072 01c6 80BD     		pop	{r7, pc}
 8073              	.L490:
 8074              		.align	2
 8075              	.L489:
 8076 01c8 00000000 		.word	.LC0
 8077 01cc 00000000 		.word	__func__.2
 8078 01d0 04000000 		.word	.LC1
 8079 01d4 00000000 		.word	uxSchedulerSuspended
 8080 01d8 00000000 		.word	uxTopReadyPriority
 8081 01dc 00000000 		.word	pxReadyTasksLists
 8082 01e0 00000000 		.word	xPendingReadyList
 8083 01e4 00000000 		.word	pxCurrentTCB
 8084 01e8 00000000 		.word	xYieldPending
 8085              		.cfi_endproc
 8086              	.LFE59:
 8088              		.section	.text.xTaskGenericNotifyStateClear,"ax",%progbits
 8089              		.align	1
 8090              		.global	xTaskGenericNotifyStateClear
 8091              		.syntax unified
 8092              		.thumb
 8093              		.thumb_func
 8095              	xTaskGenericNotifyStateClear:
 8096              	.LFB60:
5262:Lib/FreeRTOS/Source/tasks.c **** 
5263:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5264:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5265:Lib/FreeRTOS/Source/tasks.c **** 
5266:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5267:Lib/FreeRTOS/Source/tasks.c **** 
5268:Lib/FreeRTOS/Source/tasks.c ****     BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
5269:Lib/FreeRTOS/Source/tasks.c ****                                              UBaseType_t uxIndexToClear )
5270:Lib/FreeRTOS/Source/tasks.c ****     {
 8097              		.loc 1 5270 5
 8098              		.cfi_startproc
 8099              		@ args = 0, pretend = 0, frame = 16
 8100              		@ frame_needed = 1, uses_anonymous_args = 0
 8101 0000 80B5     		push	{r7, lr}
 8102              		.cfi_def_cfa_offset 8
 8103              		.cfi_offset 7, -8
 8104              		.cfi_offset 14, -4
 8105 0002 84B0     		sub	sp, sp, #16
 8106              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/ccTFOe4z.s 			page 234


 8107 0004 00AF     		add	r7, sp, #0
 8108              		.cfi_def_cfa_register 7
 8109 0006 7860     		str	r0, [r7, #4]
 8110 0008 3960     		str	r1, [r7]
5271:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5272:Lib/FreeRTOS/Source/tasks.c ****         BaseType_t xReturn;
5273:Lib/FreeRTOS/Source/tasks.c **** 
5274:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8111              		.loc 1 5274 9
 8112 000a 3B68     		ldr	r3, [r7]
 8113 000c 002B     		cmp	r3, #0
 8114 000e 08D0     		beq	.L492
 8115              		.loc 1 5274 9 is_stmt 0 discriminator 1
 8116 0010 FFF7FEFF 		bl	ulSetInterruptMask
 8117 0014 154B     		ldr	r3, .L498
 8118 0016 164A     		ldr	r2, .L498+4
 8119 0018 41F29A41 		movw	r1, #5274
 8120 001c 1548     		ldr	r0, .L498+8
 8121 001e FFF7FEFF 		bl	__assert_func
 8122              	.L492:
5275:Lib/FreeRTOS/Source/tasks.c **** 
5276:Lib/FreeRTOS/Source/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5277:Lib/FreeRTOS/Source/tasks.c ****          * its notification state cleared. */
5278:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
 8123              		.loc 1 5278 17 is_stmt 1
 8124 0022 7B68     		ldr	r3, [r7, #4]
 8125 0024 002B     		cmp	r3, #0
 8126 0026 02D1     		bne	.L493
 8127              		.loc 1 5278 17 is_stmt 0 discriminator 1
 8128 0028 134B     		ldr	r3, .L498+12
 8129 002a 1B68     		ldr	r3, [r3]
 8130 002c 00E0     		b	.L494
 8131              	.L493:
 8132              		.loc 1 5278 17 discriminator 2
 8133 002e 7B68     		ldr	r3, [r7, #4]
 8134              	.L494:
 8135              		.loc 1 5278 15 is_stmt 1 discriminator 4
 8136 0030 BB60     		str	r3, [r7, #8]
5279:Lib/FreeRTOS/Source/tasks.c **** 
5280:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 8137              		.loc 1 5280 9
 8138 0032 FFF7FEFF 		bl	vPortEnterCritical
5281:Lib/FreeRTOS/Source/tasks.c ****         {
5282:Lib/FreeRTOS/Source/tasks.c ****             if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 8139              		.loc 1 5282 37
 8140 0036 BA68     		ldr	r2, [r7, #8]
 8141 0038 3B68     		ldr	r3, [r7]
 8142 003a 1344     		add	r3, r3, r2
 8143 003c 5C33     		adds	r3, r3, #92
 8144 003e 1B78     		ldrb	r3, [r3]
 8145 0040 DBB2     		uxtb	r3, r3
 8146              		.loc 1 5282 15
 8147 0042 022B     		cmp	r3, #2
 8148 0044 08D1     		bne	.L495
5283:Lib/FreeRTOS/Source/tasks.c ****             {
5284:Lib/FreeRTOS/Source/tasks.c ****                 pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 8149              		.loc 1 5284 56
ARM GAS  /tmp/ccTFOe4z.s 			page 235


 8150 0046 BA68     		ldr	r2, [r7, #8]
 8151 0048 3B68     		ldr	r3, [r7]
 8152 004a 1344     		add	r3, r3, r2
 8153 004c 5C33     		adds	r3, r3, #92
 8154 004e 0022     		movs	r2, #0
 8155 0050 1A70     		strb	r2, [r3]
5285:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdPASS;
 8156              		.loc 1 5285 25
 8157 0052 0123     		movs	r3, #1
 8158 0054 FB60     		str	r3, [r7, #12]
 8159 0056 01E0     		b	.L496
 8160              	.L495:
5286:Lib/FreeRTOS/Source/tasks.c ****             }
5287:Lib/FreeRTOS/Source/tasks.c ****             else
5288:Lib/FreeRTOS/Source/tasks.c ****             {
5289:Lib/FreeRTOS/Source/tasks.c ****                 xReturn = pdFAIL;
 8161              		.loc 1 5289 25
 8162 0058 0023     		movs	r3, #0
 8163 005a FB60     		str	r3, [r7, #12]
 8164              	.L496:
5290:Lib/FreeRTOS/Source/tasks.c ****             }
5291:Lib/FreeRTOS/Source/tasks.c ****         }
5292:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 8165              		.loc 1 5292 9
 8166 005c FFF7FEFF 		bl	vPortExitCritical
5293:Lib/FreeRTOS/Source/tasks.c **** 
5294:Lib/FreeRTOS/Source/tasks.c ****         return xReturn;
 8167              		.loc 1 5294 16
 8168 0060 FB68     		ldr	r3, [r7, #12]
5295:Lib/FreeRTOS/Source/tasks.c ****     }
 8169              		.loc 1 5295 5
 8170 0062 1846     		mov	r0, r3
 8171 0064 1037     		adds	r7, r7, #16
 8172              		.cfi_def_cfa_offset 8
 8173 0066 BD46     		mov	sp, r7
 8174              		.cfi_def_cfa_register 13
 8175              		@ sp needed
 8176 0068 80BD     		pop	{r7, pc}
 8177              	.L499:
 8178 006a 00BF     		.align	2
 8179              	.L498:
 8180 006c 00000000 		.word	.LC0
 8181 0070 00000000 		.word	__func__.1
 8182 0074 04000000 		.word	.LC1
 8183 0078 00000000 		.word	pxCurrentTCB
 8184              		.cfi_endproc
 8185              	.LFE60:
 8187              		.section	.text.ulTaskGenericNotifyValueClear,"ax",%progbits
 8188              		.align	1
 8189              		.global	ulTaskGenericNotifyValueClear
 8190              		.syntax unified
 8191              		.thumb
 8192              		.thumb_func
 8194              	ulTaskGenericNotifyValueClear:
 8195              	.LFB61:
5296:Lib/FreeRTOS/Source/tasks.c **** 
5297:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
ARM GAS  /tmp/ccTFOe4z.s 			page 236


5298:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5299:Lib/FreeRTOS/Source/tasks.c **** 
5300:Lib/FreeRTOS/Source/tasks.c **** #if ( configUSE_TASK_NOTIFICATIONS == 1 )
5301:Lib/FreeRTOS/Source/tasks.c **** 
5302:Lib/FreeRTOS/Source/tasks.c ****     uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
5303:Lib/FreeRTOS/Source/tasks.c ****                                             UBaseType_t uxIndexToClear,
5304:Lib/FreeRTOS/Source/tasks.c ****                                             uint32_t ulBitsToClear )
5305:Lib/FreeRTOS/Source/tasks.c ****     {
 8196              		.loc 1 5305 5
 8197              		.cfi_startproc
 8198              		@ args = 0, pretend = 0, frame = 24
 8199              		@ frame_needed = 1, uses_anonymous_args = 0
 8200 0000 80B5     		push	{r7, lr}
 8201              		.cfi_def_cfa_offset 8
 8202              		.cfi_offset 7, -8
 8203              		.cfi_offset 14, -4
 8204 0002 86B0     		sub	sp, sp, #24
 8205              		.cfi_def_cfa_offset 32
 8206 0004 00AF     		add	r7, sp, #0
 8207              		.cfi_def_cfa_register 7
 8208 0006 F860     		str	r0, [r7, #12]
 8209 0008 B960     		str	r1, [r7, #8]
 8210 000a 7A60     		str	r2, [r7, #4]
5306:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5307:Lib/FreeRTOS/Source/tasks.c ****         uint32_t ulReturn;
5308:Lib/FreeRTOS/Source/tasks.c **** 
5309:Lib/FreeRTOS/Source/tasks.c ****         configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 8211              		.loc 1 5309 9
 8212 000c BB68     		ldr	r3, [r7, #8]
 8213 000e 002B     		cmp	r3, #0
 8214 0010 08D0     		beq	.L501
 8215              		.loc 1 5309 9 is_stmt 0 discriminator 1
 8216 0012 FFF7FEFF 		bl	ulSetInterruptMask
 8217 0016 164B     		ldr	r3, .L505
 8218 0018 164A     		ldr	r2, .L505+4
 8219 001a 41F2BD41 		movw	r1, #5309
 8220 001e 1648     		ldr	r0, .L505+8
 8221 0020 FFF7FEFF 		bl	__assert_func
 8222              	.L501:
5310:Lib/FreeRTOS/Source/tasks.c **** 
5311:Lib/FreeRTOS/Source/tasks.c ****         /* If null is passed in here then it is the calling task that is having
5312:Lib/FreeRTOS/Source/tasks.c ****          * its notification state cleared. */
5313:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
 8223              		.loc 1 5313 17 is_stmt 1
 8224 0024 FB68     		ldr	r3, [r7, #12]
 8225 0026 002B     		cmp	r3, #0
 8226 0028 02D1     		bne	.L502
 8227              		.loc 1 5313 17 is_stmt 0 discriminator 1
 8228 002a 144B     		ldr	r3, .L505+12
 8229 002c 1B68     		ldr	r3, [r3]
 8230 002e 00E0     		b	.L503
 8231              	.L502:
 8232              		.loc 1 5313 17 discriminator 2
 8233 0030 FB68     		ldr	r3, [r7, #12]
 8234              	.L503:
 8235              		.loc 1 5313 15 is_stmt 1 discriminator 4
 8236 0032 7B61     		str	r3, [r7, #20]
ARM GAS  /tmp/ccTFOe4z.s 			page 237


5314:Lib/FreeRTOS/Source/tasks.c **** 
5315:Lib/FreeRTOS/Source/tasks.c ****         taskENTER_CRITICAL();
 8237              		.loc 1 5315 9
 8238 0034 FFF7FEFF 		bl	vPortEnterCritical
5316:Lib/FreeRTOS/Source/tasks.c ****         {
5317:Lib/FreeRTOS/Source/tasks.c ****             /* Return the notification as it was before the bits were cleared,
5318:Lib/FreeRTOS/Source/tasks.c ****              * then clear the bit mask. */
5319:Lib/FreeRTOS/Source/tasks.c ****             ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 8239              		.loc 1 5319 22
 8240 0038 7B69     		ldr	r3, [r7, #20]
 8241 003a BA68     		ldr	r2, [r7, #8]
 8242 003c 1632     		adds	r2, r2, #22
 8243 003e 53F82230 		ldr	r3, [r3, r2, lsl #2]
 8244 0042 3B61     		str	r3, [r7, #16]
5320:Lib/FreeRTOS/Source/tasks.c ****             pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 8245              		.loc 1 5320 35
 8246 0044 7B69     		ldr	r3, [r7, #20]
 8247 0046 BA68     		ldr	r2, [r7, #8]
 8248 0048 1632     		adds	r2, r2, #22
 8249 004a 53F82220 		ldr	r2, [r3, r2, lsl #2]
 8250              		.loc 1 5320 57
 8251 004e 7B68     		ldr	r3, [r7, #4]
 8252 0050 DB43     		mvns	r3, r3
 8253              		.loc 1 5320 54
 8254 0052 02EA0301 		and	r1, r2, r3
 8255 0056 7B69     		ldr	r3, [r7, #20]
 8256 0058 BA68     		ldr	r2, [r7, #8]
 8257 005a 1632     		adds	r2, r2, #22
 8258 005c 43F82210 		str	r1, [r3, r2, lsl #2]
5321:Lib/FreeRTOS/Source/tasks.c ****         }
5322:Lib/FreeRTOS/Source/tasks.c ****         taskEXIT_CRITICAL();
 8259              		.loc 1 5322 9
 8260 0060 FFF7FEFF 		bl	vPortExitCritical
5323:Lib/FreeRTOS/Source/tasks.c **** 
5324:Lib/FreeRTOS/Source/tasks.c ****         return ulReturn;
 8261              		.loc 1 5324 16
 8262 0064 3B69     		ldr	r3, [r7, #16]
5325:Lib/FreeRTOS/Source/tasks.c ****     }
 8263              		.loc 1 5325 5
 8264 0066 1846     		mov	r0, r3
 8265 0068 1837     		adds	r7, r7, #24
 8266              		.cfi_def_cfa_offset 8
 8267 006a BD46     		mov	sp, r7
 8268              		.cfi_def_cfa_register 13
 8269              		@ sp needed
 8270 006c 80BD     		pop	{r7, pc}
 8271              	.L506:
 8272 006e 00BF     		.align	2
 8273              	.L505:
 8274 0070 00000000 		.word	.LC0
 8275 0074 00000000 		.word	__func__.0
 8276 0078 04000000 		.word	.LC1
 8277 007c 00000000 		.word	pxCurrentTCB
 8278              		.cfi_endproc
 8279              	.LFE61:
 8281              		.section	.text.ulTaskGetRunTimeCounter,"ax",%progbits
 8282              		.align	1
ARM GAS  /tmp/ccTFOe4z.s 			page 238


 8283              		.global	ulTaskGetRunTimeCounter
 8284              		.syntax unified
 8285              		.thumb
 8286              		.thumb_func
 8288              	ulTaskGetRunTimeCounter:
 8289              	.LFB62:
5326:Lib/FreeRTOS/Source/tasks.c **** 
5327:Lib/FreeRTOS/Source/tasks.c **** #endif /* configUSE_TASK_NOTIFICATIONS */
5328:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5329:Lib/FreeRTOS/Source/tasks.c **** 
5330:Lib/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
5331:Lib/FreeRTOS/Source/tasks.c **** 
5332:Lib/FreeRTOS/Source/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimeCounter( const TaskHandle_t xTask )
5333:Lib/FreeRTOS/Source/tasks.c ****     {
 8290              		.loc 1 5333 5
 8291              		.cfi_startproc
 8292              		@ args = 0, pretend = 0, frame = 8
 8293              		@ frame_needed = 1, uses_anonymous_args = 0
 8294              		@ link register save eliminated.
 8295 0000 80B4     		push	{r7}
 8296              		.cfi_def_cfa_offset 4
 8297              		.cfi_offset 7, -4
 8298 0002 83B0     		sub	sp, sp, #12
 8299              		.cfi_def_cfa_offset 16
 8300 0004 00AF     		add	r7, sp, #0
 8301              		.cfi_def_cfa_register 7
 8302 0006 7860     		str	r0, [r7, #4]
5334:Lib/FreeRTOS/Source/tasks.c ****         return xTask->ulRunTimeCounter;
 8303              		.loc 1 5334 21
 8304 0008 7B68     		ldr	r3, [r7, #4]
 8305 000a 5B6D     		ldr	r3, [r3, #84]
5335:Lib/FreeRTOS/Source/tasks.c ****     }
 8306              		.loc 1 5335 5
 8307 000c 1846     		mov	r0, r3
 8308 000e 0C37     		adds	r7, r7, #12
 8309              		.cfi_def_cfa_offset 4
 8310 0010 BD46     		mov	sp, r7
 8311              		.cfi_def_cfa_register 13
 8312              		@ sp needed
 8313 0012 5DF8047B 		ldr	r7, [sp], #4
 8314              		.cfi_restore 7
 8315              		.cfi_def_cfa_offset 0
 8316 0016 7047     		bx	lr
 8317              		.cfi_endproc
 8318              	.LFE62:
 8320              		.section	.text.ulTaskGetRunTimePercent,"ax",%progbits
 8321              		.align	1
 8322              		.global	ulTaskGetRunTimePercent
 8323              		.syntax unified
 8324              		.thumb
 8325              		.thumb_func
 8327              	ulTaskGetRunTimePercent:
 8328              	.LFB63:
5336:Lib/FreeRTOS/Source/tasks.c **** 
5337:Lib/FreeRTOS/Source/tasks.c **** #endif
5338:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5339:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 239


5340:Lib/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
5341:Lib/FreeRTOS/Source/tasks.c **** 
5342:Lib/FreeRTOS/Source/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetRunTimePercent( const TaskHandle_t xTask )
5343:Lib/FreeRTOS/Source/tasks.c ****     {
 8329              		.loc 1 5343 5
 8330              		.cfi_startproc
 8331              		@ args = 0, pretend = 0, frame = 16
 8332              		@ frame_needed = 1, uses_anonymous_args = 0
 8333 0000 80B5     		push	{r7, lr}
 8334              		.cfi_def_cfa_offset 8
 8335              		.cfi_offset 7, -8
 8336              		.cfi_offset 14, -4
 8337 0002 84B0     		sub	sp, sp, #16
 8338              		.cfi_def_cfa_offset 24
 8339 0004 00AF     		add	r7, sp, #0
 8340              		.cfi_def_cfa_register 7
 8341 0006 7860     		str	r0, [r7, #4]
5344:Lib/FreeRTOS/Source/tasks.c ****         configRUN_TIME_COUNTER_TYPE ulTotalTime, ulReturn;
5345:Lib/FreeRTOS/Source/tasks.c **** 
5346:Lib/FreeRTOS/Source/tasks.c ****         ulTotalTime = ( configRUN_TIME_COUNTER_TYPE ) portGET_RUN_TIME_COUNTER_VALUE();
 8342              		.loc 1 5346 55
 8343 0008 FFF7FEFF 		bl	TIM4_Get_Value
 8344 000c B860     		str	r0, [r7, #8]
5347:Lib/FreeRTOS/Source/tasks.c **** 
5348:Lib/FreeRTOS/Source/tasks.c ****         /* For percentage calculations. */
5349:Lib/FreeRTOS/Source/tasks.c ****         ulTotalTime /= ( configRUN_TIME_COUNTER_TYPE ) 100;
 8345              		.loc 1 5349 21
 8346 000e BB68     		ldr	r3, [r7, #8]
 8347 0010 0A4A     		ldr	r2, .L513
 8348 0012 A2FB0323 		umull	r2, r3, r2, r3
 8349 0016 5B09     		lsrs	r3, r3, #5
 8350 0018 BB60     		str	r3, [r7, #8]
5350:Lib/FreeRTOS/Source/tasks.c **** 
5351:Lib/FreeRTOS/Source/tasks.c ****         /* Avoid divide by zero errors. */
5352:Lib/FreeRTOS/Source/tasks.c ****         if( ulTotalTime > ( configRUN_TIME_COUNTER_TYPE ) 0 )
 8351              		.loc 1 5352 11
 8352 001a BB68     		ldr	r3, [r7, #8]
 8353 001c 002B     		cmp	r3, #0
 8354 001e 06D0     		beq	.L510
5353:Lib/FreeRTOS/Source/tasks.c ****         {
5354:Lib/FreeRTOS/Source/tasks.c ****             ulReturn = xTask->ulRunTimeCounter / ulTotalTime;
 8355              		.loc 1 5354 29
 8356 0020 7B68     		ldr	r3, [r7, #4]
 8357 0022 5A6D     		ldr	r2, [r3, #84]
 8358              		.loc 1 5354 22
 8359 0024 BB68     		ldr	r3, [r7, #8]
 8360 0026 B2FBF3F3 		udiv	r3, r2, r3
 8361 002a FB60     		str	r3, [r7, #12]
 8362 002c 01E0     		b	.L511
 8363              	.L510:
5355:Lib/FreeRTOS/Source/tasks.c ****         }
5356:Lib/FreeRTOS/Source/tasks.c ****         else
5357:Lib/FreeRTOS/Source/tasks.c ****         {
5358:Lib/FreeRTOS/Source/tasks.c ****             ulReturn = 0;
 8364              		.loc 1 5358 22
 8365 002e 0023     		movs	r3, #0
 8366 0030 FB60     		str	r3, [r7, #12]
ARM GAS  /tmp/ccTFOe4z.s 			page 240


 8367              	.L511:
5359:Lib/FreeRTOS/Source/tasks.c ****         }
5360:Lib/FreeRTOS/Source/tasks.c **** 
5361:Lib/FreeRTOS/Source/tasks.c ****         return ulReturn;
 8368              		.loc 1 5361 16
 8369 0032 FB68     		ldr	r3, [r7, #12]
5362:Lib/FreeRTOS/Source/tasks.c ****     }
 8370              		.loc 1 5362 5
 8371 0034 1846     		mov	r0, r3
 8372 0036 1037     		adds	r7, r7, #16
 8373              		.cfi_def_cfa_offset 8
 8374 0038 BD46     		mov	sp, r7
 8375              		.cfi_def_cfa_register 13
 8376              		@ sp needed
 8377 003a 80BD     		pop	{r7, pc}
 8378              	.L514:
 8379              		.align	2
 8380              	.L513:
 8381 003c 1F85EB51 		.word	1374389535
 8382              		.cfi_endproc
 8383              	.LFE63:
 8385              		.section	.text.ulTaskGetIdleRunTimeCounter,"ax",%progbits
 8386              		.align	1
 8387              		.global	ulTaskGetIdleRunTimeCounter
 8388              		.syntax unified
 8389              		.thumb
 8390              		.thumb_func
 8392              	ulTaskGetIdleRunTimeCounter:
 8393              	.LFB64:
5363:Lib/FreeRTOS/Source/tasks.c **** 
5364:Lib/FreeRTOS/Source/tasks.c **** #endif /* if ( configGENERATE_RUN_TIME_STATS == 1 ) */
5365:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5366:Lib/FreeRTOS/Source/tasks.c **** 
5367:Lib/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
5368:Lib/FreeRTOS/Source/tasks.c **** 
5369:Lib/FreeRTOS/Source/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimeCounter( void )
5370:Lib/FreeRTOS/Source/tasks.c ****     {
 8394              		.loc 1 5370 5
 8395              		.cfi_startproc
 8396              		@ args = 0, pretend = 0, frame = 0
 8397              		@ frame_needed = 1, uses_anonymous_args = 0
 8398 0000 80B5     		push	{r7, lr}
 8399              		.cfi_def_cfa_offset 8
 8400              		.cfi_offset 7, -8
 8401              		.cfi_offset 14, -4
 8402 0002 00AF     		add	r7, sp, #0
 8403              		.cfi_def_cfa_register 7
5371:Lib/FreeRTOS/Source/tasks.c ****         return ulTaskGetRunTimeCounter( xIdleTaskHandle );
 8404              		.loc 1 5371 16
 8405 0004 034B     		ldr	r3, .L517
 8406 0006 1B68     		ldr	r3, [r3]
 8407 0008 1846     		mov	r0, r3
 8408 000a FFF7FEFF 		bl	ulTaskGetRunTimeCounter
 8409 000e 0346     		mov	r3, r0
5372:Lib/FreeRTOS/Source/tasks.c ****     }
 8410              		.loc 1 5372 5
 8411 0010 1846     		mov	r0, r3
ARM GAS  /tmp/ccTFOe4z.s 			page 241


 8412 0012 80BD     		pop	{r7, pc}
 8413              	.L518:
 8414              		.align	2
 8415              	.L517:
 8416 0014 00000000 		.word	xIdleTaskHandle
 8417              		.cfi_endproc
 8418              	.LFE64:
 8420              		.section	.text.ulTaskGetIdleRunTimePercent,"ax",%progbits
 8421              		.align	1
 8422              		.global	ulTaskGetIdleRunTimePercent
 8423              		.syntax unified
 8424              		.thumb
 8425              		.thumb_func
 8427              	ulTaskGetIdleRunTimePercent:
 8428              	.LFB65:
5373:Lib/FreeRTOS/Source/tasks.c **** 
5374:Lib/FreeRTOS/Source/tasks.c **** #endif
5375:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5376:Lib/FreeRTOS/Source/tasks.c **** 
5377:Lib/FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
5378:Lib/FreeRTOS/Source/tasks.c **** 
5379:Lib/FreeRTOS/Source/tasks.c ****     configRUN_TIME_COUNTER_TYPE ulTaskGetIdleRunTimePercent( void )
5380:Lib/FreeRTOS/Source/tasks.c ****     {
 8429              		.loc 1 5380 5
 8430              		.cfi_startproc
 8431              		@ args = 0, pretend = 0, frame = 0
 8432              		@ frame_needed = 1, uses_anonymous_args = 0
 8433 0000 80B5     		push	{r7, lr}
 8434              		.cfi_def_cfa_offset 8
 8435              		.cfi_offset 7, -8
 8436              		.cfi_offset 14, -4
 8437 0002 00AF     		add	r7, sp, #0
 8438              		.cfi_def_cfa_register 7
5381:Lib/FreeRTOS/Source/tasks.c ****         return ulTaskGetRunTimePercent( xIdleTaskHandle );
 8439              		.loc 1 5381 16
 8440 0004 034B     		ldr	r3, .L521
 8441 0006 1B68     		ldr	r3, [r3]
 8442 0008 1846     		mov	r0, r3
 8443 000a FFF7FEFF 		bl	ulTaskGetRunTimePercent
 8444 000e 0346     		mov	r3, r0
5382:Lib/FreeRTOS/Source/tasks.c ****     }
 8445              		.loc 1 5382 5
 8446 0010 1846     		mov	r0, r3
 8447 0012 80BD     		pop	{r7, pc}
 8448              	.L522:
 8449              		.align	2
 8450              	.L521:
 8451 0014 00000000 		.word	xIdleTaskHandle
 8452              		.cfi_endproc
 8453              	.LFE65:
 8455              		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 8456              		.align	1
 8457              		.syntax unified
 8458              		.thumb
 8459              		.thumb_func
 8461              	prvAddCurrentTaskToDelayedList:
 8462              	.LFB66:
ARM GAS  /tmp/ccTFOe4z.s 			page 242


5383:Lib/FreeRTOS/Source/tasks.c **** 
5384:Lib/FreeRTOS/Source/tasks.c **** #endif
5385:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5386:Lib/FreeRTOS/Source/tasks.c **** 
5387:Lib/FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
5388:Lib/FreeRTOS/Source/tasks.c ****                                             const BaseType_t xCanBlockIndefinitely )
5389:Lib/FreeRTOS/Source/tasks.c **** {
 8463              		.loc 1 5389 1
 8464              		.cfi_startproc
 8465              		@ args = 0, pretend = 0, frame = 24
 8466              		@ frame_needed = 1, uses_anonymous_args = 0
 8467 0000 80B5     		push	{r7, lr}
 8468              		.cfi_def_cfa_offset 8
 8469              		.cfi_offset 7, -8
 8470              		.cfi_offset 14, -4
 8471 0002 86B0     		sub	sp, sp, #24
 8472              		.cfi_def_cfa_offset 32
 8473 0004 00AF     		add	r7, sp, #0
 8474              		.cfi_def_cfa_register 7
 8475 0006 7860     		str	r0, [r7, #4]
 8476 0008 3960     		str	r1, [r7]
5390:Lib/FreeRTOS/Source/tasks.c ****     TickType_t xTimeToWake;
5391:Lib/FreeRTOS/Source/tasks.c ****     const TickType_t xConstTickCount = xTickCount;
 8477              		.loc 1 5391 22
 8478 000a 2E4B     		ldr	r3, .L528
 8479 000c 1B68     		ldr	r3, [r3]
 8480 000e 7B61     		str	r3, [r7, #20]
5392:Lib/FreeRTOS/Source/tasks.c **** 
5393:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_xTaskAbortDelay == 1 )
5394:Lib/FreeRTOS/Source/tasks.c ****     {
5395:Lib/FreeRTOS/Source/tasks.c ****         /* About to enter a delayed list, so ensure the ucDelayAborted flag is
5396:Lib/FreeRTOS/Source/tasks.c ****          * reset to pdFALSE so it can be detected as having been set to pdTRUE
5397:Lib/FreeRTOS/Source/tasks.c ****          * when the task leaves the Blocked state. */
5398:Lib/FreeRTOS/Source/tasks.c ****         pxCurrentTCB->ucDelayAborted = pdFALSE;
5399:Lib/FreeRTOS/Source/tasks.c ****     }
5400:Lib/FreeRTOS/Source/tasks.c ****     #endif
5401:Lib/FreeRTOS/Source/tasks.c **** 
5402:Lib/FreeRTOS/Source/tasks.c ****     /* Remove the task from the ready list before adding it to the blocked list
5403:Lib/FreeRTOS/Source/tasks.c ****      * as the same list item is used for both lists. */
5404:Lib/FreeRTOS/Source/tasks.c ****     if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8481              		.loc 1 5404 38
 8482 0010 2D4B     		ldr	r3, .L528+4
 8483 0012 1B68     		ldr	r3, [r3]
 8484              		.loc 1 5404 9
 8485 0014 0433     		adds	r3, r3, #4
 8486 0016 1846     		mov	r0, r3
 8487 0018 FFF7FEFF 		bl	uxListRemove
5405:Lib/FreeRTOS/Source/tasks.c ****     {
5406:Lib/FreeRTOS/Source/tasks.c ****         /* The current task must be in a ready list, so there is no need to
5407:Lib/FreeRTOS/Source/tasks.c ****          * check, and the port reset macro can be called directly. */
5408:Lib/FreeRTOS/Source/tasks.c ****         portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCu
5409:Lib/FreeRTOS/Source/tasks.c ****     }
5410:Lib/FreeRTOS/Source/tasks.c ****     else
5411:Lib/FreeRTOS/Source/tasks.c ****     {
5412:Lib/FreeRTOS/Source/tasks.c ****         mtCOVERAGE_TEST_MARKER();
5413:Lib/FreeRTOS/Source/tasks.c ****     }
5414:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 243


5415:Lib/FreeRTOS/Source/tasks.c ****     #if ( INCLUDE_vTaskSuspend == 1 )
5416:Lib/FreeRTOS/Source/tasks.c ****     {
5417:Lib/FreeRTOS/Source/tasks.c ****         if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8488              		.loc 1 5417 11
 8489 001c 7B68     		ldr	r3, [r7, #4]
 8490 001e B3F1FF3F 		cmp	r3, #-1
 8491 0022 24D1     		bne	.L524
 8492              		.loc 1 5417 47 discriminator 1
 8493 0024 3B68     		ldr	r3, [r7]
 8494 0026 002B     		cmp	r3, #0
 8495 0028 21D0     		beq	.L524
 8496              	.LBB46:
5418:Lib/FreeRTOS/Source/tasks.c ****         {
5419:Lib/FreeRTOS/Source/tasks.c ****             /* Add the task to the suspended task list instead of a delayed task
5420:Lib/FreeRTOS/Source/tasks.c ****              * list to ensure it is not woken by a timing event.  It will block
5421:Lib/FreeRTOS/Source/tasks.c ****              * indefinitely. */
5422:Lib/FreeRTOS/Source/tasks.c ****             listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8497              		.loc 1 5422 13
 8498 002a 284B     		ldr	r3, .L528+8
 8499 002c 5B68     		ldr	r3, [r3, #4]
 8500 002e 3B61     		str	r3, [r7, #16]
 8501 0030 254B     		ldr	r3, .L528+4
 8502 0032 1B68     		ldr	r3, [r3]
 8503 0034 3A69     		ldr	r2, [r7, #16]
 8504 0036 9A60     		str	r2, [r3, #8]
 8505 0038 234B     		ldr	r3, .L528+4
 8506 003a 1B68     		ldr	r3, [r3]
 8507 003c 3A69     		ldr	r2, [r7, #16]
 8508 003e 9268     		ldr	r2, [r2, #8]
 8509 0040 DA60     		str	r2, [r3, #12]
 8510 0042 214B     		ldr	r3, .L528+4
 8511 0044 1A68     		ldr	r2, [r3]
 8512 0046 3B69     		ldr	r3, [r7, #16]
 8513 0048 9B68     		ldr	r3, [r3, #8]
 8514 004a 0432     		adds	r2, r2, #4
 8515 004c 5A60     		str	r2, [r3, #4]
 8516 004e 1E4B     		ldr	r3, .L528+4
 8517 0050 1B68     		ldr	r3, [r3]
 8518 0052 1A1D     		adds	r2, r3, #4
 8519 0054 3B69     		ldr	r3, [r7, #16]
 8520 0056 9A60     		str	r2, [r3, #8]
 8521 0058 1B4B     		ldr	r3, .L528+4
 8522 005a 1B68     		ldr	r3, [r3]
 8523 005c 1B4A     		ldr	r2, .L528+8
 8524 005e 5A61     		str	r2, [r3, #20]
 8525 0060 1A4B     		ldr	r3, .L528+8
 8526 0062 1B68     		ldr	r3, [r3]
 8527 0064 0133     		adds	r3, r3, #1
 8528 0066 194A     		ldr	r2, .L528+8
 8529 0068 1360     		str	r3, [r2]
 8530              	.LBE46:
 8531 006a 00BF     		nop
5423:Lib/FreeRTOS/Source/tasks.c ****         }
5424:Lib/FreeRTOS/Source/tasks.c ****         else
5425:Lib/FreeRTOS/Source/tasks.c ****         {
5426:Lib/FreeRTOS/Source/tasks.c ****             /* Calculate the time at which the task should be woken if the event
5427:Lib/FreeRTOS/Source/tasks.c ****              * does not occur.  This may overflow but this doesn't matter, the
ARM GAS  /tmp/ccTFOe4z.s 			page 244


5428:Lib/FreeRTOS/Source/tasks.c ****              * kernel will manage it correctly. */
5429:Lib/FreeRTOS/Source/tasks.c ****             xTimeToWake = xConstTickCount + xTicksToWait;
5430:Lib/FreeRTOS/Source/tasks.c **** 
5431:Lib/FreeRTOS/Source/tasks.c ****             /* The list item will be inserted in wake time order. */
5432:Lib/FreeRTOS/Source/tasks.c ****             listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5433:Lib/FreeRTOS/Source/tasks.c **** 
5434:Lib/FreeRTOS/Source/tasks.c ****             if( xTimeToWake < xConstTickCount )
5435:Lib/FreeRTOS/Source/tasks.c ****             {
5436:Lib/FreeRTOS/Source/tasks.c ****                 /* Wake time has overflowed.  Place this item in the overflow
5437:Lib/FreeRTOS/Source/tasks.c ****                  * list. */
5438:Lib/FreeRTOS/Source/tasks.c ****                 vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5439:Lib/FreeRTOS/Source/tasks.c ****             }
5440:Lib/FreeRTOS/Source/tasks.c ****             else
5441:Lib/FreeRTOS/Source/tasks.c ****             {
5442:Lib/FreeRTOS/Source/tasks.c ****                 /* The wake time has not overflowed, so the current block list
5443:Lib/FreeRTOS/Source/tasks.c ****                  * is used. */
5444:Lib/FreeRTOS/Source/tasks.c ****                 vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5445:Lib/FreeRTOS/Source/tasks.c **** 
5446:Lib/FreeRTOS/Source/tasks.c ****                 /* If the task entering the blocked state was placed at the
5447:Lib/FreeRTOS/Source/tasks.c ****                  * head of the list of blocked tasks then xNextTaskUnblockTime
5448:Lib/FreeRTOS/Source/tasks.c ****                  * needs to be updated too. */
5449:Lib/FreeRTOS/Source/tasks.c ****                 if( xTimeToWake < xNextTaskUnblockTime )
5450:Lib/FreeRTOS/Source/tasks.c ****                 {
5451:Lib/FreeRTOS/Source/tasks.c ****                     xNextTaskUnblockTime = xTimeToWake;
5452:Lib/FreeRTOS/Source/tasks.c ****                 }
5453:Lib/FreeRTOS/Source/tasks.c ****                 else
5454:Lib/FreeRTOS/Source/tasks.c ****                 {
5455:Lib/FreeRTOS/Source/tasks.c ****                     mtCOVERAGE_TEST_MARKER();
5456:Lib/FreeRTOS/Source/tasks.c ****                 }
5457:Lib/FreeRTOS/Source/tasks.c ****             }
5458:Lib/FreeRTOS/Source/tasks.c ****         }
5459:Lib/FreeRTOS/Source/tasks.c ****     }
5460:Lib/FreeRTOS/Source/tasks.c ****     #else /* INCLUDE_vTaskSuspend */
5461:Lib/FreeRTOS/Source/tasks.c ****     {
5462:Lib/FreeRTOS/Source/tasks.c ****         /* Calculate the time at which the task should be woken if the event
5463:Lib/FreeRTOS/Source/tasks.c ****          * does not occur.  This may overflow but this doesn't matter, the kernel
5464:Lib/FreeRTOS/Source/tasks.c ****          * will manage it correctly. */
5465:Lib/FreeRTOS/Source/tasks.c ****         xTimeToWake = xConstTickCount + xTicksToWait;
5466:Lib/FreeRTOS/Source/tasks.c **** 
5467:Lib/FreeRTOS/Source/tasks.c ****         /* The list item will be inserted in wake time order. */
5468:Lib/FreeRTOS/Source/tasks.c ****         listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
5469:Lib/FreeRTOS/Source/tasks.c **** 
5470:Lib/FreeRTOS/Source/tasks.c ****         if( xTimeToWake < xConstTickCount )
5471:Lib/FreeRTOS/Source/tasks.c ****         {
5472:Lib/FreeRTOS/Source/tasks.c ****             /* Wake time has overflowed.  Place this item in the overflow list. */
5473:Lib/FreeRTOS/Source/tasks.c ****             vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5474:Lib/FreeRTOS/Source/tasks.c ****         }
5475:Lib/FreeRTOS/Source/tasks.c ****         else
5476:Lib/FreeRTOS/Source/tasks.c ****         {
5477:Lib/FreeRTOS/Source/tasks.c ****             /* The wake time has not overflowed, so the current block list is used. */
5478:Lib/FreeRTOS/Source/tasks.c ****             vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
5479:Lib/FreeRTOS/Source/tasks.c **** 
5480:Lib/FreeRTOS/Source/tasks.c ****             /* If the task entering the blocked state was placed at the head of the
5481:Lib/FreeRTOS/Source/tasks.c ****              * list of blocked tasks then xNextTaskUnblockTime needs to be updated
5482:Lib/FreeRTOS/Source/tasks.c ****              * too. */
5483:Lib/FreeRTOS/Source/tasks.c ****             if( xTimeToWake < xNextTaskUnblockTime )
5484:Lib/FreeRTOS/Source/tasks.c ****             {
ARM GAS  /tmp/ccTFOe4z.s 			page 245


5485:Lib/FreeRTOS/Source/tasks.c ****                 xNextTaskUnblockTime = xTimeToWake;
5486:Lib/FreeRTOS/Source/tasks.c ****             }
5487:Lib/FreeRTOS/Source/tasks.c ****             else
5488:Lib/FreeRTOS/Source/tasks.c ****             {
5489:Lib/FreeRTOS/Source/tasks.c ****                 mtCOVERAGE_TEST_MARKER();
5490:Lib/FreeRTOS/Source/tasks.c ****             }
5491:Lib/FreeRTOS/Source/tasks.c ****         }
5492:Lib/FreeRTOS/Source/tasks.c **** 
5493:Lib/FreeRTOS/Source/tasks.c ****         /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
5494:Lib/FreeRTOS/Source/tasks.c ****         ( void ) xCanBlockIndefinitely;
5495:Lib/FreeRTOS/Source/tasks.c ****     }
5496:Lib/FreeRTOS/Source/tasks.c ****     #endif /* INCLUDE_vTaskSuspend */
5497:Lib/FreeRTOS/Source/tasks.c **** }
 8532              		.loc 1 5497 1
 8533 006c 26E0     		b	.L527
 8534              	.L524:
5429:Lib/FreeRTOS/Source/tasks.c **** 
 8535              		.loc 1 5429 25
 8536 006e 7A69     		ldr	r2, [r7, #20]
 8537 0070 7B68     		ldr	r3, [r7, #4]
 8538 0072 1344     		add	r3, r3, r2
 8539 0074 FB60     		str	r3, [r7, #12]
5432:Lib/FreeRTOS/Source/tasks.c **** 
 8540              		.loc 1 5432 13
 8541 0076 144B     		ldr	r3, .L528+4
 8542 0078 1B68     		ldr	r3, [r3]
 8543 007a FA68     		ldr	r2, [r7, #12]
 8544 007c 5A60     		str	r2, [r3, #4]
5434:Lib/FreeRTOS/Source/tasks.c ****             {
 8545              		.loc 1 5434 15
 8546 007e FA68     		ldr	r2, [r7, #12]
 8547 0080 7B69     		ldr	r3, [r7, #20]
 8548 0082 9A42     		cmp	r2, r3
 8549 0084 09D2     		bcs	.L526
5438:Lib/FreeRTOS/Source/tasks.c ****             }
 8550              		.loc 1 5438 17
 8551 0086 124B     		ldr	r3, .L528+12
 8552 0088 1A68     		ldr	r2, [r3]
5438:Lib/FreeRTOS/Source/tasks.c ****             }
 8553              		.loc 1 5438 72
 8554 008a 0F4B     		ldr	r3, .L528+4
 8555 008c 1B68     		ldr	r3, [r3]
5438:Lib/FreeRTOS/Source/tasks.c ****             }
 8556              		.loc 1 5438 17
 8557 008e 0433     		adds	r3, r3, #4
 8558 0090 1946     		mov	r1, r3
 8559 0092 1046     		mov	r0, r2
 8560 0094 FFF7FEFF 		bl	vListInsert
 8561              		.loc 1 5497 1
 8562 0098 10E0     		b	.L527
 8563              	.L526:
5444:Lib/FreeRTOS/Source/tasks.c **** 
 8564              		.loc 1 5444 17
 8565 009a 0E4B     		ldr	r3, .L528+16
 8566 009c 1A68     		ldr	r2, [r3]
5444:Lib/FreeRTOS/Source/tasks.c **** 
 8567              		.loc 1 5444 64
ARM GAS  /tmp/ccTFOe4z.s 			page 246


 8568 009e 0A4B     		ldr	r3, .L528+4
 8569 00a0 1B68     		ldr	r3, [r3]
5444:Lib/FreeRTOS/Source/tasks.c **** 
 8570              		.loc 1 5444 17
 8571 00a2 0433     		adds	r3, r3, #4
 8572 00a4 1946     		mov	r1, r3
 8573 00a6 1046     		mov	r0, r2
 8574 00a8 FFF7FEFF 		bl	vListInsert
5449:Lib/FreeRTOS/Source/tasks.c ****                 {
 8575              		.loc 1 5449 33
 8576 00ac 0A4B     		ldr	r3, .L528+20
 8577 00ae 1B68     		ldr	r3, [r3]
5449:Lib/FreeRTOS/Source/tasks.c ****                 {
 8578              		.loc 1 5449 19
 8579 00b0 FA68     		ldr	r2, [r7, #12]
 8580 00b2 9A42     		cmp	r2, r3
 8581 00b4 02D2     		bcs	.L527
5451:Lib/FreeRTOS/Source/tasks.c ****                 }
 8582              		.loc 1 5451 42
 8583 00b6 084A     		ldr	r2, .L528+20
 8584 00b8 FB68     		ldr	r3, [r7, #12]
 8585 00ba 1360     		str	r3, [r2]
 8586              	.L527:
 8587              		.loc 1 5497 1
 8588 00bc 00BF     		nop
 8589 00be 1837     		adds	r7, r7, #24
 8590              		.cfi_def_cfa_offset 8
 8591 00c0 BD46     		mov	sp, r7
 8592              		.cfi_def_cfa_register 13
 8593              		@ sp needed
 8594 00c2 80BD     		pop	{r7, pc}
 8595              	.L529:
 8596              		.align	2
 8597              	.L528:
 8598 00c4 00000000 		.word	xTickCount
 8599 00c8 00000000 		.word	pxCurrentTCB
 8600 00cc 00000000 		.word	xSuspendedTaskList
 8601 00d0 00000000 		.word	pxOverflowDelayedTaskList
 8602 00d4 00000000 		.word	pxDelayedTaskList
 8603 00d8 00000000 		.word	xNextTaskUnblockTime
 8604              		.cfi_endproc
 8605              	.LFE66:
 8607              		.section	.text.freertos_tasks_c_additions_init,"ax",%progbits
 8608              		.align	1
 8609              		.syntax unified
 8610              		.thumb
 8611              		.thumb_func
 8613              	freertos_tasks_c_additions_init:
 8614              	.LFB67:
5498:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5499:Lib/FreeRTOS/Source/tasks.c **** 
5500:Lib/FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
5501:Lib/FreeRTOS/Source/tasks.c **** 
5502:Lib/FreeRTOS/Source/tasks.c ****     xMPU_SETTINGS * xTaskGetMPUSettings( TaskHandle_t xTask )
5503:Lib/FreeRTOS/Source/tasks.c ****     {
5504:Lib/FreeRTOS/Source/tasks.c ****         TCB_t * pxTCB;
5505:Lib/FreeRTOS/Source/tasks.c **** 
ARM GAS  /tmp/ccTFOe4z.s 			page 247


5506:Lib/FreeRTOS/Source/tasks.c ****         pxTCB = prvGetTCBFromHandle( xTask );
5507:Lib/FreeRTOS/Source/tasks.c **** 
5508:Lib/FreeRTOS/Source/tasks.c ****         return &( pxTCB->xMPUSettings );
5509:Lib/FreeRTOS/Source/tasks.c ****     }
5510:Lib/FreeRTOS/Source/tasks.c **** 
5511:Lib/FreeRTOS/Source/tasks.c **** #endif /* portUSING_MPU_WRAPPERS */
5512:Lib/FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
5513:Lib/FreeRTOS/Source/tasks.c **** 
5514:Lib/FreeRTOS/Source/tasks.c **** /* Code below here allows additional code to be inserted into this source file,
5515:Lib/FreeRTOS/Source/tasks.c ****  * especially where access to file scope functions and data is needed (for example
5516:Lib/FreeRTOS/Source/tasks.c ****  * when performing module tests). */
5517:Lib/FreeRTOS/Source/tasks.c **** 
5518:Lib/FreeRTOS/Source/tasks.c **** #ifdef FREERTOS_MODULE_TEST
5519:Lib/FreeRTOS/Source/tasks.c ****     #include "tasks_test_access_functions.h"
5520:Lib/FreeRTOS/Source/tasks.c **** #endif
5521:Lib/FreeRTOS/Source/tasks.c **** 
5522:Lib/FreeRTOS/Source/tasks.c **** 
5523:Lib/FreeRTOS/Source/tasks.c **** #if ( configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H == 1 )
5524:Lib/FreeRTOS/Source/tasks.c **** 
5525:Lib/FreeRTOS/Source/tasks.c ****     #include "freertos_tasks_c_additions.h"
5526:Lib/FreeRTOS/Source/tasks.c **** 
5527:Lib/FreeRTOS/Source/tasks.c ****     #ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
5528:Lib/FreeRTOS/Source/tasks.c ****         static void freertos_tasks_c_additions_init( void )
5529:Lib/FreeRTOS/Source/tasks.c ****         {
 8615              		.loc 1 5529 9
 8616              		.cfi_startproc
 8617              		@ args = 0, pretend = 0, frame = 0
 8618              		@ frame_needed = 1, uses_anonymous_args = 0
 8619 0000 80B5     		push	{r7, lr}
 8620              		.cfi_def_cfa_offset 8
 8621              		.cfi_offset 7, -8
 8622              		.cfi_offset 14, -4
 8623 0002 00AF     		add	r7, sp, #0
 8624              		.cfi_def_cfa_register 7
5530:Lib/FreeRTOS/Source/tasks.c ****             FREERTOS_TASKS_C_ADDITIONS_INIT();
 8625              		.loc 1 5530 13
 8626 0004 FFF7FEFF 		bl	freertos_libc_init
5531:Lib/FreeRTOS/Source/tasks.c ****         }
 8627              		.loc 1 5531 9
 8628 0008 00BF     		nop
 8629 000a 80BD     		pop	{r7, pc}
 8630              		.cfi_endproc
 8631              	.LFE67:
 8633              		.section	.rodata.__func__.34,"a"
 8634              		.align	2
 8637              	__func__.34:
 8638 0000 78546173 		.ascii	"xTaskCreateStatic\000"
 8638      6B437265 
 8638      61746553 
 8638      74617469 
 8638      6300
 8639              		.section	.rodata.__func__.33,"a"
 8640              		.align	2
 8643              	__func__.33:
 8644 0000 70727649 		.ascii	"prvInitialiseNewTask\000"
 8644      6E697469 
 8644      616C6973 
ARM GAS  /tmp/ccTFOe4z.s 			page 248


 8644      654E6577 
 8644      5461736B 
 8645              		.section	.rodata.__func__.32,"a"
 8646              		.align	2
 8649              	__func__.32:
 8650 0000 76546173 		.ascii	"vTaskDelete\000"
 8650      6B44656C 
 8650      65746500 
 8651              		.section	.rodata.__func__.31,"a"
 8652              		.align	2
 8655              	__func__.31:
 8656 0000 78546173 		.ascii	"xTaskDelayUntil\000"
 8656      6B44656C 
 8656      6179556E 
 8656      74696C00 
 8657              		.section	.rodata.__func__.30,"a"
 8658              		.align	2
 8661              	__func__.30:
 8662 0000 76546173 		.ascii	"vTaskDelay\000"
 8662      6B44656C 
 8662      617900
 8663              		.section	.rodata.__func__.29,"a"
 8664              		.align	2
 8667              	__func__.29:
 8668 0000 65546173 		.ascii	"eTaskGetState\000"
 8668      6B476574 
 8668      53746174 
 8668      6500
 8669              		.section	.rodata.__func__.28,"a"
 8670              		.align	2
 8673              	__func__.28:
 8674 0000 76546173 		.ascii	"vTaskPrioritySet\000"
 8674      6B507269 
 8674      6F726974 
 8674      79536574 
 8674      00
 8675              		.section	.rodata.__func__.27,"a"
 8676              		.align	2
 8679              	__func__.27:
 8680 0000 76546173 		.ascii	"vTaskSuspend\000"
 8680      6B537573 
 8680      70656E64 
 8680      00
 8681              		.section	.rodata.__func__.26,"a"
 8682              		.align	2
 8685              	__func__.26:
 8686 0000 70727654 		.ascii	"prvTaskIsTaskSuspended\000"
 8686      61736B49 
 8686      73546173 
 8686      6B537573 
 8686      70656E64 
 8687              		.section	.rodata.__func__.25,"a"
 8688              		.align	2
 8691              	__func__.25:
 8692 0000 76546173 		.ascii	"vTaskResume\000"
 8692      6B526573 
 8692      756D6500 
ARM GAS  /tmp/ccTFOe4z.s 			page 249


 8693              		.section	.rodata.__func__.24,"a"
 8694              		.align	2
 8697              	__func__.24:
 8698 0000 78546173 		.ascii	"xTaskResumeFromISR\000"
 8698      6B526573 
 8698      756D6546 
 8698      726F6D49 
 8698      535200
 8699              		.section	.rodata.__func__.23,"a"
 8700              		.align	2
 8703              	__func__.23:
 8704 0000 76546173 		.ascii	"vTaskStartScheduler\000"
 8704      6B537461 
 8704      72745363 
 8704      68656475 
 8704      6C657200 
 8705              		.section	.rodata.__func__.22,"a"
 8706              		.align	2
 8709              	__func__.22:
 8710 0000 78546173 		.ascii	"xTaskResumeAll\000"
 8710      6B526573 
 8710      756D6541 
 8710      6C6C00
 8711              		.section	.rodata.__func__.21,"a"
 8712              		.align	2
 8715              	__func__.21:
 8716 0000 70635461 		.ascii	"pcTaskGetName\000"
 8716      736B4765 
 8716      744E616D 
 8716      6500
 8717              		.section	.rodata.__func__.20,"a"
 8718              		.align	2
 8721              	__func__.20:
 8722 0000 78546173 		.ascii	"xTaskGetStaticBuffers\000"
 8722      6B476574 
 8722      53746174 
 8722      69634275 
 8722      66666572 
 8723              		.section	.rodata.__func__.19,"a"
 8724              		.align	2
 8727              	__func__.19:
 8728 0000 78546173 		.ascii	"xTaskGetIdleTaskHandle\000"
 8728      6B476574 
 8728      49646C65 
 8728      5461736B 
 8728      48616E64 
 8729              		.section	.rodata.__func__.18,"a"
 8730              		.align	2
 8733              	__func__.18:
 8734 0000 78546173 		.ascii	"xTaskCatchUpTicks\000"
 8734      6B436174 
 8734      63685570 
 8734      5469636B 
 8734      7300
 8735              		.section	.rodata.__func__.17,"a"
 8736              		.align	2
 8739              	__func__.17:
ARM GAS  /tmp/ccTFOe4z.s 			page 250


 8740 0000 78546173 		.ascii	"xTaskIncrementTick\000"
 8740      6B496E63 
 8740      72656D65 
 8740      6E745469 
 8740      636B00
 8741              		.section	.rodata.__func__.16,"a"
 8742              		.align	2
 8745              	__func__.16:
 8746 0000 76546173 		.ascii	"vTaskSwitchContext\000"
 8746      6B537769 
 8746      74636843 
 8746      6F6E7465 
 8746      787400
 8747              		.section	.rodata.__func__.15,"a"
 8748              		.align	2
 8751              	__func__.15:
 8752 0000 76546173 		.ascii	"vTaskPlaceOnEventList\000"
 8752      6B506C61 
 8752      63654F6E 
 8752      4576656E 
 8752      744C6973 
 8753              		.section	.rodata.__func__.14,"a"
 8754              		.align	2
 8757              	__func__.14:
 8758 0000 76546173 		.ascii	"vTaskPlaceOnUnorderedEventList\000"
 8758      6B506C61 
 8758      63654F6E 
 8758      556E6F72 
 8758      64657265 
 8759              		.section	.rodata.__func__.13,"a"
 8760              		.align	2
 8763              	__func__.13:
 8764 0000 76546173 		.ascii	"vTaskPlaceOnEventListRestricted\000"
 8764      6B506C61 
 8764      63654F6E 
 8764      4576656E 
 8764      744C6973 
 8765              		.section	.rodata.__func__.12,"a"
 8766              		.align	2
 8769              	__func__.12:
 8770 0000 78546173 		.ascii	"xTaskRemoveFromEventList\000"
 8770      6B52656D 
 8770      6F766546 
 8770      726F6D45 
 8770      76656E74 
 8771              		.section	.rodata.__func__.11,"a"
 8772              		.align	2
 8775              	__func__.11:
 8776 0000 76546173 		.ascii	"vTaskRemoveFromUnorderedEventList\000"
 8776      6B52656D 
 8776      6F766546 
 8776      726F6D55 
 8776      6E6F7264 
 8777              		.section	.rodata.__func__.10,"a"
 8778              		.align	2
 8781              	__func__.10:
 8782 0000 76546173 		.ascii	"vTaskSetTimeOutState\000"
ARM GAS  /tmp/ccTFOe4z.s 			page 251


 8782      6B536574 
 8782      54696D65 
 8782      4F757453 
 8782      74617465 
 8783              		.section	.rodata.__func__.9,"a"
 8784              		.align	2
 8787              	__func__.9:
 8788 0000 78546173 		.ascii	"xTaskCheckForTimeOut\000"
 8788      6B436865 
 8788      636B466F 
 8788      7254696D 
 8788      654F7574 
 8789              		.section	.rodata.__func__.8,"a"
 8790              		.align	2
 8793              	__func__.8:
 8794 0000 78546173 		.ascii	"xTaskPriorityDisinherit\000"
 8794      6B507269 
 8794      6F726974 
 8794      79446973 
 8794      696E6865 
 8795              		.section	.rodata.__func__.7,"a"
 8796              		.align	2
 8799              	__func__.7:
 8800 0000 76546173 		.ascii	"vTaskPriorityDisinheritAfterTimeout\000"
 8800      6B507269 
 8800      6F726974 
 8800      79446973 
 8800      696E6865 
 8801              		.section	.rodata.__func__.6,"a"
 8802              		.align	2
 8805              	__func__.6:
 8806 0000 756C5461 		.ascii	"ulTaskGenericNotifyTake\000"
 8806      736B4765 
 8806      6E657269 
 8806      634E6F74 
 8806      69667954 
 8807              		.section	.rodata.__func__.5,"a"
 8808              		.align	2
 8811              	__func__.5:
 8812 0000 78546173 		.ascii	"xTaskGenericNotifyWait\000"
 8812      6B47656E 
 8812      65726963 
 8812      4E6F7469 
 8812      66795761 
 8813              		.section	.rodata.__func__.4,"a"
 8814              		.align	2
 8817              	__func__.4:
 8818 0000 78546173 		.ascii	"xTaskGenericNotify\000"
 8818      6B47656E 
 8818      65726963 
 8818      4E6F7469 
 8818      667900
 8819              		.section	.rodata.__func__.3,"a"
 8820              		.align	2
 8823              	__func__.3:
 8824 0000 78546173 		.ascii	"xTaskGenericNotifyFromISR\000"
 8824      6B47656E 
ARM GAS  /tmp/ccTFOe4z.s 			page 252


 8824      65726963 
 8824      4E6F7469 
 8824      66794672 
 8825              		.section	.rodata.__func__.2,"a"
 8826              		.align	2
 8829              	__func__.2:
 8830 0000 76546173 		.ascii	"vTaskGenericNotifyGiveFromISR\000"
 8830      6B47656E 
 8830      65726963 
 8830      4E6F7469 
 8830      66794769 
 8831              		.section	.rodata.__func__.1,"a"
 8832              		.align	2
 8835              	__func__.1:
 8836 0000 78546173 		.ascii	"xTaskGenericNotifyStateClear\000"
 8836      6B47656E 
 8836      65726963 
 8836      4E6F7469 
 8836      66795374 
 8837              		.section	.rodata.__func__.0,"a"
 8838              		.align	2
 8841              	__func__.0:
 8842 0000 756C5461 		.ascii	"ulTaskGenericNotifyValueClear\000"
 8842      736B4765 
 8842      6E657269 
 8842      634E6F74 
 8842      69667956 
 8843              		.text
 8844              	.Letext0:
 8845              		.file 2 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 8846              		.file 3 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 8847              		.file 4 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 8848              		.file 5 "Lib/FreeRTOS/Source/include/projdefs.h"
 8849              		.file 6 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 8850              		.file 7 "Lib/FreeRTOS/Source/include/FreeRTOS.h"
 8851              		.file 8 "Lib/FreeRTOS/Source/include/list.h"
 8852              		.file 9 "Lib/FreeRTOS/Source/include/task.h"
 8853              		.file 10 "Inc/freertos_tasks_c_additions.h"
 8854              		.file 11 "Lib/FreeRTOS/Source/include/portable.h"
 8855              		.file 12 "Inc/FreeRTOSConfig.h"
 8856              		.file 13 "Lib/FreeRTOS/Source/include/timers.h"
 8857              		.file 14 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 8858              		.file 15 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
ARM GAS  /tmp/ccTFOe4z.s 			page 253


DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccTFOe4z.s:30     .bss.pxCurrentTCB:00000000 pxCurrentTCB
     /tmp/ccTFOe4z.s:27     .bss.pxCurrentTCB:00000000 $d
     /tmp/ccTFOe4z.s:33     .bss.pxReadyTasksLists:00000000 $d
     /tmp/ccTFOe4z.s:36     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
     /tmp/ccTFOe4z.s:39     .bss.xDelayedTaskList1:00000000 $d
     /tmp/ccTFOe4z.s:42     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
     /tmp/ccTFOe4z.s:45     .bss.xDelayedTaskList2:00000000 $d
     /tmp/ccTFOe4z.s:48     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
     /tmp/ccTFOe4z.s:51     .bss.pxDelayedTaskList:00000000 $d
     /tmp/ccTFOe4z.s:54     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
     /tmp/ccTFOe4z.s:57     .bss.pxOverflowDelayedTaskList:00000000 $d
     /tmp/ccTFOe4z.s:60     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
     /tmp/ccTFOe4z.s:63     .bss.xPendingReadyList:00000000 $d
     /tmp/ccTFOe4z.s:66     .bss.xPendingReadyList:00000000 xPendingReadyList
     /tmp/ccTFOe4z.s:69     .bss.xTasksWaitingTermination:00000000 $d
     /tmp/ccTFOe4z.s:72     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
     /tmp/ccTFOe4z.s:75     .bss.uxDeletedTasksWaitingCleanUp:00000000 $d
     /tmp/ccTFOe4z.s:78     .bss.uxDeletedTasksWaitingCleanUp:00000000 uxDeletedTasksWaitingCleanUp
     /tmp/ccTFOe4z.s:81     .bss.xSuspendedTaskList:00000000 $d
     /tmp/ccTFOe4z.s:84     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
     /tmp/ccTFOe4z.s:87     .bss.uxCurrentNumberOfTasks:00000000 $d
     /tmp/ccTFOe4z.s:90     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
     /tmp/ccTFOe4z.s:93     .bss.xTickCount:00000000 $d
     /tmp/ccTFOe4z.s:96     .bss.xTickCount:00000000 xTickCount
     /tmp/ccTFOe4z.s:99     .bss.uxTopReadyPriority:00000000 $d
     /tmp/ccTFOe4z.s:102    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
     /tmp/ccTFOe4z.s:105    .bss.xSchedulerRunning:00000000 $d
     /tmp/ccTFOe4z.s:108    .bss.xSchedulerRunning:00000000 xSchedulerRunning
     /tmp/ccTFOe4z.s:111    .bss.xPendedTicks:00000000 $d
     /tmp/ccTFOe4z.s:114    .bss.xPendedTicks:00000000 xPendedTicks
     /tmp/ccTFOe4z.s:117    .bss.xYieldPending:00000000 $d
     /tmp/ccTFOe4z.s:120    .bss.xYieldPending:00000000 xYieldPending
     /tmp/ccTFOe4z.s:123    .bss.xNumOfOverflows:00000000 $d
     /tmp/ccTFOe4z.s:126    .bss.xNumOfOverflows:00000000 xNumOfOverflows
     /tmp/ccTFOe4z.s:129    .bss.uxTaskNumber:00000000 $d
     /tmp/ccTFOe4z.s:132    .bss.uxTaskNumber:00000000 uxTaskNumber
     /tmp/ccTFOe4z.s:135    .bss.xNextTaskUnblockTime:00000000 $d
     /tmp/ccTFOe4z.s:138    .bss.xNextTaskUnblockTime:00000000 xNextTaskUnblockTime
     /tmp/ccTFOe4z.s:141    .bss.xIdleTaskHandle:00000000 $d
     /tmp/ccTFOe4z.s:144    .bss.xIdleTaskHandle:00000000 xIdleTaskHandle
     /tmp/ccTFOe4z.s:151    .rodata.uxTopUsedPriority:00000000 uxTopUsedPriority
     /tmp/ccTFOe4z.s:148    .rodata.uxTopUsedPriority:00000000 $d
     /tmp/ccTFOe4z.s:154    .bss.uxSchedulerSuspended:00000000 $d
     /tmp/ccTFOe4z.s:157    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
     /tmp/ccTFOe4z.s:160    .bss.ulTaskSwitchedInTime:00000000 $d
     /tmp/ccTFOe4z.s:163    .bss.ulTaskSwitchedInTime:00000000 ulTaskSwitchedInTime
     /tmp/ccTFOe4z.s:166    .bss.ulTotalRunTime:00000000 $d
     /tmp/ccTFOe4z.s:169    .bss.ulTotalRunTime:00000000 ulTotalRunTime
     /tmp/ccTFOe4z.s:172    .rodata:00000000 $d
     /tmp/ccTFOe4z.s:179    .text.xTaskCreateStatic:00000000 $t
     /tmp/ccTFOe4z.s:185    .text.xTaskCreateStatic:00000000 xTaskCreateStatic
     /tmp/ccTFOe4z.s:314    .text.prvInitialiseNewTask:00000000 prvInitialiseNewTask
     /tmp/ccTFOe4z.s:514    .text.prvAddNewTaskToReadyList:00000000 prvAddNewTaskToReadyList
     /tmp/ccTFOe4z.s:302    .text.xTaskCreateStatic:000000b0 $d
     /tmp/ccTFOe4z.s:8637   .rodata.__func__.34:00000000 __func__.34
ARM GAS  /tmp/ccTFOe4z.s 			page 254


     /tmp/ccTFOe4z.s:309    .text.prvInitialiseNewTask:00000000 $t
     /tmp/ccTFOe4z.s:502    .text.prvInitialiseNewTask:00000118 $d
     /tmp/ccTFOe4z.s:8643   .rodata.__func__.33:00000000 __func__.33
     /tmp/ccTFOe4z.s:509    .text.prvAddNewTaskToReadyList:00000000 $t
     /tmp/ccTFOe4z.s:5222   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
     /tmp/ccTFOe4z.s:691    .text.prvAddNewTaskToReadyList:00000108 $d
     /tmp/ccTFOe4z.s:701    .text.vTaskDelete:00000000 $t
     /tmp/ccTFOe4z.s:707    .text.vTaskDelete:00000000 vTaskDelete
     /tmp/ccTFOe4z.s:5863   .text.prvResetNextTaskUnblockTime:00000000 prvResetNextTaskUnblockTime
     /tmp/ccTFOe4z.s:5828   .text.prvDeleteTCB:00000000 prvDeleteTCB
     /tmp/ccTFOe4z.s:844    .text.vTaskDelete:000000c0 $d
     /tmp/ccTFOe4z.s:8649   .rodata.__func__.32:00000000 __func__.32
     /tmp/ccTFOe4z.s:858    .text.xTaskDelayUntil:00000000 $t
     /tmp/ccTFOe4z.s:864    .text.xTaskDelayUntil:00000000 xTaskDelayUntil
     /tmp/ccTFOe4z.s:2489   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
     /tmp/ccTFOe4z.s:8461   .text.prvAddCurrentTaskToDelayedList:00000000 prvAddCurrentTaskToDelayedList
     /tmp/ccTFOe4z.s:2531   .text.xTaskResumeAll:00000000 xTaskResumeAll
     /tmp/ccTFOe4z.s:1015   .text.xTaskDelayUntil:000000d8 $d
     /tmp/ccTFOe4z.s:8655   .rodata.__func__.31:00000000 __func__.31
     /tmp/ccTFOe4z.s:1024   .text.vTaskDelay:00000000 $t
     /tmp/ccTFOe4z.s:1030   .text.vTaskDelay:00000000 vTaskDelay
     /tmp/ccTFOe4z.s:1093   .text.vTaskDelay:00000050 $d
     /tmp/ccTFOe4z.s:8661   .rodata.__func__.30:00000000 __func__.30
     /tmp/ccTFOe4z.s:1101   .text.eTaskGetState:00000000 $t
     /tmp/ccTFOe4z.s:1107   .text.eTaskGetState:00000000 eTaskGetState
     /tmp/ccTFOe4z.s:1281   .text.eTaskGetState:000000f0 $d
     /tmp/ccTFOe4z.s:8667   .rodata.__func__.29:00000000 __func__.29
     /tmp/ccTFOe4z.s:1294   .text.uxTaskPriorityGet:00000000 $t
     /tmp/ccTFOe4z.s:1300   .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
     /tmp/ccTFOe4z.s:1350   .text.uxTaskPriorityGet:00000030 $d
     /tmp/ccTFOe4z.s:1355   .text.uxTaskPriorityGetFromISR:00000000 $t
     /tmp/ccTFOe4z.s:1361   .text.uxTaskPriorityGetFromISR:00000000 uxTaskPriorityGetFromISR
     /tmp/ccTFOe4z.s:1415   .text.uxTaskPriorityGetFromISR:00000038 $d
     /tmp/ccTFOe4z.s:1420   .text.vTaskPrioritySet:00000000 $t
     /tmp/ccTFOe4z.s:1426   .text.vTaskPrioritySet:00000000 vTaskPrioritySet
     /tmp/ccTFOe4z.s:1669   .text.vTaskPrioritySet:0000016c $d
     /tmp/ccTFOe4z.s:8673   .rodata.__func__.28:00000000 __func__.28
     /tmp/ccTFOe4z.s:1679   .text.vTaskSuspend:00000000 $t
     /tmp/ccTFOe4z.s:1685   .text.vTaskSuspend:00000000 vTaskSuspend
     /tmp/ccTFOe4z.s:3812   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
     /tmp/ccTFOe4z.s:1850   .text.vTaskSuspend:000000dc $d
     /tmp/ccTFOe4z.s:8679   .rodata.__func__.27:00000000 __func__.27
     /tmp/ccTFOe4z.s:1862   .text.prvTaskIsTaskSuspended:00000000 $t
     /tmp/ccTFOe4z.s:1867   .text.prvTaskIsTaskSuspended:00000000 prvTaskIsTaskSuspended
     /tmp/ccTFOe4z.s:1937   .text.prvTaskIsTaskSuspended:00000054 $d
     /tmp/ccTFOe4z.s:8685   .rodata.__func__.26:00000000 __func__.26
     /tmp/ccTFOe4z.s:1946   .text.vTaskResume:00000000 $t
     /tmp/ccTFOe4z.s:1952   .text.vTaskResume:00000000 vTaskResume
     /tmp/ccTFOe4z.s:2104   .text.vTaskResume:000000ec $d
     /tmp/ccTFOe4z.s:8691   .rodata.__func__.25:00000000 __func__.25
     /tmp/ccTFOe4z.s:2114   .text.xTaskResumeFromISR:00000000 $t
     /tmp/ccTFOe4z.s:2120   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
     /tmp/ccTFOe4z.s:2289   .text.xTaskResumeFromISR:00000108 $d
     /tmp/ccTFOe4z.s:8697   .rodata.__func__.24:00000000 __func__.24
     /tmp/ccTFOe4z.s:2306   .text.vTaskStartScheduler:00000000 $t
     /tmp/ccTFOe4z.s:2312   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
     /tmp/ccTFOe4z.s:8613   .text.freertos_tasks_c_additions_init:00000000 freertos_tasks_c_additions_init
ARM GAS  /tmp/ccTFOe4z.s 			page 255


     /tmp/ccTFOe4z.s:2432   .text.vTaskStartScheduler:000000ac $d
     /tmp/ccTFOe4z.s:5181   .text.prvIdleTask:00000000 prvIdleTask
     /tmp/ccTFOe4z.s:8703   .rodata.__func__.23:00000000 __func__.23
     /tmp/ccTFOe4z.s:2446   .text.vTaskEndScheduler:00000000 $t
     /tmp/ccTFOe4z.s:2452   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
     /tmp/ccTFOe4z.s:2478   .text.vTaskEndScheduler:00000018 $d
     /tmp/ccTFOe4z.s:2483   .text.vTaskSuspendAll:00000000 $t
     /tmp/ccTFOe4z.s:2520   .text.vTaskSuspendAll:00000018 $d
     /tmp/ccTFOe4z.s:2525   .text.xTaskResumeAll:00000000 $t
     /tmp/ccTFOe4z.s:3454   .text.xTaskIncrementTick:00000000 xTaskIncrementTick
     /tmp/ccTFOe4z.s:2828   .text.xTaskResumeAll:000001c4 $d
     /tmp/ccTFOe4z.s:8709   .rodata.__func__.22:00000000 __func__.22
     /tmp/ccTFOe4z.s:2843   .text.xTaskGetTickCount:00000000 $t
     /tmp/ccTFOe4z.s:2849   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
     /tmp/ccTFOe4z.s:2883   .text.xTaskGetTickCount:0000001c $d
     /tmp/ccTFOe4z.s:2888   .text.xTaskGetTickCountFromISR:00000000 $t
     /tmp/ccTFOe4z.s:2894   .text.xTaskGetTickCountFromISR:00000000 xTaskGetTickCountFromISR
     /tmp/ccTFOe4z.s:2930   .text.xTaskGetTickCountFromISR:00000020 $d
     /tmp/ccTFOe4z.s:2935   .text.uxTaskGetNumberOfTasks:00000000 $t
     /tmp/ccTFOe4z.s:2941   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
     /tmp/ccTFOe4z.s:2968   .text.uxTaskGetNumberOfTasks:00000014 $d
     /tmp/ccTFOe4z.s:2973   .text.pcTaskGetName:00000000 $t
     /tmp/ccTFOe4z.s:2979   .text.pcTaskGetName:00000000 pcTaskGetName
     /tmp/ccTFOe4z.s:3034   .text.pcTaskGetName:0000003c $d
     /tmp/ccTFOe4z.s:8715   .rodata.__func__.21:00000000 __func__.21
     /tmp/ccTFOe4z.s:3042   .text.xTaskGetStaticBuffers:00000000 $t
     /tmp/ccTFOe4z.s:3048   .text.xTaskGetStaticBuffers:00000000 xTaskGetStaticBuffers
     /tmp/ccTFOe4z.s:3129   .text.xTaskGetStaticBuffers:00000068 $d
     /tmp/ccTFOe4z.s:8721   .rodata.__func__.20:00000000 __func__.20
     /tmp/ccTFOe4z.s:3137   .text.uxTaskGetSystemState:00000000 $t
     /tmp/ccTFOe4z.s:3143   .text.uxTaskGetSystemState:00000000 uxTaskGetSystemState
     /tmp/ccTFOe4z.s:5577   .text.prvListTasksWithinSingleList:00000000 prvListTasksWithinSingleList
     /tmp/ccTFOe4z.s:3318   .text.uxTaskGetSystemState:00000108 $d
     /tmp/ccTFOe4z.s:3328   .text.xTaskGetIdleTaskHandle:00000000 $t
     /tmp/ccTFOe4z.s:3334   .text.xTaskGetIdleTaskHandle:00000000 xTaskGetIdleTaskHandle
     /tmp/ccTFOe4z.s:3368   .text.xTaskGetIdleTaskHandle:00000028 $d
     /tmp/ccTFOe4z.s:8727   .rodata.__func__.19:00000000 __func__.19
     /tmp/ccTFOe4z.s:3376   .text.xTaskCatchUpTicks:00000000 $t
     /tmp/ccTFOe4z.s:3382   .text.xTaskCatchUpTicks:00000000 xTaskCatchUpTicks
     /tmp/ccTFOe4z.s:3439   .text.xTaskCatchUpTicks:0000004c $d
     /tmp/ccTFOe4z.s:8733   .rodata.__func__.18:00000000 __func__.18
     /tmp/ccTFOe4z.s:3448   .text.xTaskIncrementTick:00000000 $t
     /tmp/ccTFOe4z.s:3788   .text.xTaskIncrementTick:00000200 $d
     /tmp/ccTFOe4z.s:8739   .rodata.__func__.17:00000000 __func__.17
     /tmp/ccTFOe4z.s:3806   .text.vTaskSwitchContext:00000000 $t
     /tmp/ccTFOe4z.s:3962   .text.vTaskSwitchContext:000000d0 $d
     /tmp/ccTFOe4z.s:8745   .rodata.__func__.16:00000000 __func__.16
     /tmp/ccTFOe4z.s:3976   .text.vTaskPlaceOnEventList:00000000 $t
     /tmp/ccTFOe4z.s:3982   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
     /tmp/ccTFOe4z.s:4033   .text.vTaskPlaceOnEventList:00000040 $d
     /tmp/ccTFOe4z.s:8751   .rodata.__func__.15:00000000 __func__.15
     /tmp/ccTFOe4z.s:4041   .text.vTaskPlaceOnUnorderedEventList:00000000 $t
     /tmp/ccTFOe4z.s:4047   .text.vTaskPlaceOnUnorderedEventList:00000000 vTaskPlaceOnUnorderedEventList
     /tmp/ccTFOe4z.s:4145   .text.vTaskPlaceOnUnorderedEventList:0000009c $d
     /tmp/ccTFOe4z.s:8757   .rodata.__func__.14:00000000 __func__.14
     /tmp/ccTFOe4z.s:4154   .text.vTaskPlaceOnEventListRestricted:00000000 $t
     /tmp/ccTFOe4z.s:4160   .text.vTaskPlaceOnEventListRestricted:00000000 vTaskPlaceOnEventListRestricted
ARM GAS  /tmp/ccTFOe4z.s 			page 256


     /tmp/ccTFOe4z.s:4247   .text.vTaskPlaceOnEventListRestricted:00000084 $d
     /tmp/ccTFOe4z.s:8763   .rodata.__func__.13:00000000 __func__.13
     /tmp/ccTFOe4z.s:4255   .text.xTaskRemoveFromEventList:00000000 $t
     /tmp/ccTFOe4z.s:4261   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
     /tmp/ccTFOe4z.s:4513   .text.xTaskRemoveFromEventList:00000190 $d
     /tmp/ccTFOe4z.s:8769   .rodata.__func__.12:00000000 __func__.12
     /tmp/ccTFOe4z.s:4526   .text.vTaskRemoveFromUnorderedEventList:00000000 $t
     /tmp/ccTFOe4z.s:4532   .text.vTaskRemoveFromUnorderedEventList:00000000 vTaskRemoveFromUnorderedEventList
     /tmp/ccTFOe4z.s:4751   .text.vTaskRemoveFromUnorderedEventList:00000164 $d
     /tmp/ccTFOe4z.s:8775   .rodata.__func__.11:00000000 __func__.11
     /tmp/ccTFOe4z.s:4763   .text.vTaskSetTimeOutState:00000000 $t
     /tmp/ccTFOe4z.s:4769   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
     /tmp/ccTFOe4z.s:4821   .text.vTaskSetTimeOutState:00000040 $d
     /tmp/ccTFOe4z.s:8781   .rodata.__func__.10:00000000 __func__.10
     /tmp/ccTFOe4z.s:4830   .text.vTaskInternalSetTimeOutState:00000000 $t
     /tmp/ccTFOe4z.s:4836   .text.vTaskInternalSetTimeOutState:00000000 vTaskInternalSetTimeOutState
     /tmp/ccTFOe4z.s:4875   .text.vTaskInternalSetTimeOutState:00000024 $d
     /tmp/ccTFOe4z.s:4881   .text.xTaskCheckForTimeOut:00000000 $t
     /tmp/ccTFOe4z.s:4887   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
     /tmp/ccTFOe4z.s:5024   .text.xTaskCheckForTimeOut:000000bc $d
     /tmp/ccTFOe4z.s:8787   .rodata.__func__.9:00000000 __func__.9
     /tmp/ccTFOe4z.s:5033   .text.vTaskMissedYield:00000000 $t
     /tmp/ccTFOe4z.s:5039   .text.vTaskMissedYield:00000000 vTaskMissedYield
     /tmp/ccTFOe4z.s:5067   .text.vTaskMissedYield:00000014 $d
     /tmp/ccTFOe4z.s:5072   .text.uxTaskGetTaskNumber:00000000 $t
     /tmp/ccTFOe4z.s:5078   .text.uxTaskGetTaskNumber:00000000 uxTaskGetTaskNumber
     /tmp/ccTFOe4z.s:5127   .text.vTaskSetTaskNumber:00000000 $t
     /tmp/ccTFOe4z.s:5133   .text.vTaskSetTaskNumber:00000000 vTaskSetTaskNumber
     /tmp/ccTFOe4z.s:5176   .text.prvIdleTask:00000000 $t
     /tmp/ccTFOe4z.s:5312   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
     /tmp/ccTFOe4z.s:5212   .text.prvIdleTask:0000001c $d
     /tmp/ccTFOe4z.s:5217   .text.prvInitialiseTaskLists:00000000 $t
     /tmp/ccTFOe4z.s:5295   .text.prvInitialiseTaskLists:00000060 $d
     /tmp/ccTFOe4z.s:5307   .text.prvCheckTasksWaitingTermination:00000000 $t
     /tmp/ccTFOe4z.s:5379   .text.prvCheckTasksWaitingTermination:00000050 $d
     /tmp/ccTFOe4z.s:5386   .text.vTaskGetInfo:00000000 $t
     /tmp/ccTFOe4z.s:5392   .text.vTaskGetInfo:00000000 vTaskGetInfo
     /tmp/ccTFOe4z.s:5702   .text.prvTaskCheckFreeStackSpace:00000000 prvTaskCheckFreeStackSpace
     /tmp/ccTFOe4z.s:5566   .text.vTaskGetInfo:000000e0 $d
     /tmp/ccTFOe4z.s:5572   .text.prvListTasksWithinSingleList:00000000 $t
     /tmp/ccTFOe4z.s:5697   .text.prvTaskCheckFreeStackSpace:00000000 $t
     /tmp/ccTFOe4z.s:5760   .text.uxTaskGetStackHighWaterMark:00000000 $t
     /tmp/ccTFOe4z.s:5766   .text.uxTaskGetStackHighWaterMark:00000000 uxTaskGetStackHighWaterMark
     /tmp/ccTFOe4z.s:5818   .text.uxTaskGetStackHighWaterMark:00000034 $d
     /tmp/ccTFOe4z.s:5823   .text.prvDeleteTCB:00000000 $t
     /tmp/ccTFOe4z.s:5858   .text.prvResetNextTaskUnblockTime:00000000 $t
     /tmp/ccTFOe4z.s:5910   .text.prvResetNextTaskUnblockTime:00000030 $d
     /tmp/ccTFOe4z.s:5916   .text.xTaskGetCurrentTaskHandle:00000000 $t
     /tmp/ccTFOe4z.s:5922   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
     /tmp/ccTFOe4z.s:5956   .text.xTaskGetCurrentTaskHandle:0000001c $d
     /tmp/ccTFOe4z.s:5961   .text.xTaskGetSchedulerState:00000000 $t
     /tmp/ccTFOe4z.s:5967   .text.xTaskGetSchedulerState:00000000 xTaskGetSchedulerState
     /tmp/ccTFOe4z.s:6023   .text.xTaskGetSchedulerState:00000034 $d
     /tmp/ccTFOe4z.s:6029   .text.xTaskPriorityInherit:00000000 $t
     /tmp/ccTFOe4z.s:6035   .text.xTaskPriorityInherit:00000000 xTaskPriorityInherit
     /tmp/ccTFOe4z.s:6222   .text.xTaskPriorityInherit:00000114 $d
     /tmp/ccTFOe4z.s:6229   .text.xTaskPriorityDisinherit:00000000 $t
ARM GAS  /tmp/ccTFOe4z.s 			page 257


     /tmp/ccTFOe4z.s:6235   .text.xTaskPriorityDisinherit:00000000 xTaskPriorityDisinherit
     /tmp/ccTFOe4z.s:6413   .text.xTaskPriorityDisinherit:00000118 $d
     /tmp/ccTFOe4z.s:8793   .rodata.__func__.8:00000000 __func__.8
     /tmp/ccTFOe4z.s:6423   .text.vTaskPriorityDisinheritAfterTimeout:00000000 $t
     /tmp/ccTFOe4z.s:6429   .text.vTaskPriorityDisinheritAfterTimeout:00000000 vTaskPriorityDisinheritAfterTimeout
     /tmp/ccTFOe4z.s:6633   .text.vTaskPriorityDisinheritAfterTimeout:00000140 $d
     /tmp/ccTFOe4z.s:8799   .rodata.__func__.7:00000000 __func__.7
     /tmp/ccTFOe4z.s:6643   .text.uxTaskResetEventItemValue:00000000 $t
     /tmp/ccTFOe4z.s:6649   .text.uxTaskResetEventItemValue:00000000 uxTaskResetEventItemValue
     /tmp/ccTFOe4z.s:6693   .text.uxTaskResetEventItemValue:0000002c $d
     /tmp/ccTFOe4z.s:6698   .text.pvTaskIncrementMutexHeldCount:00000000 $t
     /tmp/ccTFOe4z.s:6704   .text.pvTaskIncrementMutexHeldCount:00000000 pvTaskIncrementMutexHeldCount
     /tmp/ccTFOe4z.s:6745   .text.pvTaskIncrementMutexHeldCount:00000024 $d
     /tmp/ccTFOe4z.s:6750   .text.ulTaskGenericNotifyTake:00000000 $t
     /tmp/ccTFOe4z.s:6756   .text.ulTaskGenericNotifyTake:00000000 ulTaskGenericNotifyTake
     /tmp/ccTFOe4z.s:6882   .text.ulTaskGenericNotifyTake:000000b8 $d
     /tmp/ccTFOe4z.s:8805   .rodata.__func__.6:00000000 __func__.6
     /tmp/ccTFOe4z.s:6890   .text.xTaskGenericNotifyWait:00000000 $t
     /tmp/ccTFOe4z.s:6896   .text.xTaskGenericNotifyWait:00000000 xTaskGenericNotifyWait
     /tmp/ccTFOe4z.s:7054   .text.xTaskGenericNotifyWait:000000e8 $d
     /tmp/ccTFOe4z.s:8811   .rodata.__func__.5:00000000 __func__.5
     /tmp/ccTFOe4z.s:7062   .text.xTaskGenericNotify:00000000 $t
     /tmp/ccTFOe4z.s:7068   .text.xTaskGenericNotify:00000000 xTaskGenericNotify
     /tmp/ccTFOe4z.s:7153   .text.xTaskGenericNotify:00000084 $d
     /tmp/ccTFOe4z.s:7158   .text.xTaskGenericNotify:00000098 $t
     /tmp/ccTFOe4z.s:7389   .text.xTaskGenericNotify:00000214 $d
     /tmp/ccTFOe4z.s:8817   .rodata.__func__.4:00000000 __func__.4
     /tmp/ccTFOe4z.s:7400   .text.xTaskGenericNotifyFromISR:00000000 $t
     /tmp/ccTFOe4z.s:7406   .text.xTaskGenericNotifyFromISR:00000000 xTaskGenericNotifyFromISR
     /tmp/ccTFOe4z.s:7494   .text.xTaskGenericNotifyFromISR:0000008c $d
     /tmp/ccTFOe4z.s:7499   .text.xTaskGenericNotifyFromISR:000000a0 $t
     /tmp/ccTFOe4z.s:7781   .text.xTaskGenericNotifyFromISR:00000274 $d
     /tmp/ccTFOe4z.s:8823   .rodata.__func__.3:00000000 __func__.3
     /tmp/ccTFOe4z.s:7795   .text.vTaskGenericNotifyGiveFromISR:00000000 $t
     /tmp/ccTFOe4z.s:7801   .text.vTaskGenericNotifyGiveFromISR:00000000 vTaskGenericNotifyGiveFromISR
     /tmp/ccTFOe4z.s:8076   .text.vTaskGenericNotifyGiveFromISR:000001c8 $d
     /tmp/ccTFOe4z.s:8829   .rodata.__func__.2:00000000 __func__.2
     /tmp/ccTFOe4z.s:8089   .text.xTaskGenericNotifyStateClear:00000000 $t
     /tmp/ccTFOe4z.s:8095   .text.xTaskGenericNotifyStateClear:00000000 xTaskGenericNotifyStateClear
     /tmp/ccTFOe4z.s:8180   .text.xTaskGenericNotifyStateClear:0000006c $d
     /tmp/ccTFOe4z.s:8835   .rodata.__func__.1:00000000 __func__.1
     /tmp/ccTFOe4z.s:8188   .text.ulTaskGenericNotifyValueClear:00000000 $t
     /tmp/ccTFOe4z.s:8194   .text.ulTaskGenericNotifyValueClear:00000000 ulTaskGenericNotifyValueClear
     /tmp/ccTFOe4z.s:8274   .text.ulTaskGenericNotifyValueClear:00000070 $d
     /tmp/ccTFOe4z.s:8841   .rodata.__func__.0:00000000 __func__.0
     /tmp/ccTFOe4z.s:8282   .text.ulTaskGetRunTimeCounter:00000000 $t
     /tmp/ccTFOe4z.s:8288   .text.ulTaskGetRunTimeCounter:00000000 ulTaskGetRunTimeCounter
     /tmp/ccTFOe4z.s:8321   .text.ulTaskGetRunTimePercent:00000000 $t
     /tmp/ccTFOe4z.s:8327   .text.ulTaskGetRunTimePercent:00000000 ulTaskGetRunTimePercent
     /tmp/ccTFOe4z.s:8381   .text.ulTaskGetRunTimePercent:0000003c $d
     /tmp/ccTFOe4z.s:8386   .text.ulTaskGetIdleRunTimeCounter:00000000 $t
     /tmp/ccTFOe4z.s:8392   .text.ulTaskGetIdleRunTimeCounter:00000000 ulTaskGetIdleRunTimeCounter
     /tmp/ccTFOe4z.s:8416   .text.ulTaskGetIdleRunTimeCounter:00000014 $d
     /tmp/ccTFOe4z.s:8421   .text.ulTaskGetIdleRunTimePercent:00000000 $t
     /tmp/ccTFOe4z.s:8427   .text.ulTaskGetIdleRunTimePercent:00000000 ulTaskGetIdleRunTimePercent
     /tmp/ccTFOe4z.s:8451   .text.ulTaskGetIdleRunTimePercent:00000014 $d
     /tmp/ccTFOe4z.s:8456   .text.prvAddCurrentTaskToDelayedList:00000000 $t
ARM GAS  /tmp/ccTFOe4z.s 			page 258


     /tmp/ccTFOe4z.s:8598   .text.prvAddCurrentTaskToDelayedList:000000c4 $d
     /tmp/ccTFOe4z.s:8608   .text.freertos_tasks_c_additions_init:00000000 $t
     /tmp/ccTFOe4z.s:8634   .rodata.__func__.34:00000000 $d
     /tmp/ccTFOe4z.s:8640   .rodata.__func__.33:00000000 $d
     /tmp/ccTFOe4z.s:8646   .rodata.__func__.32:00000000 $d
     /tmp/ccTFOe4z.s:8652   .rodata.__func__.31:00000000 $d
     /tmp/ccTFOe4z.s:8658   .rodata.__func__.30:00000000 $d
     /tmp/ccTFOe4z.s:8664   .rodata.__func__.29:00000000 $d
     /tmp/ccTFOe4z.s:8670   .rodata.__func__.28:00000000 $d
     /tmp/ccTFOe4z.s:8676   .rodata.__func__.27:00000000 $d
     /tmp/ccTFOe4z.s:8682   .rodata.__func__.26:00000000 $d
     /tmp/ccTFOe4z.s:8688   .rodata.__func__.25:00000000 $d
     /tmp/ccTFOe4z.s:8694   .rodata.__func__.24:00000000 $d
     /tmp/ccTFOe4z.s:8700   .rodata.__func__.23:00000000 $d
     /tmp/ccTFOe4z.s:8706   .rodata.__func__.22:00000000 $d
     /tmp/ccTFOe4z.s:8712   .rodata.__func__.21:00000000 $d
     /tmp/ccTFOe4z.s:8718   .rodata.__func__.20:00000000 $d
     /tmp/ccTFOe4z.s:8724   .rodata.__func__.19:00000000 $d
     /tmp/ccTFOe4z.s:8730   .rodata.__func__.18:00000000 $d
     /tmp/ccTFOe4z.s:8736   .rodata.__func__.17:00000000 $d
     /tmp/ccTFOe4z.s:8742   .rodata.__func__.16:00000000 $d
     /tmp/ccTFOe4z.s:8748   .rodata.__func__.15:00000000 $d
     /tmp/ccTFOe4z.s:8754   .rodata.__func__.14:00000000 $d
     /tmp/ccTFOe4z.s:8760   .rodata.__func__.13:00000000 $d
     /tmp/ccTFOe4z.s:8766   .rodata.__func__.12:00000000 $d
     /tmp/ccTFOe4z.s:8772   .rodata.__func__.11:00000000 $d
     /tmp/ccTFOe4z.s:8778   .rodata.__func__.10:00000000 $d
     /tmp/ccTFOe4z.s:8784   .rodata.__func__.9:00000000 $d
     /tmp/ccTFOe4z.s:8790   .rodata.__func__.8:00000000 $d
     /tmp/ccTFOe4z.s:8796   .rodata.__func__.7:00000000 $d
     /tmp/ccTFOe4z.s:8802   .rodata.__func__.6:00000000 $d
     /tmp/ccTFOe4z.s:8808   .rodata.__func__.5:00000000 $d
     /tmp/ccTFOe4z.s:8814   .rodata.__func__.4:00000000 $d
     /tmp/ccTFOe4z.s:8820   .rodata.__func__.3:00000000 $d
     /tmp/ccTFOe4z.s:8826   .rodata.__func__.2:00000000 $d
     /tmp/ccTFOe4z.s:8832   .rodata.__func__.1:00000000 $d
     /tmp/ccTFOe4z.s:8838   .rodata.__func__.0:00000000 $d
                           .group:00000000 wm4.0.2a10773746a5c5ebb5552f50e466f80b
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.newlib.h.27.4b972ceed5d01f491020c20f1e546cab
                           .group:00000000 wm4.features.h.22.9dfb1293666eb4caf24cccb81c86a551
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.185.882514a1a6169ceba9142f401cbe27c6
                           .group:00000000 wm4.stddef.h.39.794fa375de48dda278c4aebb5c74aa5b
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:00000000 wm4.cdefs.h.49.70fc7af612f78ddcace70fdd90b5623b
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
ARM GAS  /tmp/ccTFOe4z.s 			page 259


                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.FreeRTOSConfig.h.59.2629c72cff9e6dbe880a2dc225eae516
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.timers.h.57.6dc18d93eadf96866a61b56e192cd706
                           .group:00000000 wm4.stack_macros.h.30.db3ad6dc67b15c658de1ab15f96037bf

UNDEFINED SYMBOLS
ulSetInterruptMask
__assert_func
memset
vListInitialiseItem
pxPortInitialiseStack
vPortEnterCritical
vPortExitCritical
vPortYield
uxListRemove
vListInsertEnd
vPortValidateInterruptPriority
vClearInterruptMask
vApplicationGetIdleTaskMemory
xTimerCreateTimerTask
TIM4_Config
xPortStartScheduler
vPortEndScheduler
TIM4_Get_Value
vListInsert
vListInitialise
freertos_libc_init
