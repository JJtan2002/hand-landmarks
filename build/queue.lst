ARM GAS  /tmp/cchrzcnP.s 			page 1


   1              		.arch armv8.1-m.main
   2              		.fpu fpv5-d16
   3              		.arch_extension dsp
   4              		.arch_extension fp
   5              		.arch_extension fp.dp
   6              		.arch_extension mve
   7              		.arch_extension mve.fp
   8              		.eabi_attribute 5, "cortex-m55"
   9              		.eabi_attribute 28, 1
  10              		.eabi_attribute 20, 1
  11              		.eabi_attribute 21, 1
  12              		.eabi_attribute 23, 3
  13              		.eabi_attribute 24, 1
  14              		.eabi_attribute 25, 1
  15              		.eabi_attribute 26, 1
  16              		.eabi_attribute 30, 6
  17              		.eabi_attribute 34, 1
  18              		.eabi_attribute 38, 1
  19              		.eabi_attribute 18, 4
  20              		.file	"queue.c"
  21              		.text
  22              	.Ltext0:
  23              		.cfi_sections	.debug_frame
  24              		.file 1 "Lib/FreeRTOS/Source/queue.c"
  25              		.global	xQueueRegistry
  26              		.section	.bss.xQueueRegistry,"aw",%nobits
  27              		.align	2
  30              	xQueueRegistry:
  31 0000 00000000 		.space	64
  31      00000000 
  31      00000000 
  31      00000000 
  31      00000000 
  32              		.section	.rodata
  33              		.align	2
  34              	.LC0:
  35 0000 3000     		.ascii	"0\000"
  36 0002 0000     		.align	2
  37              	.LC1:
  38 0004 4C69622F 		.ascii	"Lib/FreeRTOS/Source/queue.c\000"
  38      46726565 
  38      52544F53 
  38      2F536F75 
  38      7263652F 
  39              		.section	.text.xQueueGenericReset,"ax",%progbits
  40              		.align	1
  41              		.global	xQueueGenericReset
  42              		.syntax unified
  43              		.thumb
  44              		.thumb_func
  46              	xQueueGenericReset:
  47              	.LFB0:
   1:Lib/FreeRTOS/Source/queue.c **** /*
   2:Lib/FreeRTOS/Source/queue.c ****  * FreeRTOS Kernel V10.6.2
   3:Lib/FreeRTOS/Source/queue.c ****  * Copyright (C) 2021 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
   4:Lib/FreeRTOS/Source/queue.c ****  *
   5:Lib/FreeRTOS/Source/queue.c ****  * SPDX-License-Identifier: MIT
ARM GAS  /tmp/cchrzcnP.s 			page 2


   6:Lib/FreeRTOS/Source/queue.c ****  *
   7:Lib/FreeRTOS/Source/queue.c ****  * Permission is hereby granted, free of charge, to any person obtaining a copy of
   8:Lib/FreeRTOS/Source/queue.c ****  * this software and associated documentation files (the "Software"), to deal in
   9:Lib/FreeRTOS/Source/queue.c ****  * the Software without restriction, including without limitation the rights to
  10:Lib/FreeRTOS/Source/queue.c ****  * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
  11:Lib/FreeRTOS/Source/queue.c ****  * the Software, and to permit persons to whom the Software is furnished to do so,
  12:Lib/FreeRTOS/Source/queue.c ****  * subject to the following conditions:
  13:Lib/FreeRTOS/Source/queue.c ****  *
  14:Lib/FreeRTOS/Source/queue.c ****  * The above copyright notice and this permission notice shall be included in all
  15:Lib/FreeRTOS/Source/queue.c ****  * copies or substantial portions of the Software.
  16:Lib/FreeRTOS/Source/queue.c ****  *
  17:Lib/FreeRTOS/Source/queue.c ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  18:Lib/FreeRTOS/Source/queue.c ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
  19:Lib/FreeRTOS/Source/queue.c ****  * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
  20:Lib/FreeRTOS/Source/queue.c ****  * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  21:Lib/FreeRTOS/Source/queue.c ****  * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  22:Lib/FreeRTOS/Source/queue.c ****  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  23:Lib/FreeRTOS/Source/queue.c ****  *
  24:Lib/FreeRTOS/Source/queue.c ****  * https://www.FreeRTOS.org
  25:Lib/FreeRTOS/Source/queue.c ****  * https://github.com/FreeRTOS
  26:Lib/FreeRTOS/Source/queue.c ****  *
  27:Lib/FreeRTOS/Source/queue.c ****  */
  28:Lib/FreeRTOS/Source/queue.c **** 
  29:Lib/FreeRTOS/Source/queue.c **** #include <stdlib.h>
  30:Lib/FreeRTOS/Source/queue.c **** #include <string.h>
  31:Lib/FreeRTOS/Source/queue.c **** 
  32:Lib/FreeRTOS/Source/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  33:Lib/FreeRTOS/Source/queue.c ****  * all the API functions to use the MPU wrappers.  That should only be done when
  34:Lib/FreeRTOS/Source/queue.c ****  * task.h is included from an application file. */
  35:Lib/FreeRTOS/Source/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  36:Lib/FreeRTOS/Source/queue.c **** 
  37:Lib/FreeRTOS/Source/queue.c **** #include "FreeRTOS.h"
  38:Lib/FreeRTOS/Source/queue.c **** #include "task.h"
  39:Lib/FreeRTOS/Source/queue.c **** #include "queue.h"
  40:Lib/FreeRTOS/Source/queue.c **** 
  41:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  42:Lib/FreeRTOS/Source/queue.c ****     #include "croutine.h"
  43:Lib/FreeRTOS/Source/queue.c **** #endif
  44:Lib/FreeRTOS/Source/queue.c **** 
  45:Lib/FreeRTOS/Source/queue.c **** /* Lint e9021, e961 and e750 are suppressed as a MISRA exception justified
  46:Lib/FreeRTOS/Source/queue.c ****  * because the MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined
  47:Lib/FreeRTOS/Source/queue.c ****  * for the header files above, but not in this file, in order to generate the
  48:Lib/FreeRTOS/Source/queue.c ****  * correct privileged Vs unprivileged linkage and placement. */
  49:Lib/FreeRTOS/Source/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750 !e9021. */
  50:Lib/FreeRTOS/Source/queue.c **** 
  51:Lib/FreeRTOS/Source/queue.c **** 
  52:Lib/FreeRTOS/Source/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  53:Lib/FreeRTOS/Source/queue.c **** #define queueUNLOCKED             ( ( int8_t ) -1 )
  54:Lib/FreeRTOS/Source/queue.c **** #define queueLOCKED_UNMODIFIED    ( ( int8_t ) 0 )
  55:Lib/FreeRTOS/Source/queue.c **** #define queueINT8_MAX             ( ( int8_t ) 127 )
  56:Lib/FreeRTOS/Source/queue.c **** 
  57:Lib/FreeRTOS/Source/queue.c **** /* When the Queue_t structure is used to represent a base queue its pcHead and
  58:Lib/FreeRTOS/Source/queue.c ****  * pcTail members are used as pointers into the queue storage area.  When the
  59:Lib/FreeRTOS/Source/queue.c ****  * Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
  60:Lib/FreeRTOS/Source/queue.c ****  * not necessary, and the pcHead pointer is set to NULL to indicate that the
  61:Lib/FreeRTOS/Source/queue.c ****  * structure instead holds a pointer to the mutex holder (if any).  Map alternative
  62:Lib/FreeRTOS/Source/queue.c ****  * names to the pcHead and structure member to ensure the readability of the code
ARM GAS  /tmp/cchrzcnP.s 			page 3


  63:Lib/FreeRTOS/Source/queue.c ****  * is maintained.  The QueuePointers_t and SemaphoreData_t types are used to form
  64:Lib/FreeRTOS/Source/queue.c ****  * a union as their usage is mutually exclusive dependent on what the queue is
  65:Lib/FreeRTOS/Source/queue.c ****  * being used for. */
  66:Lib/FreeRTOS/Source/queue.c **** #define uxQueueType               pcHead
  67:Lib/FreeRTOS/Source/queue.c **** #define queueQUEUE_IS_MUTEX       NULL
  68:Lib/FreeRTOS/Source/queue.c **** 
  69:Lib/FreeRTOS/Source/queue.c **** typedef struct QueuePointers
  70:Lib/FreeRTOS/Source/queue.c **** {
  71:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcTail;     /**< Points to the byte at the end of the queue storage area.  Once more b
  72:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcReadFrom; /**< Points to the last place that a queued item was read from when the st
  73:Lib/FreeRTOS/Source/queue.c **** } QueuePointers_t;
  74:Lib/FreeRTOS/Source/queue.c **** 
  75:Lib/FreeRTOS/Source/queue.c **** typedef struct SemaphoreData
  76:Lib/FreeRTOS/Source/queue.c **** {
  77:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xMutexHolder;        /**< The handle of the task that holds the mutex. */
  78:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxRecursiveCallCount; /**< Maintains a count of the number of times a recursive mut
  79:Lib/FreeRTOS/Source/queue.c **** } SemaphoreData_t;
  80:Lib/FreeRTOS/Source/queue.c **** 
  81:Lib/FreeRTOS/Source/queue.c **** /* Semaphores do not actually store or copy data, so have an item size of
  82:Lib/FreeRTOS/Source/queue.c ****  * zero. */
  83:Lib/FreeRTOS/Source/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH    ( ( UBaseType_t ) 0 )
  84:Lib/FreeRTOS/Source/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME          ( ( TickType_t ) 0U )
  85:Lib/FreeRTOS/Source/queue.c **** 
  86:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_PREEMPTION == 0 )
  87:Lib/FreeRTOS/Source/queue.c **** 
  88:Lib/FreeRTOS/Source/queue.c **** /* If the cooperative scheduler is being used then a yield should not be
  89:Lib/FreeRTOS/Source/queue.c ****  * performed just because a higher priority task has been woken. */
  90:Lib/FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()
  91:Lib/FreeRTOS/Source/queue.c **** #else
  92:Lib/FreeRTOS/Source/queue.c ****     #define queueYIELD_IF_USING_PREEMPTION()    portYIELD_WITHIN_API()
  93:Lib/FreeRTOS/Source/queue.c **** #endif
  94:Lib/FreeRTOS/Source/queue.c **** 
  95:Lib/FreeRTOS/Source/queue.c **** /*
  96:Lib/FreeRTOS/Source/queue.c ****  * Definition of the queue used by the scheduler.
  97:Lib/FreeRTOS/Source/queue.c ****  * Items are queued by copy, not reference.  See the following link for the
  98:Lib/FreeRTOS/Source/queue.c ****  * rationale: https://www.FreeRTOS.org/Embedded-RTOS-Queues.html
  99:Lib/FreeRTOS/Source/queue.c ****  */
 100:Lib/FreeRTOS/Source/queue.c **** typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel awar
 101:Lib/FreeRTOS/Source/queue.c **** {
 102:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcHead;           /**< Points to the beginning of the queue storage area. */
 103:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcWriteTo;        /**< Points to the free next place in the storage area. */
 104:Lib/FreeRTOS/Source/queue.c **** 
 105:Lib/FreeRTOS/Source/queue.c ****     union
 106:Lib/FreeRTOS/Source/queue.c ****     {
 107:Lib/FreeRTOS/Source/queue.c ****         QueuePointers_t xQueue;     /**< Data required exclusively when this structure is used as a
 108:Lib/FreeRTOS/Source/queue.c ****         SemaphoreData_t xSemaphore; /**< Data required exclusively when this structure is used as a
 109:Lib/FreeRTOS/Source/queue.c ****     } u;
 110:Lib/FreeRTOS/Source/queue.c **** 
 111:Lib/FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToSend;             /**< List of tasks that are blocked waiting to post ont
 112:Lib/FreeRTOS/Source/queue.c ****     List_t xTasksWaitingToReceive;          /**< List of tasks that are blocked waiting to read fro
 113:Lib/FreeRTOS/Source/queue.c **** 
 114:Lib/FreeRTOS/Source/queue.c ****     volatile UBaseType_t uxMessagesWaiting; /**< The number of items currently in the queue. */
 115:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxLength;                   /**< The length of the queue defined as the number of i
 116:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxItemSize;                 /**< The size of each items that the queue will hold. *
 117:Lib/FreeRTOS/Source/queue.c **** 
 118:Lib/FreeRTOS/Source/queue.c ****     volatile int8_t cRxLock;                /**< Stores the number of items received from the queue
 119:Lib/FreeRTOS/Source/queue.c ****     volatile int8_t cTxLock;                /**< Stores the number of items transmitted to the queu
ARM GAS  /tmp/cchrzcnP.s 			page 4


 120:Lib/FreeRTOS/Source/queue.c **** 
 121:Lib/FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 122:Lib/FreeRTOS/Source/queue.c ****         uint8_t ucStaticallyAllocated; /**< Set to pdTRUE if the memory used by the queue was stati
 123:Lib/FreeRTOS/Source/queue.c ****     #endif
 124:Lib/FreeRTOS/Source/queue.c **** 
 125:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 126:Lib/FreeRTOS/Source/queue.c ****         struct QueueDefinition * pxQueueSetContainer;
 127:Lib/FreeRTOS/Source/queue.c ****     #endif
 128:Lib/FreeRTOS/Source/queue.c **** 
 129:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 130:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t uxQueueNumber;
 131:Lib/FreeRTOS/Source/queue.c ****         uint8_t ucQueueType;
 132:Lib/FreeRTOS/Source/queue.c ****     #endif
 133:Lib/FreeRTOS/Source/queue.c **** } xQUEUE;
 134:Lib/FreeRTOS/Source/queue.c **** 
 135:Lib/FreeRTOS/Source/queue.c **** /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
 136:Lib/FreeRTOS/Source/queue.c ****  * name below to enable the use of older kernel aware debuggers. */
 137:Lib/FreeRTOS/Source/queue.c **** typedef xQUEUE Queue_t;
 138:Lib/FreeRTOS/Source/queue.c **** 
 139:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 140:Lib/FreeRTOS/Source/queue.c **** 
 141:Lib/FreeRTOS/Source/queue.c **** /*
 142:Lib/FreeRTOS/Source/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 143:Lib/FreeRTOS/Source/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 144:Lib/FreeRTOS/Source/queue.c ****  */
 145:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
 146:Lib/FreeRTOS/Source/queue.c **** 
 147:Lib/FreeRTOS/Source/queue.c **** /* The type stored within the queue registry array.  This allows a name
 148:Lib/FreeRTOS/Source/queue.c ****  * to be assigned to each queue making kernel aware debugging a little
 149:Lib/FreeRTOS/Source/queue.c ****  * more user friendly. */
 150:Lib/FreeRTOS/Source/queue.c ****     typedef struct QUEUE_REGISTRY_ITEM
 151:Lib/FreeRTOS/Source/queue.c ****     {
 152:Lib/FreeRTOS/Source/queue.c ****         const char * pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and s
 153:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle;
 154:Lib/FreeRTOS/Source/queue.c ****     } xQueueRegistryItem;
 155:Lib/FreeRTOS/Source/queue.c **** 
 156:Lib/FreeRTOS/Source/queue.c **** /* The old xQueueRegistryItem name is maintained above then typedefed to the
 157:Lib/FreeRTOS/Source/queue.c ****  * new xQueueRegistryItem name below to enable the use of older kernel aware
 158:Lib/FreeRTOS/Source/queue.c ****  * debuggers. */
 159:Lib/FreeRTOS/Source/queue.c ****     typedef xQueueRegistryItem QueueRegistryItem_t;
 160:Lib/FreeRTOS/Source/queue.c **** 
 161:Lib/FreeRTOS/Source/queue.c **** /* The queue registry is simply an array of QueueRegistryItem_t structures.
 162:Lib/FreeRTOS/Source/queue.c ****  * The pcQueueName member of a structure being NULL is indicative of the
 163:Lib/FreeRTOS/Source/queue.c ****  * array position being vacant. */
 164:Lib/FreeRTOS/Source/queue.c ****     PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 165:Lib/FreeRTOS/Source/queue.c **** 
 166:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
 167:Lib/FreeRTOS/Source/queue.c **** 
 168:Lib/FreeRTOS/Source/queue.c **** /*
 169:Lib/FreeRTOS/Source/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 170:Lib/FreeRTOS/Source/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 171:Lib/FreeRTOS/Source/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 172:Lib/FreeRTOS/Source/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 173:Lib/FreeRTOS/Source/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 174:Lib/FreeRTOS/Source/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 175:Lib/FreeRTOS/Source/queue.c ****  */
 176:Lib/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
ARM GAS  /tmp/cchrzcnP.s 			page 5


 177:Lib/FreeRTOS/Source/queue.c **** 
 178:Lib/FreeRTOS/Source/queue.c **** /*
 179:Lib/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 180:Lib/FreeRTOS/Source/queue.c ****  *
 181:Lib/FreeRTOS/Source/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 182:Lib/FreeRTOS/Source/queue.c ****  */
 183:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 184:Lib/FreeRTOS/Source/queue.c **** 
 185:Lib/FreeRTOS/Source/queue.c **** /*
 186:Lib/FreeRTOS/Source/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 187:Lib/FreeRTOS/Source/queue.c ****  *
 188:Lib/FreeRTOS/Source/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 189:Lib/FreeRTOS/Source/queue.c ****  */
 190:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue ) PRIVILEGED_FUNCTION;
 191:Lib/FreeRTOS/Source/queue.c **** 
 192:Lib/FreeRTOS/Source/queue.c **** /*
 193:Lib/FreeRTOS/Source/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 194:Lib/FreeRTOS/Source/queue.c ****  * back of the queue.
 195:Lib/FreeRTOS/Source/queue.c ****  */
 196:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
 197:Lib/FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
 198:Lib/FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
 199:Lib/FreeRTOS/Source/queue.c **** 
 200:Lib/FreeRTOS/Source/queue.c **** /*
 201:Lib/FreeRTOS/Source/queue.c ****  * Copies an item out of a queue.
 202:Lib/FreeRTOS/Source/queue.c ****  */
 203:Lib/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
 204:Lib/FreeRTOS/Source/queue.c ****                                   void * const pvBuffer ) PRIVILEGED_FUNCTION;
 205:Lib/FreeRTOS/Source/queue.c **** 
 206:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_QUEUE_SETS == 1 )
 207:Lib/FreeRTOS/Source/queue.c **** 
 208:Lib/FreeRTOS/Source/queue.c **** /*
 209:Lib/FreeRTOS/Source/queue.c ****  * Checks to see if a queue is a member of a queue set, and if so, notifies
 210:Lib/FreeRTOS/Source/queue.c ****  * the queue set that the queue contains data.
 211:Lib/FreeRTOS/Source/queue.c ****  */
 212:Lib/FreeRTOS/Source/queue.c ****     static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTI
 213:Lib/FreeRTOS/Source/queue.c **** #endif
 214:Lib/FreeRTOS/Source/queue.c **** 
 215:Lib/FreeRTOS/Source/queue.c **** /*
 216:Lib/FreeRTOS/Source/queue.c ****  * Called after a Queue_t structure has been allocated either statically or
 217:Lib/FreeRTOS/Source/queue.c ****  * dynamically to fill in the structure's members.
 218:Lib/FreeRTOS/Source/queue.c ****  */
 219:Lib/FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 220:Lib/FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 221:Lib/FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 222:Lib/FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 223:Lib/FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 224:Lib/FreeRTOS/Source/queue.c **** 
 225:Lib/FreeRTOS/Source/queue.c **** /*
 226:Lib/FreeRTOS/Source/queue.c ****  * Mutexes are a special type of queue.  When a mutex is created, first the
 227:Lib/FreeRTOS/Source/queue.c ****  * queue is created, then prvInitialiseMutex() is called to configure the queue
 228:Lib/FreeRTOS/Source/queue.c ****  * as a mutex.
 229:Lib/FreeRTOS/Source/queue.c ****  */
 230:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 231:Lib/FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue ) PRIVILEGED_FUNCTION;
 232:Lib/FreeRTOS/Source/queue.c **** #endif
 233:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 6


 234:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 235:Lib/FreeRTOS/Source/queue.c **** 
 236:Lib/FreeRTOS/Source/queue.c **** /*
 237:Lib/FreeRTOS/Source/queue.c ****  * If a task waiting for a mutex causes the mutex holder to inherit a
 238:Lib/FreeRTOS/Source/queue.c ****  * priority, but the waiting task times out, then the holder should
 239:Lib/FreeRTOS/Source/queue.c ****  * disinherit the priority - but only down to the highest priority of any
 240:Lib/FreeRTOS/Source/queue.c ****  * other tasks that are waiting for the same mutex.  This function returns
 241:Lib/FreeRTOS/Source/queue.c ****  * that priority.
 242:Lib/FreeRTOS/Source/queue.c ****  */
 243:Lib/FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVIL
 244:Lib/FreeRTOS/Source/queue.c **** #endif
 245:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 246:Lib/FreeRTOS/Source/queue.c **** 
 247:Lib/FreeRTOS/Source/queue.c **** /*
 248:Lib/FreeRTOS/Source/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 249:Lib/FreeRTOS/Source/queue.c ****  * accessing the queue event lists.
 250:Lib/FreeRTOS/Source/queue.c ****  */
 251:Lib/FreeRTOS/Source/queue.c **** #define prvLockQueue( pxQueue )                            \
 252:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();                                  \
 253:Lib/FreeRTOS/Source/queue.c ****     {                                                      \
 254:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cRxLock == queueUNLOCKED )        \
 255:Lib/FreeRTOS/Source/queue.c ****         {                                                  \
 256:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED; \
 257:Lib/FreeRTOS/Source/queue.c ****         }                                                  \
 258:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue )->cTxLock == queueUNLOCKED )        \
 259:Lib/FreeRTOS/Source/queue.c ****         {                                                  \
 260:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED; \
 261:Lib/FreeRTOS/Source/queue.c ****         }                                                  \
 262:Lib/FreeRTOS/Source/queue.c ****     }                                                      \
 263:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL()
 264:Lib/FreeRTOS/Source/queue.c **** 
 265:Lib/FreeRTOS/Source/queue.c **** /*
 266:Lib/FreeRTOS/Source/queue.c ****  * Macro to increment cTxLock member of the queue data structure. It is
 267:Lib/FreeRTOS/Source/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 268:Lib/FreeRTOS/Source/queue.c ****  * tasks than the number of tasks in the system.
 269:Lib/FreeRTOS/Source/queue.c ****  */
 270:Lib/FreeRTOS/Source/queue.c **** #define prvIncrementQueueTxLock( pxQueue, cTxLock )                           \
 271:Lib/FreeRTOS/Source/queue.c ****     do {                                                                      \
 272:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 273:Lib/FreeRTOS/Source/queue.c ****         if( ( UBaseType_t ) ( cTxLock ) < uxNumberOfTasks )                   \
 274:Lib/FreeRTOS/Source/queue.c ****         {                                                                     \
 275:Lib/FreeRTOS/Source/queue.c ****             configASSERT( ( cTxLock ) != queueINT8_MAX );                     \
 276:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cTxLock = ( int8_t ) ( ( cTxLock ) + ( int8_t ) 1 ); \
 277:Lib/FreeRTOS/Source/queue.c ****         }                                                                     \
 278:Lib/FreeRTOS/Source/queue.c ****     } while( 0 )
 279:Lib/FreeRTOS/Source/queue.c **** 
 280:Lib/FreeRTOS/Source/queue.c **** /*
 281:Lib/FreeRTOS/Source/queue.c ****  * Macro to increment cRxLock member of the queue data structure. It is
 282:Lib/FreeRTOS/Source/queue.c ****  * capped at the number of tasks in the system as we cannot unblock more
 283:Lib/FreeRTOS/Source/queue.c ****  * tasks than the number of tasks in the system.
 284:Lib/FreeRTOS/Source/queue.c ****  */
 285:Lib/FreeRTOS/Source/queue.c **** #define prvIncrementQueueRxLock( pxQueue, cRxLock )                           \
 286:Lib/FreeRTOS/Source/queue.c ****     do {                                                                      \
 287:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxNumberOfTasks = uxTaskGetNumberOfTasks();         \
 288:Lib/FreeRTOS/Source/queue.c ****         if( ( UBaseType_t ) ( cRxLock ) < uxNumberOfTasks )                   \
 289:Lib/FreeRTOS/Source/queue.c ****         {                                                                     \
 290:Lib/FreeRTOS/Source/queue.c ****             configASSERT( ( cRxLock ) != queueINT8_MAX );                     \
ARM GAS  /tmp/cchrzcnP.s 			page 7


 291:Lib/FreeRTOS/Source/queue.c ****             ( pxQueue )->cRxLock = ( int8_t ) ( ( cRxLock ) + ( int8_t ) 1 ); \
 292:Lib/FreeRTOS/Source/queue.c ****         }                                                                     \
 293:Lib/FreeRTOS/Source/queue.c ****     } while( 0 )
 294:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 295:Lib/FreeRTOS/Source/queue.c **** 
 296:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
 297:Lib/FreeRTOS/Source/queue.c ****                                BaseType_t xNewQueue )
 298:Lib/FreeRTOS/Source/queue.c **** {
  48              		.loc 1 298 1
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 16
  51              		@ frame_needed = 1, uses_anonymous_args = 0
  52 0000 80B5     		push	{r7, lr}
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 7, -8
  55              		.cfi_offset 14, -4
  56 0002 84B0     		sub	sp, sp, #16
  57              		.cfi_def_cfa_offset 24
  58 0004 00AF     		add	r7, sp, #0
  59              		.cfi_def_cfa_register 7
  60 0006 7860     		str	r0, [r7, #4]
  61 0008 3960     		str	r1, [r7]
 299:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdPASS;
  62              		.loc 1 299 16
  63 000a 0123     		movs	r3, #1
  64 000c FB60     		str	r3, [r7, #12]
 300:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
  65              		.loc 1 300 21
  66 000e 7B68     		ldr	r3, [r7, #4]
  67 0010 BB60     		str	r3, [r7, #8]
 301:Lib/FreeRTOS/Source/queue.c **** 
 302:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
  68              		.loc 1 302 5
  69 0012 BB68     		ldr	r3, [r7, #8]
  70 0014 002B     		cmp	r3, #0
  71 0016 08D1     		bne	.L2
  72              		.loc 1 302 5 is_stmt 0 discriminator 1
  73 0018 FFF7FEFF 		bl	ulSetInterruptMask
  74 001c 3A4B     		ldr	r3, .L11
  75 001e 3B4A     		ldr	r2, .L11+4
  76 0020 4FF49771 		mov	r1, #302
  77 0024 3A48     		ldr	r0, .L11+8
  78 0026 FFF7FEFF 		bl	__assert_func
  79              	.L2:
 303:Lib/FreeRTOS/Source/queue.c **** 
 304:Lib/FreeRTOS/Source/queue.c ****     if( ( pxQueue != NULL ) &&
  80              		.loc 1 304 7 is_stmt 1
  81 002a BB68     		ldr	r3, [r7, #8]
  82 002c 002B     		cmp	r3, #0
  83 002e 57D0     		beq	.L3
 305:Lib/FreeRTOS/Source/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
  84              		.loc 1 305 18
  85 0030 BB68     		ldr	r3, [r7, #8]
  86 0032 DB6B     		ldr	r3, [r3, #60]
 304:Lib/FreeRTOS/Source/queue.c ****         ( pxQueue->uxLength >= 1U ) &&
  87              		.loc 1 304 29 discriminator 1
  88 0034 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 8


  89 0036 53D0     		beq	.L3
 306:Lib/FreeRTOS/Source/queue.c ****         /* Check for multiplication overflow. */
 307:Lib/FreeRTOS/Source/queue.c ****         ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
  90              		.loc 1 307 54
  91 0038 BB68     		ldr	r3, [r7, #8]
  92 003a 1A6C     		ldr	r2, [r3, #64]
  93              		.loc 1 307 31
  94 003c BB68     		ldr	r3, [r7, #8]
  95 003e DB6B     		ldr	r3, [r3, #60]
  96              		.loc 1 307 44
  97 0040 0021     		movs	r1, #0
  98 0042 A3FB0223 		umull	r2, r3, r3, r2
  99 0046 002B     		cmp	r3, #0
 100 0048 00D0     		beq	.L4
 101 004a 0121     		movs	r1, #1
 102              	.L4:
 103              		.loc 1 307 44 is_stmt 0 discriminator 1
 104 004c 0B46     		mov	r3, r1
 305:Lib/FreeRTOS/Source/queue.c ****         /* Check for multiplication overflow. */
 105              		.loc 1 305 37 is_stmt 1
 106 004e 002B     		cmp	r3, #0
 107 0050 46D1     		bne	.L3
 308:Lib/FreeRTOS/Source/queue.c ****     {
 309:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 108              		.loc 1 309 9
 109 0052 FFF7FEFF 		bl	vPortEnterCritical
 310:Lib/FreeRTOS/Source/queue.c ****         {
 311:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize 
 110              		.loc 1 311 47
 111 0056 BB68     		ldr	r3, [r7, #8]
 112 0058 1A68     		ldr	r2, [r3]
 113              		.loc 1 311 67
 114 005a BB68     		ldr	r3, [r7, #8]
 115 005c DB6B     		ldr	r3, [r3, #60]
 116              		.loc 1 311 87
 117 005e B968     		ldr	r1, [r7, #8]
 118 0060 096C     		ldr	r1, [r1, #64]
 119              		.loc 1 311 78
 120 0062 01FB03F3 		mul	r3, r1, r3
 121              		.loc 1 311 56
 122 0066 1A44     		add	r2, r2, r3
 123              		.loc 1 311 38
 124 0068 BB68     		ldr	r3, [r7, #8]
 125 006a 9A60     		str	r2, [r3, #8]
 312:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 126              		.loc 1 312 40
 127 006c BB68     		ldr	r3, [r7, #8]
 128 006e 0022     		movs	r2, #0
 129 0070 9A63     		str	r2, [r3, #56]
 313:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 130              		.loc 1 313 41
 131 0072 BB68     		ldr	r3, [r7, #8]
 132 0074 1A68     		ldr	r2, [r3]
 133              		.loc 1 313 32
 134 0076 BB68     		ldr	r3, [r7, #8]
 135 0078 5A60     		str	r2, [r3, #4]
 314:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue
ARM GAS  /tmp/cchrzcnP.s 			page 9


 136              		.loc 1 314 51
 137 007a BB68     		ldr	r3, [r7, #8]
 138 007c 1A68     		ldr	r2, [r3]
 139              		.loc 1 314 73
 140 007e BB68     		ldr	r3, [r7, #8]
 141 0080 DB6B     		ldr	r3, [r3, #60]
 142              		.loc 1 314 84
 143 0082 013B     		subs	r3, r3, #1
 144              		.loc 1 314 100
 145 0084 B968     		ldr	r1, [r7, #8]
 146 0086 096C     		ldr	r1, [r1, #64]
 147              		.loc 1 314 91
 148 0088 01FB03F3 		mul	r3, r1, r3
 149              		.loc 1 314 60
 150 008c 1A44     		add	r2, r2, r3
 151              		.loc 1 314 42
 152 008e BB68     		ldr	r3, [r7, #8]
 153 0090 DA60     		str	r2, [r3, #12]
 315:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cRxLock = queueUNLOCKED;
 154              		.loc 1 315 30
 155 0092 BB68     		ldr	r3, [r7, #8]
 156 0094 FF22     		movs	r2, #255
 157 0096 83F84420 		strb	r2, [r3, #68]
 316:Lib/FreeRTOS/Source/queue.c ****             pxQueue->cTxLock = queueUNLOCKED;
 158              		.loc 1 316 30
 159 009a BB68     		ldr	r3, [r7, #8]
 160 009c FF22     		movs	r2, #255
 161 009e 83F84520 		strb	r2, [r3, #69]
 317:Lib/FreeRTOS/Source/queue.c **** 
 318:Lib/FreeRTOS/Source/queue.c ****             if( xNewQueue == pdFALSE )
 162              		.loc 1 318 15
 163 00a2 3B68     		ldr	r3, [r7]
 164 00a4 002B     		cmp	r3, #0
 165 00a6 0ED1     		bne	.L6
 319:Lib/FreeRTOS/Source/queue.c ****             {
 320:Lib/FreeRTOS/Source/queue.c ****                 /* If there are tasks blocked waiting to read from the queue, then
 321:Lib/FreeRTOS/Source/queue.c ****                  * the tasks will remain blocked as after this function exits the queue
 322:Lib/FreeRTOS/Source/queue.c ****                  * will still be empty.  If there are tasks blocked waiting to write to
 323:Lib/FreeRTOS/Source/queue.c ****                  * the queue, then one should be unblocked as after this function exits
 324:Lib/FreeRTOS/Source/queue.c ****                  * it will be possible to write to it. */
 325:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 166              		.loc 1 325 21
 167 00a8 BB68     		ldr	r3, [r7, #8]
 168 00aa 1B69     		ldr	r3, [r3, #16]
 169              		.loc 1 325 19
 170 00ac 002B     		cmp	r3, #0
 171 00ae 14D0     		beq	.L7
 326:Lib/FreeRTOS/Source/queue.c ****                 {
 327:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 172              		.loc 1 327 51
 173 00b0 BB68     		ldr	r3, [r7, #8]
 174 00b2 1033     		adds	r3, r3, #16
 175              		.loc 1 327 25
 176 00b4 1846     		mov	r0, r3
 177 00b6 FFF7FEFF 		bl	xTaskRemoveFromEventList
 178 00ba 0346     		mov	r3, r0
 179              		.loc 1 327 23 discriminator 1
ARM GAS  /tmp/cchrzcnP.s 			page 10


 180 00bc 002B     		cmp	r3, #0
 181 00be 0CD0     		beq	.L7
 328:Lib/FreeRTOS/Source/queue.c ****                     {
 329:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 182              		.loc 1 329 25
 183 00c0 FFF7FEFF 		bl	vPortYield
 184 00c4 09E0     		b	.L7
 185              	.L6:
 330:Lib/FreeRTOS/Source/queue.c ****                     }
 331:Lib/FreeRTOS/Source/queue.c ****                     else
 332:Lib/FreeRTOS/Source/queue.c ****                     {
 333:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
 334:Lib/FreeRTOS/Source/queue.c ****                     }
 335:Lib/FreeRTOS/Source/queue.c ****                 }
 336:Lib/FreeRTOS/Source/queue.c ****                 else
 337:Lib/FreeRTOS/Source/queue.c ****                 {
 338:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
 339:Lib/FreeRTOS/Source/queue.c ****                 }
 340:Lib/FreeRTOS/Source/queue.c ****             }
 341:Lib/FreeRTOS/Source/queue.c ****             else
 342:Lib/FreeRTOS/Source/queue.c ****             {
 343:Lib/FreeRTOS/Source/queue.c ****                 /* Ensure the event queues start in the correct state. */
 344:Lib/FreeRTOS/Source/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 186              		.loc 1 344 17
 187 00c6 BB68     		ldr	r3, [r7, #8]
 188 00c8 1033     		adds	r3, r3, #16
 189 00ca 1846     		mov	r0, r3
 190 00cc FFF7FEFF 		bl	vListInitialise
 345:Lib/FreeRTOS/Source/queue.c ****                 vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 191              		.loc 1 345 17
 192 00d0 BB68     		ldr	r3, [r7, #8]
 193 00d2 2433     		adds	r3, r3, #36
 194 00d4 1846     		mov	r0, r3
 195 00d6 FFF7FEFF 		bl	vListInitialise
 196              	.L7:
 346:Lib/FreeRTOS/Source/queue.c ****             }
 347:Lib/FreeRTOS/Source/queue.c ****         }
 348:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 197              		.loc 1 348 9
 198 00da FFF7FEFF 		bl	vPortExitCritical
 199 00de 01E0     		b	.L8
 200              	.L3:
 349:Lib/FreeRTOS/Source/queue.c ****     }
 350:Lib/FreeRTOS/Source/queue.c ****     else
 351:Lib/FreeRTOS/Source/queue.c ****     {
 352:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFAIL;
 201              		.loc 1 352 17
 202 00e0 0023     		movs	r3, #0
 203 00e2 FB60     		str	r3, [r7, #12]
 204              	.L8:
 353:Lib/FreeRTOS/Source/queue.c ****     }
 354:Lib/FreeRTOS/Source/queue.c **** 
 355:Lib/FreeRTOS/Source/queue.c ****     configASSERT( xReturn != pdFAIL );
 205              		.loc 1 355 5
 206 00e4 FB68     		ldr	r3, [r7, #12]
 207 00e6 002B     		cmp	r3, #0
 208 00e8 08D1     		bne	.L9
ARM GAS  /tmp/cchrzcnP.s 			page 11


 209              		.loc 1 355 5 is_stmt 0 discriminator 1
 210 00ea FFF7FEFF 		bl	ulSetInterruptMask
 211 00ee 064B     		ldr	r3, .L11
 212 00f0 064A     		ldr	r2, .L11+4
 213 00f2 40F26311 		movw	r1, #355
 214 00f6 0648     		ldr	r0, .L11+8
 215 00f8 FFF7FEFF 		bl	__assert_func
 216              	.L9:
 356:Lib/FreeRTOS/Source/queue.c **** 
 357:Lib/FreeRTOS/Source/queue.c ****     /* A value is returned for calling semantic consistency with previous
 358:Lib/FreeRTOS/Source/queue.c ****      * versions. */
 359:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 217              		.loc 1 359 12 is_stmt 1
 218 00fc FB68     		ldr	r3, [r7, #12]
 360:Lib/FreeRTOS/Source/queue.c **** }
 219              		.loc 1 360 1
 220 00fe 1846     		mov	r0, r3
 221 0100 1037     		adds	r7, r7, #16
 222              		.cfi_def_cfa_offset 8
 223 0102 BD46     		mov	sp, r7
 224              		.cfi_def_cfa_register 13
 225              		@ sp needed
 226 0104 80BD     		pop	{r7, pc}
 227              	.L12:
 228 0106 00BF     		.align	2
 229              	.L11:
 230 0108 00000000 		.word	.LC0
 231 010c 00000000 		.word	__func__.24
 232 0110 04000000 		.word	.LC1
 233              		.cfi_endproc
 234              	.LFE0:
 236              		.section	.text.xQueueGenericCreateStatic,"ax",%progbits
 237              		.align	1
 238              		.global	xQueueGenericCreateStatic
 239              		.syntax unified
 240              		.thumb
 241              		.thumb_func
 243              	xQueueGenericCreateStatic:
 244              	.LFB1:
 361:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 362:Lib/FreeRTOS/Source/queue.c **** 
 363:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 364:Lib/FreeRTOS/Source/queue.c **** 
 365:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength,
 366:Lib/FreeRTOS/Source/queue.c ****                                              const UBaseType_t uxItemSize,
 367:Lib/FreeRTOS/Source/queue.c ****                                              uint8_t * pucQueueStorage,
 368:Lib/FreeRTOS/Source/queue.c ****                                              StaticQueue_t * pxStaticQueue,
 369:Lib/FreeRTOS/Source/queue.c ****                                              const uint8_t ucQueueType )
 370:Lib/FreeRTOS/Source/queue.c ****     {
 245              		.loc 1 370 5
 246              		.cfi_startproc
 247              		@ args = 4, pretend = 0, frame = 24
 248              		@ frame_needed = 1, uses_anonymous_args = 0
 249 0000 80B5     		push	{r7, lr}
 250              		.cfi_def_cfa_offset 8
 251              		.cfi_offset 7, -8
 252              		.cfi_offset 14, -4
ARM GAS  /tmp/cchrzcnP.s 			page 12


 253 0002 88B0     		sub	sp, sp, #32
 254              		.cfi_def_cfa_offset 40
 255 0004 02AF     		add	r7, sp, #8
 256              		.cfi_def_cfa 7, 32
 257 0006 F860     		str	r0, [r7, #12]
 258 0008 B960     		str	r1, [r7, #8]
 259 000a 7A60     		str	r2, [r7, #4]
 260 000c 3B60     		str	r3, [r7]
 371:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
 261              		.loc 1 371 19
 262 000e 0023     		movs	r3, #0
 263 0010 7B61     		str	r3, [r7, #20]
 372:Lib/FreeRTOS/Source/queue.c **** 
 373:Lib/FreeRTOS/Source/queue.c ****         /* The StaticQueue_t structure and the queue storage area must be
 374:Lib/FreeRTOS/Source/queue.c ****          * supplied. */
 375:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxStaticQueue );
 264              		.loc 1 375 9
 265 0012 3B68     		ldr	r3, [r7]
 266 0014 002B     		cmp	r3, #0
 267 0016 08D1     		bne	.L14
 268              		.loc 1 375 9 is_stmt 0 discriminator 1
 269 0018 FFF7FEFF 		bl	ulSetInterruptMask
 270 001c 224B     		ldr	r3, .L21
 271 001e 234A     		ldr	r2, .L21+4
 272 0020 40F27711 		movw	r1, #375
 273 0024 2248     		ldr	r0, .L21+8
 274 0026 FFF7FEFF 		bl	__assert_func
 275              	.L14:
 376:Lib/FreeRTOS/Source/queue.c **** 
 377:Lib/FreeRTOS/Source/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 276              		.loc 1 377 11 is_stmt 1
 277 002a FB68     		ldr	r3, [r7, #12]
 278 002c 002B     		cmp	r3, #0
 279 002e 2AD0     		beq	.L15
 280              		.loc 1 377 51 discriminator 1
 281 0030 3B68     		ldr	r3, [r7]
 282 0032 002B     		cmp	r3, #0
 283 0034 27D0     		beq	.L15
 378:Lib/FreeRTOS/Source/queue.c ****             ( pxStaticQueue != NULL ) &&
 284              		.loc 1 378 39
 285 0036 7B68     		ldr	r3, [r7, #4]
 286 0038 002B     		cmp	r3, #0
 287 003a 02D0     		beq	.L16
 379:Lib/FreeRTOS/Source/queue.c **** 
 380:Lib/FreeRTOS/Source/queue.c ****             /* A queue storage area should be provided if the item size is not 0, and
 381:Lib/FreeRTOS/Source/queue.c ****              * should not be provided if the item size is 0. */
 382:Lib/FreeRTOS/Source/queue.c ****             ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 288              		.loc 1 382 15
 289 003c BB68     		ldr	r3, [r7, #8]
 290 003e 002B     		cmp	r3, #0
 291 0040 21D0     		beq	.L15
 292              	.L16:
 293              		.loc 1 382 73 discriminator 1
 294 0042 7B68     		ldr	r3, [r7, #4]
 295 0044 002B     		cmp	r3, #0
 296 0046 02D1     		bne	.L17
 383:Lib/FreeRTOS/Source/queue.c ****             ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
ARM GAS  /tmp/cchrzcnP.s 			page 13


 297              		.loc 1 383 15
 298 0048 BB68     		ldr	r3, [r7, #8]
 299 004a 002B     		cmp	r3, #0
 300 004c 1BD1     		bne	.L15
 301              	.L17:
 302              	.LBB2:
 384:Lib/FreeRTOS/Source/queue.c ****         {
 385:Lib/FreeRTOS/Source/queue.c ****             #if ( configASSERT_DEFINED == 1 )
 386:Lib/FreeRTOS/Source/queue.c ****             {
 387:Lib/FreeRTOS/Source/queue.c ****                 /* Sanity check that the size of the structure used to declare a
 388:Lib/FreeRTOS/Source/queue.c ****                  * variable of type StaticQueue_t or StaticSemaphore_t equals the size of
 389:Lib/FreeRTOS/Source/queue.c ****                  * the real queue and semaphore structures. */
 390:Lib/FreeRTOS/Source/queue.c ****                 volatile size_t xSize = sizeof( StaticQueue_t );
 303              		.loc 1 390 33
 304 004e 5023     		movs	r3, #80
 305 0050 3B61     		str	r3, [r7, #16]
 391:Lib/FreeRTOS/Source/queue.c **** 
 392:Lib/FreeRTOS/Source/queue.c ****                 /* This assertion cannot be branch covered in unit tests */
 393:Lib/FreeRTOS/Source/queue.c ****                 configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 306              		.loc 1 393 17
 307 0052 3B69     		ldr	r3, [r7, #16]
 308 0054 502B     		cmp	r3, #80
 309 0056 08D0     		beq	.L18
 310              		.loc 1 393 17 is_stmt 0 discriminator 1
 311 0058 FFF7FEFF 		bl	ulSetInterruptMask
 312 005c 124B     		ldr	r3, .L21
 313 005e 134A     		ldr	r2, .L21+4
 314 0060 40F28911 		movw	r1, #393
 315 0064 1248     		ldr	r0, .L21+8
 316 0066 FFF7FEFF 		bl	__assert_func
 317              	.L18:
 394:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xSize;                             /* Keeps lint quiet when configASSERT()
 318              		.loc 1 394 17 is_stmt 1
 319 006a 3B69     		ldr	r3, [r7, #16]
 320              	.LBE2:
 395:Lib/FreeRTOS/Source/queue.c ****             }
 396:Lib/FreeRTOS/Source/queue.c ****             #endif /* configASSERT_DEFINED */
 397:Lib/FreeRTOS/Source/queue.c **** 
 398:Lib/FreeRTOS/Source/queue.c ****             /* The address of a statically allocated queue was passed in, use it.
 399:Lib/FreeRTOS/Source/queue.c ****              * The address of a statically allocated storage area was also passed in
 400:Lib/FreeRTOS/Source/queue.c ****              * but is already set. */
 401:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the
 321              		.loc 1 401 24
 322 006c 3B68     		ldr	r3, [r7]
 323 006e 7B61     		str	r3, [r7, #20]
 402:Lib/FreeRTOS/Source/queue.c **** 
 403:Lib/FreeRTOS/Source/queue.c ****             #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 404:Lib/FreeRTOS/Source/queue.c ****             {
 405:Lib/FreeRTOS/Source/queue.c ****                 /* Queues can be allocated wither statically or dynamically, so
 406:Lib/FreeRTOS/Source/queue.c ****                  * note this queue was allocated statically in case the queue is
 407:Lib/FreeRTOS/Source/queue.c ****                  * later deleted. */
 408:Lib/FreeRTOS/Source/queue.c ****                 pxNewQueue->ucStaticallyAllocated = pdTRUE;
 409:Lib/FreeRTOS/Source/queue.c ****             }
 410:Lib/FreeRTOS/Source/queue.c ****             #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 411:Lib/FreeRTOS/Source/queue.c **** 
 412:Lib/FreeRTOS/Source/queue.c ****             prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQu
 324              		.loc 1 412 13
ARM GAS  /tmp/cchrzcnP.s 			page 14


 325 0070 97F82020 		ldrb	r2, [r7, #32]	@ zero_extendqisi2
 326 0074 7B69     		ldr	r3, [r7, #20]
 327 0076 0093     		str	r3, [sp]
 328 0078 1346     		mov	r3, r2
 329 007a 7A68     		ldr	r2, [r7, #4]
 330 007c B968     		ldr	r1, [r7, #8]
 331 007e F868     		ldr	r0, [r7, #12]
 332 0080 FFF7FEFF 		bl	prvInitialiseNewQueue
 333 0084 0BE0     		b	.L19
 334              	.L15:
 413:Lib/FreeRTOS/Source/queue.c ****         }
 414:Lib/FreeRTOS/Source/queue.c ****         else
 415:Lib/FreeRTOS/Source/queue.c ****         {
 416:Lib/FreeRTOS/Source/queue.c ****             configASSERT( pxNewQueue );
 335              		.loc 1 416 13
 336 0086 7B69     		ldr	r3, [r7, #20]
 337 0088 002B     		cmp	r3, #0
 338 008a 08D1     		bne	.L19
 339              		.loc 1 416 13 is_stmt 0 discriminator 1
 340 008c FFF7FEFF 		bl	ulSetInterruptMask
 341 0090 054B     		ldr	r3, .L21
 342 0092 064A     		ldr	r2, .L21+4
 343 0094 4FF4D071 		mov	r1, #416
 344 0098 0548     		ldr	r0, .L21+8
 345 009a FFF7FEFF 		bl	__assert_func
 346              	.L19:
 417:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 418:Lib/FreeRTOS/Source/queue.c ****         }
 419:Lib/FreeRTOS/Source/queue.c **** 
 420:Lib/FreeRTOS/Source/queue.c ****         return pxNewQueue;
 347              		.loc 1 420 16 is_stmt 1
 348 009e 7B69     		ldr	r3, [r7, #20]
 421:Lib/FreeRTOS/Source/queue.c ****     }
 349              		.loc 1 421 5
 350 00a0 1846     		mov	r0, r3
 351 00a2 1837     		adds	r7, r7, #24
 352              		.cfi_def_cfa_offset 8
 353 00a4 BD46     		mov	sp, r7
 354              		.cfi_def_cfa_register 13
 355              		@ sp needed
 356 00a6 80BD     		pop	{r7, pc}
 357              	.L22:
 358              		.align	2
 359              	.L21:
 360 00a8 00000000 		.word	.LC0
 361 00ac 00000000 		.word	__func__.23
 362 00b0 04000000 		.word	.LC1
 363              		.cfi_endproc
 364              	.LFE1:
 366              		.section	.text.xQueueGenericGetStaticBuffers,"ax",%progbits
 367              		.align	1
 368              		.global	xQueueGenericGetStaticBuffers
 369              		.syntax unified
 370              		.thumb
 371              		.thumb_func
 373              	xQueueGenericGetStaticBuffers:
 374              	.LFB2:
ARM GAS  /tmp/cchrzcnP.s 			page 15


 422:Lib/FreeRTOS/Source/queue.c **** 
 423:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 424:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 425:Lib/FreeRTOS/Source/queue.c **** 
 426:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 427:Lib/FreeRTOS/Source/queue.c **** 
 428:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueGenericGetStaticBuffers( QueueHandle_t xQueue,
 429:Lib/FreeRTOS/Source/queue.c ****                                               uint8_t ** ppucQueueStorage,
 430:Lib/FreeRTOS/Source/queue.c ****                                               StaticQueue_t ** ppxStaticQueue )
 431:Lib/FreeRTOS/Source/queue.c ****     {
 375              		.loc 1 431 5
 376              		.cfi_startproc
 377              		@ args = 0, pretend = 0, frame = 24
 378              		@ frame_needed = 1, uses_anonymous_args = 0
 379 0000 80B5     		push	{r7, lr}
 380              		.cfi_def_cfa_offset 8
 381              		.cfi_offset 7, -8
 382              		.cfi_offset 14, -4
 383 0002 86B0     		sub	sp, sp, #24
 384              		.cfi_def_cfa_offset 32
 385 0004 00AF     		add	r7, sp, #0
 386              		.cfi_def_cfa_register 7
 387 0006 F860     		str	r0, [r7, #12]
 388 0008 B960     		str	r1, [r7, #8]
 389 000a 7A60     		str	r2, [r7, #4]
 432:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 433:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 390              		.loc 1 433 25
 391 000c FB68     		ldr	r3, [r7, #12]
 392 000e 7B61     		str	r3, [r7, #20]
 434:Lib/FreeRTOS/Source/queue.c **** 
 435:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxQueue );
 393              		.loc 1 435 9
 394 0010 7B69     		ldr	r3, [r7, #20]
 395 0012 002B     		cmp	r3, #0
 396 0014 08D1     		bne	.L24
 397              		.loc 1 435 9 is_stmt 0 discriminator 1
 398 0016 FFF7FEFF 		bl	ulSetInterruptMask
 399 001a 124B     		ldr	r3, .L28
 400 001c 124A     		ldr	r2, .L28+4
 401 001e 40F2B311 		movw	r1, #435
 402 0022 1248     		ldr	r0, .L28+8
 403 0024 FFF7FEFF 		bl	__assert_func
 404              	.L24:
 436:Lib/FreeRTOS/Source/queue.c ****         configASSERT( ppxStaticQueue );
 405              		.loc 1 436 9 is_stmt 1
 406 0028 7B68     		ldr	r3, [r7, #4]
 407 002a 002B     		cmp	r3, #0
 408 002c 08D1     		bne	.L25
 409              		.loc 1 436 9 is_stmt 0 discriminator 1
 410 002e FFF7FEFF 		bl	ulSetInterruptMask
 411 0032 0C4B     		ldr	r3, .L28
 412 0034 0C4A     		ldr	r2, .L28+4
 413 0036 4FF4DA71 		mov	r1, #436
 414 003a 0C48     		ldr	r0, .L28+8
 415 003c FFF7FEFF 		bl	__assert_func
 416              	.L25:
ARM GAS  /tmp/cchrzcnP.s 			page 16


 437:Lib/FreeRTOS/Source/queue.c **** 
 438:Lib/FreeRTOS/Source/queue.c ****         #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 439:Lib/FreeRTOS/Source/queue.c ****         {
 440:Lib/FreeRTOS/Source/queue.c ****             /* Check if the queue was statically allocated. */
 441:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdTRUE )
 442:Lib/FreeRTOS/Source/queue.c ****             {
 443:Lib/FreeRTOS/Source/queue.c ****                 if( ppucQueueStorage != NULL )
 444:Lib/FreeRTOS/Source/queue.c ****                 {
 445:Lib/FreeRTOS/Source/queue.c ****                     *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;
 446:Lib/FreeRTOS/Source/queue.c ****                 }
 447:Lib/FreeRTOS/Source/queue.c **** 
 448:Lib/FreeRTOS/Source/queue.c ****                 *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;
 449:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdTRUE;
 450:Lib/FreeRTOS/Source/queue.c ****             }
 451:Lib/FreeRTOS/Source/queue.c ****             else
 452:Lib/FreeRTOS/Source/queue.c ****             {
 453:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdFALSE;
 454:Lib/FreeRTOS/Source/queue.c ****             }
 455:Lib/FreeRTOS/Source/queue.c ****         }
 456:Lib/FreeRTOS/Source/queue.c ****         #else /* configSUPPORT_DYNAMIC_ALLOCATION */
 457:Lib/FreeRTOS/Source/queue.c ****         {
 458:Lib/FreeRTOS/Source/queue.c ****             /* Queue must have been statically allocated. */
 459:Lib/FreeRTOS/Source/queue.c ****             if( ppucQueueStorage != NULL )
 417              		.loc 1 459 15 is_stmt 1
 418 0040 BB68     		ldr	r3, [r7, #8]
 419 0042 002B     		cmp	r3, #0
 420 0044 03D0     		beq	.L26
 460:Lib/FreeRTOS/Source/queue.c ****             {
 461:Lib/FreeRTOS/Source/queue.c ****                 *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;
 421              		.loc 1 461 58
 422 0046 7B69     		ldr	r3, [r7, #20]
 423 0048 1A68     		ldr	r2, [r3]
 424              		.loc 1 461 35
 425 004a BB68     		ldr	r3, [r7, #8]
 426 004c 1A60     		str	r2, [r3]
 427              	.L26:
 462:Lib/FreeRTOS/Source/queue.c ****             }
 463:Lib/FreeRTOS/Source/queue.c **** 
 464:Lib/FreeRTOS/Source/queue.c ****             *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;
 428              		.loc 1 464 29
 429 004e 7B68     		ldr	r3, [r7, #4]
 430 0050 7A69     		ldr	r2, [r7, #20]
 431 0052 1A60     		str	r2, [r3]
 465:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 432              		.loc 1 465 21
 433 0054 0123     		movs	r3, #1
 434 0056 3B61     		str	r3, [r7, #16]
 466:Lib/FreeRTOS/Source/queue.c ****         }
 467:Lib/FreeRTOS/Source/queue.c ****         #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
 468:Lib/FreeRTOS/Source/queue.c **** 
 469:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 435              		.loc 1 469 16
 436 0058 3B69     		ldr	r3, [r7, #16]
 470:Lib/FreeRTOS/Source/queue.c ****     }
 437              		.loc 1 470 5
 438 005a 1846     		mov	r0, r3
 439 005c 1837     		adds	r7, r7, #24
ARM GAS  /tmp/cchrzcnP.s 			page 17


 440              		.cfi_def_cfa_offset 8
 441 005e BD46     		mov	sp, r7
 442              		.cfi_def_cfa_register 13
 443              		@ sp needed
 444 0060 80BD     		pop	{r7, pc}
 445              	.L29:
 446 0062 00BF     		.align	2
 447              	.L28:
 448 0064 00000000 		.word	.LC0
 449 0068 00000000 		.word	__func__.22
 450 006c 04000000 		.word	.LC1
 451              		.cfi_endproc
 452              	.LFE2:
 454              		.section	.text.prvInitialiseNewQueue,"ax",%progbits
 455              		.align	1
 456              		.syntax unified
 457              		.thumb
 458              		.thumb_func
 460              	prvInitialiseNewQueue:
 461              	.LFB3:
 471:Lib/FreeRTOS/Source/queue.c **** 
 472:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 473:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 474:Lib/FreeRTOS/Source/queue.c **** 
 475:Lib/FreeRTOS/Source/queue.c **** #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
 476:Lib/FreeRTOS/Source/queue.c **** 
 477:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
 478:Lib/FreeRTOS/Source/queue.c ****                                        const UBaseType_t uxItemSize,
 479:Lib/FreeRTOS/Source/queue.c ****                                        const uint8_t ucQueueType )
 480:Lib/FreeRTOS/Source/queue.c ****     {
 481:Lib/FreeRTOS/Source/queue.c ****         Queue_t * pxNewQueue = NULL;
 482:Lib/FreeRTOS/Source/queue.c ****         size_t xQueueSizeInBytes;
 483:Lib/FreeRTOS/Source/queue.c ****         uint8_t * pucQueueStorage;
 484:Lib/FreeRTOS/Source/queue.c **** 
 485:Lib/FreeRTOS/Source/queue.c ****         if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 486:Lib/FreeRTOS/Source/queue.c ****             /* Check for multiplication overflow. */
 487:Lib/FreeRTOS/Source/queue.c ****             ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 488:Lib/FreeRTOS/Source/queue.c ****             /* Check for addition overflow. */
 489:Lib/FreeRTOS/Source/queue.c ****             ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 490:Lib/FreeRTOS/Source/queue.c ****         {
 491:Lib/FreeRTOS/Source/queue.c ****             /* Allocate enough space to hold the maximum number of items that
 492:Lib/FreeRTOS/Source/queue.c ****              * can be in the queue at any time.  It is valid for uxItemSize to be
 493:Lib/FreeRTOS/Source/queue.c ****              * zero in the case the queue is used as a semaphore. */
 494:Lib/FreeRTOS/Source/queue.c ****             xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA excep
 495:Lib/FreeRTOS/Source/queue.c **** 
 496:Lib/FreeRTOS/Source/queue.c ****             /* Allocate the queue and storage area.  Justification for MISRA
 497:Lib/FreeRTOS/Source/queue.c ****              * deviation as follows:  pvPortMalloc() always ensures returned memory
 498:Lib/FreeRTOS/Source/queue.c ****              * blocks are aligned per the requirements of the MCU stack.  In this case
 499:Lib/FreeRTOS/Source/queue.c ****              * pvPortMalloc() must return a pointer that is guaranteed to meet the
 500:Lib/FreeRTOS/Source/queue.c ****              * alignment requirements of the Queue_t structure - which in this case
 501:Lib/FreeRTOS/Source/queue.c ****              * is an int8_t *.  Therefore, whenever the stack alignment requirements
 502:Lib/FreeRTOS/Source/queue.c ****              * are greater than or equal to the pointer to char requirements the cast
 503:Lib/FreeRTOS/Source/queue.c ****              * is safe.  In other cases alignment requirements are not strict (one or
 504:Lib/FreeRTOS/Source/queue.c ****              * two bytes). */
 505:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lin
 506:Lib/FreeRTOS/Source/queue.c **** 
 507:Lib/FreeRTOS/Source/queue.c ****             if( pxNewQueue != NULL )
ARM GAS  /tmp/cchrzcnP.s 			page 18


 508:Lib/FreeRTOS/Source/queue.c ****             {
 509:Lib/FreeRTOS/Source/queue.c ****                 /* Jump past the queue structure to find the location of the queue
 510:Lib/FreeRTOS/Source/queue.c ****                  * storage area. */
 511:Lib/FreeRTOS/Source/queue.c ****                 pucQueueStorage = ( uint8_t * ) pxNewQueue;
 512:Lib/FreeRTOS/Source/queue.c ****                 pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on c
 513:Lib/FreeRTOS/Source/queue.c **** 
 514:Lib/FreeRTOS/Source/queue.c ****                 #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
 515:Lib/FreeRTOS/Source/queue.c ****                 {
 516:Lib/FreeRTOS/Source/queue.c ****                     /* Queues can be created either statically or dynamically, so
 517:Lib/FreeRTOS/Source/queue.c ****                      * note this task was created dynamically in case it is later
 518:Lib/FreeRTOS/Source/queue.c ****                      * deleted. */
 519:Lib/FreeRTOS/Source/queue.c ****                     pxNewQueue->ucStaticallyAllocated = pdFALSE;
 520:Lib/FreeRTOS/Source/queue.c ****                 }
 521:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configSUPPORT_STATIC_ALLOCATION */
 522:Lib/FreeRTOS/Source/queue.c **** 
 523:Lib/FreeRTOS/Source/queue.c ****                 prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxN
 524:Lib/FreeRTOS/Source/queue.c ****             }
 525:Lib/FreeRTOS/Source/queue.c ****             else
 526:Lib/FreeRTOS/Source/queue.c ****             {
 527:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_CREATE_FAILED( ucQueueType );
 528:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 529:Lib/FreeRTOS/Source/queue.c ****             }
 530:Lib/FreeRTOS/Source/queue.c ****         }
 531:Lib/FreeRTOS/Source/queue.c ****         else
 532:Lib/FreeRTOS/Source/queue.c ****         {
 533:Lib/FreeRTOS/Source/queue.c ****             configASSERT( pxNewQueue );
 534:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 535:Lib/FreeRTOS/Source/queue.c ****         }
 536:Lib/FreeRTOS/Source/queue.c **** 
 537:Lib/FreeRTOS/Source/queue.c ****         return pxNewQueue;
 538:Lib/FreeRTOS/Source/queue.c ****     }
 539:Lib/FreeRTOS/Source/queue.c **** 
 540:Lib/FreeRTOS/Source/queue.c **** #endif /* configSUPPORT_STATIC_ALLOCATION */
 541:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 542:Lib/FreeRTOS/Source/queue.c **** 
 543:Lib/FreeRTOS/Source/queue.c **** static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
 544:Lib/FreeRTOS/Source/queue.c ****                                    const UBaseType_t uxItemSize,
 545:Lib/FreeRTOS/Source/queue.c ****                                    uint8_t * pucQueueStorage,
 546:Lib/FreeRTOS/Source/queue.c ****                                    const uint8_t ucQueueType,
 547:Lib/FreeRTOS/Source/queue.c ****                                    Queue_t * pxNewQueue )
 548:Lib/FreeRTOS/Source/queue.c **** {
 462              		.loc 1 548 1
 463              		.cfi_startproc
 464              		@ args = 4, pretend = 0, frame = 16
 465              		@ frame_needed = 1, uses_anonymous_args = 0
 466 0000 80B5     		push	{r7, lr}
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 7, -8
 469              		.cfi_offset 14, -4
 470 0002 84B0     		sub	sp, sp, #16
 471              		.cfi_def_cfa_offset 24
 472 0004 00AF     		add	r7, sp, #0
 473              		.cfi_def_cfa_register 7
 474 0006 F860     		str	r0, [r7, #12]
 475 0008 B960     		str	r1, [r7, #8]
 476 000a 7A60     		str	r2, [r7, #4]
 477 000c FB70     		strb	r3, [r7, #3]
ARM GAS  /tmp/cchrzcnP.s 			page 19


 549:Lib/FreeRTOS/Source/queue.c ****     /* Remove compiler warnings about unused parameters should
 550:Lib/FreeRTOS/Source/queue.c ****      * configUSE_TRACE_FACILITY not be set to 1. */
 551:Lib/FreeRTOS/Source/queue.c ****     ( void ) ucQueueType;
 552:Lib/FreeRTOS/Source/queue.c **** 
 553:Lib/FreeRTOS/Source/queue.c ****     if( uxItemSize == ( UBaseType_t ) 0 )
 478              		.loc 1 553 7
 479 000e BB68     		ldr	r3, [r7, #8]
 480 0010 002B     		cmp	r3, #0
 481 0012 03D1     		bne	.L31
 554:Lib/FreeRTOS/Source/queue.c ****     {
 555:Lib/FreeRTOS/Source/queue.c ****         /* No RAM was allocated for the queue storage area, but PC head cannot
 556:Lib/FreeRTOS/Source/queue.c ****          * be set to NULL because NULL is used as a key to say the queue is used as
 557:Lib/FreeRTOS/Source/queue.c ****          * a mutex.  Therefore just set pcHead to point to the queue as a benign
 558:Lib/FreeRTOS/Source/queue.c ****          * value that is known to be within the memory map. */
 559:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 482              		.loc 1 559 28
 483 0014 BB69     		ldr	r3, [r7, #24]
 484 0016 BA69     		ldr	r2, [r7, #24]
 485 0018 1A60     		str	r2, [r3]
 486 001a 02E0     		b	.L32
 487              	.L31:
 560:Lib/FreeRTOS/Source/queue.c ****     }
 561:Lib/FreeRTOS/Source/queue.c ****     else
 562:Lib/FreeRTOS/Source/queue.c ****     {
 563:Lib/FreeRTOS/Source/queue.c ****         /* Set the head to the start of the queue storage area. */
 564:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 488              		.loc 1 564 28
 489 001c BB69     		ldr	r3, [r7, #24]
 490 001e 7A68     		ldr	r2, [r7, #4]
 491 0020 1A60     		str	r2, [r3]
 492              	.L32:
 565:Lib/FreeRTOS/Source/queue.c ****     }
 566:Lib/FreeRTOS/Source/queue.c **** 
 567:Lib/FreeRTOS/Source/queue.c ****     /* Initialise the queue members as described where the queue type is
 568:Lib/FreeRTOS/Source/queue.c ****      * defined. */
 569:Lib/FreeRTOS/Source/queue.c ****     pxNewQueue->uxLength = uxQueueLength;
 493              		.loc 1 569 26
 494 0022 BB69     		ldr	r3, [r7, #24]
 495 0024 FA68     		ldr	r2, [r7, #12]
 496 0026 DA63     		str	r2, [r3, #60]
 570:Lib/FreeRTOS/Source/queue.c ****     pxNewQueue->uxItemSize = uxItemSize;
 497              		.loc 1 570 28
 498 0028 BB69     		ldr	r3, [r7, #24]
 499 002a BA68     		ldr	r2, [r7, #8]
 500 002c 1A64     		str	r2, [r3, #64]
 571:Lib/FreeRTOS/Source/queue.c ****     ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 501              		.loc 1 571 14
 502 002e 0121     		movs	r1, #1
 503 0030 B869     		ldr	r0, [r7, #24]
 504 0032 FFF7FEFF 		bl	xQueueGenericReset
 572:Lib/FreeRTOS/Source/queue.c **** 
 573:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_TRACE_FACILITY == 1 )
 574:Lib/FreeRTOS/Source/queue.c ****     {
 575:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->ucQueueType = ucQueueType;
 505              		.loc 1 575 33
 506 0036 BB69     		ldr	r3, [r7, #24]
 507 0038 FA78     		ldrb	r2, [r7, #3]
ARM GAS  /tmp/cchrzcnP.s 			page 20


 508 003a 83F84C20 		strb	r2, [r3, #76]
 576:Lib/FreeRTOS/Source/queue.c ****     }
 577:Lib/FreeRTOS/Source/queue.c ****     #endif /* configUSE_TRACE_FACILITY */
 578:Lib/FreeRTOS/Source/queue.c **** 
 579:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_QUEUE_SETS == 1 )
 580:Lib/FreeRTOS/Source/queue.c ****     {
 581:Lib/FreeRTOS/Source/queue.c ****         pxNewQueue->pxQueueSetContainer = NULL;
 582:Lib/FreeRTOS/Source/queue.c ****     }
 583:Lib/FreeRTOS/Source/queue.c ****     #endif /* configUSE_QUEUE_SETS */
 584:Lib/FreeRTOS/Source/queue.c **** 
 585:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_CREATE( pxNewQueue );
 586:Lib/FreeRTOS/Source/queue.c **** }
 509              		.loc 1 586 1
 510 003e 00BF     		nop
 511 0040 1037     		adds	r7, r7, #16
 512              		.cfi_def_cfa_offset 8
 513 0042 BD46     		mov	sp, r7
 514              		.cfi_def_cfa_register 13
 515              		@ sp needed
 516 0044 80BD     		pop	{r7, pc}
 517              		.cfi_endproc
 518              	.LFE3:
 520              		.section	.text.prvInitialiseMutex,"ax",%progbits
 521              		.align	1
 522              		.syntax unified
 523              		.thumb
 524              		.thumb_func
 526              	prvInitialiseMutex:
 527              	.LFB4:
 587:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 588:Lib/FreeRTOS/Source/queue.c **** 
 589:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
 590:Lib/FreeRTOS/Source/queue.c **** 
 591:Lib/FreeRTOS/Source/queue.c ****     static void prvInitialiseMutex( Queue_t * pxNewQueue )
 592:Lib/FreeRTOS/Source/queue.c ****     {
 528              		.loc 1 592 5
 529              		.cfi_startproc
 530              		@ args = 0, pretend = 0, frame = 8
 531              		@ frame_needed = 1, uses_anonymous_args = 0
 532 0000 80B5     		push	{r7, lr}
 533              		.cfi_def_cfa_offset 8
 534              		.cfi_offset 7, -8
 535              		.cfi_offset 14, -4
 536 0002 82B0     		sub	sp, sp, #8
 537              		.cfi_def_cfa_offset 16
 538 0004 00AF     		add	r7, sp, #0
 539              		.cfi_def_cfa_register 7
 540 0006 7860     		str	r0, [r7, #4]
 593:Lib/FreeRTOS/Source/queue.c ****         if( pxNewQueue != NULL )
 541              		.loc 1 593 11
 542 0008 7B68     		ldr	r3, [r7, #4]
 543 000a 002B     		cmp	r3, #0
 544 000c 0ED0     		beq	.L35
 594:Lib/FreeRTOS/Source/queue.c ****         {
 595:Lib/FreeRTOS/Source/queue.c ****             /* The queue create function will set all the queue structure members
 596:Lib/FreeRTOS/Source/queue.c ****             * correctly for a generic queue, but this function is creating a
 597:Lib/FreeRTOS/Source/queue.c ****             * mutex.  Overwrite those members that need to be set differently -
ARM GAS  /tmp/cchrzcnP.s 			page 21


 598:Lib/FreeRTOS/Source/queue.c ****             * in particular the information required for priority inheritance. */
 599:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 545              		.loc 1 599 51
 546 000e 7B68     		ldr	r3, [r7, #4]
 547 0010 0022     		movs	r2, #0
 548 0012 9A60     		str	r2, [r3, #8]
 600:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 549              		.loc 1 600 37
 550 0014 7B68     		ldr	r3, [r7, #4]
 551 0016 0022     		movs	r2, #0
 552 0018 1A60     		str	r2, [r3]
 601:Lib/FreeRTOS/Source/queue.c **** 
 602:Lib/FreeRTOS/Source/queue.c ****             /* In case this is a recursive mutex. */
 603:Lib/FreeRTOS/Source/queue.c ****             pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 553              		.loc 1 603 59
 554 001a 7B68     		ldr	r3, [r7, #4]
 555 001c 0022     		movs	r2, #0
 556 001e DA60     		str	r2, [r3, #12]
 604:Lib/FreeRTOS/Source/queue.c **** 
 605:Lib/FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX( pxNewQueue );
 606:Lib/FreeRTOS/Source/queue.c **** 
 607:Lib/FreeRTOS/Source/queue.c ****             /* Start with the semaphore in the expected state. */
 608:Lib/FreeRTOS/Source/queue.c ****             ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 557              		.loc 1 608 22
 558 0020 0023     		movs	r3, #0
 559 0022 0022     		movs	r2, #0
 560 0024 0021     		movs	r1, #0
 561 0026 7868     		ldr	r0, [r7, #4]
 562 0028 FFF7FEFF 		bl	xQueueGenericSend
 563              	.L35:
 609:Lib/FreeRTOS/Source/queue.c ****         }
 610:Lib/FreeRTOS/Source/queue.c ****         else
 611:Lib/FreeRTOS/Source/queue.c ****         {
 612:Lib/FreeRTOS/Source/queue.c ****             traceCREATE_MUTEX_FAILED();
 613:Lib/FreeRTOS/Source/queue.c ****         }
 614:Lib/FreeRTOS/Source/queue.c ****     }
 564              		.loc 1 614 5
 565 002c 00BF     		nop
 566 002e 0837     		adds	r7, r7, #8
 567              		.cfi_def_cfa_offset 8
 568 0030 BD46     		mov	sp, r7
 569              		.cfi_def_cfa_register 13
 570              		@ sp needed
 571 0032 80BD     		pop	{r7, pc}
 572              		.cfi_endproc
 573              	.LFE4:
 575              		.section	.text.xQueueCreateMutexStatic,"ax",%progbits
 576              		.align	1
 577              		.global	xQueueCreateMutexStatic
 578              		.syntax unified
 579              		.thumb
 580              		.thumb_func
 582              	xQueueCreateMutexStatic:
 583              	.LFB5:
 615:Lib/FreeRTOS/Source/queue.c **** 
 616:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 617:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/cchrzcnP.s 			page 22


 618:Lib/FreeRTOS/Source/queue.c **** 
 619:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 620:Lib/FreeRTOS/Source/queue.c **** 
 621:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
 622:Lib/FreeRTOS/Source/queue.c ****     {
 623:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 624:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 625:Lib/FreeRTOS/Source/queue.c **** 
 626:Lib/FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 627:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 628:Lib/FreeRTOS/Source/queue.c **** 
 629:Lib/FreeRTOS/Source/queue.c ****         return xNewQueue;
 630:Lib/FreeRTOS/Source/queue.c ****     }
 631:Lib/FreeRTOS/Source/queue.c **** 
 632:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 633:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 634:Lib/FreeRTOS/Source/queue.c **** 
 635:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 636:Lib/FreeRTOS/Source/queue.c **** 
 637:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType,
 638:Lib/FreeRTOS/Source/queue.c ****                                            StaticQueue_t * pxStaticQueue )
 639:Lib/FreeRTOS/Source/queue.c ****     {
 584              		.loc 1 639 5
 585              		.cfi_startproc
 586              		@ args = 0, pretend = 0, frame = 24
 587              		@ frame_needed = 1, uses_anonymous_args = 0
 588 0000 80B5     		push	{r7, lr}
 589              		.cfi_def_cfa_offset 8
 590              		.cfi_offset 7, -8
 591              		.cfi_offset 14, -4
 592 0002 88B0     		sub	sp, sp, #32
 593              		.cfi_def_cfa_offset 40
 594 0004 02AF     		add	r7, sp, #8
 595              		.cfi_def_cfa 7, 32
 596 0006 0346     		mov	r3, r0
 597 0008 3960     		str	r1, [r7]
 598 000a FB71     		strb	r3, [r7, #7]
 640:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xNewQueue;
 641:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 599              		.loc 1 641 27
 600 000c 0123     		movs	r3, #1
 601 000e 7B61     		str	r3, [r7, #20]
 602              		.loc 1 641 62
 603 0010 0023     		movs	r3, #0
 604 0012 3B61     		str	r3, [r7, #16]
 642:Lib/FreeRTOS/Source/queue.c **** 
 643:Lib/FreeRTOS/Source/queue.c ****         /* Prevent compiler warnings about unused parameters if
 644:Lib/FreeRTOS/Source/queue.c ****          * configUSE_TRACE_FACILITY does not equal 1. */
 645:Lib/FreeRTOS/Source/queue.c ****         ( void ) ucQueueType;
 646:Lib/FreeRTOS/Source/queue.c **** 
 647:Lib/FreeRTOS/Source/queue.c ****         xNewQueue = xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQ
 605              		.loc 1 647 21
 606 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 607 0016 0093     		str	r3, [sp]
 608 0018 3B68     		ldr	r3, [r7]
 609 001a 0022     		movs	r2, #0
 610 001c 3969     		ldr	r1, [r7, #16]
ARM GAS  /tmp/cchrzcnP.s 			page 23


 611 001e 7869     		ldr	r0, [r7, #20]
 612 0020 FFF7FEFF 		bl	xQueueGenericCreateStatic
 613 0024 F860     		str	r0, [r7, #12]
 648:Lib/FreeRTOS/Source/queue.c ****         prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 614              		.loc 1 648 9
 615 0026 F868     		ldr	r0, [r7, #12]
 616 0028 FFF7FEFF 		bl	prvInitialiseMutex
 649:Lib/FreeRTOS/Source/queue.c **** 
 650:Lib/FreeRTOS/Source/queue.c ****         return xNewQueue;
 617              		.loc 1 650 16
 618 002c FB68     		ldr	r3, [r7, #12]
 651:Lib/FreeRTOS/Source/queue.c ****     }
 619              		.loc 1 651 5
 620 002e 1846     		mov	r0, r3
 621 0030 1837     		adds	r7, r7, #24
 622              		.cfi_def_cfa_offset 8
 623 0032 BD46     		mov	sp, r7
 624              		.cfi_def_cfa_register 13
 625              		@ sp needed
 626 0034 80BD     		pop	{r7, pc}
 627              		.cfi_endproc
 628              	.LFE5:
 630              		.section	.text.xQueueGetMutexHolder,"ax",%progbits
 631              		.align	1
 632              		.global	xQueueGetMutexHolder
 633              		.syntax unified
 634              		.thumb
 635              		.thumb_func
 637              	xQueueGetMutexHolder:
 638              	.LFB6:
 652:Lib/FreeRTOS/Source/queue.c **** 
 653:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
 654:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 655:Lib/FreeRTOS/Source/queue.c **** 
 656:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 657:Lib/FreeRTOS/Source/queue.c **** 
 658:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolder( QueueHandle_t xSemaphore )
 659:Lib/FreeRTOS/Source/queue.c ****     {
 639              		.loc 1 659 5
 640              		.cfi_startproc
 641              		@ args = 0, pretend = 0, frame = 16
 642              		@ frame_needed = 1, uses_anonymous_args = 0
 643 0000 80B5     		push	{r7, lr}
 644              		.cfi_def_cfa_offset 8
 645              		.cfi_offset 7, -8
 646              		.cfi_offset 14, -4
 647 0002 84B0     		sub	sp, sp, #16
 648              		.cfi_def_cfa_offset 24
 649 0004 00AF     		add	r7, sp, #0
 650              		.cfi_def_cfa_register 7
 651 0006 7860     		str	r0, [r7, #4]
 660:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 661:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxSemaphore = ( Queue_t * ) xSemaphore;
 652              		.loc 1 661 25
 653 0008 7B68     		ldr	r3, [r7, #4]
 654 000a BB60     		str	r3, [r7, #8]
 662:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 24


 663:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xSemaphore );
 655              		.loc 1 663 9
 656 000c 7B68     		ldr	r3, [r7, #4]
 657 000e 002B     		cmp	r3, #0
 658 0010 08D1     		bne	.L39
 659              		.loc 1 663 9 is_stmt 0 discriminator 1
 660 0012 FFF7FEFF 		bl	ulSetInterruptMask
 661 0016 0D4B     		ldr	r3, .L43
 662 0018 0D4A     		ldr	r2, .L43+4
 663 001a 40F29721 		movw	r1, #663
 664 001e 0D48     		ldr	r0, .L43+8
 665 0020 FFF7FEFF 		bl	__assert_func
 666              	.L39:
 664:Lib/FreeRTOS/Source/queue.c **** 
 665:Lib/FreeRTOS/Source/queue.c ****         /* This function is called by xSemaphoreGetMutexHolder(), and should not
 666:Lib/FreeRTOS/Source/queue.c ****          * be called directly.  Note:  This is a good way of determining if the
 667:Lib/FreeRTOS/Source/queue.c ****          * calling task is the mutex holder, but not a good way of determining the
 668:Lib/FreeRTOS/Source/queue.c ****          * identity of the mutex holder, as the holder may change between the
 669:Lib/FreeRTOS/Source/queue.c ****          * following critical section exiting and the function returning. */
 670:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 667              		.loc 1 670 9 is_stmt 1
 668 0024 FFF7FEFF 		bl	vPortEnterCritical
 671:Lib/FreeRTOS/Source/queue.c ****         {
 672:Lib/FreeRTOS/Source/queue.c ****             if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 669              		.loc 1 672 28
 670 0028 BB68     		ldr	r3, [r7, #8]
 671 002a 1B68     		ldr	r3, [r3]
 672              		.loc 1 672 15
 673 002c 002B     		cmp	r3, #0
 674 002e 03D1     		bne	.L40
 673:Lib/FreeRTOS/Source/queue.c ****             {
 674:Lib/FreeRTOS/Source/queue.c ****                 pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 675              		.loc 1 674 26
 676 0030 BB68     		ldr	r3, [r7, #8]
 677 0032 9B68     		ldr	r3, [r3, #8]
 678 0034 FB60     		str	r3, [r7, #12]
 679 0036 01E0     		b	.L41
 680              	.L40:
 675:Lib/FreeRTOS/Source/queue.c ****             }
 676:Lib/FreeRTOS/Source/queue.c ****             else
 677:Lib/FreeRTOS/Source/queue.c ****             {
 678:Lib/FreeRTOS/Source/queue.c ****                 pxReturn = NULL;
 681              		.loc 1 678 26
 682 0038 0023     		movs	r3, #0
 683 003a FB60     		str	r3, [r7, #12]
 684              	.L41:
 679:Lib/FreeRTOS/Source/queue.c ****             }
 680:Lib/FreeRTOS/Source/queue.c ****         }
 681:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 685              		.loc 1 681 9
 686 003c FFF7FEFF 		bl	vPortExitCritical
 682:Lib/FreeRTOS/Source/queue.c **** 
 683:Lib/FreeRTOS/Source/queue.c ****         return pxReturn;
 687              		.loc 1 683 16
 688 0040 FB68     		ldr	r3, [r7, #12]
 684:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 689              		.loc 1 684 5
ARM GAS  /tmp/cchrzcnP.s 			page 25


 690 0042 1846     		mov	r0, r3
 691 0044 1037     		adds	r7, r7, #16
 692              		.cfi_def_cfa_offset 8
 693 0046 BD46     		mov	sp, r7
 694              		.cfi_def_cfa_register 13
 695              		@ sp needed
 696 0048 80BD     		pop	{r7, pc}
 697              	.L44:
 698 004a 00BF     		.align	2
 699              	.L43:
 700 004c 00000000 		.word	.LC0
 701 0050 00000000 		.word	__func__.21
 702 0054 04000000 		.word	.LC1
 703              		.cfi_endproc
 704              	.LFE6:
 706              		.section	.text.xQueueGetMutexHolderFromISR,"ax",%progbits
 707              		.align	1
 708              		.global	xQueueGetMutexHolderFromISR
 709              		.syntax unified
 710              		.thumb
 711              		.thumb_func
 713              	xQueueGetMutexHolderFromISR:
 714              	.LFB7:
 685:Lib/FreeRTOS/Source/queue.c **** 
 686:Lib/FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 687:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 688:Lib/FreeRTOS/Source/queue.c **** 
 689:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
 690:Lib/FreeRTOS/Source/queue.c **** 
 691:Lib/FreeRTOS/Source/queue.c ****     TaskHandle_t xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
 692:Lib/FreeRTOS/Source/queue.c ****     {
 715              		.loc 1 692 5
 716              		.cfi_startproc
 717              		@ args = 0, pretend = 0, frame = 16
 718              		@ frame_needed = 1, uses_anonymous_args = 0
 719 0000 80B5     		push	{r7, lr}
 720              		.cfi_def_cfa_offset 8
 721              		.cfi_offset 7, -8
 722              		.cfi_offset 14, -4
 723 0002 84B0     		sub	sp, sp, #16
 724              		.cfi_def_cfa_offset 24
 725 0004 00AF     		add	r7, sp, #0
 726              		.cfi_def_cfa_register 7
 727 0006 7860     		str	r0, [r7, #4]
 693:Lib/FreeRTOS/Source/queue.c ****         TaskHandle_t pxReturn;
 694:Lib/FreeRTOS/Source/queue.c **** 
 695:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xSemaphore );
 728              		.loc 1 695 9
 729 0008 7B68     		ldr	r3, [r7, #4]
 730 000a 002B     		cmp	r3, #0
 731 000c 08D1     		bne	.L46
 732              		.loc 1 695 9 is_stmt 0 discriminator 1
 733 000e FFF7FEFF 		bl	ulSetInterruptMask
 734 0012 0B4B     		ldr	r3, .L50
 735 0014 0B4A     		ldr	r2, .L50+4
 736 0016 40F2B721 		movw	r1, #695
 737 001a 0B48     		ldr	r0, .L50+8
ARM GAS  /tmp/cchrzcnP.s 			page 26


 738 001c FFF7FEFF 		bl	__assert_func
 739              	.L46:
 696:Lib/FreeRTOS/Source/queue.c **** 
 697:Lib/FreeRTOS/Source/queue.c ****         /* Mutexes cannot be used in interrupt service routines, so the mutex
 698:Lib/FreeRTOS/Source/queue.c ****          * holder should not change in an ISR, and therefore a critical section is
 699:Lib/FreeRTOS/Source/queue.c ****          * not required here. */
 700:Lib/FreeRTOS/Source/queue.c ****         if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 740              		.loc 1 700 41 is_stmt 1
 741 0020 7B68     		ldr	r3, [r7, #4]
 742 0022 1B68     		ldr	r3, [r3]
 743              		.loc 1 700 11
 744 0024 002B     		cmp	r3, #0
 745 0026 03D1     		bne	.L47
 701:Lib/FreeRTOS/Source/queue.c ****         {
 702:Lib/FreeRTOS/Source/queue.c ****             pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 746              		.loc 1 702 22
 747 0028 7B68     		ldr	r3, [r7, #4]
 748 002a 9B68     		ldr	r3, [r3, #8]
 749 002c FB60     		str	r3, [r7, #12]
 750 002e 01E0     		b	.L48
 751              	.L47:
 703:Lib/FreeRTOS/Source/queue.c ****         }
 704:Lib/FreeRTOS/Source/queue.c ****         else
 705:Lib/FreeRTOS/Source/queue.c ****         {
 706:Lib/FreeRTOS/Source/queue.c ****             pxReturn = NULL;
 752              		.loc 1 706 22
 753 0030 0023     		movs	r3, #0
 754 0032 FB60     		str	r3, [r7, #12]
 755              	.L48:
 707:Lib/FreeRTOS/Source/queue.c ****         }
 708:Lib/FreeRTOS/Source/queue.c **** 
 709:Lib/FreeRTOS/Source/queue.c ****         return pxReturn;
 756              		.loc 1 709 16
 757 0034 FB68     		ldr	r3, [r7, #12]
 710:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
 758              		.loc 1 710 5
 759 0036 1846     		mov	r0, r3
 760 0038 1037     		adds	r7, r7, #16
 761              		.cfi_def_cfa_offset 8
 762 003a BD46     		mov	sp, r7
 763              		.cfi_def_cfa_register 13
 764              		@ sp needed
 765 003c 80BD     		pop	{r7, pc}
 766              	.L51:
 767 003e 00BF     		.align	2
 768              	.L50:
 769 0040 00000000 		.word	.LC0
 770 0044 00000000 		.word	__func__.20
 771 0048 04000000 		.word	.LC1
 772              		.cfi_endproc
 773              	.LFE7:
 775              		.section	.text.xQueueGiveMutexRecursive,"ax",%progbits
 776              		.align	1
 777              		.global	xQueueGiveMutexRecursive
 778              		.syntax unified
 779              		.thumb
 780              		.thumb_func
ARM GAS  /tmp/cchrzcnP.s 			page 27


 782              	xQueueGiveMutexRecursive:
 783              	.LFB8:
 711:Lib/FreeRTOS/Source/queue.c **** 
 712:Lib/FreeRTOS/Source/queue.c **** #endif /* if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) ) */
 713:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 714:Lib/FreeRTOS/Source/queue.c **** 
 715:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 716:Lib/FreeRTOS/Source/queue.c **** 
 717:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
 718:Lib/FreeRTOS/Source/queue.c ****     {
 784              		.loc 1 718 5
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 16
 787              		@ frame_needed = 1, uses_anonymous_args = 0
 788 0000 90B5     		push	{r4, r7, lr}
 789              		.cfi_def_cfa_offset 12
 790              		.cfi_offset 4, -12
 791              		.cfi_offset 7, -8
 792              		.cfi_offset 14, -4
 793 0002 85B0     		sub	sp, sp, #20
 794              		.cfi_def_cfa_offset 32
 795 0004 00AF     		add	r7, sp, #0
 796              		.cfi_def_cfa_register 7
 797 0006 7860     		str	r0, [r7, #4]
 719:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 720:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 798              		.loc 1 720 25
 799 0008 7B68     		ldr	r3, [r7, #4]
 800 000a BB60     		str	r3, [r7, #8]
 721:Lib/FreeRTOS/Source/queue.c **** 
 722:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 801              		.loc 1 722 9
 802 000c BB68     		ldr	r3, [r7, #8]
 803 000e 002B     		cmp	r3, #0
 804 0010 08D1     		bne	.L53
 805              		.loc 1 722 9 is_stmt 0 discriminator 1
 806 0012 FFF7FEFF 		bl	ulSetInterruptMask
 807 0016 134B     		ldr	r3, .L58
 808 0018 134A     		ldr	r2, .L58+4
 809 001a 40F2D221 		movw	r1, #722
 810 001e 1348     		ldr	r0, .L58+8
 811 0020 FFF7FEFF 		bl	__assert_func
 812              	.L53:
 723:Lib/FreeRTOS/Source/queue.c **** 
 724:Lib/FreeRTOS/Source/queue.c ****         /* If this is the task that holds the mutex then xMutexHolder will not
 725:Lib/FreeRTOS/Source/queue.c ****          * change outside of this task.  If this task does not hold the mutex then
 726:Lib/FreeRTOS/Source/queue.c ****          * pxMutexHolder can never coincidentally equal the tasks handle, and as
 727:Lib/FreeRTOS/Source/queue.c ****          * this is the only condition we are interested in it does not matter if
 728:Lib/FreeRTOS/Source/queue.c ****          * pxMutexHolder is accessed simultaneously by another task.  Therefore no
 729:Lib/FreeRTOS/Source/queue.c ****          * mutual exclusion is required to test the pxMutexHolder variable. */
 730:Lib/FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 813              		.loc 1 730 34 is_stmt 1
 814 0024 BB68     		ldr	r3, [r7, #8]
 815 0026 9C68     		ldr	r4, [r3, #8]
 816              		.loc 1 730 51
 817 0028 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 818 002c 0346     		mov	r3, r0
ARM GAS  /tmp/cchrzcnP.s 			page 28


 819              		.loc 1 730 11 discriminator 1
 820 002e 9C42     		cmp	r4, r3
 821 0030 11D1     		bne	.L54
 731:Lib/FreeRTOS/Source/queue.c ****         {
 732:Lib/FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE( pxMutex );
 733:Lib/FreeRTOS/Source/queue.c **** 
 734:Lib/FreeRTOS/Source/queue.c ****             /* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
 735:Lib/FreeRTOS/Source/queue.c ****              * the task handle, therefore no underflow check is required.  Also,
 736:Lib/FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount is only modified by the mutex holder, and as
 737:Lib/FreeRTOS/Source/queue.c ****              * there can only be one, no mutual exclusion is required to modify the
 738:Lib/FreeRTOS/Source/queue.c ****              * uxRecursiveCallCount member. */
 739:Lib/FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 822              		.loc 1 739 36
 823 0032 BB68     		ldr	r3, [r7, #8]
 824 0034 DB68     		ldr	r3, [r3, #12]
 825              		.loc 1 739 59
 826 0036 5A1E     		subs	r2, r3, #1
 827 0038 BB68     		ldr	r3, [r7, #8]
 828 003a DA60     		str	r2, [r3, #12]
 740:Lib/FreeRTOS/Source/queue.c **** 
 741:Lib/FreeRTOS/Source/queue.c ****             /* Has the recursive call count unwound to 0? */
 742:Lib/FreeRTOS/Source/queue.c ****             if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 829              		.loc 1 742 38
 830 003c BB68     		ldr	r3, [r7, #8]
 831 003e DB68     		ldr	r3, [r3, #12]
 832              		.loc 1 742 15
 833 0040 002B     		cmp	r3, #0
 834 0042 05D1     		bne	.L55
 743:Lib/FreeRTOS/Source/queue.c ****             {
 744:Lib/FreeRTOS/Source/queue.c ****                 /* Return the mutex.  This will automatically unblock any other
 745:Lib/FreeRTOS/Source/queue.c ****                  * task that might be waiting to access the mutex. */
 746:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO
 835              		.loc 1 746 26
 836 0044 0023     		movs	r3, #0
 837 0046 0022     		movs	r2, #0
 838 0048 0021     		movs	r1, #0
 839 004a B868     		ldr	r0, [r7, #8]
 840 004c FFF7FEFF 		bl	xQueueGenericSend
 841              	.L55:
 747:Lib/FreeRTOS/Source/queue.c ****             }
 748:Lib/FreeRTOS/Source/queue.c ****             else
 749:Lib/FreeRTOS/Source/queue.c ****             {
 750:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
 751:Lib/FreeRTOS/Source/queue.c ****             }
 752:Lib/FreeRTOS/Source/queue.c **** 
 753:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 842              		.loc 1 753 21
 843 0050 0123     		movs	r3, #1
 844 0052 FB60     		str	r3, [r7, #12]
 845 0054 01E0     		b	.L56
 846              	.L54:
 754:Lib/FreeRTOS/Source/queue.c ****         }
 755:Lib/FreeRTOS/Source/queue.c ****         else
 756:Lib/FreeRTOS/Source/queue.c ****         {
 757:Lib/FreeRTOS/Source/queue.c ****             /* The mutex cannot be given because the calling task is not the
 758:Lib/FreeRTOS/Source/queue.c ****              * holder. */
 759:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
ARM GAS  /tmp/cchrzcnP.s 			page 29


 847              		.loc 1 759 21
 848 0056 0023     		movs	r3, #0
 849 0058 FB60     		str	r3, [r7, #12]
 850              	.L56:
 760:Lib/FreeRTOS/Source/queue.c **** 
 761:Lib/FreeRTOS/Source/queue.c ****             traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 762:Lib/FreeRTOS/Source/queue.c ****         }
 763:Lib/FreeRTOS/Source/queue.c **** 
 764:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 851              		.loc 1 764 16
 852 005a FB68     		ldr	r3, [r7, #12]
 765:Lib/FreeRTOS/Source/queue.c ****     }
 853              		.loc 1 765 5
 854 005c 1846     		mov	r0, r3
 855 005e 1437     		adds	r7, r7, #20
 856              		.cfi_def_cfa_offset 12
 857 0060 BD46     		mov	sp, r7
 858              		.cfi_def_cfa_register 13
 859              		@ sp needed
 860 0062 90BD     		pop	{r4, r7, pc}
 861              	.L59:
 862              		.align	2
 863              	.L58:
 864 0064 00000000 		.word	.LC0
 865 0068 00000000 		.word	__func__.19
 866 006c 04000000 		.word	.LC1
 867              		.cfi_endproc
 868              	.LFE8:
 870              		.section	.text.xQueueTakeMutexRecursive,"ax",%progbits
 871              		.align	1
 872              		.global	xQueueTakeMutexRecursive
 873              		.syntax unified
 874              		.thumb
 875              		.thumb_func
 877              	xQueueTakeMutexRecursive:
 878              	.LFB9:
 766:Lib/FreeRTOS/Source/queue.c **** 
 767:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 768:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 769:Lib/FreeRTOS/Source/queue.c **** 
 770:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_RECURSIVE_MUTEXES == 1 )
 771:Lib/FreeRTOS/Source/queue.c **** 
 772:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex,
 773:Lib/FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait )
 774:Lib/FreeRTOS/Source/queue.c ****     {
 879              		.loc 1 774 5
 880              		.cfi_startproc
 881              		@ args = 0, pretend = 0, frame = 16
 882              		@ frame_needed = 1, uses_anonymous_args = 0
 883 0000 90B5     		push	{r4, r7, lr}
 884              		.cfi_def_cfa_offset 12
 885              		.cfi_offset 4, -12
 886              		.cfi_offset 7, -8
 887              		.cfi_offset 14, -4
 888 0002 85B0     		sub	sp, sp, #20
 889              		.cfi_def_cfa_offset 32
 890 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/cchrzcnP.s 			page 30


 891              		.cfi_def_cfa_register 7
 892 0006 7860     		str	r0, [r7, #4]
 893 0008 3960     		str	r1, [r7]
 775:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
 776:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 894              		.loc 1 776 25
 895 000a 7B68     		ldr	r3, [r7, #4]
 896 000c BB60     		str	r3, [r7, #8]
 777:Lib/FreeRTOS/Source/queue.c **** 
 778:Lib/FreeRTOS/Source/queue.c ****         configASSERT( pxMutex );
 897              		.loc 1 778 9
 898 000e BB68     		ldr	r3, [r7, #8]
 899 0010 002B     		cmp	r3, #0
 900 0012 08D1     		bne	.L61
 901              		.loc 1 778 9 is_stmt 0 discriminator 1
 902 0014 FFF7FEFF 		bl	ulSetInterruptMask
 903 0018 134B     		ldr	r3, .L65
 904 001a 144A     		ldr	r2, .L65+4
 905 001c 40F20A31 		movw	r1, #778
 906 0020 1348     		ldr	r0, .L65+8
 907 0022 FFF7FEFF 		bl	__assert_func
 908              	.L61:
 779:Lib/FreeRTOS/Source/queue.c **** 
 780:Lib/FreeRTOS/Source/queue.c ****         /* Comments regarding mutual exclusion as per those within
 781:Lib/FreeRTOS/Source/queue.c ****          * xQueueGiveMutexRecursive(). */
 782:Lib/FreeRTOS/Source/queue.c **** 
 783:Lib/FreeRTOS/Source/queue.c ****         traceTAKE_MUTEX_RECURSIVE( pxMutex );
 784:Lib/FreeRTOS/Source/queue.c **** 
 785:Lib/FreeRTOS/Source/queue.c ****         if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 909              		.loc 1 785 34 is_stmt 1
 910 0026 BB68     		ldr	r3, [r7, #8]
 911 0028 9C68     		ldr	r4, [r3, #8]
 912              		.loc 1 785 51
 913 002a FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 914 002e 0346     		mov	r3, r0
 915              		.loc 1 785 11 discriminator 1
 916 0030 9C42     		cmp	r4, r3
 917 0032 07D1     		bne	.L62
 786:Lib/FreeRTOS/Source/queue.c ****         {
 787:Lib/FreeRTOS/Source/queue.c ****             ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 918              		.loc 1 787 36
 919 0034 BB68     		ldr	r3, [r7, #8]
 920 0036 DB68     		ldr	r3, [r3, #12]
 921              		.loc 1 787 59
 922 0038 5A1C     		adds	r2, r3, #1
 923 003a BB68     		ldr	r3, [r7, #8]
 924 003c DA60     		str	r2, [r3, #12]
 788:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 925              		.loc 1 788 21
 926 003e 0123     		movs	r3, #1
 927 0040 FB60     		str	r3, [r7, #12]
 928 0042 0CE0     		b	.L63
 929              	.L62:
 789:Lib/FreeRTOS/Source/queue.c ****         }
 790:Lib/FreeRTOS/Source/queue.c ****         else
 791:Lib/FreeRTOS/Source/queue.c ****         {
 792:Lib/FreeRTOS/Source/queue.c ****             xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
ARM GAS  /tmp/cchrzcnP.s 			page 31


 930              		.loc 1 792 23
 931 0044 3968     		ldr	r1, [r7]
 932 0046 B868     		ldr	r0, [r7, #8]
 933 0048 FFF7FEFF 		bl	xQueueSemaphoreTake
 934 004c F860     		str	r0, [r7, #12]
 793:Lib/FreeRTOS/Source/queue.c **** 
 794:Lib/FreeRTOS/Source/queue.c ****             /* pdPASS will only be returned if the mutex was successfully
 795:Lib/FreeRTOS/Source/queue.c ****              * obtained.  The calling task may have entered the Blocked state
 796:Lib/FreeRTOS/Source/queue.c ****              * before reaching here. */
 797:Lib/FreeRTOS/Source/queue.c ****             if( xReturn != pdFAIL )
 935              		.loc 1 797 15
 936 004e FB68     		ldr	r3, [r7, #12]
 937 0050 002B     		cmp	r3, #0
 938 0052 04D0     		beq	.L63
 798:Lib/FreeRTOS/Source/queue.c ****             {
 799:Lib/FreeRTOS/Source/queue.c ****                 ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 939              		.loc 1 799 40
 940 0054 BB68     		ldr	r3, [r7, #8]
 941 0056 DB68     		ldr	r3, [r3, #12]
 942              		.loc 1 799 63
 943 0058 5A1C     		adds	r2, r3, #1
 944 005a BB68     		ldr	r3, [r7, #8]
 945 005c DA60     		str	r2, [r3, #12]
 946              	.L63:
 800:Lib/FreeRTOS/Source/queue.c ****             }
 801:Lib/FreeRTOS/Source/queue.c ****             else
 802:Lib/FreeRTOS/Source/queue.c ****             {
 803:Lib/FreeRTOS/Source/queue.c ****                 traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 804:Lib/FreeRTOS/Source/queue.c ****             }
 805:Lib/FreeRTOS/Source/queue.c ****         }
 806:Lib/FreeRTOS/Source/queue.c **** 
 807:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
 947              		.loc 1 807 16
 948 005e FB68     		ldr	r3, [r7, #12]
 808:Lib/FreeRTOS/Source/queue.c ****     }
 949              		.loc 1 808 5
 950 0060 1846     		mov	r0, r3
 951 0062 1437     		adds	r7, r7, #20
 952              		.cfi_def_cfa_offset 12
 953 0064 BD46     		mov	sp, r7
 954              		.cfi_def_cfa_register 13
 955              		@ sp needed
 956 0066 90BD     		pop	{r4, r7, pc}
 957              	.L66:
 958              		.align	2
 959              	.L65:
 960 0068 00000000 		.word	.LC0
 961 006c 00000000 		.word	__func__.18
 962 0070 04000000 		.word	.LC1
 963              		.cfi_endproc
 964              	.LFE9:
 966              		.section	.text.xQueueCreateCountingSemaphoreStatic,"ax",%progbits
 967              		.align	1
 968              		.global	xQueueCreateCountingSemaphoreStatic
 969              		.syntax unified
 970              		.thumb
 971              		.thumb_func
ARM GAS  /tmp/cchrzcnP.s 			page 32


 973              	xQueueCreateCountingSemaphoreStatic:
 974              	.LFB10:
 809:Lib/FreeRTOS/Source/queue.c **** 
 810:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 811:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 812:Lib/FreeRTOS/Source/queue.c **** 
 813:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
 814:Lib/FreeRTOS/Source/queue.c **** 
 815:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount,
 816:Lib/FreeRTOS/Source/queue.c ****                                                        const UBaseType_t uxInitialCount,
 817:Lib/FreeRTOS/Source/queue.c ****                                                        StaticQueue_t * pxStaticQueue )
 818:Lib/FreeRTOS/Source/queue.c ****     {
 975              		.loc 1 818 5
 976              		.cfi_startproc
 977              		@ args = 0, pretend = 0, frame = 24
 978              		@ frame_needed = 1, uses_anonymous_args = 0
 979 0000 80B5     		push	{r7, lr}
 980              		.cfi_def_cfa_offset 8
 981              		.cfi_offset 7, -8
 982              		.cfi_offset 14, -4
 983 0002 88B0     		sub	sp, sp, #32
 984              		.cfi_def_cfa_offset 40
 985 0004 02AF     		add	r7, sp, #8
 986              		.cfi_def_cfa 7, 32
 987 0006 F860     		str	r0, [r7, #12]
 988 0008 B960     		str	r1, [r7, #8]
 989 000a 7A60     		str	r2, [r7, #4]
 819:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 990              		.loc 1 819 23
 991 000c 0023     		movs	r3, #0
 992 000e 7B61     		str	r3, [r7, #20]
 820:Lib/FreeRTOS/Source/queue.c **** 
 821:Lib/FreeRTOS/Source/queue.c ****         if( ( uxMaxCount != 0 ) &&
 993              		.loc 1 821 11
 994 0010 FB68     		ldr	r3, [r7, #12]
 995 0012 002B     		cmp	r3, #0
 996 0014 13D0     		beq	.L68
 997              		.loc 1 821 33 discriminator 1
 998 0016 BA68     		ldr	r2, [r7, #8]
 999 0018 FB68     		ldr	r3, [r7, #12]
 1000 001a 9A42     		cmp	r2, r3
 1001 001c 0FD8     		bhi	.L68
 822:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 823:Lib/FreeRTOS/Source/queue.c ****         {
 824:Lib/FreeRTOS/Source/queue.c ****             xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL
 1002              		.loc 1 824 23
 1003 001e 0223     		movs	r3, #2
 1004 0020 0093     		str	r3, [sp]
 1005 0022 7B68     		ldr	r3, [r7, #4]
 1006 0024 0022     		movs	r2, #0
 1007 0026 0021     		movs	r1, #0
 1008 0028 F868     		ldr	r0, [r7, #12]
 1009 002a FFF7FEFF 		bl	xQueueGenericCreateStatic
 1010 002e 7861     		str	r0, [r7, #20]
 825:Lib/FreeRTOS/Source/queue.c **** 
 826:Lib/FreeRTOS/Source/queue.c ****             if( xHandle != NULL )
 1011              		.loc 1 826 15
ARM GAS  /tmp/cchrzcnP.s 			page 33


 1012 0030 7B69     		ldr	r3, [r7, #20]
 1013 0032 002B     		cmp	r3, #0
 1014 0034 0FD0     		beq	.L70
 827:Lib/FreeRTOS/Source/queue.c ****             {
 828:Lib/FreeRTOS/Source/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 1015              		.loc 1 828 62
 1016 0036 7B69     		ldr	r3, [r7, #20]
 1017 0038 BA68     		ldr	r2, [r7, #8]
 1018 003a 9A63     		str	r2, [r3, #56]
 826:Lib/FreeRTOS/Source/queue.c ****             {
 1019              		.loc 1 826 15
 1020 003c 0BE0     		b	.L70
 1021              	.L68:
 829:Lib/FreeRTOS/Source/queue.c **** 
 830:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 831:Lib/FreeRTOS/Source/queue.c ****             }
 832:Lib/FreeRTOS/Source/queue.c ****             else
 833:Lib/FreeRTOS/Source/queue.c ****             {
 834:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 835:Lib/FreeRTOS/Source/queue.c ****             }
 836:Lib/FreeRTOS/Source/queue.c ****         }
 837:Lib/FreeRTOS/Source/queue.c ****         else
 838:Lib/FreeRTOS/Source/queue.c ****         {
 839:Lib/FreeRTOS/Source/queue.c ****             configASSERT( xHandle );
 1022              		.loc 1 839 13
 1023 003e 7B69     		ldr	r3, [r7, #20]
 1024 0040 002B     		cmp	r3, #0
 1025 0042 08D1     		bne	.L70
 1026              		.loc 1 839 13 is_stmt 0 discriminator 1
 1027 0044 FFF7FEFF 		bl	ulSetInterruptMask
 1028 0048 054B     		ldr	r3, .L72
 1029 004a 064A     		ldr	r2, .L72+4
 1030 004c 40F24731 		movw	r1, #839
 1031 0050 0548     		ldr	r0, .L72+8
 1032 0052 FFF7FEFF 		bl	__assert_func
 1033              	.L70:
 840:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 841:Lib/FreeRTOS/Source/queue.c ****         }
 842:Lib/FreeRTOS/Source/queue.c **** 
 843:Lib/FreeRTOS/Source/queue.c ****         return xHandle;
 1034              		.loc 1 843 16 is_stmt 1
 1035 0056 7B69     		ldr	r3, [r7, #20]
 844:Lib/FreeRTOS/Source/queue.c ****     }
 1036              		.loc 1 844 5
 1037 0058 1846     		mov	r0, r3
 1038 005a 1837     		adds	r7, r7, #24
 1039              		.cfi_def_cfa_offset 8
 1040 005c BD46     		mov	sp, r7
 1041              		.cfi_def_cfa_register 13
 1042              		@ sp needed
 1043 005e 80BD     		pop	{r7, pc}
 1044              	.L73:
 1045              		.align	2
 1046              	.L72:
 1047 0060 00000000 		.word	.LC0
 1048 0064 00000000 		.word	__func__.17
 1049 0068 04000000 		.word	.LC1
ARM GAS  /tmp/cchrzcnP.s 			page 34


 1050              		.cfi_endproc
 1051              	.LFE10:
 1053              		.section	.text.xQueueGenericSend,"ax",%progbits
 1054              		.align	1
 1055              		.global	xQueueGenericSend
 1056              		.syntax unified
 1057              		.thumb
 1058              		.thumb_func
 1060              	xQueueGenericSend:
 1061              	.LFB11:
 845:Lib/FreeRTOS/Source/queue.c **** 
 846:Lib/FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 847:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 848:Lib/FreeRTOS/Source/queue.c **** 
 849:Lib/FreeRTOS/Source/queue.c **** #if ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
 850:Lib/FreeRTOS/Source/queue.c **** 
 851:Lib/FreeRTOS/Source/queue.c ****     QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount,
 852:Lib/FreeRTOS/Source/queue.c ****                                                  const UBaseType_t uxInitialCount )
 853:Lib/FreeRTOS/Source/queue.c ****     {
 854:Lib/FreeRTOS/Source/queue.c ****         QueueHandle_t xHandle = NULL;
 855:Lib/FreeRTOS/Source/queue.c **** 
 856:Lib/FreeRTOS/Source/queue.c ****         if( ( uxMaxCount != 0 ) &&
 857:Lib/FreeRTOS/Source/queue.c ****             ( uxInitialCount <= uxMaxCount ) )
 858:Lib/FreeRTOS/Source/queue.c ****         {
 859:Lib/FreeRTOS/Source/queue.c ****             xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE
 860:Lib/FreeRTOS/Source/queue.c **** 
 861:Lib/FreeRTOS/Source/queue.c ****             if( xHandle != NULL )
 862:Lib/FreeRTOS/Source/queue.c ****             {
 863:Lib/FreeRTOS/Source/queue.c ****                 ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 864:Lib/FreeRTOS/Source/queue.c **** 
 865:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE();
 866:Lib/FreeRTOS/Source/queue.c ****             }
 867:Lib/FreeRTOS/Source/queue.c ****             else
 868:Lib/FreeRTOS/Source/queue.c ****             {
 869:Lib/FreeRTOS/Source/queue.c ****                 traceCREATE_COUNTING_SEMAPHORE_FAILED();
 870:Lib/FreeRTOS/Source/queue.c ****             }
 871:Lib/FreeRTOS/Source/queue.c ****         }
 872:Lib/FreeRTOS/Source/queue.c ****         else
 873:Lib/FreeRTOS/Source/queue.c ****         {
 874:Lib/FreeRTOS/Source/queue.c ****             configASSERT( xHandle );
 875:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
 876:Lib/FreeRTOS/Source/queue.c ****         }
 877:Lib/FreeRTOS/Source/queue.c **** 
 878:Lib/FreeRTOS/Source/queue.c ****         return xHandle;
 879:Lib/FreeRTOS/Source/queue.c ****     }
 880:Lib/FreeRTOS/Source/queue.c **** 
 881:Lib/FreeRTOS/Source/queue.c **** #endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) *
 882:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
 883:Lib/FreeRTOS/Source/queue.c **** 
 884:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
 885:Lib/FreeRTOS/Source/queue.c ****                               const void * const pvItemToQueue,
 886:Lib/FreeRTOS/Source/queue.c ****                               TickType_t xTicksToWait,
 887:Lib/FreeRTOS/Source/queue.c ****                               const BaseType_t xCopyPosition )
 888:Lib/FreeRTOS/Source/queue.c **** {
 1062              		.loc 1 888 1
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 40
ARM GAS  /tmp/cchrzcnP.s 			page 35


 1065              		@ frame_needed = 1, uses_anonymous_args = 0
 1066 0000 80B5     		push	{r7, lr}
 1067              		.cfi_def_cfa_offset 8
 1068              		.cfi_offset 7, -8
 1069              		.cfi_offset 14, -4
 1070 0002 8AB0     		sub	sp, sp, #40
 1071              		.cfi_def_cfa_offset 48
 1072 0004 00AF     		add	r7, sp, #0
 1073              		.cfi_def_cfa_register 7
 1074 0006 F860     		str	r0, [r7, #12]
 1075 0008 B960     		str	r1, [r7, #8]
 1076 000a 7A60     		str	r2, [r7, #4]
 1077 000c 3B60     		str	r3, [r7]
 889:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1078              		.loc 1 889 16
 1079 000e 0023     		movs	r3, #0
 1080 0010 7B62     		str	r3, [r7, #36]
 890:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
 891:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1081              		.loc 1 891 21
 1082 0012 FB68     		ldr	r3, [r7, #12]
 1083 0014 3B62     		str	r3, [r7, #32]
 892:Lib/FreeRTOS/Source/queue.c **** 
 893:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 1084              		.loc 1 893 5
 1085 0016 3B6A     		ldr	r3, [r7, #32]
 1086 0018 002B     		cmp	r3, #0
 1087 001a 08D1     		bne	.L75
 1088              		.loc 1 893 5 is_stmt 0 discriminator 1
 1089 001c FFF7FEFF 		bl	ulSetInterruptMask
 1090 0020 684B     		ldr	r3, .L101
 1091 0022 694A     		ldr	r2, .L101+4
 1092 0024 40F27D31 		movw	r1, #893
 1093 0028 6848     		ldr	r0, .L101+8
 1094 002a FFF7FEFF 		bl	__assert_func
 1095              	.L75:
 894:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1096              		.loc 1 894 5 is_stmt 1
 1097 002e BB68     		ldr	r3, [r7, #8]
 1098 0030 002B     		cmp	r3, #0
 1099 0032 03D1     		bne	.L76
 1100              		.loc 1 894 5 is_stmt 0 discriminator 2
 1101 0034 3B6A     		ldr	r3, [r7, #32]
 1102 0036 1B6C     		ldr	r3, [r3, #64]
 1103 0038 002B     		cmp	r3, #0
 1104 003a 01D1     		bne	.L77
 1105              	.L76:
 1106              		.loc 1 894 5 discriminator 3
 1107 003c 0123     		movs	r3, #1
 1108              		.loc 1 894 5
 1109 003e 00E0     		b	.L78
 1110              	.L77:
 1111              		.loc 1 894 5 discriminator 4
 1112 0040 0023     		movs	r3, #0
 1113              	.L78:
 1114              		.loc 1 894 5 discriminator 6
 1115 0042 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 36


 1116 0044 08D1     		bne	.L79
 1117              		.loc 1 894 5 discriminator 7
 1118 0046 FFF7FEFF 		bl	ulSetInterruptMask
 1119              		.loc 1 894 5 discriminator 1
 1120 004a 5E4B     		ldr	r3, .L101
 1121 004c 5E4A     		ldr	r2, .L101+4
 1122 004e 40F27E31 		movw	r1, #894
 1123 0052 5E48     		ldr	r0, .L101+8
 1124 0054 FFF7FEFF 		bl	__assert_func
 1125              	.L79:
 895:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1126              		.loc 1 895 5 is_stmt 1
 1127 0058 3B68     		ldr	r3, [r7]
 1128 005a 022B     		cmp	r3, #2
 1129 005c 03D1     		bne	.L80
 1130              		.loc 1 895 5 is_stmt 0 discriminator 2
 1131 005e 3B6A     		ldr	r3, [r7, #32]
 1132 0060 DB6B     		ldr	r3, [r3, #60]
 1133 0062 012B     		cmp	r3, #1
 1134 0064 01D1     		bne	.L81
 1135              	.L80:
 1136              		.loc 1 895 5 discriminator 3
 1137 0066 0123     		movs	r3, #1
 1138              		.loc 1 895 5
 1139 0068 00E0     		b	.L82
 1140              	.L81:
 1141              		.loc 1 895 5 discriminator 4
 1142 006a 0023     		movs	r3, #0
 1143              	.L82:
 1144              		.loc 1 895 5 discriminator 6
 1145 006c 002B     		cmp	r3, #0
 1146 006e 08D1     		bne	.L83
 1147              		.loc 1 895 5 discriminator 7
 1148 0070 FFF7FEFF 		bl	ulSetInterruptMask
 1149              		.loc 1 895 5 discriminator 1
 1150 0074 534B     		ldr	r3, .L101
 1151 0076 544A     		ldr	r2, .L101+4
 1152 0078 40F27F31 		movw	r1, #895
 1153 007c 5348     		ldr	r0, .L101+8
 1154 007e FFF7FEFF 		bl	__assert_func
 1155              	.L83:
 896:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
 897:Lib/FreeRTOS/Source/queue.c ****     {
 898:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 1156              		.loc 1 898 9 is_stmt 1
 1157 0082 FFF7FEFF 		bl	xTaskGetSchedulerState
 1158 0086 0346     		mov	r3, r0
 1159              		.loc 1 898 9 is_stmt 0 discriminator 1
 1160 0088 002B     		cmp	r3, #0
 1161 008a 02D1     		bne	.L84
 1162              		.loc 1 898 9 discriminator 2
 1163 008c 7B68     		ldr	r3, [r7, #4]
 1164 008e 002B     		cmp	r3, #0
 1165 0090 01D1     		bne	.L85
 1166              	.L84:
 1167              		.loc 1 898 9 discriminator 3
 1168 0092 0123     		movs	r3, #1
ARM GAS  /tmp/cchrzcnP.s 			page 37


 1169              		.loc 1 898 9
 1170 0094 00E0     		b	.L86
 1171              	.L85:
 1172              		.loc 1 898 9 discriminator 4
 1173 0096 0023     		movs	r3, #0
 1174              	.L86:
 1175              		.loc 1 898 9 discriminator 6
 1176 0098 002B     		cmp	r3, #0
 1177 009a 08D1     		bne	.L87
 1178              		.loc 1 898 9 discriminator 7
 1179 009c FFF7FEFF 		bl	ulSetInterruptMask
 1180              		.loc 1 898 9 discriminator 1
 1181 00a0 484B     		ldr	r3, .L101
 1182 00a2 494A     		ldr	r2, .L101+4
 1183 00a4 40F28231 		movw	r1, #898
 1184 00a8 4848     		ldr	r0, .L101+8
 1185 00aa FFF7FEFF 		bl	__assert_func
 1186              	.L87:
 899:Lib/FreeRTOS/Source/queue.c ****     }
 900:Lib/FreeRTOS/Source/queue.c ****     #endif
 901:Lib/FreeRTOS/Source/queue.c **** 
 902:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to
 903:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
 904:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
 905:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
 906:Lib/FreeRTOS/Source/queue.c ****     {
 907:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 1187              		.loc 1 907 9 is_stmt 1
 1188 00ae FFF7FEFF 		bl	vPortEnterCritical
 908:Lib/FreeRTOS/Source/queue.c ****         {
 909:Lib/FreeRTOS/Source/queue.c ****             /* Is there room on the queue now?  The running task must be the
 910:Lib/FreeRTOS/Source/queue.c ****              * highest priority task wanting to access the queue.  If the head item
 911:Lib/FreeRTOS/Source/queue.c ****              * in the queue is to be overwritten then it does not matter if the
 912:Lib/FreeRTOS/Source/queue.c ****              * queue is full. */
 913:Lib/FreeRTOS/Source/queue.c ****             if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERW
 1189              		.loc 1 913 26
 1190 00b2 3B6A     		ldr	r3, [r7, #32]
 1191 00b4 9A6B     		ldr	r2, [r3, #56]
 1192              		.loc 1 913 55
 1193 00b6 3B6A     		ldr	r3, [r7, #32]
 1194 00b8 DB6B     		ldr	r3, [r3, #60]
 1195              		.loc 1 913 15
 1196 00ba 9A42     		cmp	r2, r3
 1197 00bc 02D3     		bcc	.L88
 1198              		.loc 1 913 68 discriminator 1
 1199 00be 3B68     		ldr	r3, [r7]
 1200 00c0 022B     		cmp	r3, #2
 1201 00c2 1DD1     		bne	.L89
 1202              	.L88:
 914:Lib/FreeRTOS/Source/queue.c ****             {
 915:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_SEND( pxQueue );
 916:Lib/FreeRTOS/Source/queue.c **** 
 917:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
 918:Lib/FreeRTOS/Source/queue.c ****                 {
 919:Lib/FreeRTOS/Source/queue.c ****                     const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 920:Lib/FreeRTOS/Source/queue.c **** 
 921:Lib/FreeRTOS/Source/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
ARM GAS  /tmp/cchrzcnP.s 			page 38


 922:Lib/FreeRTOS/Source/queue.c **** 
 923:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
 924:Lib/FreeRTOS/Source/queue.c ****                     {
 925:Lib/FreeRTOS/Source/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
 926:Lib/FreeRTOS/Source/queue.c ****                         {
 927:Lib/FreeRTOS/Source/queue.c ****                             /* Do not notify the queue set as an existing item
 928:Lib/FreeRTOS/Source/queue.c ****                              * was overwritten in the queue so the number of items
 929:Lib/FreeRTOS/Source/queue.c ****                              * in the queue has not changed. */
 930:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 931:Lib/FreeRTOS/Source/queue.c ****                         }
 932:Lib/FreeRTOS/Source/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 933:Lib/FreeRTOS/Source/queue.c ****                         {
 934:Lib/FreeRTOS/Source/queue.c ****                             /* The queue is a member of a queue set, and posting
 935:Lib/FreeRTOS/Source/queue.c ****                              * to the queue set caused a higher priority task to
 936:Lib/FreeRTOS/Source/queue.c ****                              * unblock. A context switch is required. */
 937:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 938:Lib/FreeRTOS/Source/queue.c ****                         }
 939:Lib/FreeRTOS/Source/queue.c ****                         else
 940:Lib/FreeRTOS/Source/queue.c ****                         {
 941:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 942:Lib/FreeRTOS/Source/queue.c ****                         }
 943:Lib/FreeRTOS/Source/queue.c ****                     }
 944:Lib/FreeRTOS/Source/queue.c ****                     else
 945:Lib/FreeRTOS/Source/queue.c ****                     {
 946:Lib/FreeRTOS/Source/queue.c ****                         /* If there was a task waiting for data to arrive on the
 947:Lib/FreeRTOS/Source/queue.c ****                          * queue then unblock it now. */
 948:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 949:Lib/FreeRTOS/Source/queue.c ****                         {
 950:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
 951:Lib/FreeRTOS/Source/queue.c ****                             {
 952:Lib/FreeRTOS/Source/queue.c ****                                 /* The unblocked task has a priority higher than
 953:Lib/FreeRTOS/Source/queue.c ****                                  * our own so yield immediately.  Yes it is ok to
 954:Lib/FreeRTOS/Source/queue.c ****                                  * do this from within the critical section - the
 955:Lib/FreeRTOS/Source/queue.c ****                                  * kernel takes care of that. */
 956:Lib/FreeRTOS/Source/queue.c ****                                 queueYIELD_IF_USING_PREEMPTION();
 957:Lib/FreeRTOS/Source/queue.c ****                             }
 958:Lib/FreeRTOS/Source/queue.c ****                             else
 959:Lib/FreeRTOS/Source/queue.c ****                             {
 960:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
 961:Lib/FreeRTOS/Source/queue.c ****                             }
 962:Lib/FreeRTOS/Source/queue.c ****                         }
 963:Lib/FreeRTOS/Source/queue.c ****                         else if( xYieldRequired != pdFALSE )
 964:Lib/FreeRTOS/Source/queue.c ****                         {
 965:Lib/FreeRTOS/Source/queue.c ****                             /* This path is a special case that will only get
 966:Lib/FreeRTOS/Source/queue.c ****                              * executed if the task was holding multiple mutexes
 967:Lib/FreeRTOS/Source/queue.c ****                              * and the mutexes were given back in an order that is
 968:Lib/FreeRTOS/Source/queue.c ****                              * different to that in which they were taken. */
 969:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 970:Lib/FreeRTOS/Source/queue.c ****                         }
 971:Lib/FreeRTOS/Source/queue.c ****                         else
 972:Lib/FreeRTOS/Source/queue.c ****                         {
 973:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 974:Lib/FreeRTOS/Source/queue.c ****                         }
 975:Lib/FreeRTOS/Source/queue.c ****                     }
 976:Lib/FreeRTOS/Source/queue.c ****                 }
 977:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
 978:Lib/FreeRTOS/Source/queue.c ****                 {
ARM GAS  /tmp/cchrzcnP.s 			page 39


 979:Lib/FreeRTOS/Source/queue.c ****                     xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1203              		.loc 1 979 38
 1204 00c4 3A68     		ldr	r2, [r7]
 1205 00c6 B968     		ldr	r1, [r7, #8]
 1206 00c8 386A     		ldr	r0, [r7, #32]
 1207 00ca FFF7FEFF 		bl	prvCopyDataToQueue
 1208 00ce F861     		str	r0, [r7, #28]
 980:Lib/FreeRTOS/Source/queue.c **** 
 981:Lib/FreeRTOS/Source/queue.c ****                     /* If there was a task waiting for data to arrive on the
 982:Lib/FreeRTOS/Source/queue.c ****                      * queue then unblock it now. */
 983:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1209              		.loc 1 983 25
 1210 00d0 3B6A     		ldr	r3, [r7, #32]
 1211 00d2 5B6A     		ldr	r3, [r3, #36]
 1212              		.loc 1 983 23
 1213 00d4 002B     		cmp	r3, #0
 1214 00d6 0AD0     		beq	.L90
 984:Lib/FreeRTOS/Source/queue.c ****                     {
 985:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 1215              		.loc 1 985 55
 1216 00d8 3B6A     		ldr	r3, [r7, #32]
 1217 00da 2433     		adds	r3, r3, #36
 1218              		.loc 1 985 29
 1219 00dc 1846     		mov	r0, r3
 1220 00de FFF7FEFF 		bl	xTaskRemoveFromEventList
 1221 00e2 0346     		mov	r3, r0
 1222              		.loc 1 985 27 discriminator 1
 1223 00e4 002B     		cmp	r3, #0
 1224 00e6 07D0     		beq	.L91
 986:Lib/FreeRTOS/Source/queue.c ****                         {
 987:Lib/FreeRTOS/Source/queue.c ****                             /* The unblocked task has a priority higher than
 988:Lib/FreeRTOS/Source/queue.c ****                              * our own so yield immediately.  Yes it is ok to do
 989:Lib/FreeRTOS/Source/queue.c ****                              * this from within the critical section - the kernel
 990:Lib/FreeRTOS/Source/queue.c ****                              * takes care of that. */
 991:Lib/FreeRTOS/Source/queue.c ****                             queueYIELD_IF_USING_PREEMPTION();
 1225              		.loc 1 991 29
 1226 00e8 FFF7FEFF 		bl	vPortYield
 1227 00ec 04E0     		b	.L91
 1228              	.L90:
 992:Lib/FreeRTOS/Source/queue.c ****                         }
 993:Lib/FreeRTOS/Source/queue.c ****                         else
 994:Lib/FreeRTOS/Source/queue.c ****                         {
 995:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
 996:Lib/FreeRTOS/Source/queue.c ****                         }
 997:Lib/FreeRTOS/Source/queue.c ****                     }
 998:Lib/FreeRTOS/Source/queue.c ****                     else if( xYieldRequired != pdFALSE )
 1229              		.loc 1 998 28
 1230 00ee FB69     		ldr	r3, [r7, #28]
 1231 00f0 002B     		cmp	r3, #0
 1232 00f2 01D0     		beq	.L91
 999:Lib/FreeRTOS/Source/queue.c ****                     {
1000:Lib/FreeRTOS/Source/queue.c ****                         /* This path is a special case that will only get
1001:Lib/FreeRTOS/Source/queue.c ****                          * executed if the task was holding multiple mutexes and
1002:Lib/FreeRTOS/Source/queue.c ****                          * the mutexes were given back in an order that is
1003:Lib/FreeRTOS/Source/queue.c ****                          * different to that in which they were taken. */
1004:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 1233              		.loc 1 1004 25
ARM GAS  /tmp/cchrzcnP.s 			page 40


 1234 00f4 FFF7FEFF 		bl	vPortYield
 1235              	.L91:
1005:Lib/FreeRTOS/Source/queue.c ****                     }
1006:Lib/FreeRTOS/Source/queue.c ****                     else
1007:Lib/FreeRTOS/Source/queue.c ****                     {
1008:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1009:Lib/FreeRTOS/Source/queue.c ****                     }
1010:Lib/FreeRTOS/Source/queue.c ****                 }
1011:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1012:Lib/FreeRTOS/Source/queue.c **** 
1013:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
 1236              		.loc 1 1013 17
 1237 00f8 FFF7FEFF 		bl	vPortExitCritical
1014:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 1238              		.loc 1 1014 24
 1239 00fc 0123     		movs	r3, #1
 1240 00fe 5CE0     		b	.L100
 1241              	.L89:
1015:Lib/FreeRTOS/Source/queue.c ****             }
1016:Lib/FreeRTOS/Source/queue.c ****             else
1017:Lib/FreeRTOS/Source/queue.c ****             {
1018:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 1242              		.loc 1 1018 34
 1243 0100 7B68     		ldr	r3, [r7, #4]
 1244              		.loc 1 1018 19
 1245 0102 002B     		cmp	r3, #0
 1246 0104 03D1     		bne	.L93
1019:Lib/FreeRTOS/Source/queue.c ****                 {
1020:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was full and no block time is specified (or
1021:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1022:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
 1247              		.loc 1 1022 21
 1248 0106 FFF7FEFF 		bl	vPortExitCritical
1023:Lib/FreeRTOS/Source/queue.c **** 
1024:Lib/FreeRTOS/Source/queue.c ****                     /* Return to the original privilege level before exiting
1025:Lib/FreeRTOS/Source/queue.c ****                      * the function. */
1026:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_SEND_FAILED( pxQueue );
1027:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
 1249              		.loc 1 1027 28
 1250 010a 0023     		movs	r3, #0
 1251 010c 55E0     		b	.L100
 1252              	.L93:
1028:Lib/FreeRTOS/Source/queue.c ****                 }
1029:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 1253              		.loc 1 1029 24
 1254 010e 7B6A     		ldr	r3, [r7, #36]
 1255 0110 002B     		cmp	r3, #0
 1256 0112 06D1     		bne	.L94
1030:Lib/FreeRTOS/Source/queue.c ****                 {
1031:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was full and a block time was specified so
1032:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
1033:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 1257              		.loc 1 1033 21
 1258 0114 07F11403 		add	r3, r7, #20
 1259 0118 1846     		mov	r0, r3
 1260 011a FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1034:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
ARM GAS  /tmp/cchrzcnP.s 			page 41


 1261              		.loc 1 1034 35
 1262 011e 0123     		movs	r3, #1
 1263 0120 7B62     		str	r3, [r7, #36]
 1264              	.L94:
1035:Lib/FreeRTOS/Source/queue.c ****                 }
1036:Lib/FreeRTOS/Source/queue.c ****                 else
1037:Lib/FreeRTOS/Source/queue.c ****                 {
1038:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1039:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1040:Lib/FreeRTOS/Source/queue.c ****                 }
1041:Lib/FreeRTOS/Source/queue.c ****             }
1042:Lib/FreeRTOS/Source/queue.c ****         }
1043:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 1265              		.loc 1 1043 9
 1266 0122 FFF7FEFF 		bl	vPortExitCritical
1044:Lib/FreeRTOS/Source/queue.c **** 
1045:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1046:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1047:Lib/FreeRTOS/Source/queue.c **** 
1048:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
 1267              		.loc 1 1048 9
 1268 0126 FFF7FEFF 		bl	vTaskSuspendAll
1049:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 1269              		.loc 1 1049 9
 1270 012a FFF7FEFF 		bl	vPortEnterCritical
 1271              		.loc 1 1049 9 is_stmt 0 discriminator 1
 1272 012e 3B6A     		ldr	r3, [r7, #32]
 1273 0130 93F84430 		ldrb	r3, [r3, #68]
 1274 0134 5BB2     		sxtb	r3, r3
 1275 0136 B3F1FF3F 		cmp	r3, #-1
 1276 013a 03D1     		bne	.L95
 1277 013c 3B6A     		ldr	r3, [r7, #32]
 1278 013e 0022     		movs	r2, #0
 1279 0140 83F84420 		strb	r2, [r3, #68]
 1280              	.L95:
 1281              		.loc 1 1049 9 discriminator 3
 1282 0144 3B6A     		ldr	r3, [r7, #32]
 1283 0146 93F84530 		ldrb	r3, [r3, #69]
 1284 014a 5BB2     		sxtb	r3, r3
 1285 014c B3F1FF3F 		cmp	r3, #-1
 1286 0150 03D1     		bne	.L96
 1287              		.loc 1 1049 9 discriminator 4
 1288 0152 3B6A     		ldr	r3, [r7, #32]
 1289 0154 0022     		movs	r2, #0
 1290 0156 83F84520 		strb	r2, [r3, #69]
 1291              	.L96:
 1292              		.loc 1 1049 9 discriminator 6
 1293 015a FFF7FEFF 		bl	vPortExitCritical
1050:Lib/FreeRTOS/Source/queue.c **** 
1051:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1052:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1294              		.loc 1 1052 13 is_stmt 1
 1295 015e 3A1D     		adds	r2, r7, #4
 1296 0160 07F11403 		add	r3, r7, #20
 1297 0164 1146     		mov	r1, r2
 1298 0166 1846     		mov	r0, r3
 1299 0168 FFF7FEFF 		bl	xTaskCheckForTimeOut
ARM GAS  /tmp/cchrzcnP.s 			page 42


 1300 016c 0346     		mov	r3, r0
 1301              		.loc 1 1052 11 discriminator 1
 1302 016e 002B     		cmp	r3, #0
 1303 0170 1DD1     		bne	.L97
1053:Lib/FreeRTOS/Source/queue.c ****         {
1054:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
 1304              		.loc 1 1054 17
 1305 0172 386A     		ldr	r0, [r7, #32]
 1306 0174 FFF7FEFF 		bl	prvIsQueueFull
 1307 0178 0346     		mov	r3, r0
 1308              		.loc 1 1054 15 discriminator 1
 1309 017a 002B     		cmp	r3, #0
 1310 017c 11D0     		beq	.L98
1055:Lib/FreeRTOS/Source/queue.c ****             {
1056:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_SEND( pxQueue );
1057:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1311              		.loc 1 1057 17
 1312 017e 3B6A     		ldr	r3, [r7, #32]
 1313 0180 1033     		adds	r3, r3, #16
 1314 0182 7A68     		ldr	r2, [r7, #4]
 1315 0184 1146     		mov	r1, r2
 1316 0186 1846     		mov	r0, r3
 1317 0188 FFF7FEFF 		bl	vTaskPlaceOnEventList
1058:Lib/FreeRTOS/Source/queue.c **** 
1059:Lib/FreeRTOS/Source/queue.c ****                 /* Unlocking the queue means queue events can effect the
1060:Lib/FreeRTOS/Source/queue.c ****                  * event list. It is possible that interrupts occurring now
1061:Lib/FreeRTOS/Source/queue.c ****                  * remove this task from the event list again - but as the
1062:Lib/FreeRTOS/Source/queue.c ****                  * scheduler is suspended the task will go onto the pending
1063:Lib/FreeRTOS/Source/queue.c ****                  * ready list instead of the actual ready list. */
1064:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1318              		.loc 1 1064 17
 1319 018c 386A     		ldr	r0, [r7, #32]
 1320 018e FFF7FEFF 		bl	prvUnlockQueue
1065:Lib/FreeRTOS/Source/queue.c **** 
1066:Lib/FreeRTOS/Source/queue.c ****                 /* Resuming the scheduler will move tasks from the pending
1067:Lib/FreeRTOS/Source/queue.c ****                  * ready list into the ready list - so it is feasible that this
1068:Lib/FreeRTOS/Source/queue.c ****                  * task is already in the ready list before it yields - in which
1069:Lib/FreeRTOS/Source/queue.c ****                  * case the yield will not cause a context switch unless there
1070:Lib/FreeRTOS/Source/queue.c ****                  * is also a higher priority task in the pending ready list. */
1071:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 1321              		.loc 1 1071 21
 1322 0192 FFF7FEFF 		bl	xTaskResumeAll
 1323 0196 0346     		mov	r3, r0
 1324              		.loc 1 1071 19 discriminator 1
 1325 0198 002B     		cmp	r3, #0
 1326 019a 88D1     		bne	.L87
1072:Lib/FreeRTOS/Source/queue.c ****                 {
1073:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
 1327              		.loc 1 1073 21
 1328 019c FFF7FEFF 		bl	vPortYield
 1329 01a0 85E7     		b	.L87
 1330              	.L98:
1074:Lib/FreeRTOS/Source/queue.c ****                 }
1075:Lib/FreeRTOS/Source/queue.c ****             }
1076:Lib/FreeRTOS/Source/queue.c ****             else
1077:Lib/FreeRTOS/Source/queue.c ****             {
1078:Lib/FreeRTOS/Source/queue.c ****                 /* Try again. */
ARM GAS  /tmp/cchrzcnP.s 			page 43


1079:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 1331              		.loc 1 1079 17
 1332 01a2 386A     		ldr	r0, [r7, #32]
 1333 01a4 FFF7FEFF 		bl	prvUnlockQueue
1080:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 1334              		.loc 1 1080 26
 1335 01a8 FFF7FEFF 		bl	xTaskResumeAll
 1336 01ac 7FE7     		b	.L87
 1337              	.L97:
1081:Lib/FreeRTOS/Source/queue.c ****             }
1082:Lib/FreeRTOS/Source/queue.c ****         }
1083:Lib/FreeRTOS/Source/queue.c ****         else
1084:Lib/FreeRTOS/Source/queue.c ****         {
1085:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has expired. */
1086:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
 1338              		.loc 1 1086 13
 1339 01ae 386A     		ldr	r0, [r7, #32]
 1340 01b0 FFF7FEFF 		bl	prvUnlockQueue
1087:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 1341              		.loc 1 1087 22
 1342 01b4 FFF7FEFF 		bl	xTaskResumeAll
1088:Lib/FreeRTOS/Source/queue.c **** 
1089:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FAILED( pxQueue );
1090:Lib/FreeRTOS/Source/queue.c ****             return errQUEUE_FULL;
 1343              		.loc 1 1090 20
 1344 01b8 0023     		movs	r3, #0
 1345              	.L100:
1091:Lib/FreeRTOS/Source/queue.c ****         }
1092:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1093:Lib/FreeRTOS/Source/queue.c **** }
 1346              		.loc 1 1093 1
 1347 01ba 1846     		mov	r0, r3
 1348 01bc 2837     		adds	r7, r7, #40
 1349              		.cfi_def_cfa_offset 8
 1350 01be BD46     		mov	sp, r7
 1351              		.cfi_def_cfa_register 13
 1352              		@ sp needed
 1353 01c0 80BD     		pop	{r7, pc}
 1354              	.L102:
 1355 01c2 00BF     		.align	2
 1356              	.L101:
 1357 01c4 00000000 		.word	.LC0
 1358 01c8 00000000 		.word	__func__.16
 1359 01cc 04000000 		.word	.LC1
 1360              		.cfi_endproc
 1361              	.LFE11:
 1363              		.section	.text.xQueueGenericSendFromISR,"ax",%progbits
 1364              		.align	1
 1365              		.global	xQueueGenericSendFromISR
 1366              		.syntax unified
 1367              		.thumb
 1368              		.thumb_func
 1370              	xQueueGenericSendFromISR:
 1371              	.LFB12:
1094:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1095:Lib/FreeRTOS/Source/queue.c **** 
1096:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
ARM GAS  /tmp/cchrzcnP.s 			page 44


1097:Lib/FreeRTOS/Source/queue.c ****                                      const void * const pvItemToQueue,
1098:Lib/FreeRTOS/Source/queue.c ****                                      BaseType_t * const pxHigherPriorityTaskWoken,
1099:Lib/FreeRTOS/Source/queue.c ****                                      const BaseType_t xCopyPosition )
1100:Lib/FreeRTOS/Source/queue.c **** {
 1372              		.loc 1 1100 1
 1373              		.cfi_startproc
 1374              		@ args = 0, pretend = 0, frame = 40
 1375              		@ frame_needed = 1, uses_anonymous_args = 0
 1376 0000 80B5     		push	{r7, lr}
 1377              		.cfi_def_cfa_offset 8
 1378              		.cfi_offset 7, -8
 1379              		.cfi_offset 14, -4
 1380 0002 8AB0     		sub	sp, sp, #40
 1381              		.cfi_def_cfa_offset 48
 1382 0004 00AF     		add	r7, sp, #0
 1383              		.cfi_def_cfa_register 7
 1384 0006 F860     		str	r0, [r7, #12]
 1385 0008 B960     		str	r1, [r7, #8]
 1386 000a 7A60     		str	r2, [r7, #4]
 1387 000c 3B60     		str	r3, [r7]
1101:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1102:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1103:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1388              		.loc 1 1103 21
 1389 000e FB68     		ldr	r3, [r7, #12]
 1390 0010 3B62     		str	r3, [r7, #32]
1104:Lib/FreeRTOS/Source/queue.c **** 
1105:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 1391              		.loc 1 1105 5
 1392 0012 3B6A     		ldr	r3, [r7, #32]
 1393 0014 002B     		cmp	r3, #0
 1394 0016 08D1     		bne	.L104
 1395              		.loc 1 1105 5 is_stmt 0 discriminator 1
 1396 0018 FFF7FEFF 		bl	ulSetInterruptMask
 1397 001c 454B     		ldr	r3, .L120
 1398 001e 464A     		ldr	r2, .L120+4
 1399 0020 40F25141 		movw	r1, #1105
 1400 0024 4548     		ldr	r0, .L120+8
 1401 0026 FFF7FEFF 		bl	__assert_func
 1402              	.L104:
1106:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) )
 1403              		.loc 1 1106 5 is_stmt 1
 1404 002a BB68     		ldr	r3, [r7, #8]
 1405 002c 002B     		cmp	r3, #0
 1406 002e 03D1     		bne	.L105
 1407              		.loc 1 1106 5 is_stmt 0 discriminator 2
 1408 0030 3B6A     		ldr	r3, [r7, #32]
 1409 0032 1B6C     		ldr	r3, [r3, #64]
 1410 0034 002B     		cmp	r3, #0
 1411 0036 01D1     		bne	.L106
 1412              	.L105:
 1413              		.loc 1 1106 5 discriminator 3
 1414 0038 0123     		movs	r3, #1
 1415              		.loc 1 1106 5
 1416 003a 00E0     		b	.L107
 1417              	.L106:
 1418              		.loc 1 1106 5 discriminator 4
ARM GAS  /tmp/cchrzcnP.s 			page 45


 1419 003c 0023     		movs	r3, #0
 1420              	.L107:
 1421              		.loc 1 1106 5 discriminator 6
 1422 003e 002B     		cmp	r3, #0
 1423 0040 08D1     		bne	.L108
 1424              		.loc 1 1106 5 discriminator 7
 1425 0042 FFF7FEFF 		bl	ulSetInterruptMask
 1426              		.loc 1 1106 5 discriminator 1
 1427 0046 3B4B     		ldr	r3, .L120
 1428 0048 3B4A     		ldr	r2, .L120+4
 1429 004a 40F25241 		movw	r1, #1106
 1430 004e 3B48     		ldr	r0, .L120+8
 1431 0050 FFF7FEFF 		bl	__assert_func
 1432              	.L108:
1107:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 1433              		.loc 1 1107 5 is_stmt 1
 1434 0054 3B68     		ldr	r3, [r7]
 1435 0056 022B     		cmp	r3, #2
 1436 0058 03D1     		bne	.L109
 1437              		.loc 1 1107 5 is_stmt 0 discriminator 2
 1438 005a 3B6A     		ldr	r3, [r7, #32]
 1439 005c DB6B     		ldr	r3, [r3, #60]
 1440 005e 012B     		cmp	r3, #1
 1441 0060 01D1     		bne	.L110
 1442              	.L109:
 1443              		.loc 1 1107 5 discriminator 3
 1444 0062 0123     		movs	r3, #1
 1445              		.loc 1 1107 5
 1446 0064 00E0     		b	.L111
 1447              	.L110:
 1448              		.loc 1 1107 5 discriminator 4
 1449 0066 0023     		movs	r3, #0
 1450              	.L111:
 1451              		.loc 1 1107 5 discriminator 6
 1452 0068 002B     		cmp	r3, #0
 1453 006a 08D1     		bne	.L112
 1454              		.loc 1 1107 5 discriminator 7
 1455 006c FFF7FEFF 		bl	ulSetInterruptMask
 1456              		.loc 1 1107 5 discriminator 1
 1457 0070 304B     		ldr	r3, .L120
 1458 0072 314A     		ldr	r2, .L120+4
 1459 0074 40F25341 		movw	r1, #1107
 1460 0078 3048     		ldr	r0, .L120+8
 1461 007a FFF7FEFF 		bl	__assert_func
 1462              	.L112:
1108:Lib/FreeRTOS/Source/queue.c **** 
1109:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1110:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1111:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1112:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1113:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1114:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1115:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1116:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1117:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1118:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1119:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
ARM GAS  /tmp/cchrzcnP.s 			page 46


1120:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1121:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1122:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1123:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1463              		.loc 1 1123 5 is_stmt 1
 1464 007e FFF7FEFF 		bl	vPortValidateInterruptPriority
1124:Lib/FreeRTOS/Source/queue.c **** 
1125:Lib/FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSend, except without blocking if there is no room
1126:Lib/FreeRTOS/Source/queue.c ****      * in the queue.  Also don't directly wake a task that was blocked on a queue
1127:Lib/FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1128:Lib/FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1129:Lib/FreeRTOS/Source/queue.c ****      * post). */
1130:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1465              		.loc 1 1130 30
 1466 0082 FFF7FEFF 		bl	ulSetInterruptMask
 1467 0086 F861     		str	r0, [r7, #28]
1131:Lib/FreeRTOS/Source/queue.c ****     {
1132:Lib/FreeRTOS/Source/queue.c ****         if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE
 1468              		.loc 1 1132 22
 1469 0088 3B6A     		ldr	r3, [r7, #32]
 1470 008a 9A6B     		ldr	r2, [r3, #56]
 1471              		.loc 1 1132 51
 1472 008c 3B6A     		ldr	r3, [r7, #32]
 1473 008e DB6B     		ldr	r3, [r3, #60]
 1474              		.loc 1 1132 11
 1475 0090 9A42     		cmp	r2, r3
 1476 0092 02D3     		bcc	.L113
 1477              		.loc 1 1132 64 discriminator 1
 1478 0094 3B68     		ldr	r3, [r7]
 1479 0096 022B     		cmp	r3, #2
 1480 0098 42D1     		bne	.L114
 1481              	.L113:
 1482              	.LBB3:
1133:Lib/FreeRTOS/Source/queue.c ****         {
1134:Lib/FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 1483              		.loc 1 1134 26
 1484 009a 3B6A     		ldr	r3, [r7, #32]
 1485 009c 93F84530 		ldrb	r3, [r3, #69]
 1486 00a0 FB76     		strb	r3, [r7, #27]
1135:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 1487              		.loc 1 1135 31
 1488 00a2 3B6A     		ldr	r3, [r7, #32]
 1489 00a4 9B6B     		ldr	r3, [r3, #56]
 1490 00a6 7B61     		str	r3, [r7, #20]
1136:Lib/FreeRTOS/Source/queue.c **** 
1137:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1138:Lib/FreeRTOS/Source/queue.c **** 
1139:Lib/FreeRTOS/Source/queue.c ****             /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
1140:Lib/FreeRTOS/Source/queue.c ****              *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
1141:Lib/FreeRTOS/Source/queue.c ****              *  in a task disinheriting a priority and prvCopyDataToQueue() can be
1142:Lib/FreeRTOS/Source/queue.c ****              *  called here even though the disinherit function does not check if
1143:Lib/FreeRTOS/Source/queue.c ****              *  the scheduler is suspended before accessing the ready lists. */
1144:Lib/FreeRTOS/Source/queue.c ****             ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1491              		.loc 1 1144 22
 1492 00a8 3A68     		ldr	r2, [r7]
 1493 00aa B968     		ldr	r1, [r7, #8]
 1494 00ac 386A     		ldr	r0, [r7, #32]
ARM GAS  /tmp/cchrzcnP.s 			page 47


 1495 00ae FFF7FEFF 		bl	prvCopyDataToQueue
1145:Lib/FreeRTOS/Source/queue.c **** 
1146:Lib/FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1147:Lib/FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1148:Lib/FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
 1496              		.loc 1 1148 15
 1497 00b2 97F91B30 		ldrsb	r3, [r7, #27]
 1498 00b6 B3F1FF3F 		cmp	r3, #-1
 1499 00ba 12D1     		bne	.L115
1149:Lib/FreeRTOS/Source/queue.c ****             {
1150:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1151:Lib/FreeRTOS/Source/queue.c ****                 {
1152:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1153:Lib/FreeRTOS/Source/queue.c ****                     {
1154:Lib/FreeRTOS/Source/queue.c ****                         if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != (
1155:Lib/FreeRTOS/Source/queue.c ****                         {
1156:Lib/FreeRTOS/Source/queue.c ****                             /* Do not notify the queue set as an existing item
1157:Lib/FreeRTOS/Source/queue.c ****                              * was overwritten in the queue so the number of items
1158:Lib/FreeRTOS/Source/queue.c ****                              * in the queue has not changed. */
1159:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1160:Lib/FreeRTOS/Source/queue.c ****                         }
1161:Lib/FreeRTOS/Source/queue.c ****                         else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1162:Lib/FreeRTOS/Source/queue.c ****                         {
1163:Lib/FreeRTOS/Source/queue.c ****                             /* The queue is a member of a queue set, and posting
1164:Lib/FreeRTOS/Source/queue.c ****                              * to the queue set caused a higher priority task to
1165:Lib/FreeRTOS/Source/queue.c ****                              * unblock.  A context switch is required. */
1166:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1167:Lib/FreeRTOS/Source/queue.c ****                             {
1168:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1169:Lib/FreeRTOS/Source/queue.c ****                             }
1170:Lib/FreeRTOS/Source/queue.c ****                             else
1171:Lib/FreeRTOS/Source/queue.c ****                             {
1172:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1173:Lib/FreeRTOS/Source/queue.c ****                             }
1174:Lib/FreeRTOS/Source/queue.c ****                         }
1175:Lib/FreeRTOS/Source/queue.c ****                         else
1176:Lib/FreeRTOS/Source/queue.c ****                         {
1177:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1178:Lib/FreeRTOS/Source/queue.c ****                         }
1179:Lib/FreeRTOS/Source/queue.c ****                     }
1180:Lib/FreeRTOS/Source/queue.c ****                     else
1181:Lib/FreeRTOS/Source/queue.c ****                     {
1182:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1183:Lib/FreeRTOS/Source/queue.c ****                         {
1184:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1185:Lib/FreeRTOS/Source/queue.c ****                             {
1186:Lib/FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so
1187:Lib/FreeRTOS/Source/queue.c ****                                  *  record that a context switch is required. */
1188:Lib/FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1189:Lib/FreeRTOS/Source/queue.c ****                                 {
1190:Lib/FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1191:Lib/FreeRTOS/Source/queue.c ****                                 }
1192:Lib/FreeRTOS/Source/queue.c ****                                 else
1193:Lib/FreeRTOS/Source/queue.c ****                                 {
1194:Lib/FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1195:Lib/FreeRTOS/Source/queue.c ****                                 }
1196:Lib/FreeRTOS/Source/queue.c ****                             }
ARM GAS  /tmp/cchrzcnP.s 			page 48


1197:Lib/FreeRTOS/Source/queue.c ****                             else
1198:Lib/FreeRTOS/Source/queue.c ****                             {
1199:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1200:Lib/FreeRTOS/Source/queue.c ****                             }
1201:Lib/FreeRTOS/Source/queue.c ****                         }
1202:Lib/FreeRTOS/Source/queue.c ****                         else
1203:Lib/FreeRTOS/Source/queue.c ****                         {
1204:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1205:Lib/FreeRTOS/Source/queue.c ****                         }
1206:Lib/FreeRTOS/Source/queue.c ****                     }
1207:Lib/FreeRTOS/Source/queue.c ****                 }
1208:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1209:Lib/FreeRTOS/Source/queue.c ****                 {
1210:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1500              		.loc 1 1210 25
 1501 00bc 3B6A     		ldr	r3, [r7, #32]
 1502 00be 5B6A     		ldr	r3, [r3, #36]
 1503              		.loc 1 1210 23
 1504 00c0 002B     		cmp	r3, #0
 1505 00c2 2AD0     		beq	.L116
1211:Lib/FreeRTOS/Source/queue.c ****                     {
1212:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 1506              		.loc 1 1212 55
 1507 00c4 3B6A     		ldr	r3, [r7, #32]
 1508 00c6 2433     		adds	r3, r3, #36
 1509              		.loc 1 1212 29
 1510 00c8 1846     		mov	r0, r3
 1511 00ca FFF7FEFF 		bl	xTaskRemoveFromEventList
 1512 00ce 0346     		mov	r3, r0
 1513              		.loc 1 1212 27 discriminator 1
 1514 00d0 002B     		cmp	r3, #0
 1515 00d2 22D0     		beq	.L116
1213:Lib/FreeRTOS/Source/queue.c ****                         {
1214:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
1215:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
1216:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
 1516              		.loc 1 1216 31
 1517 00d4 7B68     		ldr	r3, [r7, #4]
 1518 00d6 002B     		cmp	r3, #0
 1519 00d8 1FD0     		beq	.L116
1217:Lib/FreeRTOS/Source/queue.c ****                             {
1218:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
 1520              		.loc 1 1218 60
 1521 00da 7B68     		ldr	r3, [r7, #4]
 1522 00dc 0122     		movs	r2, #1
 1523 00de 1A60     		str	r2, [r3]
 1524 00e0 1BE0     		b	.L116
 1525              	.L115:
 1526              	.LBB4:
1219:Lib/FreeRTOS/Source/queue.c ****                             }
1220:Lib/FreeRTOS/Source/queue.c ****                             else
1221:Lib/FreeRTOS/Source/queue.c ****                             {
1222:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1223:Lib/FreeRTOS/Source/queue.c ****                             }
1224:Lib/FreeRTOS/Source/queue.c ****                         }
1225:Lib/FreeRTOS/Source/queue.c ****                         else
1226:Lib/FreeRTOS/Source/queue.c ****                         {
ARM GAS  /tmp/cchrzcnP.s 			page 49


1227:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1228:Lib/FreeRTOS/Source/queue.c ****                         }
1229:Lib/FreeRTOS/Source/queue.c ****                     }
1230:Lib/FreeRTOS/Source/queue.c ****                     else
1231:Lib/FreeRTOS/Source/queue.c ****                     {
1232:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1233:Lib/FreeRTOS/Source/queue.c ****                     }
1234:Lib/FreeRTOS/Source/queue.c **** 
1235:Lib/FreeRTOS/Source/queue.c ****                     /* Not used in this path. */
1236:Lib/FreeRTOS/Source/queue.c ****                     ( void ) uxPreviousMessagesWaiting;
1237:Lib/FreeRTOS/Source/queue.c ****                 }
1238:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1239:Lib/FreeRTOS/Source/queue.c ****             }
1240:Lib/FreeRTOS/Source/queue.c ****             else
1241:Lib/FreeRTOS/Source/queue.c ****             {
1242:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1243:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1244:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
 1527              		.loc 1 1244 17
 1528 00e2 FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1529 00e6 3861     		str	r0, [r7, #16]
 1530              		.loc 1 1244 17 is_stmt 0 discriminator 1
 1531 00e8 97F91B30 		ldrsb	r3, [r7, #27]
 1532 00ec 3A69     		ldr	r2, [r7, #16]
 1533 00ee 9A42     		cmp	r2, r3
 1534 00f0 13D9     		bls	.L116
 1535 00f2 97F91B30 		ldrsb	r3, [r7, #27]
 1536 00f6 7F2B     		cmp	r3, #127
 1537 00f8 08D1     		bne	.L117
 1538              		.loc 1 1244 17 discriminator 2
 1539 00fa FFF7FEFF 		bl	ulSetInterruptMask
 1540              		.loc 1 1244 17 discriminator 1
 1541 00fe 0D4B     		ldr	r3, .L120
 1542 0100 0D4A     		ldr	r2, .L120+4
 1543 0102 40F2DC41 		movw	r1, #1244
 1544 0106 0D48     		ldr	r0, .L120+8
 1545 0108 FFF7FEFF 		bl	__assert_func
 1546              	.L117:
 1547              		.loc 1 1244 17 discriminator 3
 1548 010c FB7E     		ldrb	r3, [r7, #27]	@ zero_extendqisi2
 1549 010e 0133     		adds	r3, r3, #1
 1550 0110 DBB2     		uxtb	r3, r3
 1551 0112 5AB2     		sxtb	r2, r3
 1552 0114 3B6A     		ldr	r3, [r7, #32]
 1553 0116 83F84520 		strb	r2, [r3, #69]
 1554              	.L116:
 1555              	.LBE4:
1245:Lib/FreeRTOS/Source/queue.c ****             }
1246:Lib/FreeRTOS/Source/queue.c **** 
1247:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 1556              		.loc 1 1247 21 is_stmt 1
 1557 011a 0123     		movs	r3, #1
 1558 011c 7B62     		str	r3, [r7, #36]
 1559              	.LBE3:
1133:Lib/FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 1560              		.loc 1 1133 9
 1561 011e 01E0     		b	.L118
ARM GAS  /tmp/cchrzcnP.s 			page 50


 1562              	.L114:
1248:Lib/FreeRTOS/Source/queue.c ****         }
1249:Lib/FreeRTOS/Source/queue.c ****         else
1250:Lib/FreeRTOS/Source/queue.c ****         {
1251:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1252:Lib/FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
 1563              		.loc 1 1252 21
 1564 0120 0023     		movs	r3, #0
 1565 0122 7B62     		str	r3, [r7, #36]
 1566              	.L118:
1253:Lib/FreeRTOS/Source/queue.c ****         }
1254:Lib/FreeRTOS/Source/queue.c ****     }
1255:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1567              		.loc 1 1255 5
 1568 0124 F869     		ldr	r0, [r7, #28]
 1569 0126 FFF7FEFF 		bl	vClearInterruptMask
1256:Lib/FreeRTOS/Source/queue.c **** 
1257:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 1570              		.loc 1 1257 12
 1571 012a 7B6A     		ldr	r3, [r7, #36]
1258:Lib/FreeRTOS/Source/queue.c **** }
 1572              		.loc 1 1258 1
 1573 012c 1846     		mov	r0, r3
 1574 012e 2837     		adds	r7, r7, #40
 1575              		.cfi_def_cfa_offset 8
 1576 0130 BD46     		mov	sp, r7
 1577              		.cfi_def_cfa_register 13
 1578              		@ sp needed
 1579 0132 80BD     		pop	{r7, pc}
 1580              	.L121:
 1581              		.align	2
 1582              	.L120:
 1583 0134 00000000 		.word	.LC0
 1584 0138 00000000 		.word	__func__.15
 1585 013c 04000000 		.word	.LC1
 1586              		.cfi_endproc
 1587              	.LFE12:
 1589              		.section	.text.xQueueGiveFromISR,"ax",%progbits
 1590              		.align	1
 1591              		.global	xQueueGiveFromISR
 1592              		.syntax unified
 1593              		.thumb
 1594              		.thumb_func
 1596              	xQueueGiveFromISR:
 1597              	.LFB13:
1259:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1260:Lib/FreeRTOS/Source/queue.c **** 
1261:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
1262:Lib/FreeRTOS/Source/queue.c ****                               BaseType_t * const pxHigherPriorityTaskWoken )
1263:Lib/FreeRTOS/Source/queue.c **** {
 1598              		.loc 1 1263 1
 1599              		.cfi_startproc
 1600              		@ args = 0, pretend = 0, frame = 32
 1601              		@ frame_needed = 1, uses_anonymous_args = 0
 1602 0000 80B5     		push	{r7, lr}
 1603              		.cfi_def_cfa_offset 8
 1604              		.cfi_offset 7, -8
ARM GAS  /tmp/cchrzcnP.s 			page 51


 1605              		.cfi_offset 14, -4
 1606 0002 88B0     		sub	sp, sp, #32
 1607              		.cfi_def_cfa_offset 40
 1608 0004 00AF     		add	r7, sp, #0
 1609              		.cfi_def_cfa_register 7
 1610 0006 7860     		str	r0, [r7, #4]
 1611 0008 3960     		str	r1, [r7]
1264:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1265:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1266:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1612              		.loc 1 1266 21
 1613 000a 7B68     		ldr	r3, [r7, #4]
 1614 000c BB61     		str	r3, [r7, #24]
1267:Lib/FreeRTOS/Source/queue.c **** 
1268:Lib/FreeRTOS/Source/queue.c ****     /* Similar to xQueueGenericSendFromISR() but used with semaphores where the
1269:Lib/FreeRTOS/Source/queue.c ****      * item size is 0.  Don't directly wake a task that was blocked on a queue
1270:Lib/FreeRTOS/Source/queue.c ****      * read, instead return a flag to say whether a context switch is required or
1271:Lib/FreeRTOS/Source/queue.c ****      * not (i.e. has a task with a higher priority than us been woken by this
1272:Lib/FreeRTOS/Source/queue.c ****      * post). */
1273:Lib/FreeRTOS/Source/queue.c **** 
1274:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 1615              		.loc 1 1274 5
 1616 000e BB69     		ldr	r3, [r7, #24]
 1617 0010 002B     		cmp	r3, #0
 1618 0012 08D1     		bne	.L123
 1619              		.loc 1 1274 5 is_stmt 0 discriminator 1
 1620 0014 FFF7FEFF 		bl	ulSetInterruptMask
 1621 0018 3F4B     		ldr	r3, .L135
 1622 001a 404A     		ldr	r2, .L135+4
 1623 001c 40F2FA41 		movw	r1, #1274
 1624 0020 3F48     		ldr	r0, .L135+8
 1625 0022 FFF7FEFF 		bl	__assert_func
 1626              	.L123:
1275:Lib/FreeRTOS/Source/queue.c **** 
1276:Lib/FreeRTOS/Source/queue.c ****     /* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
1277:Lib/FreeRTOS/Source/queue.c ****      * if the item size is not 0. */
1278:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
 1627              		.loc 1 1278 5 is_stmt 1
 1628 0026 BB69     		ldr	r3, [r7, #24]
 1629 0028 1B6C     		ldr	r3, [r3, #64]
 1630 002a 002B     		cmp	r3, #0
 1631 002c 08D0     		beq	.L124
 1632              		.loc 1 1278 5 is_stmt 0 discriminator 1
 1633 002e FFF7FEFF 		bl	ulSetInterruptMask
 1634 0032 394B     		ldr	r3, .L135
 1635 0034 394A     		ldr	r2, .L135+4
 1636 0036 40F2FE41 		movw	r1, #1278
 1637 003a 3948     		ldr	r0, .L135+8
 1638 003c FFF7FEFF 		bl	__assert_func
 1639              	.L124:
1279:Lib/FreeRTOS/Source/queue.c **** 
1280:Lib/FreeRTOS/Source/queue.c ****     /* Normally a mutex would not be given from an interrupt, especially if
1281:Lib/FreeRTOS/Source/queue.c ****      * there is a mutex holder, as priority inheritance makes no sense for an
1282:Lib/FreeRTOS/Source/queue.c ****      * interrupts, only tasks. */
1283:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMu
 1640              		.loc 1 1283 5 is_stmt 1
 1641 0040 BB69     		ldr	r3, [r7, #24]
ARM GAS  /tmp/cchrzcnP.s 			page 52


 1642 0042 1B68     		ldr	r3, [r3]
 1643 0044 002B     		cmp	r3, #0
 1644 0046 03D1     		bne	.L125
 1645              		.loc 1 1283 5 is_stmt 0 discriminator 2
 1646 0048 BB69     		ldr	r3, [r7, #24]
 1647 004a 9B68     		ldr	r3, [r3, #8]
 1648 004c 002B     		cmp	r3, #0
 1649 004e 01D1     		bne	.L126
 1650              	.L125:
 1651              		.loc 1 1283 5 discriminator 3
 1652 0050 0123     		movs	r3, #1
 1653              		.loc 1 1283 5
 1654 0052 00E0     		b	.L127
 1655              	.L126:
 1656              		.loc 1 1283 5 discriminator 4
 1657 0054 0023     		movs	r3, #0
 1658              	.L127:
 1659              		.loc 1 1283 5 discriminator 6
 1660 0056 002B     		cmp	r3, #0
 1661 0058 08D1     		bne	.L128
 1662              		.loc 1 1283 5 discriminator 7
 1663 005a FFF7FEFF 		bl	ulSetInterruptMask
 1664              		.loc 1 1283 5 discriminator 1
 1665 005e 2E4B     		ldr	r3, .L135
 1666 0060 2E4A     		ldr	r2, .L135+4
 1667 0062 40F20351 		movw	r1, #1283
 1668 0066 2E48     		ldr	r0, .L135+8
 1669 0068 FFF7FEFF 		bl	__assert_func
 1670              	.L128:
1284:Lib/FreeRTOS/Source/queue.c **** 
1285:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1286:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1287:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1288:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1289:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1290:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1291:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1292:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1293:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1294:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1295:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1296:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1297:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1298:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1299:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 1671              		.loc 1 1299 5 is_stmt 1
 1672 006c FFF7FEFF 		bl	vPortValidateInterruptPriority
1300:Lib/FreeRTOS/Source/queue.c **** 
1301:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1673              		.loc 1 1301 30
 1674 0070 FFF7FEFF 		bl	ulSetInterruptMask
 1675 0074 7861     		str	r0, [r7, #20]
 1676              	.LBB5:
1302:Lib/FreeRTOS/Source/queue.c ****     {
1303:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1677              		.loc 1 1303 27
 1678 0076 BB69     		ldr	r3, [r7, #24]
ARM GAS  /tmp/cchrzcnP.s 			page 53


 1679 0078 9B6B     		ldr	r3, [r3, #56]
 1680 007a 3B61     		str	r3, [r7, #16]
1304:Lib/FreeRTOS/Source/queue.c **** 
1305:Lib/FreeRTOS/Source/queue.c ****         /* When the queue is used to implement a semaphore no data is ever
1306:Lib/FreeRTOS/Source/queue.c ****          * moved through the queue but it is still valid to see if the queue 'has
1307:Lib/FreeRTOS/Source/queue.c ****          * space'. */
1308:Lib/FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting < pxQueue->uxLength )
 1681              		.loc 1 1308 40
 1682 007c BB69     		ldr	r3, [r7, #24]
 1683 007e DB6B     		ldr	r3, [r3, #60]
 1684              		.loc 1 1308 11
 1685 0080 3A69     		ldr	r2, [r7, #16]
 1686 0082 9A42     		cmp	r2, r3
 1687 0084 3ED2     		bcs	.L129
 1688              	.LBB6:
1309:Lib/FreeRTOS/Source/queue.c ****         {
1310:Lib/FreeRTOS/Source/queue.c ****             const int8_t cTxLock = pxQueue->cTxLock;
 1689              		.loc 1 1310 26
 1690 0086 BB69     		ldr	r3, [r7, #24]
 1691 0088 93F84530 		ldrb	r3, [r3, #69]
 1692 008c FB73     		strb	r3, [r7, #15]
1311:Lib/FreeRTOS/Source/queue.c **** 
1312:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR( pxQueue );
1313:Lib/FreeRTOS/Source/queue.c **** 
1314:Lib/FreeRTOS/Source/queue.c ****             /* A task can only have an inherited priority if it is a mutex
1315:Lib/FreeRTOS/Source/queue.c ****              * holder - and if there is a mutex holder then the mutex cannot be
1316:Lib/FreeRTOS/Source/queue.c ****              * given from an ISR.  As this is the ISR version of the function it
1317:Lib/FreeRTOS/Source/queue.c ****              * can be assumed there is no mutex holder and no need to determine if
1318:Lib/FreeRTOS/Source/queue.c ****              * priority disinheritance is needed.  Simply increase the count of
1319:Lib/FreeRTOS/Source/queue.c ****              * messages (semaphores) available. */
1320:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 1693              		.loc 1 1320 60
 1694 008e 3B69     		ldr	r3, [r7, #16]
 1695 0090 5A1C     		adds	r2, r3, #1
 1696              		.loc 1 1320 40
 1697 0092 BB69     		ldr	r3, [r7, #24]
 1698 0094 9A63     		str	r2, [r3, #56]
1321:Lib/FreeRTOS/Source/queue.c **** 
1322:Lib/FreeRTOS/Source/queue.c ****             /* The event list is not altered if the queue is locked.  This will
1323:Lib/FreeRTOS/Source/queue.c ****              * be done when the queue is unlocked later. */
1324:Lib/FreeRTOS/Source/queue.c ****             if( cTxLock == queueUNLOCKED )
 1699              		.loc 1 1324 15
 1700 0096 97F90F30 		ldrsb	r3, [r7, #15]
 1701 009a B3F1FF3F 		cmp	r3, #-1
 1702 009e 12D1     		bne	.L130
1325:Lib/FreeRTOS/Source/queue.c ****             {
1326:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_QUEUE_SETS == 1 )
1327:Lib/FreeRTOS/Source/queue.c ****                 {
1328:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->pxQueueSetContainer != NULL )
1329:Lib/FreeRTOS/Source/queue.c ****                     {
1330:Lib/FreeRTOS/Source/queue.c ****                         if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
1331:Lib/FreeRTOS/Source/queue.c ****                         {
1332:Lib/FreeRTOS/Source/queue.c ****                             /* The semaphore is a member of a queue set, and
1333:Lib/FreeRTOS/Source/queue.c ****                              * posting to the queue set caused a higher priority
1334:Lib/FreeRTOS/Source/queue.c ****                              * task to unblock.  A context switch is required. */
1335:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
1336:Lib/FreeRTOS/Source/queue.c ****                             {
ARM GAS  /tmp/cchrzcnP.s 			page 54


1337:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
1338:Lib/FreeRTOS/Source/queue.c ****                             }
1339:Lib/FreeRTOS/Source/queue.c ****                             else
1340:Lib/FreeRTOS/Source/queue.c ****                             {
1341:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1342:Lib/FreeRTOS/Source/queue.c ****                             }
1343:Lib/FreeRTOS/Source/queue.c ****                         }
1344:Lib/FreeRTOS/Source/queue.c ****                         else
1345:Lib/FreeRTOS/Source/queue.c ****                         {
1346:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1347:Lib/FreeRTOS/Source/queue.c ****                         }
1348:Lib/FreeRTOS/Source/queue.c ****                     }
1349:Lib/FreeRTOS/Source/queue.c ****                     else
1350:Lib/FreeRTOS/Source/queue.c ****                     {
1351:Lib/FreeRTOS/Source/queue.c ****                         if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1352:Lib/FreeRTOS/Source/queue.c ****                         {
1353:Lib/FreeRTOS/Source/queue.c ****                             if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) !=
1354:Lib/FreeRTOS/Source/queue.c ****                             {
1355:Lib/FreeRTOS/Source/queue.c ****                                 /* The task waiting has a higher priority so
1356:Lib/FreeRTOS/Source/queue.c ****                                  *  record that a context switch is required. */
1357:Lib/FreeRTOS/Source/queue.c ****                                 if( pxHigherPriorityTaskWoken != NULL )
1358:Lib/FreeRTOS/Source/queue.c ****                                 {
1359:Lib/FreeRTOS/Source/queue.c ****                                     *pxHigherPriorityTaskWoken = pdTRUE;
1360:Lib/FreeRTOS/Source/queue.c ****                                 }
1361:Lib/FreeRTOS/Source/queue.c ****                                 else
1362:Lib/FreeRTOS/Source/queue.c ****                                 {
1363:Lib/FreeRTOS/Source/queue.c ****                                     mtCOVERAGE_TEST_MARKER();
1364:Lib/FreeRTOS/Source/queue.c ****                                 }
1365:Lib/FreeRTOS/Source/queue.c ****                             }
1366:Lib/FreeRTOS/Source/queue.c ****                             else
1367:Lib/FreeRTOS/Source/queue.c ****                             {
1368:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1369:Lib/FreeRTOS/Source/queue.c ****                             }
1370:Lib/FreeRTOS/Source/queue.c ****                         }
1371:Lib/FreeRTOS/Source/queue.c ****                         else
1372:Lib/FreeRTOS/Source/queue.c ****                         {
1373:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1374:Lib/FreeRTOS/Source/queue.c ****                         }
1375:Lib/FreeRTOS/Source/queue.c ****                     }
1376:Lib/FreeRTOS/Source/queue.c ****                 }
1377:Lib/FreeRTOS/Source/queue.c ****                 #else /* configUSE_QUEUE_SETS */
1378:Lib/FreeRTOS/Source/queue.c ****                 {
1379:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1703              		.loc 1 1379 25
 1704 00a0 BB69     		ldr	r3, [r7, #24]
 1705 00a2 5B6A     		ldr	r3, [r3, #36]
 1706              		.loc 1 1379 23
 1707 00a4 002B     		cmp	r3, #0
 1708 00a6 2AD0     		beq	.L131
1380:Lib/FreeRTOS/Source/queue.c ****                     {
1381:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
 1709              		.loc 1 1381 55
 1710 00a8 BB69     		ldr	r3, [r7, #24]
 1711 00aa 2433     		adds	r3, r3, #36
 1712              		.loc 1 1381 29
 1713 00ac 1846     		mov	r0, r3
 1714 00ae FFF7FEFF 		bl	xTaskRemoveFromEventList
ARM GAS  /tmp/cchrzcnP.s 			page 55


 1715 00b2 0346     		mov	r3, r0
 1716              		.loc 1 1381 27 discriminator 1
 1717 00b4 002B     		cmp	r3, #0
 1718 00b6 22D0     		beq	.L131
1382:Lib/FreeRTOS/Source/queue.c ****                         {
1383:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
1384:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
1385:Lib/FreeRTOS/Source/queue.c ****                             if( pxHigherPriorityTaskWoken != NULL )
 1719              		.loc 1 1385 31
 1720 00b8 3B68     		ldr	r3, [r7]
 1721 00ba 002B     		cmp	r3, #0
 1722 00bc 1FD0     		beq	.L131
1386:Lib/FreeRTOS/Source/queue.c ****                             {
1387:Lib/FreeRTOS/Source/queue.c ****                                 *pxHigherPriorityTaskWoken = pdTRUE;
 1723              		.loc 1 1387 60
 1724 00be 3B68     		ldr	r3, [r7]
 1725 00c0 0122     		movs	r2, #1
 1726 00c2 1A60     		str	r2, [r3]
 1727 00c4 1BE0     		b	.L131
 1728              	.L130:
 1729              	.LBB7:
1388:Lib/FreeRTOS/Source/queue.c ****                             }
1389:Lib/FreeRTOS/Source/queue.c ****                             else
1390:Lib/FreeRTOS/Source/queue.c ****                             {
1391:Lib/FreeRTOS/Source/queue.c ****                                 mtCOVERAGE_TEST_MARKER();
1392:Lib/FreeRTOS/Source/queue.c ****                             }
1393:Lib/FreeRTOS/Source/queue.c ****                         }
1394:Lib/FreeRTOS/Source/queue.c ****                         else
1395:Lib/FreeRTOS/Source/queue.c ****                         {
1396:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1397:Lib/FreeRTOS/Source/queue.c ****                         }
1398:Lib/FreeRTOS/Source/queue.c ****                     }
1399:Lib/FreeRTOS/Source/queue.c ****                     else
1400:Lib/FreeRTOS/Source/queue.c ****                     {
1401:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1402:Lib/FreeRTOS/Source/queue.c ****                     }
1403:Lib/FreeRTOS/Source/queue.c ****                 }
1404:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_QUEUE_SETS */
1405:Lib/FreeRTOS/Source/queue.c ****             }
1406:Lib/FreeRTOS/Source/queue.c ****             else
1407:Lib/FreeRTOS/Source/queue.c ****             {
1408:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
1409:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was posted while it was locked. */
1410:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueTxLock( pxQueue, cTxLock );
 1730              		.loc 1 1410 17
 1731 00c6 FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 1732 00ca B860     		str	r0, [r7, #8]
 1733              		.loc 1 1410 17 is_stmt 0 discriminator 1
 1734 00cc 97F90F30 		ldrsb	r3, [r7, #15]
 1735 00d0 BA68     		ldr	r2, [r7, #8]
 1736 00d2 9A42     		cmp	r2, r3
 1737 00d4 13D9     		bls	.L131
 1738 00d6 97F90F30 		ldrsb	r3, [r7, #15]
 1739 00da 7F2B     		cmp	r3, #127
 1740 00dc 08D1     		bne	.L132
 1741              		.loc 1 1410 17 discriminator 2
 1742 00de FFF7FEFF 		bl	ulSetInterruptMask
ARM GAS  /tmp/cchrzcnP.s 			page 56


 1743              		.loc 1 1410 17 discriminator 1
 1744 00e2 0D4B     		ldr	r3, .L135
 1745 00e4 0D4A     		ldr	r2, .L135+4
 1746 00e6 40F28251 		movw	r1, #1410
 1747 00ea 0D48     		ldr	r0, .L135+8
 1748 00ec FFF7FEFF 		bl	__assert_func
 1749              	.L132:
 1750              		.loc 1 1410 17 discriminator 3
 1751 00f0 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1752 00f2 0133     		adds	r3, r3, #1
 1753 00f4 DBB2     		uxtb	r3, r3
 1754 00f6 5AB2     		sxtb	r2, r3
 1755 00f8 BB69     		ldr	r3, [r7, #24]
 1756 00fa 83F84520 		strb	r2, [r3, #69]
 1757              	.L131:
 1758              	.LBE7:
1411:Lib/FreeRTOS/Source/queue.c ****             }
1412:Lib/FreeRTOS/Source/queue.c **** 
1413:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 1759              		.loc 1 1413 21 is_stmt 1
 1760 00fe 0123     		movs	r3, #1
 1761 0100 FB61     		str	r3, [r7, #28]
 1762              	.LBE6:
 1763 0102 01E0     		b	.L133
 1764              	.L129:
1414:Lib/FreeRTOS/Source/queue.c ****         }
1415:Lib/FreeRTOS/Source/queue.c ****         else
1416:Lib/FreeRTOS/Source/queue.c ****         {
1417:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1418:Lib/FreeRTOS/Source/queue.c ****             xReturn = errQUEUE_FULL;
 1765              		.loc 1 1418 21
 1766 0104 0023     		movs	r3, #0
 1767 0106 FB61     		str	r3, [r7, #28]
 1768              	.L133:
 1769              	.LBE5:
1419:Lib/FreeRTOS/Source/queue.c ****         }
1420:Lib/FreeRTOS/Source/queue.c ****     }
1421:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1770              		.loc 1 1421 5
 1771 0108 7869     		ldr	r0, [r7, #20]
 1772 010a FFF7FEFF 		bl	vClearInterruptMask
1422:Lib/FreeRTOS/Source/queue.c **** 
1423:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 1773              		.loc 1 1423 12
 1774 010e FB69     		ldr	r3, [r7, #28]
1424:Lib/FreeRTOS/Source/queue.c **** }
 1775              		.loc 1 1424 1
 1776 0110 1846     		mov	r0, r3
 1777 0112 2037     		adds	r7, r7, #32
 1778              		.cfi_def_cfa_offset 8
 1779 0114 BD46     		mov	sp, r7
 1780              		.cfi_def_cfa_register 13
 1781              		@ sp needed
 1782 0116 80BD     		pop	{r7, pc}
 1783              	.L136:
 1784              		.align	2
 1785              	.L135:
ARM GAS  /tmp/cchrzcnP.s 			page 57


 1786 0118 00000000 		.word	.LC0
 1787 011c 00000000 		.word	__func__.14
 1788 0120 04000000 		.word	.LC1
 1789              		.cfi_endproc
 1790              	.LFE13:
 1792              		.section	.text.xQueueReceive,"ax",%progbits
 1793              		.align	1
 1794              		.global	xQueueReceive
 1795              		.syntax unified
 1796              		.thumb
 1797              		.thumb_func
 1799              	xQueueReceive:
 1800              	.LFB14:
1425:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1426:Lib/FreeRTOS/Source/queue.c **** 
1427:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceive( QueueHandle_t xQueue,
1428:Lib/FreeRTOS/Source/queue.c ****                           void * const pvBuffer,
1429:Lib/FreeRTOS/Source/queue.c ****                           TickType_t xTicksToWait )
1430:Lib/FreeRTOS/Source/queue.c **** {
 1801              		.loc 1 1430 1
 1802              		.cfi_startproc
 1803              		@ args = 0, pretend = 0, frame = 40
 1804              		@ frame_needed = 1, uses_anonymous_args = 0
 1805 0000 80B5     		push	{r7, lr}
 1806              		.cfi_def_cfa_offset 8
 1807              		.cfi_offset 7, -8
 1808              		.cfi_offset 14, -4
 1809 0002 8AB0     		sub	sp, sp, #40
 1810              		.cfi_def_cfa_offset 48
 1811 0004 00AF     		add	r7, sp, #0
 1812              		.cfi_def_cfa_register 7
 1813 0006 F860     		str	r0, [r7, #12]
 1814 0008 B960     		str	r1, [r7, #8]
 1815 000a 7A60     		str	r2, [r7, #4]
1431:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 1816              		.loc 1 1431 16
 1817 000c 0023     		movs	r3, #0
 1818 000e 7B62     		str	r3, [r7, #36]
1432:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1433:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 1819              		.loc 1 1433 21
 1820 0010 FB68     		ldr	r3, [r7, #12]
 1821 0012 3B62     		str	r3, [r7, #32]
1434:Lib/FreeRTOS/Source/queue.c **** 
1435:Lib/FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1436:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
 1822              		.loc 1 1436 5
 1823 0014 3B6A     		ldr	r3, [r7, #32]
 1824 0016 002B     		cmp	r3, #0
 1825 0018 08D1     		bne	.L138
 1826              		.loc 1 1436 5 is_stmt 0 discriminator 1
 1827 001a FFF7FEFF 		bl	ulSetInterruptMask
 1828 001e 5E4B     		ldr	r3, .L158
 1829 0020 5E4A     		ldr	r2, .L158+4
 1830 0022 40F29C51 		movw	r1, #1436
 1831 0026 5E48     		ldr	r0, .L158+8
 1832 0028 FFF7FEFF 		bl	__assert_func
ARM GAS  /tmp/cchrzcnP.s 			page 58


 1833              	.L138:
1437:Lib/FreeRTOS/Source/queue.c **** 
1438:Lib/FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1439:Lib/FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer). */
1440:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
 1834              		.loc 1 1440 5 is_stmt 1
 1835 002c BB68     		ldr	r3, [r7, #8]
 1836 002e 002B     		cmp	r3, #0
 1837 0030 03D1     		bne	.L139
 1838              		.loc 1 1440 5 is_stmt 0 discriminator 2
 1839 0032 3B6A     		ldr	r3, [r7, #32]
 1840 0034 1B6C     		ldr	r3, [r3, #64]
 1841 0036 002B     		cmp	r3, #0
 1842 0038 01D1     		bne	.L140
 1843              	.L139:
 1844              		.loc 1 1440 5 discriminator 3
 1845 003a 0123     		movs	r3, #1
 1846              		.loc 1 1440 5
 1847 003c 00E0     		b	.L141
 1848              	.L140:
 1849              		.loc 1 1440 5 discriminator 4
 1850 003e 0023     		movs	r3, #0
 1851              	.L141:
 1852              		.loc 1 1440 5 discriminator 6
 1853 0040 002B     		cmp	r3, #0
 1854 0042 08D1     		bne	.L142
 1855              		.loc 1 1440 5 discriminator 7
 1856 0044 FFF7FEFF 		bl	ulSetInterruptMask
 1857              		.loc 1 1440 5 discriminator 1
 1858 0048 534B     		ldr	r3, .L158
 1859 004a 544A     		ldr	r2, .L158+4
 1860 004c 4FF4B461 		mov	r1, #1440
 1861 0050 5348     		ldr	r0, .L158+8
 1862 0052 FFF7FEFF 		bl	__assert_func
 1863              	.L142:
1441:Lib/FreeRTOS/Source/queue.c **** 
1442:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1443:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1444:Lib/FreeRTOS/Source/queue.c ****     {
1445:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 1864              		.loc 1 1445 9 is_stmt 1
 1865 0056 FFF7FEFF 		bl	xTaskGetSchedulerState
 1866 005a 0346     		mov	r3, r0
 1867              		.loc 1 1445 9 is_stmt 0 discriminator 1
 1868 005c 002B     		cmp	r3, #0
 1869 005e 02D1     		bne	.L143
 1870              		.loc 1 1445 9 discriminator 2
 1871 0060 7B68     		ldr	r3, [r7, #4]
 1872 0062 002B     		cmp	r3, #0
 1873 0064 01D1     		bne	.L144
 1874              	.L143:
 1875              		.loc 1 1445 9 discriminator 3
 1876 0066 0123     		movs	r3, #1
 1877              		.loc 1 1445 9
 1878 0068 00E0     		b	.L145
 1879              	.L144:
 1880              		.loc 1 1445 9 discriminator 4
ARM GAS  /tmp/cchrzcnP.s 			page 59


 1881 006a 0023     		movs	r3, #0
 1882              	.L145:
 1883              		.loc 1 1445 9 discriminator 6
 1884 006c 002B     		cmp	r3, #0
 1885 006e 08D1     		bne	.L146
 1886              		.loc 1 1445 9 discriminator 7
 1887 0070 FFF7FEFF 		bl	ulSetInterruptMask
 1888              		.loc 1 1445 9 discriminator 1
 1889 0074 484B     		ldr	r3, .L158
 1890 0076 494A     		ldr	r2, .L158+4
 1891 0078 40F2A551 		movw	r1, #1445
 1892 007c 4848     		ldr	r0, .L158+8
 1893 007e FFF7FEFF 		bl	__assert_func
 1894              	.L146:
1446:Lib/FreeRTOS/Source/queue.c ****     }
1447:Lib/FreeRTOS/Source/queue.c ****     #endif
1448:Lib/FreeRTOS/Source/queue.c **** 
1449:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1450:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1451:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1452:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1453:Lib/FreeRTOS/Source/queue.c ****     {
1454:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 1895              		.loc 1 1454 9 is_stmt 1
 1896 0082 FFF7FEFF 		bl	vPortEnterCritical
 1897              	.LBB8:
1455:Lib/FreeRTOS/Source/queue.c ****         {
1456:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1898              		.loc 1 1456 31
 1899 0086 3B6A     		ldr	r3, [r7, #32]
 1900 0088 9B6B     		ldr	r3, [r3, #56]
 1901 008a FB61     		str	r3, [r7, #28]
1457:Lib/FreeRTOS/Source/queue.c **** 
1458:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1459:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1460:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1902              		.loc 1 1460 15
 1903 008c FB69     		ldr	r3, [r7, #28]
 1904 008e 002B     		cmp	r3, #0
 1905 0090 19D0     		beq	.L147
1461:Lib/FreeRTOS/Source/queue.c ****             {
1462:Lib/FreeRTOS/Source/queue.c ****                 /* Data available, remove one item. */
1463:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 1906              		.loc 1 1463 17
 1907 0092 B968     		ldr	r1, [r7, #8]
 1908 0094 386A     		ldr	r0, [r7, #32]
 1909 0096 FFF7FEFF 		bl	prvCopyDataFromQueue
1464:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1465:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 1910              		.loc 1 1465 64
 1911 009a FB69     		ldr	r3, [r7, #28]
 1912 009c 5A1E     		subs	r2, r3, #1
 1913              		.loc 1 1465 44
 1914 009e 3B6A     		ldr	r3, [r7, #32]
 1915 00a0 9A63     		str	r2, [r3, #56]
1466:Lib/FreeRTOS/Source/queue.c **** 
1467:Lib/FreeRTOS/Source/queue.c ****                 /* There is now space in the queue, were any tasks waiting to
ARM GAS  /tmp/cchrzcnP.s 			page 60


1468:Lib/FreeRTOS/Source/queue.c ****                  * post to the queue?  If so, unblock the highest priority waiting
1469:Lib/FreeRTOS/Source/queue.c ****                  * task. */
1470:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1916              		.loc 1 1470 21
 1917 00a2 3B6A     		ldr	r3, [r7, #32]
 1918 00a4 1B69     		ldr	r3, [r3, #16]
 1919              		.loc 1 1470 19
 1920 00a6 002B     		cmp	r3, #0
 1921 00a8 09D0     		beq	.L148
1471:Lib/FreeRTOS/Source/queue.c ****                 {
1472:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1922              		.loc 1 1472 51
 1923 00aa 3B6A     		ldr	r3, [r7, #32]
 1924 00ac 1033     		adds	r3, r3, #16
 1925              		.loc 1 1472 25
 1926 00ae 1846     		mov	r0, r3
 1927 00b0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 1928 00b4 0346     		mov	r3, r0
 1929              		.loc 1 1472 23 discriminator 1
 1930 00b6 002B     		cmp	r3, #0
 1931 00b8 01D0     		beq	.L148
1473:Lib/FreeRTOS/Source/queue.c ****                     {
1474:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
 1932              		.loc 1 1474 25
 1933 00ba FFF7FEFF 		bl	vPortYield
 1934              	.L148:
1475:Lib/FreeRTOS/Source/queue.c ****                     }
1476:Lib/FreeRTOS/Source/queue.c ****                     else
1477:Lib/FreeRTOS/Source/queue.c ****                     {
1478:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1479:Lib/FreeRTOS/Source/queue.c ****                     }
1480:Lib/FreeRTOS/Source/queue.c ****                 }
1481:Lib/FreeRTOS/Source/queue.c ****                 else
1482:Lib/FreeRTOS/Source/queue.c ****                 {
1483:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1484:Lib/FreeRTOS/Source/queue.c ****                 }
1485:Lib/FreeRTOS/Source/queue.c **** 
1486:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
 1935              		.loc 1 1486 17
 1936 00be FFF7FEFF 		bl	vPortExitCritical
1487:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 1937              		.loc 1 1487 24
 1938 00c2 0123     		movs	r3, #1
 1939 00c4 63E0     		b	.L157
 1940              	.L147:
1488:Lib/FreeRTOS/Source/queue.c ****             }
1489:Lib/FreeRTOS/Source/queue.c ****             else
1490:Lib/FreeRTOS/Source/queue.c ****             {
1491:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 1941              		.loc 1 1491 34
 1942 00c6 7B68     		ldr	r3, [r7, #4]
 1943              		.loc 1 1491 19
 1944 00c8 002B     		cmp	r3, #0
 1945 00ca 03D1     		bne	.L150
1492:Lib/FreeRTOS/Source/queue.c ****                 {
1493:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1494:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
ARM GAS  /tmp/cchrzcnP.s 			page 61


1495:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
 1946              		.loc 1 1495 21
 1947 00cc FFF7FEFF 		bl	vPortExitCritical
1496:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1497:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
 1948              		.loc 1 1497 28
 1949 00d0 0023     		movs	r3, #0
 1950 00d2 5CE0     		b	.L157
 1951              	.L150:
1498:Lib/FreeRTOS/Source/queue.c ****                 }
1499:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 1952              		.loc 1 1499 24
 1953 00d4 7B6A     		ldr	r3, [r7, #36]
 1954 00d6 002B     		cmp	r3, #0
 1955 00d8 06D1     		bne	.L151
1500:Lib/FreeRTOS/Source/queue.c ****                 {
1501:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1502:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure. */
1503:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 1956              		.loc 1 1503 21
 1957 00da 07F11403 		add	r3, r7, #20
 1958 00de 1846     		mov	r0, r3
 1959 00e0 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1504:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 1960              		.loc 1 1504 35
 1961 00e4 0123     		movs	r3, #1
 1962 00e6 7B62     		str	r3, [r7, #36]
 1963              	.L151:
 1964              	.LBE8:
1505:Lib/FreeRTOS/Source/queue.c ****                 }
1506:Lib/FreeRTOS/Source/queue.c ****                 else
1507:Lib/FreeRTOS/Source/queue.c ****                 {
1508:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1509:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1510:Lib/FreeRTOS/Source/queue.c ****                 }
1511:Lib/FreeRTOS/Source/queue.c ****             }
1512:Lib/FreeRTOS/Source/queue.c ****         }
1513:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 1965              		.loc 1 1513 9
 1966 00e8 FFF7FEFF 		bl	vPortExitCritical
1514:Lib/FreeRTOS/Source/queue.c **** 
1515:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1516:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1517:Lib/FreeRTOS/Source/queue.c **** 
1518:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
 1967              		.loc 1 1518 9
 1968 00ec FFF7FEFF 		bl	vTaskSuspendAll
1519:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 1969              		.loc 1 1519 9
 1970 00f0 FFF7FEFF 		bl	vPortEnterCritical
 1971              		.loc 1 1519 9 is_stmt 0 discriminator 1
 1972 00f4 3B6A     		ldr	r3, [r7, #32]
 1973 00f6 93F84430 		ldrb	r3, [r3, #68]
 1974 00fa 5BB2     		sxtb	r3, r3
 1975 00fc B3F1FF3F 		cmp	r3, #-1
 1976 0100 03D1     		bne	.L152
 1977 0102 3B6A     		ldr	r3, [r7, #32]
ARM GAS  /tmp/cchrzcnP.s 			page 62


 1978 0104 0022     		movs	r2, #0
 1979 0106 83F84420 		strb	r2, [r3, #68]
 1980              	.L152:
 1981              		.loc 1 1519 9 discriminator 3
 1982 010a 3B6A     		ldr	r3, [r7, #32]
 1983 010c 93F84530 		ldrb	r3, [r3, #69]
 1984 0110 5BB2     		sxtb	r3, r3
 1985 0112 B3F1FF3F 		cmp	r3, #-1
 1986 0116 03D1     		bne	.L153
 1987              		.loc 1 1519 9 discriminator 4
 1988 0118 3B6A     		ldr	r3, [r7, #32]
 1989 011a 0022     		movs	r2, #0
 1990 011c 83F84520 		strb	r2, [r3, #69]
 1991              	.L153:
 1992              		.loc 1 1519 9 discriminator 6
 1993 0120 FFF7FEFF 		bl	vPortExitCritical
1520:Lib/FreeRTOS/Source/queue.c **** 
1521:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1522:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1994              		.loc 1 1522 13 is_stmt 1
 1995 0124 3A1D     		adds	r2, r7, #4
 1996 0126 07F11403 		add	r3, r7, #20
 1997 012a 1146     		mov	r1, r2
 1998 012c 1846     		mov	r0, r3
 1999 012e FFF7FEFF 		bl	xTaskCheckForTimeOut
 2000 0132 0346     		mov	r3, r0
 2001              		.loc 1 1522 11 discriminator 1
 2002 0134 002B     		cmp	r3, #0
 2003 0136 1DD1     		bne	.L154
1523:Lib/FreeRTOS/Source/queue.c ****         {
1524:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has not expired.  If the queue is still empty place
1525:Lib/FreeRTOS/Source/queue.c ****              * the task on the list of tasks waiting to receive from the queue. */
1526:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2004              		.loc 1 1526 17
 2005 0138 386A     		ldr	r0, [r7, #32]
 2006 013a FFF7FEFF 		bl	prvIsQueueEmpty
 2007 013e 0346     		mov	r3, r0
 2008              		.loc 1 1526 15 discriminator 1
 2009 0140 002B     		cmp	r3, #0
 2010 0142 11D0     		beq	.L155
1527:Lib/FreeRTOS/Source/queue.c ****             {
1528:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1529:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2011              		.loc 1 1529 17
 2012 0144 3B6A     		ldr	r3, [r7, #32]
 2013 0146 2433     		adds	r3, r3, #36
 2014 0148 7A68     		ldr	r2, [r7, #4]
 2015 014a 1146     		mov	r1, r2
 2016 014c 1846     		mov	r0, r3
 2017 014e FFF7FEFF 		bl	vTaskPlaceOnEventList
1530:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2018              		.loc 1 1530 17
 2019 0152 386A     		ldr	r0, [r7, #32]
 2020 0154 FFF7FEFF 		bl	prvUnlockQueue
1531:Lib/FreeRTOS/Source/queue.c **** 
1532:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 2021              		.loc 1 1532 21
ARM GAS  /tmp/cchrzcnP.s 			page 63


 2022 0158 FFF7FEFF 		bl	xTaskResumeAll
 2023 015c 0346     		mov	r3, r0
 2024              		.loc 1 1532 19 discriminator 1
 2025 015e 002B     		cmp	r3, #0
 2026 0160 8FD1     		bne	.L146
1533:Lib/FreeRTOS/Source/queue.c ****                 {
1534:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
 2027              		.loc 1 1534 21
 2028 0162 FFF7FEFF 		bl	vPortYield
 2029 0166 8CE7     		b	.L146
 2030              	.L155:
1535:Lib/FreeRTOS/Source/queue.c ****                 }
1536:Lib/FreeRTOS/Source/queue.c ****                 else
1537:Lib/FreeRTOS/Source/queue.c ****                 {
1538:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1539:Lib/FreeRTOS/Source/queue.c ****                 }
1540:Lib/FreeRTOS/Source/queue.c ****             }
1541:Lib/FreeRTOS/Source/queue.c ****             else
1542:Lib/FreeRTOS/Source/queue.c ****             {
1543:Lib/FreeRTOS/Source/queue.c ****                 /* The queue contains data again.  Loop back to try and read the
1544:Lib/FreeRTOS/Source/queue.c ****                  * data. */
1545:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2031              		.loc 1 1545 17
 2032 0168 386A     		ldr	r0, [r7, #32]
 2033 016a FFF7FEFF 		bl	prvUnlockQueue
1546:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2034              		.loc 1 1546 26
 2035 016e FFF7FEFF 		bl	xTaskResumeAll
 2036 0172 86E7     		b	.L146
 2037              	.L154:
1547:Lib/FreeRTOS/Source/queue.c ****             }
1548:Lib/FreeRTOS/Source/queue.c ****         }
1549:Lib/FreeRTOS/Source/queue.c ****         else
1550:Lib/FreeRTOS/Source/queue.c ****         {
1551:Lib/FreeRTOS/Source/queue.c ****             /* Timed out.  If there is no data in the queue exit, otherwise loop
1552:Lib/FreeRTOS/Source/queue.c ****              * back and attempt to read the data. */
1553:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
 2038              		.loc 1 1553 13
 2039 0174 386A     		ldr	r0, [r7, #32]
 2040 0176 FFF7FEFF 		bl	prvUnlockQueue
1554:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2041              		.loc 1 1554 22
 2042 017a FFF7FEFF 		bl	xTaskResumeAll
1555:Lib/FreeRTOS/Source/queue.c **** 
1556:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2043              		.loc 1 1556 17
 2044 017e 386A     		ldr	r0, [r7, #32]
 2045 0180 FFF7FEFF 		bl	prvIsQueueEmpty
 2046 0184 0346     		mov	r3, r0
 2047              		.loc 1 1556 15 discriminator 1
 2048 0186 002B     		cmp	r3, #0
 2049 0188 3FF47BAF 		beq	.L146
1557:Lib/FreeRTOS/Source/queue.c ****             {
1558:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1559:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
 2050              		.loc 1 1559 24
 2051 018c 0023     		movs	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 64


 2052              	.L157:
1560:Lib/FreeRTOS/Source/queue.c ****             }
1561:Lib/FreeRTOS/Source/queue.c ****             else
1562:Lib/FreeRTOS/Source/queue.c ****             {
1563:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1564:Lib/FreeRTOS/Source/queue.c ****             }
1565:Lib/FreeRTOS/Source/queue.c ****         }
1566:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1567:Lib/FreeRTOS/Source/queue.c **** }
 2053              		.loc 1 1567 1
 2054 018e 1846     		mov	r0, r3
 2055 0190 2837     		adds	r7, r7, #40
 2056              		.cfi_def_cfa_offset 8
 2057 0192 BD46     		mov	sp, r7
 2058              		.cfi_def_cfa_register 13
 2059              		@ sp needed
 2060 0194 80BD     		pop	{r7, pc}
 2061              	.L159:
 2062 0196 00BF     		.align	2
 2063              	.L158:
 2064 0198 00000000 		.word	.LC0
 2065 019c 00000000 		.word	__func__.13
 2066 01a0 04000000 		.word	.LC1
 2067              		.cfi_endproc
 2068              	.LFE14:
 2070              		.section	.text.xQueueSemaphoreTake,"ax",%progbits
 2071              		.align	1
 2072              		.global	xQueueSemaphoreTake
 2073              		.syntax unified
 2074              		.thumb
 2075              		.thumb_func
 2077              	xQueueSemaphoreTake:
 2078              	.LFB15:
1568:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1569:Lib/FreeRTOS/Source/queue.c **** 
1570:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
1571:Lib/FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
1572:Lib/FreeRTOS/Source/queue.c **** {
 2079              		.loc 1 1572 1
 2080              		.cfi_startproc
 2081              		@ args = 0, pretend = 0, frame = 40
 2082              		@ frame_needed = 1, uses_anonymous_args = 0
 2083 0000 80B5     		push	{r7, lr}
 2084              		.cfi_def_cfa_offset 8
 2085              		.cfi_offset 7, -8
 2086              		.cfi_offset 14, -4
 2087 0002 8AB0     		sub	sp, sp, #40
 2088              		.cfi_def_cfa_offset 48
 2089 0004 00AF     		add	r7, sp, #0
 2090              		.cfi_def_cfa_register 7
 2091 0006 7860     		str	r0, [r7, #4]
 2092 0008 3960     		str	r1, [r7]
1573:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2093              		.loc 1 1573 16
 2094 000a 0023     		movs	r3, #0
 2095 000c 7B62     		str	r3, [r7, #36]
1574:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
ARM GAS  /tmp/cchrzcnP.s 			page 65


1575:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2096              		.loc 1 1575 21
 2097 000e 7B68     		ldr	r3, [r7, #4]
 2098 0010 FB61     		str	r3, [r7, #28]
1576:Lib/FreeRTOS/Source/queue.c **** 
1577:Lib/FreeRTOS/Source/queue.c ****     #if ( configUSE_MUTEXES == 1 )
1578:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xInheritanceOccurred = pdFALSE;
 2099              		.loc 1 1578 20
 2100 0012 0023     		movs	r3, #0
 2101 0014 3B62     		str	r3, [r7, #32]
1579:Lib/FreeRTOS/Source/queue.c ****     #endif
1580:Lib/FreeRTOS/Source/queue.c **** 
1581:Lib/FreeRTOS/Source/queue.c ****     /* Check the queue pointer is not NULL. */
1582:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
 2102              		.loc 1 1582 5
 2103 0016 FB69     		ldr	r3, [r7, #28]
 2104 0018 002B     		cmp	r3, #0
 2105 001a 08D1     		bne	.L161
 2106              		.loc 1 1582 5 is_stmt 0 discriminator 1
 2107 001c FFF7FEFF 		bl	ulSetInterruptMask
 2108 0020 6C4B     		ldr	r3, .L181
 2109 0022 6D4A     		ldr	r2, .L181+4
 2110 0024 40F22E61 		movw	r1, #1582
 2111 0028 6C48     		ldr	r0, .L181+8
 2112 002a FFF7FEFF 		bl	__assert_func
 2113              	.L161:
1583:Lib/FreeRTOS/Source/queue.c **** 
1584:Lib/FreeRTOS/Source/queue.c ****     /* Check this really is a semaphore, in which case the item size will be
1585:Lib/FreeRTOS/Source/queue.c ****      * 0. */
1586:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize == 0 );
 2114              		.loc 1 1586 5 is_stmt 1
 2115 002e FB69     		ldr	r3, [r7, #28]
 2116 0030 1B6C     		ldr	r3, [r3, #64]
 2117 0032 002B     		cmp	r3, #0
 2118 0034 08D0     		beq	.L162
 2119              		.loc 1 1586 5 is_stmt 0 discriminator 1
 2120 0036 FFF7FEFF 		bl	ulSetInterruptMask
 2121 003a 664B     		ldr	r3, .L181
 2122 003c 664A     		ldr	r2, .L181+4
 2123 003e 40F23261 		movw	r1, #1586
 2124 0042 6648     		ldr	r0, .L181+8
 2125 0044 FFF7FEFF 		bl	__assert_func
 2126              	.L162:
1587:Lib/FreeRTOS/Source/queue.c **** 
1588:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1589:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1590:Lib/FreeRTOS/Source/queue.c ****     {
1591:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 2127              		.loc 1 1591 9 is_stmt 1
 2128 0048 FFF7FEFF 		bl	xTaskGetSchedulerState
 2129 004c 0346     		mov	r3, r0
 2130              		.loc 1 1591 9 is_stmt 0 discriminator 1
 2131 004e 002B     		cmp	r3, #0
 2132 0050 02D1     		bne	.L163
 2133              		.loc 1 1591 9 discriminator 2
 2134 0052 3B68     		ldr	r3, [r7]
 2135 0054 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 66


 2136 0056 01D1     		bne	.L164
 2137              	.L163:
 2138              		.loc 1 1591 9 discriminator 3
 2139 0058 0123     		movs	r3, #1
 2140              		.loc 1 1591 9
 2141 005a 00E0     		b	.L165
 2142              	.L164:
 2143              		.loc 1 1591 9 discriminator 4
 2144 005c 0023     		movs	r3, #0
 2145              	.L165:
 2146              		.loc 1 1591 9 discriminator 6
 2147 005e 002B     		cmp	r3, #0
 2148 0060 08D1     		bne	.L166
 2149              		.loc 1 1591 9 discriminator 7
 2150 0062 FFF7FEFF 		bl	ulSetInterruptMask
 2151              		.loc 1 1591 9 discriminator 1
 2152 0066 5B4B     		ldr	r3, .L181
 2153 0068 5B4A     		ldr	r2, .L181+4
 2154 006a 40F23761 		movw	r1, #1591
 2155 006e 5B48     		ldr	r0, .L181+8
 2156 0070 FFF7FEFF 		bl	__assert_func
 2157              	.L166:
1592:Lib/FreeRTOS/Source/queue.c ****     }
1593:Lib/FreeRTOS/Source/queue.c ****     #endif
1594:Lib/FreeRTOS/Source/queue.c **** 
1595:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
1596:Lib/FreeRTOS/Source/queue.c ****      * statements within the function itself.  This is done in the interest
1597:Lib/FreeRTOS/Source/queue.c ****      * of execution time efficiency. */
1598:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1599:Lib/FreeRTOS/Source/queue.c ****     {
1600:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 2158              		.loc 1 1600 9 is_stmt 1
 2159 0074 FFF7FEFF 		bl	vPortEnterCritical
 2160              	.LBB9:
1601:Lib/FreeRTOS/Source/queue.c ****         {
1602:Lib/FreeRTOS/Source/queue.c ****             /* Semaphores are queues with an item size of 0, and where the
1603:Lib/FreeRTOS/Source/queue.c ****              * number of messages in the queue is the semaphore's count value. */
1604:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 2161              		.loc 1 1604 31
 2162 0078 FB69     		ldr	r3, [r7, #28]
 2163 007a 9B6B     		ldr	r3, [r3, #56]
 2164 007c BB61     		str	r3, [r7, #24]
1605:Lib/FreeRTOS/Source/queue.c **** 
1606:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1607:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1608:Lib/FreeRTOS/Source/queue.c ****             if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 2165              		.loc 1 1608 15
 2166 007e BB69     		ldr	r3, [r7, #24]
 2167 0080 002B     		cmp	r3, #0
 2168 0082 1ED0     		beq	.L167
1609:Lib/FreeRTOS/Source/queue.c ****             {
1610:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE( pxQueue );
1611:Lib/FreeRTOS/Source/queue.c **** 
1612:Lib/FreeRTOS/Source/queue.c ****                 /* Semaphores are queues with a data size of zero and where the
1613:Lib/FreeRTOS/Source/queue.c ****                  * messages waiting is the semaphore's count.  Reduce the count. */
1614:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 2169              		.loc 1 1614 63
ARM GAS  /tmp/cchrzcnP.s 			page 67


 2170 0084 BB69     		ldr	r3, [r7, #24]
 2171 0086 5A1E     		subs	r2, r3, #1
 2172              		.loc 1 1614 44
 2173 0088 FB69     		ldr	r3, [r7, #28]
 2174 008a 9A63     		str	r2, [r3, #56]
1615:Lib/FreeRTOS/Source/queue.c **** 
1616:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1617:Lib/FreeRTOS/Source/queue.c ****                 {
1618:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2175              		.loc 1 1618 32
 2176 008c FB69     		ldr	r3, [r7, #28]
 2177 008e 1B68     		ldr	r3, [r3]
 2178              		.loc 1 1618 23
 2179 0090 002B     		cmp	r3, #0
 2180 0092 04D1     		bne	.L168
1619:Lib/FreeRTOS/Source/queue.c ****                     {
1620:Lib/FreeRTOS/Source/queue.c ****                         /* Record the information required to implement
1621:Lib/FreeRTOS/Source/queue.c ****                          * priority inheritance should it become necessary. */
1622:Lib/FreeRTOS/Source/queue.c ****                         pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 2181              		.loc 1 1622 62
 2182 0094 FFF7FEFF 		bl	pvTaskIncrementMutexHeldCount
 2183 0098 0246     		mov	r2, r0
 2184              		.loc 1 1622 60 discriminator 1
 2185 009a FB69     		ldr	r3, [r7, #28]
 2186 009c 9A60     		str	r2, [r3, #8]
 2187              	.L168:
1623:Lib/FreeRTOS/Source/queue.c ****                     }
1624:Lib/FreeRTOS/Source/queue.c ****                     else
1625:Lib/FreeRTOS/Source/queue.c ****                     {
1626:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1627:Lib/FreeRTOS/Source/queue.c ****                     }
1628:Lib/FreeRTOS/Source/queue.c ****                 }
1629:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
1630:Lib/FreeRTOS/Source/queue.c **** 
1631:Lib/FreeRTOS/Source/queue.c ****                 /* Check to see if other tasks are blocked waiting to give the
1632:Lib/FreeRTOS/Source/queue.c ****                  * semaphore, and if so, unblock the highest priority such task. */
1633:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2188              		.loc 1 1633 21
 2189 009e FB69     		ldr	r3, [r7, #28]
 2190 00a0 1B69     		ldr	r3, [r3, #16]
 2191              		.loc 1 1633 19
 2192 00a2 002B     		cmp	r3, #0
 2193 00a4 09D0     		beq	.L169
1634:Lib/FreeRTOS/Source/queue.c ****                 {
1635:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2194              		.loc 1 1635 51
 2195 00a6 FB69     		ldr	r3, [r7, #28]
 2196 00a8 1033     		adds	r3, r3, #16
 2197              		.loc 1 1635 25
 2198 00aa 1846     		mov	r0, r3
 2199 00ac FFF7FEFF 		bl	xTaskRemoveFromEventList
 2200 00b0 0346     		mov	r3, r0
 2201              		.loc 1 1635 23 discriminator 1
 2202 00b2 002B     		cmp	r3, #0
 2203 00b4 01D0     		beq	.L169
1636:Lib/FreeRTOS/Source/queue.c ****                     {
1637:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
ARM GAS  /tmp/cchrzcnP.s 			page 68


 2204              		.loc 1 1637 25
 2205 00b6 FFF7FEFF 		bl	vPortYield
 2206              	.L169:
1638:Lib/FreeRTOS/Source/queue.c ****                     }
1639:Lib/FreeRTOS/Source/queue.c ****                     else
1640:Lib/FreeRTOS/Source/queue.c ****                     {
1641:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1642:Lib/FreeRTOS/Source/queue.c ****                     }
1643:Lib/FreeRTOS/Source/queue.c ****                 }
1644:Lib/FreeRTOS/Source/queue.c ****                 else
1645:Lib/FreeRTOS/Source/queue.c ****                 {
1646:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1647:Lib/FreeRTOS/Source/queue.c ****                 }
1648:Lib/FreeRTOS/Source/queue.c **** 
1649:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
 2207              		.loc 1 1649 17
 2208 00ba FFF7FEFF 		bl	vPortExitCritical
1650:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 2209              		.loc 1 1650 24
 2210 00be 0123     		movs	r3, #1
 2211 00c0 83E0     		b	.L180
 2212              	.L167:
1651:Lib/FreeRTOS/Source/queue.c ****             }
1652:Lib/FreeRTOS/Source/queue.c ****             else
1653:Lib/FreeRTOS/Source/queue.c ****             {
1654:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 2213              		.loc 1 1654 34
 2214 00c2 3B68     		ldr	r3, [r7]
 2215              		.loc 1 1654 19
 2216 00c4 002B     		cmp	r3, #0
 2217 00c6 03D1     		bne	.L171
1655:Lib/FreeRTOS/Source/queue.c ****                 {
1656:Lib/FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and no block time is specified
1657:Lib/FreeRTOS/Source/queue.c ****                      * (or the block time has expired) so exit now. */
1658:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
 2218              		.loc 1 1658 21
 2219 00c8 FFF7FEFF 		bl	vPortExitCritical
1659:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_RECEIVE_FAILED( pxQueue );
1660:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
 2220              		.loc 1 1660 28
 2221 00cc 0023     		movs	r3, #0
 2222 00ce 7CE0     		b	.L180
 2223              	.L171:
1661:Lib/FreeRTOS/Source/queue.c ****                 }
1662:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 2224              		.loc 1 1662 24
 2225 00d0 7B6A     		ldr	r3, [r7, #36]
 2226 00d2 002B     		cmp	r3, #0
 2227 00d4 06D1     		bne	.L172
1663:Lib/FreeRTOS/Source/queue.c ****                 {
1664:Lib/FreeRTOS/Source/queue.c ****                     /* The semaphore count was 0 and a block time was specified
1665:Lib/FreeRTOS/Source/queue.c ****                      * so configure the timeout structure ready to block. */
1666:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 2228              		.loc 1 1666 21
 2229 00d6 07F10C03 		add	r3, r7, #12
 2230 00da 1846     		mov	r0, r3
 2231 00dc FFF7FEFF 		bl	vTaskInternalSetTimeOutState
ARM GAS  /tmp/cchrzcnP.s 			page 69


1667:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2232              		.loc 1 1667 35
 2233 00e0 0123     		movs	r3, #1
 2234 00e2 7B62     		str	r3, [r7, #36]
 2235              	.L172:
 2236              	.LBE9:
1668:Lib/FreeRTOS/Source/queue.c ****                 }
1669:Lib/FreeRTOS/Source/queue.c ****                 else
1670:Lib/FreeRTOS/Source/queue.c ****                 {
1671:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1672:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1673:Lib/FreeRTOS/Source/queue.c ****                 }
1674:Lib/FreeRTOS/Source/queue.c ****             }
1675:Lib/FreeRTOS/Source/queue.c ****         }
1676:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 2237              		.loc 1 1676 9
 2238 00e4 FFF7FEFF 		bl	vPortExitCritical
1677:Lib/FreeRTOS/Source/queue.c **** 
1678:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can give to and take from the semaphore
1679:Lib/FreeRTOS/Source/queue.c ****          * now the critical section has been exited. */
1680:Lib/FreeRTOS/Source/queue.c **** 
1681:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
 2239              		.loc 1 1681 9
 2240 00e8 FFF7FEFF 		bl	vTaskSuspendAll
1682:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2241              		.loc 1 1682 9
 2242 00ec FFF7FEFF 		bl	vPortEnterCritical
 2243              		.loc 1 1682 9 is_stmt 0 discriminator 1
 2244 00f0 FB69     		ldr	r3, [r7, #28]
 2245 00f2 93F84430 		ldrb	r3, [r3, #68]
 2246 00f6 5BB2     		sxtb	r3, r3
 2247 00f8 B3F1FF3F 		cmp	r3, #-1
 2248 00fc 03D1     		bne	.L173
 2249 00fe FB69     		ldr	r3, [r7, #28]
 2250 0100 0022     		movs	r2, #0
 2251 0102 83F84420 		strb	r2, [r3, #68]
 2252              	.L173:
 2253              		.loc 1 1682 9 discriminator 3
 2254 0106 FB69     		ldr	r3, [r7, #28]
 2255 0108 93F84530 		ldrb	r3, [r3, #69]
 2256 010c 5BB2     		sxtb	r3, r3
 2257 010e B3F1FF3F 		cmp	r3, #-1
 2258 0112 03D1     		bne	.L174
 2259              		.loc 1 1682 9 discriminator 4
 2260 0114 FB69     		ldr	r3, [r7, #28]
 2261 0116 0022     		movs	r2, #0
 2262 0118 83F84520 		strb	r2, [r3, #69]
 2263              	.L174:
 2264              		.loc 1 1682 9 discriminator 6
 2265 011c FFF7FEFF 		bl	vPortExitCritical
1683:Lib/FreeRTOS/Source/queue.c **** 
1684:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1685:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2266              		.loc 1 1685 13 is_stmt 1
 2267 0120 3A46     		mov	r2, r7
 2268 0122 07F10C03 		add	r3, r7, #12
 2269 0126 1146     		mov	r1, r2
ARM GAS  /tmp/cchrzcnP.s 			page 70


 2270 0128 1846     		mov	r0, r3
 2271 012a FFF7FEFF 		bl	xTaskCheckForTimeOut
 2272 012e 0346     		mov	r3, r0
 2273              		.loc 1 1685 11 discriminator 1
 2274 0130 002B     		cmp	r3, #0
 2275 0132 2CD1     		bne	.L175
1686:Lib/FreeRTOS/Source/queue.c ****         {
1687:Lib/FreeRTOS/Source/queue.c ****             /* A block time is specified and not expired.  If the semaphore
1688:Lib/FreeRTOS/Source/queue.c ****              * count is 0 then enter the Blocked state to wait for a semaphore to
1689:Lib/FreeRTOS/Source/queue.c ****              * become available.  As semaphores are implemented with queues the
1690:Lib/FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1691:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2276              		.loc 1 1691 17
 2277 0134 F869     		ldr	r0, [r7, #28]
 2278 0136 FFF7FEFF 		bl	prvIsQueueEmpty
 2279 013a 0346     		mov	r3, r0
 2280              		.loc 1 1691 15 discriminator 1
 2281 013c 002B     		cmp	r3, #0
 2282 013e 20D0     		beq	.L176
1692:Lib/FreeRTOS/Source/queue.c ****             {
1693:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1694:Lib/FreeRTOS/Source/queue.c **** 
1695:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1696:Lib/FreeRTOS/Source/queue.c ****                 {
1697:Lib/FreeRTOS/Source/queue.c ****                     if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 2283              		.loc 1 1697 32
 2284 0140 FB69     		ldr	r3, [r7, #28]
 2285 0142 1B68     		ldr	r3, [r3]
 2286              		.loc 1 1697 23
 2287 0144 002B     		cmp	r3, #0
 2288 0146 09D1     		bne	.L177
1698:Lib/FreeRTOS/Source/queue.c ****                     {
1699:Lib/FreeRTOS/Source/queue.c ****                         taskENTER_CRITICAL();
 2289              		.loc 1 1699 25
 2290 0148 FFF7FEFF 		bl	vPortEnterCritical
1700:Lib/FreeRTOS/Source/queue.c ****                         {
1701:Lib/FreeRTOS/Source/queue.c ****                             xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMut
 2291              		.loc 1 1701 52
 2292 014c FB69     		ldr	r3, [r7, #28]
 2293 014e 9B68     		ldr	r3, [r3, #8]
 2294 0150 1846     		mov	r0, r3
 2295 0152 FFF7FEFF 		bl	xTaskPriorityInherit
 2296 0156 3862     		str	r0, [r7, #32]
1702:Lib/FreeRTOS/Source/queue.c ****                         }
1703:Lib/FreeRTOS/Source/queue.c ****                         taskEXIT_CRITICAL();
 2297              		.loc 1 1703 25
 2298 0158 FFF7FEFF 		bl	vPortExitCritical
 2299              	.L177:
1704:Lib/FreeRTOS/Source/queue.c ****                     }
1705:Lib/FreeRTOS/Source/queue.c ****                     else
1706:Lib/FreeRTOS/Source/queue.c ****                     {
1707:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1708:Lib/FreeRTOS/Source/queue.c ****                     }
1709:Lib/FreeRTOS/Source/queue.c ****                 }
1710:Lib/FreeRTOS/Source/queue.c ****                 #endif /* if ( configUSE_MUTEXES == 1 ) */
1711:Lib/FreeRTOS/Source/queue.c **** 
1712:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
ARM GAS  /tmp/cchrzcnP.s 			page 71


 2300              		.loc 1 1712 17
 2301 015c FB69     		ldr	r3, [r7, #28]
 2302 015e 2433     		adds	r3, r3, #36
 2303 0160 3A68     		ldr	r2, [r7]
 2304 0162 1146     		mov	r1, r2
 2305 0164 1846     		mov	r0, r3
 2306 0166 FFF7FEFF 		bl	vTaskPlaceOnEventList
1713:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2307              		.loc 1 1713 17
 2308 016a F869     		ldr	r0, [r7, #28]
 2309 016c FFF7FEFF 		bl	prvUnlockQueue
1714:Lib/FreeRTOS/Source/queue.c **** 
1715:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 2310              		.loc 1 1715 21
 2311 0170 FFF7FEFF 		bl	xTaskResumeAll
 2312 0174 0346     		mov	r3, r0
 2313              		.loc 1 1715 19 discriminator 1
 2314 0176 002B     		cmp	r3, #0
 2315 0178 7FF47CAF 		bne	.L166
1716:Lib/FreeRTOS/Source/queue.c ****                 {
1717:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
 2316              		.loc 1 1717 21
 2317 017c FFF7FEFF 		bl	vPortYield
 2318 0180 78E7     		b	.L166
 2319              	.L176:
1718:Lib/FreeRTOS/Source/queue.c ****                 }
1719:Lib/FreeRTOS/Source/queue.c ****                 else
1720:Lib/FreeRTOS/Source/queue.c ****                 {
1721:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1722:Lib/FreeRTOS/Source/queue.c ****                 }
1723:Lib/FreeRTOS/Source/queue.c ****             }
1724:Lib/FreeRTOS/Source/queue.c ****             else
1725:Lib/FreeRTOS/Source/queue.c ****             {
1726:Lib/FreeRTOS/Source/queue.c ****                 /* There was no timeout and the semaphore count was not 0, so
1727:Lib/FreeRTOS/Source/queue.c ****                  * attempt to take the semaphore again. */
1728:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2320              		.loc 1 1728 17
 2321 0182 F869     		ldr	r0, [r7, #28]
 2322 0184 FFF7FEFF 		bl	prvUnlockQueue
1729:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2323              		.loc 1 1729 26
 2324 0188 FFF7FEFF 		bl	xTaskResumeAll
 2325 018c 72E7     		b	.L166
 2326              	.L175:
1730:Lib/FreeRTOS/Source/queue.c ****             }
1731:Lib/FreeRTOS/Source/queue.c ****         }
1732:Lib/FreeRTOS/Source/queue.c ****         else
1733:Lib/FreeRTOS/Source/queue.c ****         {
1734:Lib/FreeRTOS/Source/queue.c ****             /* Timed out. */
1735:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
 2327              		.loc 1 1735 13
 2328 018e F869     		ldr	r0, [r7, #28]
 2329 0190 FFF7FEFF 		bl	prvUnlockQueue
1736:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2330              		.loc 1 1736 22
 2331 0194 FFF7FEFF 		bl	xTaskResumeAll
1737:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 72


1738:Lib/FreeRTOS/Source/queue.c ****             /* If the semaphore count is 0 exit now as the timeout has
1739:Lib/FreeRTOS/Source/queue.c ****              * expired.  Otherwise return to attempt to take the semaphore that is
1740:Lib/FreeRTOS/Source/queue.c ****              * known to be available.  As semaphores are implemented by queues the
1741:Lib/FreeRTOS/Source/queue.c ****              * queue being empty is equivalent to the semaphore count being 0. */
1742:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2332              		.loc 1 1742 17
 2333 0198 F869     		ldr	r0, [r7, #28]
 2334 019a FFF7FEFF 		bl	prvIsQueueEmpty
 2335 019e 0346     		mov	r3, r0
 2336              		.loc 1 1742 15 discriminator 1
 2337 01a0 002B     		cmp	r3, #0
 2338 01a2 3FF467AF 		beq	.L166
1743:Lib/FreeRTOS/Source/queue.c ****             {
1744:Lib/FreeRTOS/Source/queue.c ****                 #if ( configUSE_MUTEXES == 1 )
1745:Lib/FreeRTOS/Source/queue.c ****                 {
1746:Lib/FreeRTOS/Source/queue.c ****                     /* xInheritanceOccurred could only have be set if
1747:Lib/FreeRTOS/Source/queue.c ****                      * pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
1748:Lib/FreeRTOS/Source/queue.c ****                      * test the mutex type again to check it is actually a mutex. */
1749:Lib/FreeRTOS/Source/queue.c ****                     if( xInheritanceOccurred != pdFALSE )
 2339              		.loc 1 1749 23
 2340 01a6 3B6A     		ldr	r3, [r7, #32]
 2341 01a8 002B     		cmp	r3, #0
 2342 01aa 0DD0     		beq	.L179
1750:Lib/FreeRTOS/Source/queue.c ****                     {
1751:Lib/FreeRTOS/Source/queue.c ****                         taskENTER_CRITICAL();
 2343              		.loc 1 1751 25
 2344 01ac FFF7FEFF 		bl	vPortEnterCritical
 2345              	.LBB10:
1752:Lib/FreeRTOS/Source/queue.c ****                         {
1753:Lib/FreeRTOS/Source/queue.c ****                             UBaseType_t uxHighestWaitingPriority;
1754:Lib/FreeRTOS/Source/queue.c **** 
1755:Lib/FreeRTOS/Source/queue.c ****                             /* This task blocking on the mutex caused another
1756:Lib/FreeRTOS/Source/queue.c ****                              * task to inherit this task's priority.  Now this task
1757:Lib/FreeRTOS/Source/queue.c ****                              * has timed out the priority should be disinherited
1758:Lib/FreeRTOS/Source/queue.c ****                              * again, but only as low as the next highest priority
1759:Lib/FreeRTOS/Source/queue.c ****                              * task that is waiting for the same mutex. */
1760:Lib/FreeRTOS/Source/queue.c ****                             uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueu
 2346              		.loc 1 1760 56
 2347 01b0 F869     		ldr	r0, [r7, #28]
 2348 01b2 FFF7FEFF 		bl	prvGetDisinheritPriorityAfterTimeout
 2349 01b6 7861     		str	r0, [r7, #20]
1761:Lib/FreeRTOS/Source/queue.c ****                             vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder
 2350              		.loc 1 1761 29
 2351 01b8 FB69     		ldr	r3, [r7, #28]
 2352 01ba 9B68     		ldr	r3, [r3, #8]
 2353 01bc 7969     		ldr	r1, [r7, #20]
 2354 01be 1846     		mov	r0, r3
 2355 01c0 FFF7FEFF 		bl	vTaskPriorityDisinheritAfterTimeout
 2356              	.LBE10:
1762:Lib/FreeRTOS/Source/queue.c ****                         }
1763:Lib/FreeRTOS/Source/queue.c ****                         taskEXIT_CRITICAL();
 2357              		.loc 1 1763 25
 2358 01c4 FFF7FEFF 		bl	vPortExitCritical
 2359              	.L179:
1764:Lib/FreeRTOS/Source/queue.c ****                     }
1765:Lib/FreeRTOS/Source/queue.c ****                 }
1766:Lib/FreeRTOS/Source/queue.c ****                 #endif /* configUSE_MUTEXES */
ARM GAS  /tmp/cchrzcnP.s 			page 73


1767:Lib/FreeRTOS/Source/queue.c **** 
1768:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_RECEIVE_FAILED( pxQueue );
1769:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
 2360              		.loc 1 1769 24
 2361 01c8 0023     		movs	r3, #0
 2362              	.L180:
1770:Lib/FreeRTOS/Source/queue.c ****             }
1771:Lib/FreeRTOS/Source/queue.c ****             else
1772:Lib/FreeRTOS/Source/queue.c ****             {
1773:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1774:Lib/FreeRTOS/Source/queue.c ****             }
1775:Lib/FreeRTOS/Source/queue.c ****         }
1776:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1777:Lib/FreeRTOS/Source/queue.c **** }
 2363              		.loc 1 1777 1
 2364 01ca 1846     		mov	r0, r3
 2365 01cc 2837     		adds	r7, r7, #40
 2366              		.cfi_def_cfa_offset 8
 2367 01ce BD46     		mov	sp, r7
 2368              		.cfi_def_cfa_register 13
 2369              		@ sp needed
 2370 01d0 80BD     		pop	{r7, pc}
 2371              	.L182:
 2372 01d2 00BF     		.align	2
 2373              	.L181:
 2374 01d4 00000000 		.word	.LC0
 2375 01d8 00000000 		.word	__func__.12
 2376 01dc 04000000 		.word	.LC1
 2377              		.cfi_endproc
 2378              	.LFE15:
 2380              		.section	.text.xQueuePeek,"ax",%progbits
 2381              		.align	1
 2382              		.global	xQueuePeek
 2383              		.syntax unified
 2384              		.thumb
 2385              		.thumb_func
 2387              	xQueuePeek:
 2388              	.LFB16:
1778:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1779:Lib/FreeRTOS/Source/queue.c **** 
1780:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeek( QueueHandle_t xQueue,
1781:Lib/FreeRTOS/Source/queue.c ****                        void * const pvBuffer,
1782:Lib/FreeRTOS/Source/queue.c ****                        TickType_t xTicksToWait )
1783:Lib/FreeRTOS/Source/queue.c **** {
 2389              		.loc 1 1783 1
 2390              		.cfi_startproc
 2391              		@ args = 0, pretend = 0, frame = 40
 2392              		@ frame_needed = 1, uses_anonymous_args = 0
 2393 0000 80B5     		push	{r7, lr}
 2394              		.cfi_def_cfa_offset 8
 2395              		.cfi_offset 7, -8
 2396              		.cfi_offset 14, -4
 2397 0002 8AB0     		sub	sp, sp, #40
 2398              		.cfi_def_cfa_offset 48
 2399 0004 00AF     		add	r7, sp, #0
 2400              		.cfi_def_cfa_register 7
 2401 0006 F860     		str	r0, [r7, #12]
ARM GAS  /tmp/cchrzcnP.s 			page 74


 2402 0008 B960     		str	r1, [r7, #8]
 2403 000a 7A60     		str	r2, [r7, #4]
1784:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xEntryTimeSet = pdFALSE;
 2404              		.loc 1 1784 16
 2405 000c 0023     		movs	r3, #0
 2406 000e 7B62     		str	r3, [r7, #36]
1785:Lib/FreeRTOS/Source/queue.c ****     TimeOut_t xTimeOut;
1786:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
1787:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2407              		.loc 1 1787 21
 2408 0010 FB68     		ldr	r3, [r7, #12]
 2409 0012 3B62     		str	r3, [r7, #32]
1788:Lib/FreeRTOS/Source/queue.c **** 
1789:Lib/FreeRTOS/Source/queue.c ****     /* Check the pointer is not NULL. */
1790:Lib/FreeRTOS/Source/queue.c ****     configASSERT( ( pxQueue ) );
 2410              		.loc 1 1790 5
 2411 0014 3B6A     		ldr	r3, [r7, #32]
 2412 0016 002B     		cmp	r3, #0
 2413 0018 08D1     		bne	.L184
 2414              		.loc 1 1790 5 is_stmt 0 discriminator 1
 2415 001a FFF7FEFF 		bl	ulSetInterruptMask
 2416 001e 5F4B     		ldr	r3, .L204
 2417 0020 5F4A     		ldr	r2, .L204+4
 2418 0022 40F2FE61 		movw	r1, #1790
 2419 0026 5F48     		ldr	r0, .L204+8
 2420 0028 FFF7FEFF 		bl	__assert_func
 2421              	.L184:
1791:Lib/FreeRTOS/Source/queue.c **** 
1792:Lib/FreeRTOS/Source/queue.c ****     /* The buffer into which data is received can only be NULL if the data size
1793:Lib/FreeRTOS/Source/queue.c ****      * is zero (so no data is copied into the buffer. */
1794:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) 
 2422              		.loc 1 1794 5 is_stmt 1
 2423 002c BB68     		ldr	r3, [r7, #8]
 2424 002e 002B     		cmp	r3, #0
 2425 0030 03D1     		bne	.L185
 2426              		.loc 1 1794 5 is_stmt 0 discriminator 2
 2427 0032 3B6A     		ldr	r3, [r7, #32]
 2428 0034 1B6C     		ldr	r3, [r3, #64]
 2429 0036 002B     		cmp	r3, #0
 2430 0038 01D1     		bne	.L186
 2431              	.L185:
 2432              		.loc 1 1794 5 discriminator 3
 2433 003a 0123     		movs	r3, #1
 2434              		.loc 1 1794 5
 2435 003c 00E0     		b	.L187
 2436              	.L186:
 2437              		.loc 1 1794 5 discriminator 4
 2438 003e 0023     		movs	r3, #0
 2439              	.L187:
 2440              		.loc 1 1794 5 discriminator 6
 2441 0040 002B     		cmp	r3, #0
 2442 0042 08D1     		bne	.L188
 2443              		.loc 1 1794 5 discriminator 7
 2444 0044 FFF7FEFF 		bl	ulSetInterruptMask
 2445              		.loc 1 1794 5 discriminator 1
 2446 0048 544B     		ldr	r3, .L204
 2447 004a 554A     		ldr	r2, .L204+4
ARM GAS  /tmp/cchrzcnP.s 			page 75


 2448 004c 40F20271 		movw	r1, #1794
 2449 0050 5448     		ldr	r0, .L204+8
 2450 0052 FFF7FEFF 		bl	__assert_func
 2451              	.L188:
1795:Lib/FreeRTOS/Source/queue.c **** 
1796:Lib/FreeRTOS/Source/queue.c ****     /* Cannot block if the scheduler is suspended. */
1797:Lib/FreeRTOS/Source/queue.c ****     #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1798:Lib/FreeRTOS/Source/queue.c ****     {
1799:Lib/FreeRTOS/Source/queue.c ****         configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait 
 2452              		.loc 1 1799 9 is_stmt 1
 2453 0056 FFF7FEFF 		bl	xTaskGetSchedulerState
 2454 005a 0346     		mov	r3, r0
 2455              		.loc 1 1799 9 is_stmt 0 discriminator 1
 2456 005c 002B     		cmp	r3, #0
 2457 005e 02D1     		bne	.L189
 2458              		.loc 1 1799 9 discriminator 2
 2459 0060 7B68     		ldr	r3, [r7, #4]
 2460 0062 002B     		cmp	r3, #0
 2461 0064 01D1     		bne	.L190
 2462              	.L189:
 2463              		.loc 1 1799 9 discriminator 3
 2464 0066 0123     		movs	r3, #1
 2465              		.loc 1 1799 9
 2466 0068 00E0     		b	.L191
 2467              	.L190:
 2468              		.loc 1 1799 9 discriminator 4
 2469 006a 0023     		movs	r3, #0
 2470              	.L191:
 2471              		.loc 1 1799 9 discriminator 6
 2472 006c 002B     		cmp	r3, #0
 2473 006e 08D1     		bne	.L192
 2474              		.loc 1 1799 9 discriminator 7
 2475 0070 FFF7FEFF 		bl	ulSetInterruptMask
 2476              		.loc 1 1799 9 discriminator 1
 2477 0074 494B     		ldr	r3, .L204
 2478 0076 4A4A     		ldr	r2, .L204+4
 2479 0078 40F20771 		movw	r1, #1799
 2480 007c 4948     		ldr	r0, .L204+8
 2481 007e FFF7FEFF 		bl	__assert_func
 2482              	.L192:
1800:Lib/FreeRTOS/Source/queue.c ****     }
1801:Lib/FreeRTOS/Source/queue.c ****     #endif
1802:Lib/FreeRTOS/Source/queue.c **** 
1803:Lib/FreeRTOS/Source/queue.c ****     /*lint -save -e904  This function relaxes the coding standard somewhat to
1804:Lib/FreeRTOS/Source/queue.c ****      * allow return statements within the function itself.  This is done in the
1805:Lib/FreeRTOS/Source/queue.c ****      * interest of execution time efficiency. */
1806:Lib/FreeRTOS/Source/queue.c ****     for( ; ; )
1807:Lib/FreeRTOS/Source/queue.c ****     {
1808:Lib/FreeRTOS/Source/queue.c ****         taskENTER_CRITICAL();
 2483              		.loc 1 1808 9 is_stmt 1
 2484 0082 FFF7FEFF 		bl	vPortEnterCritical
 2485              	.LBB11:
1809:Lib/FreeRTOS/Source/queue.c ****         {
1810:Lib/FreeRTOS/Source/queue.c ****             const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2486              		.loc 1 1810 31
 2487 0086 3B6A     		ldr	r3, [r7, #32]
 2488 0088 9B6B     		ldr	r3, [r3, #56]
ARM GAS  /tmp/cchrzcnP.s 			page 76


 2489 008a FB61     		str	r3, [r7, #28]
1811:Lib/FreeRTOS/Source/queue.c **** 
1812:Lib/FreeRTOS/Source/queue.c ****             /* Is there data in the queue now?  To be running the calling task
1813:Lib/FreeRTOS/Source/queue.c ****              * must be the highest priority task wanting to access the queue. */
1814:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2490              		.loc 1 1814 15
 2491 008c FB69     		ldr	r3, [r7, #28]
 2492 008e 002B     		cmp	r3, #0
 2493 0090 1BD0     		beq	.L193
1815:Lib/FreeRTOS/Source/queue.c ****             {
1816:Lib/FreeRTOS/Source/queue.c ****                 /* Remember the read position so it can be reset after the data
1817:Lib/FreeRTOS/Source/queue.c ****                  * is read from the queue as this function is only peeking the
1818:Lib/FreeRTOS/Source/queue.c ****                  * data, not removing it. */
1819:Lib/FreeRTOS/Source/queue.c ****                 pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 2494              		.loc 1 1819 40
 2495 0092 3B6A     		ldr	r3, [r7, #32]
 2496 0094 DB68     		ldr	r3, [r3, #12]
 2497 0096 BB61     		str	r3, [r7, #24]
1820:Lib/FreeRTOS/Source/queue.c **** 
1821:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataFromQueue( pxQueue, pvBuffer );
 2498              		.loc 1 1821 17
 2499 0098 B968     		ldr	r1, [r7, #8]
 2500 009a 386A     		ldr	r0, [r7, #32]
 2501 009c FFF7FEFF 		bl	prvCopyDataFromQueue
1822:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK( pxQueue );
1823:Lib/FreeRTOS/Source/queue.c **** 
1824:Lib/FreeRTOS/Source/queue.c ****                 /* The data is not being removed, so reset the read pointer. */
1825:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2502              		.loc 1 1825 46
 2503 00a0 3B6A     		ldr	r3, [r7, #32]
 2504 00a2 BA69     		ldr	r2, [r7, #24]
 2505 00a4 DA60     		str	r2, [r3, #12]
1826:Lib/FreeRTOS/Source/queue.c **** 
1827:Lib/FreeRTOS/Source/queue.c ****                 /* The data is being left in the queue, so see if there are
1828:Lib/FreeRTOS/Source/queue.c ****                  * any other tasks waiting for the data. */
1829:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 2506              		.loc 1 1829 21
 2507 00a6 3B6A     		ldr	r3, [r7, #32]
 2508 00a8 5B6A     		ldr	r3, [r3, #36]
 2509              		.loc 1 1829 19
 2510 00aa 002B     		cmp	r3, #0
 2511 00ac 09D0     		beq	.L194
1830:Lib/FreeRTOS/Source/queue.c ****                 {
1831:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
 2512              		.loc 1 1831 51
 2513 00ae 3B6A     		ldr	r3, [r7, #32]
 2514 00b0 2433     		adds	r3, r3, #36
 2515              		.loc 1 1831 25
 2516 00b2 1846     		mov	r0, r3
 2517 00b4 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2518 00b8 0346     		mov	r3, r0
 2519              		.loc 1 1831 23 discriminator 1
 2520 00ba 002B     		cmp	r3, #0
 2521 00bc 01D0     		beq	.L194
1832:Lib/FreeRTOS/Source/queue.c ****                     {
1833:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than this task. */
1834:Lib/FreeRTOS/Source/queue.c ****                         queueYIELD_IF_USING_PREEMPTION();
ARM GAS  /tmp/cchrzcnP.s 			page 77


 2522              		.loc 1 1834 25
 2523 00be FFF7FEFF 		bl	vPortYield
 2524              	.L194:
1835:Lib/FreeRTOS/Source/queue.c ****                     }
1836:Lib/FreeRTOS/Source/queue.c ****                     else
1837:Lib/FreeRTOS/Source/queue.c ****                     {
1838:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1839:Lib/FreeRTOS/Source/queue.c ****                     }
1840:Lib/FreeRTOS/Source/queue.c ****                 }
1841:Lib/FreeRTOS/Source/queue.c ****                 else
1842:Lib/FreeRTOS/Source/queue.c ****                 {
1843:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1844:Lib/FreeRTOS/Source/queue.c ****                 }
1845:Lib/FreeRTOS/Source/queue.c **** 
1846:Lib/FreeRTOS/Source/queue.c ****                 taskEXIT_CRITICAL();
 2525              		.loc 1 1846 17
 2526 00c2 FFF7FEFF 		bl	vPortExitCritical
1847:Lib/FreeRTOS/Source/queue.c ****                 return pdPASS;
 2527              		.loc 1 1847 24
 2528 00c6 0123     		movs	r3, #1
 2529 00c8 63E0     		b	.L203
 2530              	.L193:
1848:Lib/FreeRTOS/Source/queue.c ****             }
1849:Lib/FreeRTOS/Source/queue.c ****             else
1850:Lib/FreeRTOS/Source/queue.c ****             {
1851:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait == ( TickType_t ) 0 )
 2531              		.loc 1 1851 34
 2532 00ca 7B68     		ldr	r3, [r7, #4]
 2533              		.loc 1 1851 19
 2534 00cc 002B     		cmp	r3, #0
 2535 00ce 03D1     		bne	.L196
1852:Lib/FreeRTOS/Source/queue.c ****                 {
1853:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and no block time is specified (or
1854:Lib/FreeRTOS/Source/queue.c ****                      * the block time has expired) so leave now. */
1855:Lib/FreeRTOS/Source/queue.c ****                     taskEXIT_CRITICAL();
 2536              		.loc 1 1855 21
 2537 00d0 FFF7FEFF 		bl	vPortExitCritical
1856:Lib/FreeRTOS/Source/queue.c ****                     traceQUEUE_PEEK_FAILED( pxQueue );
1857:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_EMPTY;
 2538              		.loc 1 1857 28
 2539 00d4 0023     		movs	r3, #0
 2540 00d6 5CE0     		b	.L203
 2541              	.L196:
1858:Lib/FreeRTOS/Source/queue.c ****                 }
1859:Lib/FreeRTOS/Source/queue.c ****                 else if( xEntryTimeSet == pdFALSE )
 2542              		.loc 1 1859 24
 2543 00d8 7B6A     		ldr	r3, [r7, #36]
 2544 00da 002B     		cmp	r3, #0
 2545 00dc 06D1     		bne	.L197
1860:Lib/FreeRTOS/Source/queue.c ****                 {
1861:Lib/FreeRTOS/Source/queue.c ****                     /* The queue was empty and a block time was specified so
1862:Lib/FreeRTOS/Source/queue.c ****                      * configure the timeout structure ready to enter the blocked
1863:Lib/FreeRTOS/Source/queue.c ****                      * state. */
1864:Lib/FreeRTOS/Source/queue.c ****                     vTaskInternalSetTimeOutState( &xTimeOut );
 2546              		.loc 1 1864 21
 2547 00de 07F11003 		add	r3, r7, #16
 2548 00e2 1846     		mov	r0, r3
ARM GAS  /tmp/cchrzcnP.s 			page 78


 2549 00e4 FFF7FEFF 		bl	vTaskInternalSetTimeOutState
1865:Lib/FreeRTOS/Source/queue.c ****                     xEntryTimeSet = pdTRUE;
 2550              		.loc 1 1865 35
 2551 00e8 0123     		movs	r3, #1
 2552 00ea 7B62     		str	r3, [r7, #36]
 2553              	.L197:
 2554              	.LBE11:
1866:Lib/FreeRTOS/Source/queue.c ****                 }
1867:Lib/FreeRTOS/Source/queue.c ****                 else
1868:Lib/FreeRTOS/Source/queue.c ****                 {
1869:Lib/FreeRTOS/Source/queue.c ****                     /* Entry time was already set. */
1870:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1871:Lib/FreeRTOS/Source/queue.c ****                 }
1872:Lib/FreeRTOS/Source/queue.c ****             }
1873:Lib/FreeRTOS/Source/queue.c ****         }
1874:Lib/FreeRTOS/Source/queue.c ****         taskEXIT_CRITICAL();
 2555              		.loc 1 1874 9
 2556 00ec FFF7FEFF 		bl	vPortExitCritical
1875:Lib/FreeRTOS/Source/queue.c **** 
1876:Lib/FreeRTOS/Source/queue.c ****         /* Interrupts and other tasks can send to and receive from the queue
1877:Lib/FreeRTOS/Source/queue.c ****          * now that the critical section has been exited. */
1878:Lib/FreeRTOS/Source/queue.c **** 
1879:Lib/FreeRTOS/Source/queue.c ****         vTaskSuspendAll();
 2557              		.loc 1 1879 9
 2558 00f0 FFF7FEFF 		bl	vTaskSuspendAll
1880:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 2559              		.loc 1 1880 9
 2560 00f4 FFF7FEFF 		bl	vPortEnterCritical
 2561              		.loc 1 1880 9 is_stmt 0 discriminator 1
 2562 00f8 3B6A     		ldr	r3, [r7, #32]
 2563 00fa 93F84430 		ldrb	r3, [r3, #68]
 2564 00fe 5BB2     		sxtb	r3, r3
 2565 0100 B3F1FF3F 		cmp	r3, #-1
 2566 0104 03D1     		bne	.L198
 2567 0106 3B6A     		ldr	r3, [r7, #32]
 2568 0108 0022     		movs	r2, #0
 2569 010a 83F84420 		strb	r2, [r3, #68]
 2570              	.L198:
 2571              		.loc 1 1880 9 discriminator 3
 2572 010e 3B6A     		ldr	r3, [r7, #32]
 2573 0110 93F84530 		ldrb	r3, [r3, #69]
 2574 0114 5BB2     		sxtb	r3, r3
 2575 0116 B3F1FF3F 		cmp	r3, #-1
 2576 011a 03D1     		bne	.L199
 2577              		.loc 1 1880 9 discriminator 4
 2578 011c 3B6A     		ldr	r3, [r7, #32]
 2579 011e 0022     		movs	r2, #0
 2580 0120 83F84520 		strb	r2, [r3, #69]
 2581              	.L199:
 2582              		.loc 1 1880 9 discriminator 6
 2583 0124 FFF7FEFF 		bl	vPortExitCritical
1881:Lib/FreeRTOS/Source/queue.c **** 
1882:Lib/FreeRTOS/Source/queue.c ****         /* Update the timeout state to see if it has expired yet. */
1883:Lib/FreeRTOS/Source/queue.c ****         if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 2584              		.loc 1 1883 13 is_stmt 1
 2585 0128 3A1D     		adds	r2, r7, #4
 2586 012a 07F11003 		add	r3, r7, #16
ARM GAS  /tmp/cchrzcnP.s 			page 79


 2587 012e 1146     		mov	r1, r2
 2588 0130 1846     		mov	r0, r3
 2589 0132 FFF7FEFF 		bl	xTaskCheckForTimeOut
 2590 0136 0346     		mov	r3, r0
 2591              		.loc 1 1883 11 discriminator 1
 2592 0138 002B     		cmp	r3, #0
 2593 013a 1DD1     		bne	.L200
1884:Lib/FreeRTOS/Source/queue.c ****         {
1885:Lib/FreeRTOS/Source/queue.c ****             /* Timeout has not expired yet, check to see if there is data in the
1886:Lib/FreeRTOS/Source/queue.c ****             * queue now, and if not enter the Blocked state to wait for data. */
1887:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2594              		.loc 1 1887 17
 2595 013c 386A     		ldr	r0, [r7, #32]
 2596 013e FFF7FEFF 		bl	prvIsQueueEmpty
 2597 0142 0346     		mov	r3, r0
 2598              		.loc 1 1887 15 discriminator 1
 2599 0144 002B     		cmp	r3, #0
 2600 0146 11D0     		beq	.L201
1888:Lib/FreeRTOS/Source/queue.c ****             {
1889:Lib/FreeRTOS/Source/queue.c ****                 traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
1890:Lib/FreeRTOS/Source/queue.c ****                 vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 2601              		.loc 1 1890 17
 2602 0148 3B6A     		ldr	r3, [r7, #32]
 2603 014a 2433     		adds	r3, r3, #36
 2604 014c 7A68     		ldr	r2, [r7, #4]
 2605 014e 1146     		mov	r1, r2
 2606 0150 1846     		mov	r0, r3
 2607 0152 FFF7FEFF 		bl	vTaskPlaceOnEventList
1891:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
 2608              		.loc 1 1891 17
 2609 0156 386A     		ldr	r0, [r7, #32]
 2610 0158 FFF7FEFF 		bl	prvUnlockQueue
1892:Lib/FreeRTOS/Source/queue.c **** 
1893:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskResumeAll() == pdFALSE )
 2611              		.loc 1 1893 21
 2612 015c FFF7FEFF 		bl	xTaskResumeAll
 2613 0160 0346     		mov	r3, r0
 2614              		.loc 1 1893 19 discriminator 1
 2615 0162 002B     		cmp	r3, #0
 2616 0164 8DD1     		bne	.L192
1894:Lib/FreeRTOS/Source/queue.c ****                 {
1895:Lib/FreeRTOS/Source/queue.c ****                     portYIELD_WITHIN_API();
 2617              		.loc 1 1895 21
 2618 0166 FFF7FEFF 		bl	vPortYield
 2619 016a 8AE7     		b	.L192
 2620              	.L201:
1896:Lib/FreeRTOS/Source/queue.c ****                 }
1897:Lib/FreeRTOS/Source/queue.c ****                 else
1898:Lib/FreeRTOS/Source/queue.c ****                 {
1899:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
1900:Lib/FreeRTOS/Source/queue.c ****                 }
1901:Lib/FreeRTOS/Source/queue.c ****             }
1902:Lib/FreeRTOS/Source/queue.c ****             else
1903:Lib/FreeRTOS/Source/queue.c ****             {
1904:Lib/FreeRTOS/Source/queue.c ****                 /* There is data in the queue now, so don't enter the blocked
1905:Lib/FreeRTOS/Source/queue.c ****                  * state, instead return to try and obtain the data. */
1906:Lib/FreeRTOS/Source/queue.c ****                 prvUnlockQueue( pxQueue );
ARM GAS  /tmp/cchrzcnP.s 			page 80


 2621              		.loc 1 1906 17
 2622 016c 386A     		ldr	r0, [r7, #32]
 2623 016e FFF7FEFF 		bl	prvUnlockQueue
1907:Lib/FreeRTOS/Source/queue.c ****                 ( void ) xTaskResumeAll();
 2624              		.loc 1 1907 26
 2625 0172 FFF7FEFF 		bl	xTaskResumeAll
 2626 0176 84E7     		b	.L192
 2627              	.L200:
1908:Lib/FreeRTOS/Source/queue.c ****             }
1909:Lib/FreeRTOS/Source/queue.c ****         }
1910:Lib/FreeRTOS/Source/queue.c ****         else
1911:Lib/FreeRTOS/Source/queue.c ****         {
1912:Lib/FreeRTOS/Source/queue.c ****             /* The timeout has expired.  If there is still no data in the queue
1913:Lib/FreeRTOS/Source/queue.c ****              * exit, otherwise go back and try to read the data again. */
1914:Lib/FreeRTOS/Source/queue.c ****             prvUnlockQueue( pxQueue );
 2628              		.loc 1 1914 13
 2629 0178 386A     		ldr	r0, [r7, #32]
 2630 017a FFF7FEFF 		bl	prvUnlockQueue
1915:Lib/FreeRTOS/Source/queue.c ****             ( void ) xTaskResumeAll();
 2631              		.loc 1 1915 22
 2632 017e FFF7FEFF 		bl	xTaskResumeAll
1916:Lib/FreeRTOS/Source/queue.c **** 
1917:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 2633              		.loc 1 1917 17
 2634 0182 386A     		ldr	r0, [r7, #32]
 2635 0184 FFF7FEFF 		bl	prvIsQueueEmpty
 2636 0188 0346     		mov	r3, r0
 2637              		.loc 1 1917 15 discriminator 1
 2638 018a 002B     		cmp	r3, #0
 2639 018c 3FF479AF 		beq	.L192
1918:Lib/FreeRTOS/Source/queue.c ****             {
1919:Lib/FreeRTOS/Source/queue.c ****                 traceQUEUE_PEEK_FAILED( pxQueue );
1920:Lib/FreeRTOS/Source/queue.c ****                 return errQUEUE_EMPTY;
 2640              		.loc 1 1920 24
 2641 0190 0023     		movs	r3, #0
 2642              	.L203:
1921:Lib/FreeRTOS/Source/queue.c ****             }
1922:Lib/FreeRTOS/Source/queue.c ****             else
1923:Lib/FreeRTOS/Source/queue.c ****             {
1924:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
1925:Lib/FreeRTOS/Source/queue.c ****             }
1926:Lib/FreeRTOS/Source/queue.c ****         }
1927:Lib/FreeRTOS/Source/queue.c ****     } /*lint -restore */
1928:Lib/FreeRTOS/Source/queue.c **** }
 2643              		.loc 1 1928 1
 2644 0192 1846     		mov	r0, r3
 2645 0194 2837     		adds	r7, r7, #40
 2646              		.cfi_def_cfa_offset 8
 2647 0196 BD46     		mov	sp, r7
 2648              		.cfi_def_cfa_register 13
 2649              		@ sp needed
 2650 0198 80BD     		pop	{r7, pc}
 2651              	.L205:
 2652 019a 00BF     		.align	2
 2653              	.L204:
 2654 019c 00000000 		.word	.LC0
 2655 01a0 00000000 		.word	__func__.11
ARM GAS  /tmp/cchrzcnP.s 			page 81


 2656 01a4 04000000 		.word	.LC1
 2657              		.cfi_endproc
 2658              	.LFE16:
 2660              		.section	.text.xQueueReceiveFromISR,"ax",%progbits
 2661              		.align	1
 2662              		.global	xQueueReceiveFromISR
 2663              		.syntax unified
 2664              		.thumb
 2665              		.thumb_func
 2667              	xQueueReceiveFromISR:
 2668              	.LFB17:
1929:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
1930:Lib/FreeRTOS/Source/queue.c **** 
1931:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
1932:Lib/FreeRTOS/Source/queue.c ****                                  void * const pvBuffer,
1933:Lib/FreeRTOS/Source/queue.c ****                                  BaseType_t * const pxHigherPriorityTaskWoken )
1934:Lib/FreeRTOS/Source/queue.c **** {
 2669              		.loc 1 1934 1
 2670              		.cfi_startproc
 2671              		@ args = 0, pretend = 0, frame = 40
 2672              		@ frame_needed = 1, uses_anonymous_args = 0
 2673 0000 80B5     		push	{r7, lr}
 2674              		.cfi_def_cfa_offset 8
 2675              		.cfi_offset 7, -8
 2676              		.cfi_offset 14, -4
 2677 0002 8AB0     		sub	sp, sp, #40
 2678              		.cfi_def_cfa_offset 48
 2679 0004 00AF     		add	r7, sp, #0
 2680              		.cfi_def_cfa_register 7
 2681 0006 F860     		str	r0, [r7, #12]
 2682 0008 B960     		str	r1, [r7, #8]
 2683 000a 7A60     		str	r2, [r7, #4]
1935:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
1936:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
1937:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2684              		.loc 1 1937 21
 2685 000c FB68     		ldr	r3, [r7, #12]
 2686 000e 3B62     		str	r3, [r7, #32]
1938:Lib/FreeRTOS/Source/queue.c **** 
1939:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 2687              		.loc 1 1939 5
 2688 0010 3B6A     		ldr	r3, [r7, #32]
 2689 0012 002B     		cmp	r3, #0
 2690 0014 08D1     		bne	.L207
 2691              		.loc 1 1939 5 is_stmt 0 discriminator 1
 2692 0016 FFF7FEFF 		bl	ulSetInterruptMask
 2693 001a 3A4B     		ldr	r3, .L218
 2694 001c 3A4A     		ldr	r2, .L218+4
 2695 001e 40F29371 		movw	r1, #1939
 2696 0022 3A48     		ldr	r0, .L218+8
 2697 0024 FFF7FEFF 		bl	__assert_func
 2698              	.L207:
1940:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2699              		.loc 1 1940 5 is_stmt 1
 2700 0028 BB68     		ldr	r3, [r7, #8]
 2701 002a 002B     		cmp	r3, #0
 2702 002c 03D1     		bne	.L208
ARM GAS  /tmp/cchrzcnP.s 			page 82


 2703              		.loc 1 1940 5 is_stmt 0 discriminator 2
 2704 002e 3B6A     		ldr	r3, [r7, #32]
 2705 0030 1B6C     		ldr	r3, [r3, #64]
 2706 0032 002B     		cmp	r3, #0
 2707 0034 01D1     		bne	.L209
 2708              	.L208:
 2709              		.loc 1 1940 5 discriminator 3
 2710 0036 0123     		movs	r3, #1
 2711              		.loc 1 1940 5
 2712 0038 00E0     		b	.L210
 2713              	.L209:
 2714              		.loc 1 1940 5 discriminator 4
 2715 003a 0023     		movs	r3, #0
 2716              	.L210:
 2717              		.loc 1 1940 5 discriminator 6
 2718 003c 002B     		cmp	r3, #0
 2719 003e 08D1     		bne	.L211
 2720              		.loc 1 1940 5 discriminator 7
 2721 0040 FFF7FEFF 		bl	ulSetInterruptMask
 2722              		.loc 1 1940 5 discriminator 1
 2723 0044 2F4B     		ldr	r3, .L218
 2724 0046 304A     		ldr	r2, .L218+4
 2725 0048 40F29471 		movw	r1, #1940
 2726 004c 2F48     		ldr	r0, .L218+8
 2727 004e FFF7FEFF 		bl	__assert_func
 2728              	.L211:
1941:Lib/FreeRTOS/Source/queue.c **** 
1942:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
1943:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
1944:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
1945:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
1946:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1947:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1948:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
1949:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
1950:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
1951:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
1952:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
1953:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
1954:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
1955:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
1956:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2729              		.loc 1 1956 5 is_stmt 1
 2730 0052 FFF7FEFF 		bl	vPortValidateInterruptPriority
1957:Lib/FreeRTOS/Source/queue.c **** 
1958:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2731              		.loc 1 1958 30
 2732 0056 FFF7FEFF 		bl	ulSetInterruptMask
 2733 005a F861     		str	r0, [r7, #28]
 2734              	.LBB12:
1959:Lib/FreeRTOS/Source/queue.c ****     {
1960:Lib/FreeRTOS/Source/queue.c ****         const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 2735              		.loc 1 1960 27
 2736 005c 3B6A     		ldr	r3, [r7, #32]
 2737 005e 9B6B     		ldr	r3, [r3, #56]
 2738 0060 BB61     		str	r3, [r7, #24]
1961:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 83


1962:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
1963:Lib/FreeRTOS/Source/queue.c ****         if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 2739              		.loc 1 1963 11
 2740 0062 BB69     		ldr	r3, [r7, #24]
 2741 0064 002B     		cmp	r3, #0
 2742 0066 42D0     		beq	.L212
 2743              	.LBB13:
1964:Lib/FreeRTOS/Source/queue.c ****         {
1965:Lib/FreeRTOS/Source/queue.c ****             const int8_t cRxLock = pxQueue->cRxLock;
 2744              		.loc 1 1965 26
 2745 0068 3B6A     		ldr	r3, [r7, #32]
 2746 006a 93F84430 		ldrb	r3, [r3, #68]
 2747 006e FB75     		strb	r3, [r7, #23]
1966:Lib/FreeRTOS/Source/queue.c **** 
1967:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1968:Lib/FreeRTOS/Source/queue.c **** 
1969:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2748              		.loc 1 1969 13
 2749 0070 B968     		ldr	r1, [r7, #8]
 2750 0072 386A     		ldr	r0, [r7, #32]
 2751 0074 FFF7FEFF 		bl	prvCopyDataFromQueue
1970:Lib/FreeRTOS/Source/queue.c ****             pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 2752              		.loc 1 1970 60
 2753 0078 BB69     		ldr	r3, [r7, #24]
 2754 007a 5A1E     		subs	r2, r3, #1
 2755              		.loc 1 1970 40
 2756 007c 3B6A     		ldr	r3, [r7, #32]
 2757 007e 9A63     		str	r2, [r3, #56]
1971:Lib/FreeRTOS/Source/queue.c **** 
1972:Lib/FreeRTOS/Source/queue.c ****             /* If the queue is locked the event list will not be modified.
1973:Lib/FreeRTOS/Source/queue.c ****              * Instead update the lock count so the task that unlocks the queue
1974:Lib/FreeRTOS/Source/queue.c ****              * will know that an ISR has removed data while the queue was
1975:Lib/FreeRTOS/Source/queue.c ****              * locked. */
1976:Lib/FreeRTOS/Source/queue.c ****             if( cRxLock == queueUNLOCKED )
 2758              		.loc 1 1976 15
 2759 0080 97F91730 		ldrsb	r3, [r7, #23]
 2760 0084 B3F1FF3F 		cmp	r3, #-1
 2761 0088 12D1     		bne	.L213
1977:Lib/FreeRTOS/Source/queue.c ****             {
1978:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 2762              		.loc 1 1978 21
 2763 008a 3B6A     		ldr	r3, [r7, #32]
 2764 008c 1B69     		ldr	r3, [r3, #16]
 2765              		.loc 1 1978 19
 2766 008e 002B     		cmp	r3, #0
 2767 0090 2AD0     		beq	.L214
1979:Lib/FreeRTOS/Source/queue.c ****                 {
1980:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 2768              		.loc 1 1980 51
 2769 0092 3B6A     		ldr	r3, [r7, #32]
 2770 0094 1033     		adds	r3, r3, #16
 2771              		.loc 1 1980 25
 2772 0096 1846     		mov	r0, r3
 2773 0098 FFF7FEFF 		bl	xTaskRemoveFromEventList
 2774 009c 0346     		mov	r3, r0
 2775              		.loc 1 1980 23 discriminator 1
 2776 009e 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 84


 2777 00a0 22D0     		beq	.L214
1981:Lib/FreeRTOS/Source/queue.c ****                     {
1982:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority than us so
1983:Lib/FreeRTOS/Source/queue.c ****                          * force a context switch. */
1984:Lib/FreeRTOS/Source/queue.c ****                         if( pxHigherPriorityTaskWoken != NULL )
 2778              		.loc 1 1984 27
 2779 00a2 7B68     		ldr	r3, [r7, #4]
 2780 00a4 002B     		cmp	r3, #0
 2781 00a6 1FD0     		beq	.L214
1985:Lib/FreeRTOS/Source/queue.c ****                         {
1986:Lib/FreeRTOS/Source/queue.c ****                             *pxHigherPriorityTaskWoken = pdTRUE;
 2782              		.loc 1 1986 56
 2783 00a8 7B68     		ldr	r3, [r7, #4]
 2784 00aa 0122     		movs	r2, #1
 2785 00ac 1A60     		str	r2, [r3]
 2786 00ae 1BE0     		b	.L214
 2787              	.L213:
 2788              	.LBB14:
1987:Lib/FreeRTOS/Source/queue.c ****                         }
1988:Lib/FreeRTOS/Source/queue.c ****                         else
1989:Lib/FreeRTOS/Source/queue.c ****                         {
1990:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
1991:Lib/FreeRTOS/Source/queue.c ****                         }
1992:Lib/FreeRTOS/Source/queue.c ****                     }
1993:Lib/FreeRTOS/Source/queue.c ****                     else
1994:Lib/FreeRTOS/Source/queue.c ****                     {
1995:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
1996:Lib/FreeRTOS/Source/queue.c ****                     }
1997:Lib/FreeRTOS/Source/queue.c ****                 }
1998:Lib/FreeRTOS/Source/queue.c ****                 else
1999:Lib/FreeRTOS/Source/queue.c ****                 {
2000:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2001:Lib/FreeRTOS/Source/queue.c ****                 }
2002:Lib/FreeRTOS/Source/queue.c ****             }
2003:Lib/FreeRTOS/Source/queue.c ****             else
2004:Lib/FreeRTOS/Source/queue.c ****             {
2005:Lib/FreeRTOS/Source/queue.c ****                 /* Increment the lock count so the task that unlocks the queue
2006:Lib/FreeRTOS/Source/queue.c ****                  * knows that data was removed while it was locked. */
2007:Lib/FreeRTOS/Source/queue.c ****                 prvIncrementQueueRxLock( pxQueue, cRxLock );
 2789              		.loc 1 2007 17
 2790 00b0 FFF7FEFF 		bl	uxTaskGetNumberOfTasks
 2791 00b4 3861     		str	r0, [r7, #16]
 2792              		.loc 1 2007 17 is_stmt 0 discriminator 1
 2793 00b6 97F91730 		ldrsb	r3, [r7, #23]
 2794 00ba 3A69     		ldr	r2, [r7, #16]
 2795 00bc 9A42     		cmp	r2, r3
 2796 00be 13D9     		bls	.L214
 2797 00c0 97F91730 		ldrsb	r3, [r7, #23]
 2798 00c4 7F2B     		cmp	r3, #127
 2799 00c6 08D1     		bne	.L215
 2800              		.loc 1 2007 17 discriminator 2
 2801 00c8 FFF7FEFF 		bl	ulSetInterruptMask
 2802              		.loc 1 2007 17 discriminator 1
 2803 00cc 0D4B     		ldr	r3, .L218
 2804 00ce 0E4A     		ldr	r2, .L218+4
 2805 00d0 40F2D771 		movw	r1, #2007
 2806 00d4 0D48     		ldr	r0, .L218+8
ARM GAS  /tmp/cchrzcnP.s 			page 85


 2807 00d6 FFF7FEFF 		bl	__assert_func
 2808              	.L215:
 2809              		.loc 1 2007 17 discriminator 3
 2810 00da FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 2811 00dc 0133     		adds	r3, r3, #1
 2812 00de DBB2     		uxtb	r3, r3
 2813 00e0 5AB2     		sxtb	r2, r3
 2814 00e2 3B6A     		ldr	r3, [r7, #32]
 2815 00e4 83F84420 		strb	r2, [r3, #68]
 2816              	.L214:
 2817              	.LBE14:
2008:Lib/FreeRTOS/Source/queue.c ****             }
2009:Lib/FreeRTOS/Source/queue.c **** 
2010:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 2818              		.loc 1 2010 21 is_stmt 1
 2819 00e8 0123     		movs	r3, #1
 2820 00ea 7B62     		str	r3, [r7, #36]
 2821              	.LBE13:
 2822 00ec 01E0     		b	.L216
 2823              	.L212:
2011:Lib/FreeRTOS/Source/queue.c ****         }
2012:Lib/FreeRTOS/Source/queue.c ****         else
2013:Lib/FreeRTOS/Source/queue.c ****         {
2014:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
 2824              		.loc 1 2014 21
 2825 00ee 0023     		movs	r3, #0
 2826 00f0 7B62     		str	r3, [r7, #36]
 2827              	.L216:
 2828              	.LBE12:
2015:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
2016:Lib/FreeRTOS/Source/queue.c ****         }
2017:Lib/FreeRTOS/Source/queue.c ****     }
2018:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2829              		.loc 1 2018 5
 2830 00f2 F869     		ldr	r0, [r7, #28]
 2831 00f4 FFF7FEFF 		bl	vClearInterruptMask
2019:Lib/FreeRTOS/Source/queue.c **** 
2020:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 2832              		.loc 1 2020 12
 2833 00f8 7B6A     		ldr	r3, [r7, #36]
2021:Lib/FreeRTOS/Source/queue.c **** }
 2834              		.loc 1 2021 1
 2835 00fa 1846     		mov	r0, r3
 2836 00fc 2837     		adds	r7, r7, #40
 2837              		.cfi_def_cfa_offset 8
 2838 00fe BD46     		mov	sp, r7
 2839              		.cfi_def_cfa_register 13
 2840              		@ sp needed
 2841 0100 80BD     		pop	{r7, pc}
 2842              	.L219:
 2843 0102 00BF     		.align	2
 2844              	.L218:
 2845 0104 00000000 		.word	.LC0
 2846 0108 00000000 		.word	__func__.10
 2847 010c 04000000 		.word	.LC1
 2848              		.cfi_endproc
 2849              	.LFE17:
ARM GAS  /tmp/cchrzcnP.s 			page 86


 2851              		.section	.text.xQueuePeekFromISR,"ax",%progbits
 2852              		.align	1
 2853              		.global	xQueuePeekFromISR
 2854              		.syntax unified
 2855              		.thumb
 2856              		.thumb_func
 2858              	xQueuePeekFromISR:
 2859              	.LFB18:
2022:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2023:Lib/FreeRTOS/Source/queue.c **** 
2024:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
2025:Lib/FreeRTOS/Source/queue.c ****                               void * const pvBuffer )
2026:Lib/FreeRTOS/Source/queue.c **** {
 2860              		.loc 1 2026 1
 2861              		.cfi_startproc
 2862              		@ args = 0, pretend = 0, frame = 24
 2863              		@ frame_needed = 1, uses_anonymous_args = 0
 2864 0000 80B5     		push	{r7, lr}
 2865              		.cfi_def_cfa_offset 8
 2866              		.cfi_offset 7, -8
 2867              		.cfi_offset 14, -4
 2868 0002 86B0     		sub	sp, sp, #24
 2869              		.cfi_def_cfa_offset 32
 2870 0004 00AF     		add	r7, sp, #0
 2871              		.cfi_def_cfa_register 7
 2872 0006 7860     		str	r0, [r7, #4]
 2873 0008 3960     		str	r1, [r7]
2027:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2028:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxSavedInterruptStatus;
2029:Lib/FreeRTOS/Source/queue.c ****     int8_t * pcOriginalReadPosition;
2030:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 2874              		.loc 1 2030 21
 2875 000a 7B68     		ldr	r3, [r7, #4]
 2876 000c 3B61     		str	r3, [r7, #16]
2031:Lib/FreeRTOS/Source/queue.c **** 
2032:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 2877              		.loc 1 2032 5
 2878 000e 3B69     		ldr	r3, [r7, #16]
 2879 0010 002B     		cmp	r3, #0
 2880 0012 08D1     		bne	.L221
 2881              		.loc 1 2032 5 is_stmt 0 discriminator 1
 2882 0014 FFF7FEFF 		bl	ulSetInterruptMask
 2883 0018 244B     		ldr	r3, .L230
 2884 001a 254A     		ldr	r2, .L230+4
 2885 001c 4FF4FE61 		mov	r1, #2032
 2886 0020 2448     		ldr	r0, .L230+8
 2887 0022 FFF7FEFF 		bl	__assert_func
 2888              	.L221:
2033:Lib/FreeRTOS/Source/queue.c ****     configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 2889              		.loc 1 2033 5 is_stmt 1
 2890 0026 3B68     		ldr	r3, [r7]
 2891 0028 002B     		cmp	r3, #0
 2892 002a 03D1     		bne	.L222
 2893              		.loc 1 2033 5 is_stmt 0 discriminator 2
 2894 002c 3B69     		ldr	r3, [r7, #16]
 2895 002e 1B6C     		ldr	r3, [r3, #64]
 2896 0030 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 87


 2897 0032 01D1     		bne	.L223
 2898              	.L222:
 2899              		.loc 1 2033 5 discriminator 3
 2900 0034 0123     		movs	r3, #1
 2901              		.loc 1 2033 5
 2902 0036 00E0     		b	.L224
 2903              	.L223:
 2904              		.loc 1 2033 5 discriminator 4
 2905 0038 0023     		movs	r3, #0
 2906              	.L224:
 2907              		.loc 1 2033 5 discriminator 6
 2908 003a 002B     		cmp	r3, #0
 2909 003c 08D1     		bne	.L225
 2910              		.loc 1 2033 5 discriminator 7
 2911 003e FFF7FEFF 		bl	ulSetInterruptMask
 2912              		.loc 1 2033 5 discriminator 1
 2913 0042 1A4B     		ldr	r3, .L230
 2914 0044 1A4A     		ldr	r2, .L230+4
 2915 0046 40F2F171 		movw	r1, #2033
 2916 004a 1A48     		ldr	r0, .L230+8
 2917 004c FFF7FEFF 		bl	__assert_func
 2918              	.L225:
2034:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 2919              		.loc 1 2034 5 is_stmt 1
 2920 0050 3B69     		ldr	r3, [r7, #16]
 2921 0052 1B6C     		ldr	r3, [r3, #64]
 2922 0054 002B     		cmp	r3, #0
 2923 0056 08D1     		bne	.L226
 2924              		.loc 1 2034 5 is_stmt 0 discriminator 1
 2925 0058 FFF7FEFF 		bl	ulSetInterruptMask
 2926 005c 134B     		ldr	r3, .L230
 2927 005e 144A     		ldr	r2, .L230+4
 2928 0060 40F2F271 		movw	r1, #2034
 2929 0064 1348     		ldr	r0, .L230+8
 2930 0066 FFF7FEFF 		bl	__assert_func
 2931              	.L226:
2035:Lib/FreeRTOS/Source/queue.c **** 
2036:Lib/FreeRTOS/Source/queue.c ****     /* RTOS ports that support interrupt nesting have the concept of a maximum
2037:Lib/FreeRTOS/Source/queue.c ****      * system call (or maximum API call) interrupt priority.  Interrupts that are
2038:Lib/FreeRTOS/Source/queue.c ****      * above the maximum system call priority are kept permanently enabled, even
2039:Lib/FreeRTOS/Source/queue.c ****      * when the RTOS kernel is in a critical section, but cannot make any calls to
2040:Lib/FreeRTOS/Source/queue.c ****      * FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
2041:Lib/FreeRTOS/Source/queue.c ****      * then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
2042:Lib/FreeRTOS/Source/queue.c ****      * failure if a FreeRTOS API function is called from an interrupt that has been
2043:Lib/FreeRTOS/Source/queue.c ****      * assigned a priority above the configured maximum system call priority.
2044:Lib/FreeRTOS/Source/queue.c ****      * Only FreeRTOS functions that end in FromISR can be called from interrupts
2045:Lib/FreeRTOS/Source/queue.c ****      * that have been assigned a priority at or (logically) below the maximum
2046:Lib/FreeRTOS/Source/queue.c ****      * system call interrupt priority.  FreeRTOS maintains a separate interrupt
2047:Lib/FreeRTOS/Source/queue.c ****      * safe API to ensure interrupt entry is as fast and as simple as possible.
2048:Lib/FreeRTOS/Source/queue.c ****      * More information (albeit Cortex-M specific) is provided on the following
2049:Lib/FreeRTOS/Source/queue.c ****      * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
2050:Lib/FreeRTOS/Source/queue.c ****     portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 2932              		.loc 1 2050 5 is_stmt 1
 2933 006a FFF7FEFF 		bl	vPortValidateInterruptPriority
2051:Lib/FreeRTOS/Source/queue.c **** 
2052:Lib/FreeRTOS/Source/queue.c ****     uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2934              		.loc 1 2052 30
ARM GAS  /tmp/cchrzcnP.s 			page 88


 2935 006e FFF7FEFF 		bl	ulSetInterruptMask
 2936 0072 F860     		str	r0, [r7, #12]
2053:Lib/FreeRTOS/Source/queue.c ****     {
2054:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block in an ISR, so check there is data available. */
2055:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 2937              		.loc 1 2055 20
 2938 0074 3B69     		ldr	r3, [r7, #16]
 2939 0076 9B6B     		ldr	r3, [r3, #56]
 2940              		.loc 1 2055 11
 2941 0078 002B     		cmp	r3, #0
 2942 007a 0CD0     		beq	.L227
2056:Lib/FreeRTOS/Source/queue.c ****         {
2057:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR( pxQueue );
2058:Lib/FreeRTOS/Source/queue.c **** 
2059:Lib/FreeRTOS/Source/queue.c ****             /* Remember the read position so it can be reset as nothing is
2060:Lib/FreeRTOS/Source/queue.c ****              * actually being removed from the queue. */
2061:Lib/FreeRTOS/Source/queue.c ****             pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 2943              		.loc 1 2061 36
 2944 007c 3B69     		ldr	r3, [r7, #16]
 2945 007e DB68     		ldr	r3, [r3, #12]
 2946 0080 BB60     		str	r3, [r7, #8]
2062:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataFromQueue( pxQueue, pvBuffer );
 2947              		.loc 1 2062 13
 2948 0082 3968     		ldr	r1, [r7]
 2949 0084 3869     		ldr	r0, [r7, #16]
 2950 0086 FFF7FEFF 		bl	prvCopyDataFromQueue
2063:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 2951              		.loc 1 2063 42
 2952 008a 3B69     		ldr	r3, [r7, #16]
 2953 008c BA68     		ldr	r2, [r7, #8]
 2954 008e DA60     		str	r2, [r3, #12]
2064:Lib/FreeRTOS/Source/queue.c **** 
2065:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
 2955              		.loc 1 2065 21
 2956 0090 0123     		movs	r3, #1
 2957 0092 7B61     		str	r3, [r7, #20]
 2958 0094 01E0     		b	.L228
 2959              	.L227:
2066:Lib/FreeRTOS/Source/queue.c ****         }
2067:Lib/FreeRTOS/Source/queue.c ****         else
2068:Lib/FreeRTOS/Source/queue.c ****         {
2069:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
 2960              		.loc 1 2069 21
 2961 0096 0023     		movs	r3, #0
 2962 0098 7B61     		str	r3, [r7, #20]
 2963              	.L228:
2070:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
2071:Lib/FreeRTOS/Source/queue.c ****         }
2072:Lib/FreeRTOS/Source/queue.c ****     }
2073:Lib/FreeRTOS/Source/queue.c ****     portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 2964              		.loc 1 2073 5
 2965 009a F868     		ldr	r0, [r7, #12]
 2966 009c FFF7FEFF 		bl	vClearInterruptMask
2074:Lib/FreeRTOS/Source/queue.c **** 
2075:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 2967              		.loc 1 2075 12
 2968 00a0 7B69     		ldr	r3, [r7, #20]
ARM GAS  /tmp/cchrzcnP.s 			page 89


2076:Lib/FreeRTOS/Source/queue.c **** }
 2969              		.loc 1 2076 1
 2970 00a2 1846     		mov	r0, r3
 2971 00a4 1837     		adds	r7, r7, #24
 2972              		.cfi_def_cfa_offset 8
 2973 00a6 BD46     		mov	sp, r7
 2974              		.cfi_def_cfa_register 13
 2975              		@ sp needed
 2976 00a8 80BD     		pop	{r7, pc}
 2977              	.L231:
 2978 00aa 00BF     		.align	2
 2979              	.L230:
 2980 00ac 00000000 		.word	.LC0
 2981 00b0 00000000 		.word	__func__.9
 2982 00b4 04000000 		.word	.LC1
 2983              		.cfi_endproc
 2984              	.LFE18:
 2986              		.section	.text.uxQueueMessagesWaiting,"ax",%progbits
 2987              		.align	1
 2988              		.global	uxQueueMessagesWaiting
 2989              		.syntax unified
 2990              		.thumb
 2991              		.thumb_func
 2993              	uxQueueMessagesWaiting:
 2994              	.LFB19:
2077:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2078:Lib/FreeRTOS/Source/queue.c **** 
2079:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
2080:Lib/FreeRTOS/Source/queue.c **** {
 2995              		.loc 1 2080 1
 2996              		.cfi_startproc
 2997              		@ args = 0, pretend = 0, frame = 16
 2998              		@ frame_needed = 1, uses_anonymous_args = 0
 2999 0000 80B5     		push	{r7, lr}
 3000              		.cfi_def_cfa_offset 8
 3001              		.cfi_offset 7, -8
 3002              		.cfi_offset 14, -4
 3003 0002 84B0     		sub	sp, sp, #16
 3004              		.cfi_def_cfa_offset 24
 3005 0004 00AF     		add	r7, sp, #0
 3006              		.cfi_def_cfa_register 7
 3007 0006 7860     		str	r0, [r7, #4]
2081:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2082:Lib/FreeRTOS/Source/queue.c **** 
2083:Lib/FreeRTOS/Source/queue.c ****     configASSERT( xQueue );
 3008              		.loc 1 2083 5
 3009 0008 7B68     		ldr	r3, [r7, #4]
 3010 000a 002B     		cmp	r3, #0
 3011 000c 08D1     		bne	.L233
 3012              		.loc 1 2083 5 is_stmt 0 discriminator 1
 3013 000e FFF7FEFF 		bl	ulSetInterruptMask
 3014 0012 094B     		ldr	r3, .L235
 3015 0014 094A     		ldr	r2, .L235+4
 3016 0016 40F62301 		movw	r1, #2083
 3017 001a 0948     		ldr	r0, .L235+8
 3018 001c FFF7FEFF 		bl	__assert_func
 3019              	.L233:
ARM GAS  /tmp/cchrzcnP.s 			page 90


2084:Lib/FreeRTOS/Source/queue.c **** 
2085:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 3020              		.loc 1 2085 5 is_stmt 1
 3021 0020 FFF7FEFF 		bl	vPortEnterCritical
2086:Lib/FreeRTOS/Source/queue.c ****     {
2087:Lib/FreeRTOS/Source/queue.c ****         uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 3022              		.loc 1 2087 18
 3023 0024 7B68     		ldr	r3, [r7, #4]
 3024 0026 9B6B     		ldr	r3, [r3, #56]
 3025 0028 FB60     		str	r3, [r7, #12]
2088:Lib/FreeRTOS/Source/queue.c ****     }
2089:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 3026              		.loc 1 2089 5
 3027 002a FFF7FEFF 		bl	vPortExitCritical
2090:Lib/FreeRTOS/Source/queue.c **** 
2091:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
 3028              		.loc 1 2091 12
 3029 002e FB68     		ldr	r3, [r7, #12]
2092:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3030              		.loc 1 2092 1
 3031 0030 1846     		mov	r0, r3
 3032 0032 1037     		adds	r7, r7, #16
 3033              		.cfi_def_cfa_offset 8
 3034 0034 BD46     		mov	sp, r7
 3035              		.cfi_def_cfa_register 13
 3036              		@ sp needed
 3037 0036 80BD     		pop	{r7, pc}
 3038              	.L236:
 3039              		.align	2
 3040              	.L235:
 3041 0038 00000000 		.word	.LC0
 3042 003c 00000000 		.word	__func__.8
 3043 0040 04000000 		.word	.LC1
 3044              		.cfi_endproc
 3045              	.LFE19:
 3047              		.section	.text.uxQueueSpacesAvailable,"ax",%progbits
 3048              		.align	1
 3049              		.global	uxQueueSpacesAvailable
 3050              		.syntax unified
 3051              		.thumb
 3052              		.thumb_func
 3054              	uxQueueSpacesAvailable:
 3055              	.LFB20:
2093:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2094:Lib/FreeRTOS/Source/queue.c **** 
2095:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
2096:Lib/FreeRTOS/Source/queue.c **** {
 3056              		.loc 1 2096 1
 3057              		.cfi_startproc
 3058              		@ args = 0, pretend = 0, frame = 16
 3059              		@ frame_needed = 1, uses_anonymous_args = 0
 3060 0000 80B5     		push	{r7, lr}
 3061              		.cfi_def_cfa_offset 8
 3062              		.cfi_offset 7, -8
 3063              		.cfi_offset 14, -4
 3064 0002 84B0     		sub	sp, sp, #16
 3065              		.cfi_def_cfa_offset 24
ARM GAS  /tmp/cchrzcnP.s 			page 91


 3066 0004 00AF     		add	r7, sp, #0
 3067              		.cfi_def_cfa_register 7
 3068 0006 7860     		str	r0, [r7, #4]
2097:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2098:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3069              		.loc 1 2098 21
 3070 0008 7B68     		ldr	r3, [r7, #4]
 3071 000a FB60     		str	r3, [r7, #12]
2099:Lib/FreeRTOS/Source/queue.c **** 
2100:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3072              		.loc 1 2100 5
 3073 000c FB68     		ldr	r3, [r7, #12]
 3074 000e 002B     		cmp	r3, #0
 3075 0010 08D1     		bne	.L238
 3076              		.loc 1 2100 5 is_stmt 0 discriminator 1
 3077 0012 FFF7FEFF 		bl	ulSetInterruptMask
 3078 0016 0B4B     		ldr	r3, .L240
 3079 0018 0B4A     		ldr	r2, .L240+4
 3080 001a 40F63401 		movw	r1, #2100
 3081 001e 0B48     		ldr	r0, .L240+8
 3082 0020 FFF7FEFF 		bl	__assert_func
 3083              	.L238:
2101:Lib/FreeRTOS/Source/queue.c **** 
2102:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 3084              		.loc 1 2102 5 is_stmt 1
 3085 0024 FFF7FEFF 		bl	vPortEnterCritical
2103:Lib/FreeRTOS/Source/queue.c ****     {
2104:Lib/FreeRTOS/Source/queue.c ****         uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 3086              		.loc 1 2104 27
 3087 0028 FB68     		ldr	r3, [r7, #12]
 3088 002a DA6B     		ldr	r2, [r3, #60]
 3089              		.loc 1 2104 47
 3090 002c FB68     		ldr	r3, [r7, #12]
 3091 002e 9B6B     		ldr	r3, [r3, #56]
 3092              		.loc 1 2104 18
 3093 0030 D31A     		subs	r3, r2, r3
 3094 0032 BB60     		str	r3, [r7, #8]
2105:Lib/FreeRTOS/Source/queue.c ****     }
2106:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 3095              		.loc 1 2106 5
 3096 0034 FFF7FEFF 		bl	vPortExitCritical
2107:Lib/FreeRTOS/Source/queue.c **** 
2108:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
 3097              		.loc 1 2108 12
 3098 0038 BB68     		ldr	r3, [r7, #8]
2109:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3099              		.loc 1 2109 1
 3100 003a 1846     		mov	r0, r3
 3101 003c 1037     		adds	r7, r7, #16
 3102              		.cfi_def_cfa_offset 8
 3103 003e BD46     		mov	sp, r7
 3104              		.cfi_def_cfa_register 13
 3105              		@ sp needed
 3106 0040 80BD     		pop	{r7, pc}
 3107              	.L241:
 3108 0042 00BF     		.align	2
 3109              	.L240:
ARM GAS  /tmp/cchrzcnP.s 			page 92


 3110 0044 00000000 		.word	.LC0
 3111 0048 00000000 		.word	__func__.7
 3112 004c 04000000 		.word	.LC1
 3113              		.cfi_endproc
 3114              	.LFE20:
 3116              		.section	.text.uxQueueMessagesWaitingFromISR,"ax",%progbits
 3117              		.align	1
 3118              		.global	uxQueueMessagesWaitingFromISR
 3119              		.syntax unified
 3120              		.thumb
 3121              		.thumb_func
 3123              	uxQueueMessagesWaitingFromISR:
 3124              	.LFB21:
2110:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2111:Lib/FreeRTOS/Source/queue.c **** 
2112:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
2113:Lib/FreeRTOS/Source/queue.c **** {
 3125              		.loc 1 2113 1
 3126              		.cfi_startproc
 3127              		@ args = 0, pretend = 0, frame = 16
 3128              		@ frame_needed = 1, uses_anonymous_args = 0
 3129 0000 80B5     		push	{r7, lr}
 3130              		.cfi_def_cfa_offset 8
 3131              		.cfi_offset 7, -8
 3132              		.cfi_offset 14, -4
 3133 0002 84B0     		sub	sp, sp, #16
 3134              		.cfi_def_cfa_offset 24
 3135 0004 00AF     		add	r7, sp, #0
 3136              		.cfi_def_cfa_register 7
 3137 0006 7860     		str	r0, [r7, #4]
2114:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxReturn;
2115:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3138              		.loc 1 2115 21
 3139 0008 7B68     		ldr	r3, [r7, #4]
 3140 000a FB60     		str	r3, [r7, #12]
2116:Lib/FreeRTOS/Source/queue.c **** 
2117:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3141              		.loc 1 2117 5
 3142 000c FB68     		ldr	r3, [r7, #12]
 3143 000e 002B     		cmp	r3, #0
 3144 0010 08D1     		bne	.L243
 3145              		.loc 1 2117 5 is_stmt 0 discriminator 1
 3146 0012 FFF7FEFF 		bl	ulSetInterruptMask
 3147 0016 074B     		ldr	r3, .L245
 3148 0018 074A     		ldr	r2, .L245+4
 3149 001a 40F64501 		movw	r1, #2117
 3150 001e 0748     		ldr	r0, .L245+8
 3151 0020 FFF7FEFF 		bl	__assert_func
 3152              	.L243:
2118:Lib/FreeRTOS/Source/queue.c ****     uxReturn = pxQueue->uxMessagesWaiting;
 3153              		.loc 1 2118 14 is_stmt 1
 3154 0024 FB68     		ldr	r3, [r7, #12]
 3155 0026 9B6B     		ldr	r3, [r3, #56]
 3156 0028 BB60     		str	r3, [r7, #8]
2119:Lib/FreeRTOS/Source/queue.c **** 
2120:Lib/FreeRTOS/Source/queue.c ****     return uxReturn;
 3157              		.loc 1 2120 12
ARM GAS  /tmp/cchrzcnP.s 			page 93


 3158 002a BB68     		ldr	r3, [r7, #8]
2121:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 3159              		.loc 1 2121 1
 3160 002c 1846     		mov	r0, r3
 3161 002e 1037     		adds	r7, r7, #16
 3162              		.cfi_def_cfa_offset 8
 3163 0030 BD46     		mov	sp, r7
 3164              		.cfi_def_cfa_register 13
 3165              		@ sp needed
 3166 0032 80BD     		pop	{r7, pc}
 3167              	.L246:
 3168              		.align	2
 3169              	.L245:
 3170 0034 00000000 		.word	.LC0
 3171 0038 00000000 		.word	__func__.6
 3172 003c 04000000 		.word	.LC1
 3173              		.cfi_endproc
 3174              	.LFE21:
 3176              		.section	.text.vQueueDelete,"ax",%progbits
 3177              		.align	1
 3178              		.global	vQueueDelete
 3179              		.syntax unified
 3180              		.thumb
 3181              		.thumb_func
 3183              	vQueueDelete:
 3184              	.LFB22:
2122:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2123:Lib/FreeRTOS/Source/queue.c **** 
2124:Lib/FreeRTOS/Source/queue.c **** void vQueueDelete( QueueHandle_t xQueue )
2125:Lib/FreeRTOS/Source/queue.c **** {
 3185              		.loc 1 2125 1
 3186              		.cfi_startproc
 3187              		@ args = 0, pretend = 0, frame = 16
 3188              		@ frame_needed = 1, uses_anonymous_args = 0
 3189 0000 80B5     		push	{r7, lr}
 3190              		.cfi_def_cfa_offset 8
 3191              		.cfi_offset 7, -8
 3192              		.cfi_offset 14, -4
 3193 0002 84B0     		sub	sp, sp, #16
 3194              		.cfi_def_cfa_offset 24
 3195 0004 00AF     		add	r7, sp, #0
 3196              		.cfi_def_cfa_register 7
 3197 0006 7860     		str	r0, [r7, #4]
2126:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3198              		.loc 1 2126 21
 3199 0008 7B68     		ldr	r3, [r7, #4]
 3200 000a FB60     		str	r3, [r7, #12]
2127:Lib/FreeRTOS/Source/queue.c **** 
2128:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3201              		.loc 1 2128 5
 3202 000c FB68     		ldr	r3, [r7, #12]
 3203 000e 002B     		cmp	r3, #0
 3204 0010 08D1     		bne	.L248
 3205              		.loc 1 2128 5 is_stmt 0 discriminator 1
 3206 0012 FFF7FEFF 		bl	ulSetInterruptMask
 3207 0016 074B     		ldr	r3, .L249
 3208 0018 074A     		ldr	r2, .L249+4
ARM GAS  /tmp/cchrzcnP.s 			page 94


 3209 001a 4FF40561 		mov	r1, #2128
 3210 001e 0748     		ldr	r0, .L249+8
 3211 0020 FFF7FEFF 		bl	__assert_func
 3212              	.L248:
2129:Lib/FreeRTOS/Source/queue.c ****     traceQUEUE_DELETE( pxQueue );
2130:Lib/FreeRTOS/Source/queue.c **** 
2131:Lib/FreeRTOS/Source/queue.c ****     #if ( configQUEUE_REGISTRY_SIZE > 0 )
2132:Lib/FreeRTOS/Source/queue.c ****     {
2133:Lib/FreeRTOS/Source/queue.c ****         vQueueUnregisterQueue( pxQueue );
 3213              		.loc 1 2133 9 is_stmt 1
 3214 0024 F868     		ldr	r0, [r7, #12]
 3215 0026 FFF7FEFF 		bl	vQueueUnregisterQueue
2134:Lib/FreeRTOS/Source/queue.c ****     }
2135:Lib/FreeRTOS/Source/queue.c ****     #endif
2136:Lib/FreeRTOS/Source/queue.c **** 
2137:Lib/FreeRTOS/Source/queue.c ****     #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
2138:Lib/FreeRTOS/Source/queue.c ****     {
2139:Lib/FreeRTOS/Source/queue.c ****         /* The queue can only have been allocated dynamically - free it
2140:Lib/FreeRTOS/Source/queue.c ****          * again. */
2141:Lib/FreeRTOS/Source/queue.c ****         vPortFree( pxQueue );
2142:Lib/FreeRTOS/Source/queue.c ****     }
2143:Lib/FreeRTOS/Source/queue.c ****     #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
2144:Lib/FreeRTOS/Source/queue.c ****     {
2145:Lib/FreeRTOS/Source/queue.c ****         /* The queue could have been allocated statically or dynamically, so
2146:Lib/FreeRTOS/Source/queue.c ****          * check before attempting to free the memory. */
2147:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
2148:Lib/FreeRTOS/Source/queue.c ****         {
2149:Lib/FreeRTOS/Source/queue.c ****             vPortFree( pxQueue );
2150:Lib/FreeRTOS/Source/queue.c ****         }
2151:Lib/FreeRTOS/Source/queue.c ****         else
2152:Lib/FreeRTOS/Source/queue.c ****         {
2153:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2154:Lib/FreeRTOS/Source/queue.c ****         }
2155:Lib/FreeRTOS/Source/queue.c ****     }
2156:Lib/FreeRTOS/Source/queue.c ****     #else /* if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION ==
2157:Lib/FreeRTOS/Source/queue.c ****     {
2158:Lib/FreeRTOS/Source/queue.c ****         /* The queue must have been statically allocated, so is not going to be
2159:Lib/FreeRTOS/Source/queue.c ****          * deleted.  Avoid compiler warnings about the unused parameter. */
2160:Lib/FreeRTOS/Source/queue.c ****         ( void ) pxQueue;
2161:Lib/FreeRTOS/Source/queue.c ****     }
2162:Lib/FreeRTOS/Source/queue.c ****     #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
2163:Lib/FreeRTOS/Source/queue.c **** }
 3216              		.loc 1 2163 1
 3217 002a 00BF     		nop
 3218 002c 1037     		adds	r7, r7, #16
 3219              		.cfi_def_cfa_offset 8
 3220 002e BD46     		mov	sp, r7
 3221              		.cfi_def_cfa_register 13
 3222              		@ sp needed
 3223 0030 80BD     		pop	{r7, pc}
 3224              	.L250:
 3225 0032 00BF     		.align	2
 3226              	.L249:
 3227 0034 00000000 		.word	.LC0
 3228 0038 00000000 		.word	__func__.5
 3229 003c 04000000 		.word	.LC1
 3230              		.cfi_endproc
ARM GAS  /tmp/cchrzcnP.s 			page 95


 3231              	.LFE22:
 3233              		.section	.text.uxQueueGetQueueNumber,"ax",%progbits
 3234              		.align	1
 3235              		.global	uxQueueGetQueueNumber
 3236              		.syntax unified
 3237              		.thumb
 3238              		.thumb_func
 3240              	uxQueueGetQueueNumber:
 3241              	.LFB23:
2164:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2165:Lib/FreeRTOS/Source/queue.c **** 
2166:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2167:Lib/FreeRTOS/Source/queue.c **** 
2168:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
2169:Lib/FreeRTOS/Source/queue.c ****     {
 3242              		.loc 1 2169 5
 3243              		.cfi_startproc
 3244              		@ args = 0, pretend = 0, frame = 8
 3245              		@ frame_needed = 1, uses_anonymous_args = 0
 3246              		@ link register save eliminated.
 3247 0000 80B4     		push	{r7}
 3248              		.cfi_def_cfa_offset 4
 3249              		.cfi_offset 7, -4
 3250 0002 83B0     		sub	sp, sp, #12
 3251              		.cfi_def_cfa_offset 16
 3252 0004 00AF     		add	r7, sp, #0
 3253              		.cfi_def_cfa_register 7
 3254 0006 7860     		str	r0, [r7, #4]
2170:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 3255              		.loc 1 2170 40
 3256 0008 7B68     		ldr	r3, [r7, #4]
 3257 000a 9B6C     		ldr	r3, [r3, #72]
2171:Lib/FreeRTOS/Source/queue.c ****     }
 3258              		.loc 1 2171 5
 3259 000c 1846     		mov	r0, r3
 3260 000e 0C37     		adds	r7, r7, #12
 3261              		.cfi_def_cfa_offset 4
 3262 0010 BD46     		mov	sp, r7
 3263              		.cfi_def_cfa_register 13
 3264              		@ sp needed
 3265 0012 5DF8047B 		ldr	r7, [sp], #4
 3266              		.cfi_restore 7
 3267              		.cfi_def_cfa_offset 0
 3268 0016 7047     		bx	lr
 3269              		.cfi_endproc
 3270              	.LFE23:
 3272              		.section	.text.vQueueSetQueueNumber,"ax",%progbits
 3273              		.align	1
 3274              		.global	vQueueSetQueueNumber
 3275              		.syntax unified
 3276              		.thumb
 3277              		.thumb_func
 3279              	vQueueSetQueueNumber:
 3280              	.LFB24:
2172:Lib/FreeRTOS/Source/queue.c **** 
2173:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2174:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/cchrzcnP.s 			page 96


2175:Lib/FreeRTOS/Source/queue.c **** 
2176:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2177:Lib/FreeRTOS/Source/queue.c **** 
2178:Lib/FreeRTOS/Source/queue.c ****     void vQueueSetQueueNumber( QueueHandle_t xQueue,
2179:Lib/FreeRTOS/Source/queue.c ****                                UBaseType_t uxQueueNumber )
2180:Lib/FreeRTOS/Source/queue.c ****     {
 3281              		.loc 1 2180 5
 3282              		.cfi_startproc
 3283              		@ args = 0, pretend = 0, frame = 8
 3284              		@ frame_needed = 1, uses_anonymous_args = 0
 3285              		@ link register save eliminated.
 3286 0000 80B4     		push	{r7}
 3287              		.cfi_def_cfa_offset 4
 3288              		.cfi_offset 7, -4
 3289 0002 83B0     		sub	sp, sp, #12
 3290              		.cfi_def_cfa_offset 16
 3291 0004 00AF     		add	r7, sp, #0
 3292              		.cfi_def_cfa_register 7
 3293 0006 7860     		str	r0, [r7, #4]
 3294 0008 3960     		str	r1, [r7]
2181:Lib/FreeRTOS/Source/queue.c ****         ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 3295              		.loc 1 2181 49
 3296 000a 7B68     		ldr	r3, [r7, #4]
 3297 000c 3A68     		ldr	r2, [r7]
 3298 000e 9A64     		str	r2, [r3, #72]
2182:Lib/FreeRTOS/Source/queue.c ****     }
 3299              		.loc 1 2182 5
 3300 0010 00BF     		nop
 3301 0012 0C37     		adds	r7, r7, #12
 3302              		.cfi_def_cfa_offset 4
 3303 0014 BD46     		mov	sp, r7
 3304              		.cfi_def_cfa_register 13
 3305              		@ sp needed
 3306 0016 5DF8047B 		ldr	r7, [sp], #4
 3307              		.cfi_restore 7
 3308              		.cfi_def_cfa_offset 0
 3309 001a 7047     		bx	lr
 3310              		.cfi_endproc
 3311              	.LFE24:
 3313              		.section	.text.ucQueueGetQueueType,"ax",%progbits
 3314              		.align	1
 3315              		.global	ucQueueGetQueueType
 3316              		.syntax unified
 3317              		.thumb
 3318              		.thumb_func
 3320              	ucQueueGetQueueType:
 3321              	.LFB25:
2183:Lib/FreeRTOS/Source/queue.c **** 
2184:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2185:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2186:Lib/FreeRTOS/Source/queue.c **** 
2187:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2188:Lib/FreeRTOS/Source/queue.c **** 
2189:Lib/FreeRTOS/Source/queue.c ****     uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
2190:Lib/FreeRTOS/Source/queue.c ****     {
 3322              		.loc 1 2190 5
 3323              		.cfi_startproc
ARM GAS  /tmp/cchrzcnP.s 			page 97


 3324              		@ args = 0, pretend = 0, frame = 8
 3325              		@ frame_needed = 1, uses_anonymous_args = 0
 3326              		@ link register save eliminated.
 3327 0000 80B4     		push	{r7}
 3328              		.cfi_def_cfa_offset 4
 3329              		.cfi_offset 7, -4
 3330 0002 83B0     		sub	sp, sp, #12
 3331              		.cfi_def_cfa_offset 16
 3332 0004 00AF     		add	r7, sp, #0
 3333              		.cfi_def_cfa_register 7
 3334 0006 7860     		str	r0, [r7, #4]
2191:Lib/FreeRTOS/Source/queue.c ****         return ( ( Queue_t * ) xQueue )->ucQueueType;
 3335              		.loc 1 2191 40
 3336 0008 7B68     		ldr	r3, [r7, #4]
 3337 000a 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
2192:Lib/FreeRTOS/Source/queue.c ****     }
 3338              		.loc 1 2192 5
 3339 000e 1846     		mov	r0, r3
 3340 0010 0C37     		adds	r7, r7, #12
 3341              		.cfi_def_cfa_offset 4
 3342 0012 BD46     		mov	sp, r7
 3343              		.cfi_def_cfa_register 13
 3344              		@ sp needed
 3345 0014 5DF8047B 		ldr	r7, [sp], #4
 3346              		.cfi_restore 7
 3347              		.cfi_def_cfa_offset 0
 3348 0018 7047     		bx	lr
 3349              		.cfi_endproc
 3350              	.LFE25:
 3352              		.section	.text.uxQueueGetQueueItemSize,"ax",%progbits
 3353              		.align	1
 3354              		.global	uxQueueGetQueueItemSize
 3355              		.syntax unified
 3356              		.thumb
 3357              		.thumb_func
 3359              	uxQueueGetQueueItemSize:
 3360              	.LFB26:
2193:Lib/FreeRTOS/Source/queue.c **** 
2194:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_TRACE_FACILITY */
2195:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2196:Lib/FreeRTOS/Source/queue.c **** 
2197:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueGetQueueItemSize( QueueHandle_t xQueue ) /* PRIVILEGED_FUNCTION */
2198:Lib/FreeRTOS/Source/queue.c **** {
 3361              		.loc 1 2198 1
 3362              		.cfi_startproc
 3363              		@ args = 0, pretend = 0, frame = 8
 3364              		@ frame_needed = 1, uses_anonymous_args = 0
 3365              		@ link register save eliminated.
 3366 0000 80B4     		push	{r7}
 3367              		.cfi_def_cfa_offset 4
 3368              		.cfi_offset 7, -4
 3369 0002 83B0     		sub	sp, sp, #12
 3370              		.cfi_def_cfa_offset 16
 3371 0004 00AF     		add	r7, sp, #0
 3372              		.cfi_def_cfa_register 7
 3373 0006 7860     		str	r0, [r7, #4]
2199:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxItemSize;
ARM GAS  /tmp/cchrzcnP.s 			page 98


 3374              		.loc 1 2199 36
 3375 0008 7B68     		ldr	r3, [r7, #4]
 3376 000a 1B6C     		ldr	r3, [r3, #64]
2200:Lib/FreeRTOS/Source/queue.c **** }
 3377              		.loc 1 2200 1
 3378 000c 1846     		mov	r0, r3
 3379 000e 0C37     		adds	r7, r7, #12
 3380              		.cfi_def_cfa_offset 4
 3381 0010 BD46     		mov	sp, r7
 3382              		.cfi_def_cfa_register 13
 3383              		@ sp needed
 3384 0012 5DF8047B 		ldr	r7, [sp], #4
 3385              		.cfi_restore 7
 3386              		.cfi_def_cfa_offset 0
 3387 0016 7047     		bx	lr
 3388              		.cfi_endproc
 3389              	.LFE26:
 3391              		.section	.text.uxQueueGetQueueLength,"ax",%progbits
 3392              		.align	1
 3393              		.global	uxQueueGetQueueLength
 3394              		.syntax unified
 3395              		.thumb
 3396              		.thumb_func
 3398              	uxQueueGetQueueLength:
 3399              	.LFB27:
2201:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2202:Lib/FreeRTOS/Source/queue.c **** 
2203:Lib/FreeRTOS/Source/queue.c **** UBaseType_t uxQueueGetQueueLength( QueueHandle_t xQueue ) /* PRIVILEGED_FUNCTION */
2204:Lib/FreeRTOS/Source/queue.c **** {
 3400              		.loc 1 2204 1
 3401              		.cfi_startproc
 3402              		@ args = 0, pretend = 0, frame = 8
 3403              		@ frame_needed = 1, uses_anonymous_args = 0
 3404              		@ link register save eliminated.
 3405 0000 80B4     		push	{r7}
 3406              		.cfi_def_cfa_offset 4
 3407              		.cfi_offset 7, -4
 3408 0002 83B0     		sub	sp, sp, #12
 3409              		.cfi_def_cfa_offset 16
 3410 0004 00AF     		add	r7, sp, #0
 3411              		.cfi_def_cfa_register 7
 3412 0006 7860     		str	r0, [r7, #4]
2205:Lib/FreeRTOS/Source/queue.c ****     return ( ( Queue_t * ) xQueue )->uxLength;
 3413              		.loc 1 2205 36
 3414 0008 7B68     		ldr	r3, [r7, #4]
 3415 000a DB6B     		ldr	r3, [r3, #60]
2206:Lib/FreeRTOS/Source/queue.c **** }
 3416              		.loc 1 2206 1
 3417 000c 1846     		mov	r0, r3
 3418 000e 0C37     		adds	r7, r7, #12
 3419              		.cfi_def_cfa_offset 4
 3420 0010 BD46     		mov	sp, r7
 3421              		.cfi_def_cfa_register 13
 3422              		@ sp needed
 3423 0012 5DF8047B 		ldr	r7, [sp], #4
 3424              		.cfi_restore 7
 3425              		.cfi_def_cfa_offset 0
ARM GAS  /tmp/cchrzcnP.s 			page 99


 3426 0016 7047     		bx	lr
 3427              		.cfi_endproc
 3428              	.LFE27:
 3430              		.section	.text.prvGetDisinheritPriorityAfterTimeout,"ax",%progbits
 3431              		.align	1
 3432              		.syntax unified
 3433              		.thumb
 3434              		.thumb_func
 3436              	prvGetDisinheritPriorityAfterTimeout:
 3437              	.LFB28:
2207:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2208:Lib/FreeRTOS/Source/queue.c **** 
2209:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_MUTEXES == 1 )
2210:Lib/FreeRTOS/Source/queue.c **** 
2211:Lib/FreeRTOS/Source/queue.c ****     static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
2212:Lib/FreeRTOS/Source/queue.c ****     {
 3438              		.loc 1 2212 5
 3439              		.cfi_startproc
 3440              		@ args = 0, pretend = 0, frame = 16
 3441              		@ frame_needed = 1, uses_anonymous_args = 0
 3442              		@ link register save eliminated.
 3443 0000 80B4     		push	{r7}
 3444              		.cfi_def_cfa_offset 4
 3445              		.cfi_offset 7, -4
 3446 0002 85B0     		sub	sp, sp, #20
 3447              		.cfi_def_cfa_offset 24
 3448 0004 00AF     		add	r7, sp, #0
 3449              		.cfi_def_cfa_register 7
 3450 0006 7860     		str	r0, [r7, #4]
2213:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t uxHighestPriorityOfWaitingTasks;
2214:Lib/FreeRTOS/Source/queue.c **** 
2215:Lib/FreeRTOS/Source/queue.c ****         /* If a task waiting for a mutex causes the mutex holder to inherit a
2216:Lib/FreeRTOS/Source/queue.c ****          * priority, but the waiting task times out, then the holder should
2217:Lib/FreeRTOS/Source/queue.c ****          * disinherit the priority - but only down to the highest priority of any
2218:Lib/FreeRTOS/Source/queue.c ****          * other tasks that are waiting for the same mutex.  For this purpose,
2219:Lib/FreeRTOS/Source/queue.c ****          * return the priority of the highest priority task that is waiting for the
2220:Lib/FreeRTOS/Source/queue.c ****          * mutex. */
2221:Lib/FreeRTOS/Source/queue.c ****         if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 3451              		.loc 1 2221 13
 3452 0008 7B68     		ldr	r3, [r7, #4]
 3453 000a 5B6A     		ldr	r3, [r3, #36]
 3454              		.loc 1 2221 11
 3455 000c 002B     		cmp	r3, #0
 3456 000e 06D0     		beq	.L261
2222:Lib/FreeRTOS/Source/queue.c ****         {
2223:Lib/FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t 
 3457              		.loc 1 2223 102
 3458 0010 7B68     		ldr	r3, [r7, #4]
 3459 0012 1B6B     		ldr	r3, [r3, #48]
 3460 0014 1B68     		ldr	r3, [r3]
 3461              		.loc 1 2223 45
 3462 0016 C3F13803 		rsb	r3, r3, #56
 3463 001a FB60     		str	r3, [r7, #12]
 3464 001c 01E0     		b	.L262
 3465              	.L261:
2224:Lib/FreeRTOS/Source/queue.c ****         }
2225:Lib/FreeRTOS/Source/queue.c ****         else
ARM GAS  /tmp/cchrzcnP.s 			page 100


2226:Lib/FreeRTOS/Source/queue.c ****         {
2227:Lib/FreeRTOS/Source/queue.c ****             uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 3466              		.loc 1 2227 45
 3467 001e 0023     		movs	r3, #0
 3468 0020 FB60     		str	r3, [r7, #12]
 3469              	.L262:
2228:Lib/FreeRTOS/Source/queue.c ****         }
2229:Lib/FreeRTOS/Source/queue.c **** 
2230:Lib/FreeRTOS/Source/queue.c ****         return uxHighestPriorityOfWaitingTasks;
 3470              		.loc 1 2230 16
 3471 0022 FB68     		ldr	r3, [r7, #12]
2231:Lib/FreeRTOS/Source/queue.c ****     }
 3472              		.loc 1 2231 5
 3473 0024 1846     		mov	r0, r3
 3474 0026 1437     		adds	r7, r7, #20
 3475              		.cfi_def_cfa_offset 4
 3476 0028 BD46     		mov	sp, r7
 3477              		.cfi_def_cfa_register 13
 3478              		@ sp needed
 3479 002a 5DF8047B 		ldr	r7, [sp], #4
 3480              		.cfi_restore 7
 3481              		.cfi_def_cfa_offset 0
 3482 002e 7047     		bx	lr
 3483              		.cfi_endproc
 3484              	.LFE28:
 3486              		.section	.text.prvCopyDataToQueue,"ax",%progbits
 3487              		.align	1
 3488              		.syntax unified
 3489              		.thumb
 3490              		.thumb_func
 3492              	prvCopyDataToQueue:
 3493              	.LFB29:
2232:Lib/FreeRTOS/Source/queue.c **** 
2233:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_MUTEXES */
2234:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2235:Lib/FreeRTOS/Source/queue.c **** 
2236:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
2237:Lib/FreeRTOS/Source/queue.c ****                                       const void * pvItemToQueue,
2238:Lib/FreeRTOS/Source/queue.c ****                                       const BaseType_t xPosition )
2239:Lib/FreeRTOS/Source/queue.c **** {
 3494              		.loc 1 2239 1
 3495              		.cfi_startproc
 3496              		@ args = 0, pretend = 0, frame = 24
 3497              		@ frame_needed = 1, uses_anonymous_args = 0
 3498 0000 80B5     		push	{r7, lr}
 3499              		.cfi_def_cfa_offset 8
 3500              		.cfi_offset 7, -8
 3501              		.cfi_offset 14, -4
 3502 0002 86B0     		sub	sp, sp, #24
 3503              		.cfi_def_cfa_offset 32
 3504 0004 00AF     		add	r7, sp, #0
 3505              		.cfi_def_cfa_register 7
 3506 0006 F860     		str	r0, [r7, #12]
 3507 0008 B960     		str	r1, [r7, #8]
 3508 000a 7A60     		str	r2, [r7, #4]
2240:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn = pdFALSE;
 3509              		.loc 1 2240 16
ARM GAS  /tmp/cchrzcnP.s 			page 101


 3510 000c 0023     		movs	r3, #0
 3511 000e 7B61     		str	r3, [r7, #20]
2241:Lib/FreeRTOS/Source/queue.c ****     UBaseType_t uxMessagesWaiting;
2242:Lib/FreeRTOS/Source/queue.c **** 
2243:Lib/FreeRTOS/Source/queue.c ****     /* This function is called from a critical section. */
2244:Lib/FreeRTOS/Source/queue.c **** 
2245:Lib/FreeRTOS/Source/queue.c ****     uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 3512              		.loc 1 2245 23
 3513 0010 FB68     		ldr	r3, [r7, #12]
 3514 0012 9B6B     		ldr	r3, [r3, #56]
 3515 0014 3B61     		str	r3, [r7, #16]
2246:Lib/FreeRTOS/Source/queue.c **** 
2247:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 3516              		.loc 1 2247 16
 3517 0016 FB68     		ldr	r3, [r7, #12]
 3518 0018 1B6C     		ldr	r3, [r3, #64]
 3519              		.loc 1 2247 7
 3520 001a 002B     		cmp	r3, #0
 3521 001c 0DD1     		bne	.L265
2248:Lib/FreeRTOS/Source/queue.c ****     {
2249:Lib/FreeRTOS/Source/queue.c ****         #if ( configUSE_MUTEXES == 1 )
2250:Lib/FreeRTOS/Source/queue.c ****         {
2251:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 3522              		.loc 1 2251 24
 3523 001e FB68     		ldr	r3, [r7, #12]
 3524 0020 1B68     		ldr	r3, [r3]
 3525              		.loc 1 2251 15
 3526 0022 002B     		cmp	r3, #0
 3527 0024 4DD1     		bne	.L266
2252:Lib/FreeRTOS/Source/queue.c ****             {
2253:Lib/FreeRTOS/Source/queue.c ****                 /* The mutex is no longer being held. */
2254:Lib/FreeRTOS/Source/queue.c ****                 xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 3528              		.loc 1 2254 27
 3529 0026 FB68     		ldr	r3, [r7, #12]
 3530 0028 9B68     		ldr	r3, [r3, #8]
 3531 002a 1846     		mov	r0, r3
 3532 002c FFF7FEFF 		bl	xTaskPriorityDisinherit
 3533 0030 7861     		str	r0, [r7, #20]
2255:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xSemaphore.xMutexHolder = NULL;
 3534              		.loc 1 2255 52
 3535 0032 FB68     		ldr	r3, [r7, #12]
 3536 0034 0022     		movs	r2, #0
 3537 0036 9A60     		str	r2, [r3, #8]
 3538 0038 43E0     		b	.L266
 3539              	.L265:
2256:Lib/FreeRTOS/Source/queue.c ****             }
2257:Lib/FreeRTOS/Source/queue.c ****             else
2258:Lib/FreeRTOS/Source/queue.c ****             {
2259:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2260:Lib/FreeRTOS/Source/queue.c ****             }
2261:Lib/FreeRTOS/Source/queue.c ****         }
2262:Lib/FreeRTOS/Source/queue.c ****         #endif /* configUSE_MUTEXES */
2263:Lib/FreeRTOS/Source/queue.c ****     }
2264:Lib/FreeRTOS/Source/queue.c ****     else if( xPosition == queueSEND_TO_BACK )
 3540              		.loc 1 2264 12
 3541 003a 7B68     		ldr	r3, [r7, #4]
 3542 003c 002B     		cmp	r3, #0
ARM GAS  /tmp/cchrzcnP.s 			page 102


 3543 003e 19D1     		bne	.L267
2265:Lib/FreeRTOS/Source/queue.c ****     {
2266:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSi
 3544              		.loc 1 2266 44
 3545 0040 FB68     		ldr	r3, [r7, #12]
 3546 0042 5868     		ldr	r0, [r3, #4]
 3547              		.loc 1 2266 90
 3548 0044 FB68     		ldr	r3, [r7, #12]
 3549 0046 1B6C     		ldr	r3, [r3, #64]
 3550              		.loc 1 2266 18
 3551 0048 1A46     		mov	r2, r3
 3552 004a B968     		ldr	r1, [r7, #8]
 3553 004c FFF7FEFF 		bl	memcpy
2267:Lib/FreeRTOS/Source/queue.c ****         pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                 
 3554              		.loc 1 2267 16
 3555 0050 FB68     		ldr	r3, [r7, #12]
 3556 0052 5A68     		ldr	r2, [r3, #4]
 3557              		.loc 1 2267 38
 3558 0054 FB68     		ldr	r3, [r7, #12]
 3559 0056 1B6C     		ldr	r3, [r3, #64]
 3560              		.loc 1 2267 28
 3561 0058 1A44     		add	r2, r2, r3
 3562 005a FB68     		ldr	r3, [r7, #12]
 3563 005c 5A60     		str	r2, [r3, #4]
2268:Lib/FreeRTOS/Source/queue.c **** 
2269:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                       
 3564              		.loc 1 2269 20
 3565 005e FB68     		ldr	r3, [r7, #12]
 3566 0060 5A68     		ldr	r2, [r3, #4]
 3567              		.loc 1 2269 52
 3568 0062 FB68     		ldr	r3, [r7, #12]
 3569 0064 9B68     		ldr	r3, [r3, #8]
 3570              		.loc 1 2269 11
 3571 0066 9A42     		cmp	r2, r3
 3572 0068 2BD3     		bcc	.L266
2270:Lib/FreeRTOS/Source/queue.c ****         {
2271:Lib/FreeRTOS/Source/queue.c ****             pxQueue->pcWriteTo = pxQueue->pcHead;
 3573              		.loc 1 2271 41
 3574 006a FB68     		ldr	r3, [r7, #12]
 3575 006c 1A68     		ldr	r2, [r3]
 3576              		.loc 1 2271 32
 3577 006e FB68     		ldr	r3, [r7, #12]
 3578 0070 5A60     		str	r2, [r3, #4]
 3579 0072 26E0     		b	.L266
 3580              	.L267:
2272:Lib/FreeRTOS/Source/queue.c ****         }
2273:Lib/FreeRTOS/Source/queue.c ****         else
2274:Lib/FreeRTOS/Source/queue.c ****         {
2275:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2276:Lib/FreeRTOS/Source/queue.c ****         }
2277:Lib/FreeRTOS/Source/queue.c ****     }
2278:Lib/FreeRTOS/Source/queue.c ****     else
2279:Lib/FreeRTOS/Source/queue.c ****     {
2280:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue
 3581              		.loc 1 2280 54
 3582 0074 FB68     		ldr	r3, [r7, #12]
 3583 0076 D868     		ldr	r0, [r3, #12]
ARM GAS  /tmp/cchrzcnP.s 			page 103


 3584              		.loc 1 2280 100
 3585 0078 FB68     		ldr	r3, [r7, #12]
 3586 007a 1B6C     		ldr	r3, [r3, #64]
 3587              		.loc 1 2280 18
 3588 007c 1A46     		mov	r2, r3
 3589 007e B968     		ldr	r1, [r7, #8]
 3590 0080 FFF7FEFF 		bl	memcpy
2281:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 3591              		.loc 1 2281 26
 3592 0084 FB68     		ldr	r3, [r7, #12]
 3593 0086 DA68     		ldr	r2, [r3, #12]
 3594              		.loc 1 2281 48
 3595 0088 FB68     		ldr	r3, [r7, #12]
 3596 008a 1B6C     		ldr	r3, [r3, #64]
 3597              		.loc 1 2281 38
 3598 008c 5B42     		rsbs	r3, r3, #0
 3599 008e 1A44     		add	r2, r2, r3
 3600 0090 FB68     		ldr	r3, [r7, #12]
 3601 0092 DA60     		str	r2, [r3, #12]
2282:Lib/FreeRTOS/Source/queue.c **** 
2283:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified
 3602              		.loc 1 2283 30
 3603 0094 FB68     		ldr	r3, [r7, #12]
 3604 0096 DA68     		ldr	r2, [r3, #12]
 3605              		.loc 1 2283 51
 3606 0098 FB68     		ldr	r3, [r7, #12]
 3607 009a 1B68     		ldr	r3, [r3]
 3608              		.loc 1 2283 11
 3609 009c 9A42     		cmp	r2, r3
 3610 009e 07D2     		bcs	.L268
2284:Lib/FreeRTOS/Source/queue.c ****         {
2285:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 3611              		.loc 1 2285 63
 3612 00a0 FB68     		ldr	r3, [r7, #12]
 3613 00a2 9A68     		ldr	r2, [r3, #8]
 3614              		.loc 1 2285 80
 3615 00a4 FB68     		ldr	r3, [r7, #12]
 3616 00a6 1B6C     		ldr	r3, [r3, #64]
 3617              		.loc 1 2285 71
 3618 00a8 5B42     		rsbs	r3, r3, #0
 3619 00aa 1A44     		add	r2, r2, r3
 3620              		.loc 1 2285 42
 3621 00ac FB68     		ldr	r3, [r7, #12]
 3622 00ae DA60     		str	r2, [r3, #12]
 3623              	.L268:
2286:Lib/FreeRTOS/Source/queue.c ****         }
2287:Lib/FreeRTOS/Source/queue.c ****         else
2288:Lib/FreeRTOS/Source/queue.c ****         {
2289:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2290:Lib/FreeRTOS/Source/queue.c ****         }
2291:Lib/FreeRTOS/Source/queue.c **** 
2292:Lib/FreeRTOS/Source/queue.c ****         if( xPosition == queueOVERWRITE )
 3624              		.loc 1 2292 11
 3625 00b0 7B68     		ldr	r3, [r7, #4]
 3626 00b2 022B     		cmp	r3, #2
 3627 00b4 05D1     		bne	.L266
2293:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/cchrzcnP.s 			page 104


2294:Lib/FreeRTOS/Source/queue.c ****             if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 3628              		.loc 1 2294 15
 3629 00b6 3B69     		ldr	r3, [r7, #16]
 3630 00b8 002B     		cmp	r3, #0
 3631 00ba 02D0     		beq	.L266
2295:Lib/FreeRTOS/Source/queue.c ****             {
2296:Lib/FreeRTOS/Source/queue.c ****                 /* An item is not being added but overwritten, so subtract
2297:Lib/FreeRTOS/Source/queue.c ****                  * one from the recorded number of items in the queue so when
2298:Lib/FreeRTOS/Source/queue.c ****                  * one is added again below the number of recorded items remains
2299:Lib/FreeRTOS/Source/queue.c ****                  * correct. */
2300:Lib/FreeRTOS/Source/queue.c ****                 --uxMessagesWaiting;
 3632              		.loc 1 2300 17
 3633 00bc 3B69     		ldr	r3, [r7, #16]
 3634 00be 013B     		subs	r3, r3, #1
 3635 00c0 3B61     		str	r3, [r7, #16]
 3636              	.L266:
2301:Lib/FreeRTOS/Source/queue.c ****             }
2302:Lib/FreeRTOS/Source/queue.c ****             else
2303:Lib/FreeRTOS/Source/queue.c ****             {
2304:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2305:Lib/FreeRTOS/Source/queue.c ****             }
2306:Lib/FreeRTOS/Source/queue.c ****         }
2307:Lib/FreeRTOS/Source/queue.c ****         else
2308:Lib/FreeRTOS/Source/queue.c ****         {
2309:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2310:Lib/FreeRTOS/Source/queue.c ****         }
2311:Lib/FreeRTOS/Source/queue.c ****     }
2312:Lib/FreeRTOS/Source/queue.c **** 
2313:Lib/FreeRTOS/Source/queue.c ****     pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 3637              		.loc 1 2313 52
 3638 00c2 3B69     		ldr	r3, [r7, #16]
 3639 00c4 5A1C     		adds	r2, r3, #1
 3640              		.loc 1 2313 32
 3641 00c6 FB68     		ldr	r3, [r7, #12]
 3642 00c8 9A63     		str	r2, [r3, #56]
2314:Lib/FreeRTOS/Source/queue.c **** 
2315:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 3643              		.loc 1 2315 12
 3644 00ca 7B69     		ldr	r3, [r7, #20]
2316:Lib/FreeRTOS/Source/queue.c **** }
 3645              		.loc 1 2316 1
 3646 00cc 1846     		mov	r0, r3
 3647 00ce 1837     		adds	r7, r7, #24
 3648              		.cfi_def_cfa_offset 8
 3649 00d0 BD46     		mov	sp, r7
 3650              		.cfi_def_cfa_register 13
 3651              		@ sp needed
 3652 00d2 80BD     		pop	{r7, pc}
 3653              		.cfi_endproc
 3654              	.LFE29:
 3656              		.section	.text.prvCopyDataFromQueue,"ax",%progbits
 3657              		.align	1
 3658              		.syntax unified
 3659              		.thumb
 3660              		.thumb_func
 3662              	prvCopyDataFromQueue:
 3663              	.LFB30:
ARM GAS  /tmp/cchrzcnP.s 			page 105


2317:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2318:Lib/FreeRTOS/Source/queue.c **** 
2319:Lib/FreeRTOS/Source/queue.c **** static void prvCopyDataFromQueue( Queue_t * const pxQueue,
2320:Lib/FreeRTOS/Source/queue.c ****                                   void * const pvBuffer )
2321:Lib/FreeRTOS/Source/queue.c **** {
 3664              		.loc 1 2321 1
 3665              		.cfi_startproc
 3666              		@ args = 0, pretend = 0, frame = 8
 3667              		@ frame_needed = 1, uses_anonymous_args = 0
 3668 0000 80B5     		push	{r7, lr}
 3669              		.cfi_def_cfa_offset 8
 3670              		.cfi_offset 7, -8
 3671              		.cfi_offset 14, -4
 3672 0002 82B0     		sub	sp, sp, #8
 3673              		.cfi_def_cfa_offset 16
 3674 0004 00AF     		add	r7, sp, #0
 3675              		.cfi_def_cfa_register 7
 3676 0006 7860     		str	r0, [r7, #4]
 3677 0008 3960     		str	r1, [r7]
2322:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 3678              		.loc 1 2322 16
 3679 000a 7B68     		ldr	r3, [r7, #4]
 3680 000c 1B6C     		ldr	r3, [r3, #64]
 3681              		.loc 1 2322 7
 3682 000e 002B     		cmp	r3, #0
 3683 0010 18D0     		beq	.L273
2323:Lib/FreeRTOS/Source/queue.c ****     {
2324:Lib/FreeRTOS/Source/queue.c ****         pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithm
 3684              		.loc 1 2324 26
 3685 0012 7B68     		ldr	r3, [r7, #4]
 3686 0014 DA68     		ldr	r2, [r3, #12]
 3687              		.loc 1 2324 48
 3688 0016 7B68     		ldr	r3, [r7, #4]
 3689 0018 1B6C     		ldr	r3, [r3, #64]
 3690              		.loc 1 2324 38
 3691 001a 1A44     		add	r2, r2, r3
 3692 001c 7B68     		ldr	r3, [r7, #4]
 3693 001e DA60     		str	r2, [r3, #12]
2325:Lib/FreeRTOS/Source/queue.c **** 
2326:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception
 3694              		.loc 1 2326 30
 3695 0020 7B68     		ldr	r3, [r7, #4]
 3696 0022 DA68     		ldr	r2, [r3, #12]
 3697              		.loc 1 2326 62
 3698 0024 7B68     		ldr	r3, [r7, #4]
 3699 0026 9B68     		ldr	r3, [r3, #8]
 3700              		.loc 1 2326 11
 3701 0028 9A42     		cmp	r2, r3
 3702 002a 03D3     		bcc	.L272
2327:Lib/FreeRTOS/Source/queue.c ****         {
2328:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 3703              		.loc 1 2328 51
 3704 002c 7B68     		ldr	r3, [r7, #4]
 3705 002e 1A68     		ldr	r2, [r3]
 3706              		.loc 1 2328 42
 3707 0030 7B68     		ldr	r3, [r7, #4]
 3708 0032 DA60     		str	r2, [r3, #12]
ARM GAS  /tmp/cchrzcnP.s 			page 106


 3709              	.L272:
2329:Lib/FreeRTOS/Source/queue.c ****         }
2330:Lib/FreeRTOS/Source/queue.c ****         else
2331:Lib/FreeRTOS/Source/queue.c ****         {
2332:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2333:Lib/FreeRTOS/Source/queue.c ****         }
2334:Lib/FreeRTOS/Source/queue.c **** 
2335:Lib/FreeRTOS/Source/queue.c ****         ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) p
 3710              		.loc 1 2335 75
 3711 0034 7B68     		ldr	r3, [r7, #4]
 3712 0036 D968     		ldr	r1, [r3, #12]
 3713              		.loc 1 2335 106
 3714 0038 7B68     		ldr	r3, [r7, #4]
 3715 003a 1B6C     		ldr	r3, [r3, #64]
 3716              		.loc 1 2335 18
 3717 003c 1A46     		mov	r2, r3
 3718 003e 3868     		ldr	r0, [r7]
 3719 0040 FFF7FEFF 		bl	memcpy
 3720              	.L273:
2336:Lib/FreeRTOS/Source/queue.c ****     }
2337:Lib/FreeRTOS/Source/queue.c **** }
 3721              		.loc 1 2337 1
 3722 0044 00BF     		nop
 3723 0046 0837     		adds	r7, r7, #8
 3724              		.cfi_def_cfa_offset 8
 3725 0048 BD46     		mov	sp, r7
 3726              		.cfi_def_cfa_register 13
 3727              		@ sp needed
 3728 004a 80BD     		pop	{r7, pc}
 3729              		.cfi_endproc
 3730              	.LFE30:
 3732              		.section	.text.prvUnlockQueue,"ax",%progbits
 3733              		.align	1
 3734              		.syntax unified
 3735              		.thumb
 3736              		.thumb_func
 3738              	prvUnlockQueue:
 3739              	.LFB31:
2338:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2339:Lib/FreeRTOS/Source/queue.c **** 
2340:Lib/FreeRTOS/Source/queue.c **** static void prvUnlockQueue( Queue_t * const pxQueue )
2341:Lib/FreeRTOS/Source/queue.c **** {
 3740              		.loc 1 2341 1
 3741              		.cfi_startproc
 3742              		@ args = 0, pretend = 0, frame = 16
 3743              		@ frame_needed = 1, uses_anonymous_args = 0
 3744 0000 80B5     		push	{r7, lr}
 3745              		.cfi_def_cfa_offset 8
 3746              		.cfi_offset 7, -8
 3747              		.cfi_offset 14, -4
 3748 0002 84B0     		sub	sp, sp, #16
 3749              		.cfi_def_cfa_offset 24
 3750 0004 00AF     		add	r7, sp, #0
 3751              		.cfi_def_cfa_register 7
 3752 0006 7860     		str	r0, [r7, #4]
2342:Lib/FreeRTOS/Source/queue.c ****     /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
2343:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 107


2344:Lib/FreeRTOS/Source/queue.c ****     /* The lock counts contains the number of extra data items placed or
2345:Lib/FreeRTOS/Source/queue.c ****      * removed from the queue while the queue was locked.  When a queue is
2346:Lib/FreeRTOS/Source/queue.c ****      * locked items can be added or removed, but the event lists cannot be
2347:Lib/FreeRTOS/Source/queue.c ****      * updated. */
2348:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 3753              		.loc 1 2348 5
 3754 0008 FFF7FEFF 		bl	vPortEnterCritical
 3755              	.LBB15:
2349:Lib/FreeRTOS/Source/queue.c ****     {
2350:Lib/FreeRTOS/Source/queue.c ****         int8_t cTxLock = pxQueue->cTxLock;
 3756              		.loc 1 2350 16
 3757 000c 7B68     		ldr	r3, [r7, #4]
 3758 000e 93F84530 		ldrb	r3, [r3, #69]
 3759 0012 FB73     		strb	r3, [r7, #15]
2351:Lib/FreeRTOS/Source/queue.c **** 
2352:Lib/FreeRTOS/Source/queue.c ****         /* See if data was added to the queue while it was locked. */
2353:Lib/FreeRTOS/Source/queue.c ****         while( cTxLock > queueLOCKED_UNMODIFIED )
 3760              		.loc 1 2353 14
 3761 0014 11E0     		b	.L275
 3762              	.L279:
2354:Lib/FreeRTOS/Source/queue.c ****         {
2355:Lib/FreeRTOS/Source/queue.c ****             /* Data was posted while the queue was locked.  Are any tasks
2356:Lib/FreeRTOS/Source/queue.c ****              * blocked waiting for data to become available? */
2357:Lib/FreeRTOS/Source/queue.c ****             #if ( configUSE_QUEUE_SETS == 1 )
2358:Lib/FreeRTOS/Source/queue.c ****             {
2359:Lib/FreeRTOS/Source/queue.c ****                 if( pxQueue->pxQueueSetContainer != NULL )
2360:Lib/FreeRTOS/Source/queue.c ****                 {
2361:Lib/FreeRTOS/Source/queue.c ****                     if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
2362:Lib/FreeRTOS/Source/queue.c ****                     {
2363:Lib/FreeRTOS/Source/queue.c ****                         /* The queue is a member of a queue set, and posting to
2364:Lib/FreeRTOS/Source/queue.c ****                          * the queue set caused a higher priority task to unblock.
2365:Lib/FreeRTOS/Source/queue.c ****                          * A context switch is required. */
2366:Lib/FreeRTOS/Source/queue.c ****                         vTaskMissedYield();
2367:Lib/FreeRTOS/Source/queue.c ****                     }
2368:Lib/FreeRTOS/Source/queue.c ****                     else
2369:Lib/FreeRTOS/Source/queue.c ****                     {
2370:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2371:Lib/FreeRTOS/Source/queue.c ****                     }
2372:Lib/FreeRTOS/Source/queue.c ****                 }
2373:Lib/FreeRTOS/Source/queue.c ****                 else
2374:Lib/FreeRTOS/Source/queue.c ****                 {
2375:Lib/FreeRTOS/Source/queue.c ****                     /* Tasks that are removed from the event list will get
2376:Lib/FreeRTOS/Source/queue.c ****                      * added to the pending ready list as the scheduler is still
2377:Lib/FreeRTOS/Source/queue.c ****                      * suspended. */
2378:Lib/FreeRTOS/Source/queue.c ****                     if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2379:Lib/FreeRTOS/Source/queue.c ****                     {
2380:Lib/FreeRTOS/Source/queue.c ****                         if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdF
2381:Lib/FreeRTOS/Source/queue.c ****                         {
2382:Lib/FreeRTOS/Source/queue.c ****                             /* The task waiting has a higher priority so record that a
2383:Lib/FreeRTOS/Source/queue.c ****                              * context switch is required. */
2384:Lib/FreeRTOS/Source/queue.c ****                             vTaskMissedYield();
2385:Lib/FreeRTOS/Source/queue.c ****                         }
2386:Lib/FreeRTOS/Source/queue.c ****                         else
2387:Lib/FreeRTOS/Source/queue.c ****                         {
2388:Lib/FreeRTOS/Source/queue.c ****                             mtCOVERAGE_TEST_MARKER();
2389:Lib/FreeRTOS/Source/queue.c ****                         }
2390:Lib/FreeRTOS/Source/queue.c ****                     }
ARM GAS  /tmp/cchrzcnP.s 			page 108


2391:Lib/FreeRTOS/Source/queue.c ****                     else
2392:Lib/FreeRTOS/Source/queue.c ****                     {
2393:Lib/FreeRTOS/Source/queue.c ****                         break;
2394:Lib/FreeRTOS/Source/queue.c ****                     }
2395:Lib/FreeRTOS/Source/queue.c ****                 }
2396:Lib/FreeRTOS/Source/queue.c ****             }
2397:Lib/FreeRTOS/Source/queue.c ****             #else /* configUSE_QUEUE_SETS */
2398:Lib/FreeRTOS/Source/queue.c ****             {
2399:Lib/FreeRTOS/Source/queue.c ****                 /* Tasks that are removed from the event list will get added to
2400:Lib/FreeRTOS/Source/queue.c ****                  * the pending ready list as the scheduler is still suspended. */
2401:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3763              		.loc 1 2401 21
 3764 0016 7B68     		ldr	r3, [r7, #4]
 3765 0018 5B6A     		ldr	r3, [r3, #36]
 3766              		.loc 1 2401 19
 3767 001a 002B     		cmp	r3, #0
 3768 001c 12D0     		beq	.L285
2402:Lib/FreeRTOS/Source/queue.c ****                 {
2403:Lib/FreeRTOS/Source/queue.c ****                     if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE
 3769              		.loc 1 2403 51
 3770 001e 7B68     		ldr	r3, [r7, #4]
 3771 0020 2433     		adds	r3, r3, #36
 3772              		.loc 1 2403 25
 3773 0022 1846     		mov	r0, r3
 3774 0024 FFF7FEFF 		bl	xTaskRemoveFromEventList
 3775 0028 0346     		mov	r3, r0
 3776              		.loc 1 2403 23 discriminator 1
 3777 002a 002B     		cmp	r3, #0
 3778 002c 01D0     		beq	.L277
2404:Lib/FreeRTOS/Source/queue.c ****                     {
2405:Lib/FreeRTOS/Source/queue.c ****                         /* The task waiting has a higher priority so record that
2406:Lib/FreeRTOS/Source/queue.c ****                          * a context switch is required. */
2407:Lib/FreeRTOS/Source/queue.c ****                         vTaskMissedYield();
 3779              		.loc 1 2407 25
 3780 002e FFF7FEFF 		bl	vTaskMissedYield
 3781              	.L277:
2408:Lib/FreeRTOS/Source/queue.c ****                     }
2409:Lib/FreeRTOS/Source/queue.c ****                     else
2410:Lib/FreeRTOS/Source/queue.c ****                     {
2411:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2412:Lib/FreeRTOS/Source/queue.c ****                     }
2413:Lib/FreeRTOS/Source/queue.c ****                 }
2414:Lib/FreeRTOS/Source/queue.c ****                 else
2415:Lib/FreeRTOS/Source/queue.c ****                 {
2416:Lib/FreeRTOS/Source/queue.c ****                     break;
2417:Lib/FreeRTOS/Source/queue.c ****                 }
2418:Lib/FreeRTOS/Source/queue.c ****             }
2419:Lib/FreeRTOS/Source/queue.c ****             #endif /* configUSE_QUEUE_SETS */
2420:Lib/FreeRTOS/Source/queue.c **** 
2421:Lib/FreeRTOS/Source/queue.c ****             --cTxLock;
 3782              		.loc 1 2421 13
 3783 0032 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 3784 0034 013B     		subs	r3, r3, #1
 3785 0036 DBB2     		uxtb	r3, r3
 3786 0038 FB73     		strb	r3, [r7, #15]
 3787              	.L275:
2353:Lib/FreeRTOS/Source/queue.c ****         {
ARM GAS  /tmp/cchrzcnP.s 			page 109


 3788              		.loc 1 2353 24
 3789 003a 97F90F30 		ldrsb	r3, [r7, #15]
 3790 003e 002B     		cmp	r3, #0
 3791 0040 E9DC     		bgt	.L279
 3792 0042 00E0     		b	.L278
 3793              	.L285:
2416:Lib/FreeRTOS/Source/queue.c ****                 }
 3794              		.loc 1 2416 21
 3795 0044 00BF     		nop
 3796              	.L278:
2422:Lib/FreeRTOS/Source/queue.c ****         }
2423:Lib/FreeRTOS/Source/queue.c **** 
2424:Lib/FreeRTOS/Source/queue.c ****         pxQueue->cTxLock = queueUNLOCKED;
 3797              		.loc 1 2424 26
 3798 0046 7B68     		ldr	r3, [r7, #4]
 3799 0048 FF22     		movs	r2, #255
 3800 004a 83F84520 		strb	r2, [r3, #69]
 3801              	.LBE15:
2425:Lib/FreeRTOS/Source/queue.c ****     }
2426:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 3802              		.loc 1 2426 5
 3803 004e FFF7FEFF 		bl	vPortExitCritical
2427:Lib/FreeRTOS/Source/queue.c **** 
2428:Lib/FreeRTOS/Source/queue.c ****     /* Do the same for the Rx lock. */
2429:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 3804              		.loc 1 2429 5
 3805 0052 FFF7FEFF 		bl	vPortEnterCritical
 3806              	.LBB16:
2430:Lib/FreeRTOS/Source/queue.c ****     {
2431:Lib/FreeRTOS/Source/queue.c ****         int8_t cRxLock = pxQueue->cRxLock;
 3807              		.loc 1 2431 16
 3808 0056 7B68     		ldr	r3, [r7, #4]
 3809 0058 93F84430 		ldrb	r3, [r3, #68]
 3810 005c BB73     		strb	r3, [r7, #14]
2432:Lib/FreeRTOS/Source/queue.c **** 
2433:Lib/FreeRTOS/Source/queue.c ****         while( cRxLock > queueLOCKED_UNMODIFIED )
 3811              		.loc 1 2433 14
 3812 005e 11E0     		b	.L280
 3813              	.L284:
2434:Lib/FreeRTOS/Source/queue.c ****         {
2435:Lib/FreeRTOS/Source/queue.c ****             if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 3814              		.loc 1 2435 17
 3815 0060 7B68     		ldr	r3, [r7, #4]
 3816 0062 1B69     		ldr	r3, [r3, #16]
 3817              		.loc 1 2435 15
 3818 0064 002B     		cmp	r3, #0
 3819 0066 12D0     		beq	.L286
2436:Lib/FreeRTOS/Source/queue.c ****             {
2437:Lib/FreeRTOS/Source/queue.c ****                 if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 3820              		.loc 1 2437 47
 3821 0068 7B68     		ldr	r3, [r7, #4]
 3822 006a 1033     		adds	r3, r3, #16
 3823              		.loc 1 2437 21
 3824 006c 1846     		mov	r0, r3
 3825 006e FFF7FEFF 		bl	xTaskRemoveFromEventList
 3826 0072 0346     		mov	r3, r0
 3827              		.loc 1 2437 19 discriminator 1
ARM GAS  /tmp/cchrzcnP.s 			page 110


 3828 0074 002B     		cmp	r3, #0
 3829 0076 01D0     		beq	.L282
2438:Lib/FreeRTOS/Source/queue.c ****                 {
2439:Lib/FreeRTOS/Source/queue.c ****                     vTaskMissedYield();
 3830              		.loc 1 2439 21
 3831 0078 FFF7FEFF 		bl	vTaskMissedYield
 3832              	.L282:
2440:Lib/FreeRTOS/Source/queue.c ****                 }
2441:Lib/FreeRTOS/Source/queue.c ****                 else
2442:Lib/FreeRTOS/Source/queue.c ****                 {
2443:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2444:Lib/FreeRTOS/Source/queue.c ****                 }
2445:Lib/FreeRTOS/Source/queue.c **** 
2446:Lib/FreeRTOS/Source/queue.c ****                 --cRxLock;
 3833              		.loc 1 2446 17
 3834 007c BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3835 007e 013B     		subs	r3, r3, #1
 3836 0080 DBB2     		uxtb	r3, r3
 3837 0082 BB73     		strb	r3, [r7, #14]
 3838              	.L280:
2433:Lib/FreeRTOS/Source/queue.c ****         {
 3839              		.loc 1 2433 24
 3840 0084 97F90E30 		ldrsb	r3, [r7, #14]
 3841 0088 002B     		cmp	r3, #0
 3842 008a E9DC     		bgt	.L284
 3843 008c 00E0     		b	.L283
 3844              	.L286:
2447:Lib/FreeRTOS/Source/queue.c ****             }
2448:Lib/FreeRTOS/Source/queue.c ****             else
2449:Lib/FreeRTOS/Source/queue.c ****             {
2450:Lib/FreeRTOS/Source/queue.c ****                 break;
 3845              		.loc 1 2450 17
 3846 008e 00BF     		nop
 3847              	.L283:
2451:Lib/FreeRTOS/Source/queue.c ****             }
2452:Lib/FreeRTOS/Source/queue.c ****         }
2453:Lib/FreeRTOS/Source/queue.c **** 
2454:Lib/FreeRTOS/Source/queue.c ****         pxQueue->cRxLock = queueUNLOCKED;
 3848              		.loc 1 2454 26
 3849 0090 7B68     		ldr	r3, [r7, #4]
 3850 0092 FF22     		movs	r2, #255
 3851 0094 83F84420 		strb	r2, [r3, #68]
 3852              	.LBE16:
2455:Lib/FreeRTOS/Source/queue.c ****     }
2456:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 3853              		.loc 1 2456 5
 3854 0098 FFF7FEFF 		bl	vPortExitCritical
2457:Lib/FreeRTOS/Source/queue.c **** }
 3855              		.loc 1 2457 1
 3856 009c 00BF     		nop
 3857 009e 1037     		adds	r7, r7, #16
 3858              		.cfi_def_cfa_offset 8
 3859 00a0 BD46     		mov	sp, r7
 3860              		.cfi_def_cfa_register 13
 3861              		@ sp needed
 3862 00a2 80BD     		pop	{r7, pc}
 3863              		.cfi_endproc
ARM GAS  /tmp/cchrzcnP.s 			page 111


 3864              	.LFE31:
 3866              		.section	.text.prvIsQueueEmpty,"ax",%progbits
 3867              		.align	1
 3868              		.syntax unified
 3869              		.thumb
 3870              		.thumb_func
 3872              	prvIsQueueEmpty:
 3873              	.LFB32:
2458:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2459:Lib/FreeRTOS/Source/queue.c **** 
2460:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
2461:Lib/FreeRTOS/Source/queue.c **** {
 3874              		.loc 1 2461 1
 3875              		.cfi_startproc
 3876              		@ args = 0, pretend = 0, frame = 16
 3877              		@ frame_needed = 1, uses_anonymous_args = 0
 3878 0000 80B5     		push	{r7, lr}
 3879              		.cfi_def_cfa_offset 8
 3880              		.cfi_offset 7, -8
 3881              		.cfi_offset 14, -4
 3882 0002 84B0     		sub	sp, sp, #16
 3883              		.cfi_def_cfa_offset 24
 3884 0004 00AF     		add	r7, sp, #0
 3885              		.cfi_def_cfa_register 7
 3886 0006 7860     		str	r0, [r7, #4]
2462:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2463:Lib/FreeRTOS/Source/queue.c **** 
2464:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 3887              		.loc 1 2464 5
 3888 0008 FFF7FEFF 		bl	vPortEnterCritical
2465:Lib/FreeRTOS/Source/queue.c ****     {
2466:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 3889              		.loc 1 2466 20
 3890 000c 7B68     		ldr	r3, [r7, #4]
 3891 000e 9B6B     		ldr	r3, [r3, #56]
 3892              		.loc 1 2466 11
 3893 0010 002B     		cmp	r3, #0
 3894 0012 02D1     		bne	.L288
2467:Lib/FreeRTOS/Source/queue.c ****         {
2468:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 3895              		.loc 1 2468 21
 3896 0014 0123     		movs	r3, #1
 3897 0016 FB60     		str	r3, [r7, #12]
 3898 0018 01E0     		b	.L289
 3899              	.L288:
2469:Lib/FreeRTOS/Source/queue.c ****         }
2470:Lib/FreeRTOS/Source/queue.c ****         else
2471:Lib/FreeRTOS/Source/queue.c ****         {
2472:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
 3900              		.loc 1 2472 21
 3901 001a 0023     		movs	r3, #0
 3902 001c FB60     		str	r3, [r7, #12]
 3903              	.L289:
2473:Lib/FreeRTOS/Source/queue.c ****         }
2474:Lib/FreeRTOS/Source/queue.c ****     }
2475:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 3904              		.loc 1 2475 5
ARM GAS  /tmp/cchrzcnP.s 			page 112


 3905 001e FFF7FEFF 		bl	vPortExitCritical
2476:Lib/FreeRTOS/Source/queue.c **** 
2477:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 3906              		.loc 1 2477 12
 3907 0022 FB68     		ldr	r3, [r7, #12]
2478:Lib/FreeRTOS/Source/queue.c **** }
 3908              		.loc 1 2478 1
 3909 0024 1846     		mov	r0, r3
 3910 0026 1037     		adds	r7, r7, #16
 3911              		.cfi_def_cfa_offset 8
 3912 0028 BD46     		mov	sp, r7
 3913              		.cfi_def_cfa_register 13
 3914              		@ sp needed
 3915 002a 80BD     		pop	{r7, pc}
 3916              		.cfi_endproc
 3917              	.LFE32:
 3919              		.section	.text.xQueueIsQueueEmptyFromISR,"ax",%progbits
 3920              		.align	1
 3921              		.global	xQueueIsQueueEmptyFromISR
 3922              		.syntax unified
 3923              		.thumb
 3924              		.thumb_func
 3926              	xQueueIsQueueEmptyFromISR:
 3927              	.LFB33:
2479:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2480:Lib/FreeRTOS/Source/queue.c **** 
2481:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
2482:Lib/FreeRTOS/Source/queue.c **** {
 3928              		.loc 1 2482 1
 3929              		.cfi_startproc
 3930              		@ args = 0, pretend = 0, frame = 16
 3931              		@ frame_needed = 1, uses_anonymous_args = 0
 3932 0000 80B5     		push	{r7, lr}
 3933              		.cfi_def_cfa_offset 8
 3934              		.cfi_offset 7, -8
 3935              		.cfi_offset 14, -4
 3936 0002 84B0     		sub	sp, sp, #16
 3937              		.cfi_def_cfa_offset 24
 3938 0004 00AF     		add	r7, sp, #0
 3939              		.cfi_def_cfa_register 7
 3940 0006 7860     		str	r0, [r7, #4]
2483:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2484:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 3941              		.loc 1 2484 21
 3942 0008 7B68     		ldr	r3, [r7, #4]
 3943 000a BB60     		str	r3, [r7, #8]
2485:Lib/FreeRTOS/Source/queue.c **** 
2486:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 3944              		.loc 1 2486 5
 3945 000c BB68     		ldr	r3, [r7, #8]
 3946 000e 002B     		cmp	r3, #0
 3947 0010 08D1     		bne	.L292
 3948              		.loc 1 2486 5 is_stmt 0 discriminator 1
 3949 0012 FFF7FEFF 		bl	ulSetInterruptMask
 3950 0016 0A4B     		ldr	r3, .L296
 3951 0018 0A4A     		ldr	r2, .L296+4
 3952 001a 40F6B611 		movw	r1, #2486
ARM GAS  /tmp/cchrzcnP.s 			page 113


 3953 001e 0A48     		ldr	r0, .L296+8
 3954 0020 FFF7FEFF 		bl	__assert_func
 3955              	.L292:
2487:Lib/FreeRTOS/Source/queue.c **** 
2488:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 3956              		.loc 1 2488 16 is_stmt 1
 3957 0024 BB68     		ldr	r3, [r7, #8]
 3958 0026 9B6B     		ldr	r3, [r3, #56]
 3959              		.loc 1 2488 7
 3960 0028 002B     		cmp	r3, #0
 3961 002a 02D1     		bne	.L293
2489:Lib/FreeRTOS/Source/queue.c ****     {
2490:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
 3962              		.loc 1 2490 17
 3963 002c 0123     		movs	r3, #1
 3964 002e FB60     		str	r3, [r7, #12]
 3965 0030 01E0     		b	.L294
 3966              	.L293:
2491:Lib/FreeRTOS/Source/queue.c ****     }
2492:Lib/FreeRTOS/Source/queue.c ****     else
2493:Lib/FreeRTOS/Source/queue.c ****     {
2494:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
 3967              		.loc 1 2494 17
 3968 0032 0023     		movs	r3, #0
 3969 0034 FB60     		str	r3, [r7, #12]
 3970              	.L294:
2495:Lib/FreeRTOS/Source/queue.c ****     }
2496:Lib/FreeRTOS/Source/queue.c **** 
2497:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 3971              		.loc 1 2497 12
 3972 0036 FB68     		ldr	r3, [r7, #12]
2498:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 3973              		.loc 1 2498 1
 3974 0038 1846     		mov	r0, r3
 3975 003a 1037     		adds	r7, r7, #16
 3976              		.cfi_def_cfa_offset 8
 3977 003c BD46     		mov	sp, r7
 3978              		.cfi_def_cfa_register 13
 3979              		@ sp needed
 3980 003e 80BD     		pop	{r7, pc}
 3981              	.L297:
 3982              		.align	2
 3983              	.L296:
 3984 0040 00000000 		.word	.LC0
 3985 0044 00000000 		.word	__func__.4
 3986 0048 04000000 		.word	.LC1
 3987              		.cfi_endproc
 3988              	.LFE33:
 3990              		.section	.text.prvIsQueueFull,"ax",%progbits
 3991              		.align	1
 3992              		.syntax unified
 3993              		.thumb
 3994              		.thumb_func
 3996              	prvIsQueueFull:
 3997              	.LFB34:
2499:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2500:Lib/FreeRTOS/Source/queue.c **** 
ARM GAS  /tmp/cchrzcnP.s 			page 114


2501:Lib/FreeRTOS/Source/queue.c **** static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
2502:Lib/FreeRTOS/Source/queue.c **** {
 3998              		.loc 1 2502 1
 3999              		.cfi_startproc
 4000              		@ args = 0, pretend = 0, frame = 16
 4001              		@ frame_needed = 1, uses_anonymous_args = 0
 4002 0000 80B5     		push	{r7, lr}
 4003              		.cfi_def_cfa_offset 8
 4004              		.cfi_offset 7, -8
 4005              		.cfi_offset 14, -4
 4006 0002 84B0     		sub	sp, sp, #16
 4007              		.cfi_def_cfa_offset 24
 4008 0004 00AF     		add	r7, sp, #0
 4009              		.cfi_def_cfa_register 7
 4010 0006 7860     		str	r0, [r7, #4]
2503:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2504:Lib/FreeRTOS/Source/queue.c **** 
2505:Lib/FreeRTOS/Source/queue.c ****     taskENTER_CRITICAL();
 4011              		.loc 1 2505 5
 4012 0008 FFF7FEFF 		bl	vPortEnterCritical
2506:Lib/FreeRTOS/Source/queue.c ****     {
2507:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4013              		.loc 1 2507 20
 4014 000c 7B68     		ldr	r3, [r7, #4]
 4015 000e 9A6B     		ldr	r2, [r3, #56]
 4016              		.loc 1 2507 50
 4017 0010 7B68     		ldr	r3, [r7, #4]
 4018 0012 DB6B     		ldr	r3, [r3, #60]
 4019              		.loc 1 2507 11
 4020 0014 9A42     		cmp	r2, r3
 4021 0016 02D1     		bne	.L299
2508:Lib/FreeRTOS/Source/queue.c ****         {
2509:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdTRUE;
 4022              		.loc 1 2509 21
 4023 0018 0123     		movs	r3, #1
 4024 001a FB60     		str	r3, [r7, #12]
 4025 001c 01E0     		b	.L300
 4026              	.L299:
2510:Lib/FreeRTOS/Source/queue.c ****         }
2511:Lib/FreeRTOS/Source/queue.c ****         else
2512:Lib/FreeRTOS/Source/queue.c ****         {
2513:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFALSE;
 4027              		.loc 1 2513 21
 4028 001e 0023     		movs	r3, #0
 4029 0020 FB60     		str	r3, [r7, #12]
 4030              	.L300:
2514:Lib/FreeRTOS/Source/queue.c ****         }
2515:Lib/FreeRTOS/Source/queue.c ****     }
2516:Lib/FreeRTOS/Source/queue.c ****     taskEXIT_CRITICAL();
 4031              		.loc 1 2516 5
 4032 0022 FFF7FEFF 		bl	vPortExitCritical
2517:Lib/FreeRTOS/Source/queue.c **** 
2518:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 4033              		.loc 1 2518 12
 4034 0026 FB68     		ldr	r3, [r7, #12]
2519:Lib/FreeRTOS/Source/queue.c **** }
 4035              		.loc 1 2519 1
ARM GAS  /tmp/cchrzcnP.s 			page 115


 4036 0028 1846     		mov	r0, r3
 4037 002a 1037     		adds	r7, r7, #16
 4038              		.cfi_def_cfa_offset 8
 4039 002c BD46     		mov	sp, r7
 4040              		.cfi_def_cfa_register 13
 4041              		@ sp needed
 4042 002e 80BD     		pop	{r7, pc}
 4043              		.cfi_endproc
 4044              	.LFE34:
 4046              		.section	.text.xQueueIsQueueFullFromISR,"ax",%progbits
 4047              		.align	1
 4048              		.global	xQueueIsQueueFullFromISR
 4049              		.syntax unified
 4050              		.thumb
 4051              		.thumb_func
 4053              	xQueueIsQueueFullFromISR:
 4054              	.LFB35:
2520:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2521:Lib/FreeRTOS/Source/queue.c **** 
2522:Lib/FreeRTOS/Source/queue.c **** BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
2523:Lib/FreeRTOS/Source/queue.c **** {
 4055              		.loc 1 2523 1
 4056              		.cfi_startproc
 4057              		@ args = 0, pretend = 0, frame = 16
 4058              		@ frame_needed = 1, uses_anonymous_args = 0
 4059 0000 80B5     		push	{r7, lr}
 4060              		.cfi_def_cfa_offset 8
 4061              		.cfi_offset 7, -8
 4062              		.cfi_offset 14, -4
 4063 0002 84B0     		sub	sp, sp, #16
 4064              		.cfi_def_cfa_offset 24
 4065 0004 00AF     		add	r7, sp, #0
 4066              		.cfi_def_cfa_register 7
 4067 0006 7860     		str	r0, [r7, #4]
2524:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xReturn;
2525:Lib/FreeRTOS/Source/queue.c ****     Queue_t * const pxQueue = xQueue;
 4068              		.loc 1 2525 21
 4069 0008 7B68     		ldr	r3, [r7, #4]
 4070 000a BB60     		str	r3, [r7, #8]
2526:Lib/FreeRTOS/Source/queue.c **** 
2527:Lib/FreeRTOS/Source/queue.c ****     configASSERT( pxQueue );
 4071              		.loc 1 2527 5
 4072 000c BB68     		ldr	r3, [r7, #8]
 4073 000e 002B     		cmp	r3, #0
 4074 0010 08D1     		bne	.L303
 4075              		.loc 1 2527 5 is_stmt 0 discriminator 1
 4076 0012 FFF7FEFF 		bl	ulSetInterruptMask
 4077 0016 0B4B     		ldr	r3, .L307
 4078 0018 0B4A     		ldr	r2, .L307+4
 4079 001a 40F6DF11 		movw	r1, #2527
 4080 001e 0B48     		ldr	r0, .L307+8
 4081 0020 FFF7FEFF 		bl	__assert_func
 4082              	.L303:
2528:Lib/FreeRTOS/Source/queue.c **** 
2529:Lib/FreeRTOS/Source/queue.c ****     if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 4083              		.loc 1 2529 16 is_stmt 1
 4084 0024 BB68     		ldr	r3, [r7, #8]
ARM GAS  /tmp/cchrzcnP.s 			page 116


 4085 0026 9A6B     		ldr	r2, [r3, #56]
 4086              		.loc 1 2529 46
 4087 0028 BB68     		ldr	r3, [r7, #8]
 4088 002a DB6B     		ldr	r3, [r3, #60]
 4089              		.loc 1 2529 7
 4090 002c 9A42     		cmp	r2, r3
 4091 002e 02D1     		bne	.L304
2530:Lib/FreeRTOS/Source/queue.c ****     {
2531:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdTRUE;
 4092              		.loc 1 2531 17
 4093 0030 0123     		movs	r3, #1
 4094 0032 FB60     		str	r3, [r7, #12]
 4095 0034 01E0     		b	.L305
 4096              	.L304:
2532:Lib/FreeRTOS/Source/queue.c ****     }
2533:Lib/FreeRTOS/Source/queue.c ****     else
2534:Lib/FreeRTOS/Source/queue.c ****     {
2535:Lib/FreeRTOS/Source/queue.c ****         xReturn = pdFALSE;
 4097              		.loc 1 2535 17
 4098 0036 0023     		movs	r3, #0
 4099 0038 FB60     		str	r3, [r7, #12]
 4100              	.L305:
2536:Lib/FreeRTOS/Source/queue.c ****     }
2537:Lib/FreeRTOS/Source/queue.c **** 
2538:Lib/FreeRTOS/Source/queue.c ****     return xReturn;
 4101              		.loc 1 2538 12
 4102 003a FB68     		ldr	r3, [r7, #12]
2539:Lib/FreeRTOS/Source/queue.c **** } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4103              		.loc 1 2539 1
 4104 003c 1846     		mov	r0, r3
 4105 003e 1037     		adds	r7, r7, #16
 4106              		.cfi_def_cfa_offset 8
 4107 0040 BD46     		mov	sp, r7
 4108              		.cfi_def_cfa_register 13
 4109              		@ sp needed
 4110 0042 80BD     		pop	{r7, pc}
 4111              	.L308:
 4112              		.align	2
 4113              	.L307:
 4114 0044 00000000 		.word	.LC0
 4115 0048 00000000 		.word	__func__.3
 4116 004c 04000000 		.word	.LC1
 4117              		.cfi_endproc
 4118              	.LFE35:
 4120              		.section	.text.vQueueAddToRegistry,"ax",%progbits
 4121              		.align	1
 4122              		.global	vQueueAddToRegistry
 4123              		.syntax unified
 4124              		.thumb
 4125              		.thumb_func
 4127              	vQueueAddToRegistry:
 4128              	.LFB36:
2540:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2541:Lib/FreeRTOS/Source/queue.c **** 
2542:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2543:Lib/FreeRTOS/Source/queue.c **** 
2544:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSend( QueueHandle_t xQueue,
ARM GAS  /tmp/cchrzcnP.s 			page 117


2545:Lib/FreeRTOS/Source/queue.c ****                              const void * pvItemToQueue,
2546:Lib/FreeRTOS/Source/queue.c ****                              TickType_t xTicksToWait )
2547:Lib/FreeRTOS/Source/queue.c ****     {
2548:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2549:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2550:Lib/FreeRTOS/Source/queue.c **** 
2551:Lib/FreeRTOS/Source/queue.c ****         /* If the queue is already full we may have to block.  A critical section
2552:Lib/FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt removing something from the queue
2553:Lib/FreeRTOS/Source/queue.c ****          * between the check to see if the queue is full and blocking on the queue. */
2554:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2555:Lib/FreeRTOS/Source/queue.c ****         {
2556:Lib/FreeRTOS/Source/queue.c ****             if( prvIsQueueFull( pxQueue ) != pdFALSE )
2557:Lib/FreeRTOS/Source/queue.c ****             {
2558:Lib/FreeRTOS/Source/queue.c ****                 /* The queue is full - do we want to block or just leave without
2559:Lib/FreeRTOS/Source/queue.c ****                  * posting? */
2560:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2561:Lib/FreeRTOS/Source/queue.c ****                 {
2562:Lib/FreeRTOS/Source/queue.c ****                     /* As this is called from a coroutine we cannot block directly, but
2563:Lib/FreeRTOS/Source/queue.c ****                      * return indicating that we need to block. */
2564:Lib/FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
2565:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2566:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2567:Lib/FreeRTOS/Source/queue.c ****                 }
2568:Lib/FreeRTOS/Source/queue.c ****                 else
2569:Lib/FreeRTOS/Source/queue.c ****                 {
2570:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2571:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2572:Lib/FreeRTOS/Source/queue.c ****                 }
2573:Lib/FreeRTOS/Source/queue.c ****             }
2574:Lib/FreeRTOS/Source/queue.c ****         }
2575:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2576:Lib/FreeRTOS/Source/queue.c **** 
2577:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2578:Lib/FreeRTOS/Source/queue.c ****         {
2579:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2580:Lib/FreeRTOS/Source/queue.c ****             {
2581:Lib/FreeRTOS/Source/queue.c ****                 /* There is room in the queue, copy the data into the queue. */
2582:Lib/FreeRTOS/Source/queue.c ****                 prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2583:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2584:Lib/FreeRTOS/Source/queue.c **** 
2585:Lib/FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for data to become available? */
2586:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2587:Lib/FreeRTOS/Source/queue.c ****                 {
2588:Lib/FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2589:Lib/FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2590:Lib/FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2591:Lib/FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2592:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2593:Lib/FreeRTOS/Source/queue.c ****                     {
2594:Lib/FreeRTOS/Source/queue.c ****                         /* The co-routine waiting has a higher priority so record
2595:Lib/FreeRTOS/Source/queue.c ****                          * that a yield might be appropriate. */
2596:Lib/FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2597:Lib/FreeRTOS/Source/queue.c ****                     }
2598:Lib/FreeRTOS/Source/queue.c ****                     else
2599:Lib/FreeRTOS/Source/queue.c ****                     {
2600:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2601:Lib/FreeRTOS/Source/queue.c ****                     }
ARM GAS  /tmp/cchrzcnP.s 			page 118


2602:Lib/FreeRTOS/Source/queue.c ****                 }
2603:Lib/FreeRTOS/Source/queue.c ****                 else
2604:Lib/FreeRTOS/Source/queue.c ****                 {
2605:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2606:Lib/FreeRTOS/Source/queue.c ****                 }
2607:Lib/FreeRTOS/Source/queue.c ****             }
2608:Lib/FreeRTOS/Source/queue.c ****             else
2609:Lib/FreeRTOS/Source/queue.c ****             {
2610:Lib/FreeRTOS/Source/queue.c ****                 xReturn = errQUEUE_FULL;
2611:Lib/FreeRTOS/Source/queue.c ****             }
2612:Lib/FreeRTOS/Source/queue.c ****         }
2613:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2614:Lib/FreeRTOS/Source/queue.c **** 
2615:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2616:Lib/FreeRTOS/Source/queue.c ****     }
2617:Lib/FreeRTOS/Source/queue.c **** 
2618:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2619:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2620:Lib/FreeRTOS/Source/queue.c **** 
2621:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2622:Lib/FreeRTOS/Source/queue.c **** 
2623:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
2624:Lib/FreeRTOS/Source/queue.c ****                                 void * pvBuffer,
2625:Lib/FreeRTOS/Source/queue.c ****                                 TickType_t xTicksToWait )
2626:Lib/FreeRTOS/Source/queue.c ****     {
2627:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2628:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2629:Lib/FreeRTOS/Source/queue.c **** 
2630:Lib/FreeRTOS/Source/queue.c ****         /* If the queue is already empty we may have to block.  A critical section
2631:Lib/FreeRTOS/Source/queue.c ****          * is required to prevent an interrupt adding something to the queue
2632:Lib/FreeRTOS/Source/queue.c ****          * between the check to see if the queue is empty and blocking on the queue. */
2633:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2634:Lib/FreeRTOS/Source/queue.c ****         {
2635:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
2636:Lib/FreeRTOS/Source/queue.c ****             {
2637:Lib/FreeRTOS/Source/queue.c ****                 /* There are no messages in the queue, do we want to block or just
2638:Lib/FreeRTOS/Source/queue.c ****                  * leave with nothing? */
2639:Lib/FreeRTOS/Source/queue.c ****                 if( xTicksToWait > ( TickType_t ) 0 )
2640:Lib/FreeRTOS/Source/queue.c ****                 {
2641:Lib/FreeRTOS/Source/queue.c ****                     /* As this is a co-routine we cannot block directly, but return
2642:Lib/FreeRTOS/Source/queue.c ****                      * indicating that we need to block. */
2643:Lib/FreeRTOS/Source/queue.c ****                     vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) 
2644:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2645:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_BLOCKED;
2646:Lib/FreeRTOS/Source/queue.c ****                 }
2647:Lib/FreeRTOS/Source/queue.c ****                 else
2648:Lib/FreeRTOS/Source/queue.c ****                 {
2649:Lib/FreeRTOS/Source/queue.c ****                     portENABLE_INTERRUPTS();
2650:Lib/FreeRTOS/Source/queue.c ****                     return errQUEUE_FULL;
2651:Lib/FreeRTOS/Source/queue.c ****                 }
2652:Lib/FreeRTOS/Source/queue.c ****             }
2653:Lib/FreeRTOS/Source/queue.c ****             else
2654:Lib/FreeRTOS/Source/queue.c ****             {
2655:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2656:Lib/FreeRTOS/Source/queue.c ****             }
2657:Lib/FreeRTOS/Source/queue.c ****         }
2658:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
ARM GAS  /tmp/cchrzcnP.s 			page 119


2659:Lib/FreeRTOS/Source/queue.c **** 
2660:Lib/FreeRTOS/Source/queue.c ****         portDISABLE_INTERRUPTS();
2661:Lib/FreeRTOS/Source/queue.c ****         {
2662:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2663:Lib/FreeRTOS/Source/queue.c ****             {
2664:Lib/FreeRTOS/Source/queue.c ****                 /* Data is available from the queue. */
2665:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2666:Lib/FreeRTOS/Source/queue.c **** 
2667:Lib/FreeRTOS/Source/queue.c ****                 if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2668:Lib/FreeRTOS/Source/queue.c ****                 {
2669:Lib/FreeRTOS/Source/queue.c ****                     pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2670:Lib/FreeRTOS/Source/queue.c ****                 }
2671:Lib/FreeRTOS/Source/queue.c ****                 else
2672:Lib/FreeRTOS/Source/queue.c ****                 {
2673:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2674:Lib/FreeRTOS/Source/queue.c ****                 }
2675:Lib/FreeRTOS/Source/queue.c **** 
2676:Lib/FreeRTOS/Source/queue.c ****                 --( pxQueue->uxMessagesWaiting );
2677:Lib/FreeRTOS/Source/queue.c ****                 ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( un
2678:Lib/FreeRTOS/Source/queue.c **** 
2679:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdPASS;
2680:Lib/FreeRTOS/Source/queue.c **** 
2681:Lib/FreeRTOS/Source/queue.c ****                 /* Were any co-routines waiting for space to become available? */
2682:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2683:Lib/FreeRTOS/Source/queue.c ****                 {
2684:Lib/FreeRTOS/Source/queue.c ****                     /* In this instance the co-routine could be placed directly
2685:Lib/FreeRTOS/Source/queue.c ****                      * into the ready list as we are within a critical section.
2686:Lib/FreeRTOS/Source/queue.c ****                      * Instead the same pending ready list mechanism is used as if
2687:Lib/FreeRTOS/Source/queue.c ****                      * the event were caused from within an interrupt. */
2688:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2689:Lib/FreeRTOS/Source/queue.c ****                     {
2690:Lib/FreeRTOS/Source/queue.c ****                         xReturn = errQUEUE_YIELD;
2691:Lib/FreeRTOS/Source/queue.c ****                     }
2692:Lib/FreeRTOS/Source/queue.c ****                     else
2693:Lib/FreeRTOS/Source/queue.c ****                     {
2694:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2695:Lib/FreeRTOS/Source/queue.c ****                     }
2696:Lib/FreeRTOS/Source/queue.c ****                 }
2697:Lib/FreeRTOS/Source/queue.c ****                 else
2698:Lib/FreeRTOS/Source/queue.c ****                 {
2699:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2700:Lib/FreeRTOS/Source/queue.c ****                 }
2701:Lib/FreeRTOS/Source/queue.c ****             }
2702:Lib/FreeRTOS/Source/queue.c ****             else
2703:Lib/FreeRTOS/Source/queue.c ****             {
2704:Lib/FreeRTOS/Source/queue.c ****                 xReturn = pdFAIL;
2705:Lib/FreeRTOS/Source/queue.c ****             }
2706:Lib/FreeRTOS/Source/queue.c ****         }
2707:Lib/FreeRTOS/Source/queue.c ****         portENABLE_INTERRUPTS();
2708:Lib/FreeRTOS/Source/queue.c **** 
2709:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2710:Lib/FreeRTOS/Source/queue.c ****     }
2711:Lib/FreeRTOS/Source/queue.c **** 
2712:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2713:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2714:Lib/FreeRTOS/Source/queue.c **** 
2715:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
ARM GAS  /tmp/cchrzcnP.s 			page 120


2716:Lib/FreeRTOS/Source/queue.c **** 
2717:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
2718:Lib/FreeRTOS/Source/queue.c ****                                     const void * pvItemToQueue,
2719:Lib/FreeRTOS/Source/queue.c ****                                     BaseType_t xCoRoutinePreviouslyWoken )
2720:Lib/FreeRTOS/Source/queue.c ****     {
2721:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
2722:Lib/FreeRTOS/Source/queue.c **** 
2723:Lib/FreeRTOS/Source/queue.c ****         /* Cannot block within an ISR so if there is no space on the queue then
2724:Lib/FreeRTOS/Source/queue.c ****          * exit without doing anything. */
2725:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2726:Lib/FreeRTOS/Source/queue.c ****         {
2727:Lib/FreeRTOS/Source/queue.c ****             prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2728:Lib/FreeRTOS/Source/queue.c **** 
2729:Lib/FreeRTOS/Source/queue.c ****             /* We only want to wake one co-routine per ISR, so check that a
2730:Lib/FreeRTOS/Source/queue.c ****              * co-routine has not already been woken. */
2731:Lib/FreeRTOS/Source/queue.c ****             if( xCoRoutinePreviouslyWoken == pdFALSE )
2732:Lib/FreeRTOS/Source/queue.c ****             {
2733:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2734:Lib/FreeRTOS/Source/queue.c ****                 {
2735:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pd
2736:Lib/FreeRTOS/Source/queue.c ****                     {
2737:Lib/FreeRTOS/Source/queue.c ****                         return pdTRUE;
2738:Lib/FreeRTOS/Source/queue.c ****                     }
2739:Lib/FreeRTOS/Source/queue.c ****                     else
2740:Lib/FreeRTOS/Source/queue.c ****                     {
2741:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2742:Lib/FreeRTOS/Source/queue.c ****                     }
2743:Lib/FreeRTOS/Source/queue.c ****                 }
2744:Lib/FreeRTOS/Source/queue.c ****                 else
2745:Lib/FreeRTOS/Source/queue.c ****                 {
2746:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2747:Lib/FreeRTOS/Source/queue.c ****                 }
2748:Lib/FreeRTOS/Source/queue.c ****             }
2749:Lib/FreeRTOS/Source/queue.c ****             else
2750:Lib/FreeRTOS/Source/queue.c ****             {
2751:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2752:Lib/FreeRTOS/Source/queue.c ****             }
2753:Lib/FreeRTOS/Source/queue.c ****         }
2754:Lib/FreeRTOS/Source/queue.c ****         else
2755:Lib/FreeRTOS/Source/queue.c ****         {
2756:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2757:Lib/FreeRTOS/Source/queue.c ****         }
2758:Lib/FreeRTOS/Source/queue.c **** 
2759:Lib/FreeRTOS/Source/queue.c ****         return xCoRoutinePreviouslyWoken;
2760:Lib/FreeRTOS/Source/queue.c ****     }
2761:Lib/FreeRTOS/Source/queue.c **** 
2762:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2763:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2764:Lib/FreeRTOS/Source/queue.c **** 
2765:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
2766:Lib/FreeRTOS/Source/queue.c **** 
2767:Lib/FreeRTOS/Source/queue.c ****     BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
2768:Lib/FreeRTOS/Source/queue.c ****                                        void * pvBuffer,
2769:Lib/FreeRTOS/Source/queue.c ****                                        BaseType_t * pxCoRoutineWoken )
2770:Lib/FreeRTOS/Source/queue.c ****     {
2771:Lib/FreeRTOS/Source/queue.c ****         BaseType_t xReturn;
2772:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
ARM GAS  /tmp/cchrzcnP.s 			page 121


2773:Lib/FreeRTOS/Source/queue.c **** 
2774:Lib/FreeRTOS/Source/queue.c ****         /* We cannot block from an ISR, so check there is data available. If
2775:Lib/FreeRTOS/Source/queue.c ****          * not then just leave without doing anything. */
2776:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2777:Lib/FreeRTOS/Source/queue.c ****         {
2778:Lib/FreeRTOS/Source/queue.c ****             /* Copy the data from the queue. */
2779:Lib/FreeRTOS/Source/queue.c ****             pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
2780:Lib/FreeRTOS/Source/queue.c **** 
2781:Lib/FreeRTOS/Source/queue.c ****             if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
2782:Lib/FreeRTOS/Source/queue.c ****             {
2783:Lib/FreeRTOS/Source/queue.c ****                 pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
2784:Lib/FreeRTOS/Source/queue.c ****             }
2785:Lib/FreeRTOS/Source/queue.c ****             else
2786:Lib/FreeRTOS/Source/queue.c ****             {
2787:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2788:Lib/FreeRTOS/Source/queue.c ****             }
2789:Lib/FreeRTOS/Source/queue.c **** 
2790:Lib/FreeRTOS/Source/queue.c ****             --( pxQueue->uxMessagesWaiting );
2791:Lib/FreeRTOS/Source/queue.c ****             ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsign
2792:Lib/FreeRTOS/Source/queue.c **** 
2793:Lib/FreeRTOS/Source/queue.c ****             if( ( *pxCoRoutineWoken ) == pdFALSE )
2794:Lib/FreeRTOS/Source/queue.c ****             {
2795:Lib/FreeRTOS/Source/queue.c ****                 if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2796:Lib/FreeRTOS/Source/queue.c ****                 {
2797:Lib/FreeRTOS/Source/queue.c ****                     if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFAL
2798:Lib/FreeRTOS/Source/queue.c ****                     {
2799:Lib/FreeRTOS/Source/queue.c ****                         *pxCoRoutineWoken = pdTRUE;
2800:Lib/FreeRTOS/Source/queue.c ****                     }
2801:Lib/FreeRTOS/Source/queue.c ****                     else
2802:Lib/FreeRTOS/Source/queue.c ****                     {
2803:Lib/FreeRTOS/Source/queue.c ****                         mtCOVERAGE_TEST_MARKER();
2804:Lib/FreeRTOS/Source/queue.c ****                     }
2805:Lib/FreeRTOS/Source/queue.c ****                 }
2806:Lib/FreeRTOS/Source/queue.c ****                 else
2807:Lib/FreeRTOS/Source/queue.c ****                 {
2808:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2809:Lib/FreeRTOS/Source/queue.c ****                 }
2810:Lib/FreeRTOS/Source/queue.c ****             }
2811:Lib/FreeRTOS/Source/queue.c ****             else
2812:Lib/FreeRTOS/Source/queue.c ****             {
2813:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2814:Lib/FreeRTOS/Source/queue.c ****             }
2815:Lib/FreeRTOS/Source/queue.c **** 
2816:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdPASS;
2817:Lib/FreeRTOS/Source/queue.c ****         }
2818:Lib/FreeRTOS/Source/queue.c ****         else
2819:Lib/FreeRTOS/Source/queue.c ****         {
2820:Lib/FreeRTOS/Source/queue.c ****             xReturn = pdFAIL;
2821:Lib/FreeRTOS/Source/queue.c ****         }
2822:Lib/FreeRTOS/Source/queue.c **** 
2823:Lib/FreeRTOS/Source/queue.c ****         return xReturn;
2824:Lib/FreeRTOS/Source/queue.c ****     }
2825:Lib/FreeRTOS/Source/queue.c **** 
2826:Lib/FreeRTOS/Source/queue.c **** #endif /* configUSE_CO_ROUTINES */
2827:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2828:Lib/FreeRTOS/Source/queue.c **** 
2829:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
ARM GAS  /tmp/cchrzcnP.s 			page 122


2830:Lib/FreeRTOS/Source/queue.c **** 
2831:Lib/FreeRTOS/Source/queue.c ****     void vQueueAddToRegistry( QueueHandle_t xQueue,
2832:Lib/FreeRTOS/Source/queue.c ****                               const char * pcQueueName ) /*lint !e971 Unqualified char types are al
2833:Lib/FreeRTOS/Source/queue.c ****     {
 4129              		.loc 1 2833 5
 4130              		.cfi_startproc
 4131              		@ args = 0, pretend = 0, frame = 16
 4132              		@ frame_needed = 1, uses_anonymous_args = 0
 4133 0000 80B5     		push	{r7, lr}
 4134              		.cfi_def_cfa_offset 8
 4135              		.cfi_offset 7, -8
 4136              		.cfi_offset 14, -4
 4137 0002 84B0     		sub	sp, sp, #16
 4138              		.cfi_def_cfa_offset 24
 4139 0004 00AF     		add	r7, sp, #0
 4140              		.cfi_def_cfa_register 7
 4141 0006 7860     		str	r0, [r7, #4]
 4142 0008 3960     		str	r1, [r7]
2834:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2835:Lib/FreeRTOS/Source/queue.c ****         QueueRegistryItem_t * pxEntryToWrite = NULL;
 4143              		.loc 1 2835 31
 4144 000a 0023     		movs	r3, #0
 4145 000c BB60     		str	r3, [r7, #8]
2836:Lib/FreeRTOS/Source/queue.c **** 
2837:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 4146              		.loc 1 2837 9
 4147 000e 7B68     		ldr	r3, [r7, #4]
 4148 0010 002B     		cmp	r3, #0
 4149 0012 08D1     		bne	.L310
 4150              		.loc 1 2837 9 is_stmt 0 discriminator 1
 4151 0014 FFF7FEFF 		bl	ulSetInterruptMask
 4152 0018 1D4B     		ldr	r3, .L318
 4153 001a 1E4A     		ldr	r2, .L318+4
 4154 001c 40F61531 		movw	r1, #2837
 4155 0020 1D48     		ldr	r0, .L318+8
 4156 0022 FFF7FEFF 		bl	__assert_func
 4157              	.L310:
2838:Lib/FreeRTOS/Source/queue.c **** 
2839:Lib/FreeRTOS/Source/queue.c ****         if( pcQueueName != NULL )
 4158              		.loc 1 2839 11 is_stmt 1
 4159 0026 3B68     		ldr	r3, [r7]
 4160 0028 002B     		cmp	r3, #0
 4161 002a 24D0     		beq	.L311
2840:Lib/FreeRTOS/Source/queue.c ****         {
2841:Lib/FreeRTOS/Source/queue.c ****             /* See if there is an empty space in the registry.  A NULL name denotes
2842:Lib/FreeRTOS/Source/queue.c ****              * a free slot. */
2843:Lib/FreeRTOS/Source/queue.c ****             for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4162              		.loc 1 2843 21
 4163 002c 0023     		movs	r3, #0
 4164 002e FB60     		str	r3, [r7, #12]
 4165              		.loc 1 2843 13
 4166 0030 1EE0     		b	.L312
 4167              	.L315:
2844:Lib/FreeRTOS/Source/queue.c ****             {
2845:Lib/FreeRTOS/Source/queue.c ****                 /* Replace an existing entry if the queue is already in the registry. */
2846:Lib/FreeRTOS/Source/queue.c ****                 if( xQueue == xQueueRegistry[ ux ].xHandle )
 4168              		.loc 1 2846 51
ARM GAS  /tmp/cchrzcnP.s 			page 123


 4169 0032 1A4A     		ldr	r2, .L318+12
 4170 0034 FB68     		ldr	r3, [r7, #12]
 4171 0036 DB00     		lsls	r3, r3, #3
 4172 0038 1344     		add	r3, r3, r2
 4173 003a 5B68     		ldr	r3, [r3, #4]
 4174              		.loc 1 2846 19
 4175 003c 7A68     		ldr	r2, [r7, #4]
 4176 003e 9A42     		cmp	r2, r3
 4177 0040 05D1     		bne	.L313
2847:Lib/FreeRTOS/Source/queue.c ****                 {
2848:Lib/FreeRTOS/Source/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
 4178              		.loc 1 2848 36
 4179 0042 FB68     		ldr	r3, [r7, #12]
 4180 0044 DB00     		lsls	r3, r3, #3
 4181 0046 154A     		ldr	r2, .L318+12
 4182 0048 1344     		add	r3, r3, r2
 4183 004a BB60     		str	r3, [r7, #8]
2849:Lib/FreeRTOS/Source/queue.c ****                     break;
 4184              		.loc 1 2849 21
 4185 004c 13E0     		b	.L311
 4186              	.L313:
2850:Lib/FreeRTOS/Source/queue.c ****                 }
2851:Lib/FreeRTOS/Source/queue.c ****                 /* Otherwise, store in the next empty location */
2852:Lib/FreeRTOS/Source/queue.c ****                 else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL )
 4187              		.loc 1 2852 24
 4188 004e BB68     		ldr	r3, [r7, #8]
 4189 0050 002B     		cmp	r3, #0
 4190 0052 0AD1     		bne	.L314
 4191              		.loc 1 2852 78 discriminator 1
 4192 0054 114A     		ldr	r2, .L318+12
 4193 0056 FB68     		ldr	r3, [r7, #12]
 4194 0058 52F83330 		ldr	r3, [r2, r3, lsl #3]
 4195              		.loc 1 2852 53 discriminator 1
 4196 005c 002B     		cmp	r3, #0
 4197 005e 04D1     		bne	.L314
2853:Lib/FreeRTOS/Source/queue.c ****                 {
2854:Lib/FreeRTOS/Source/queue.c ****                     pxEntryToWrite = &( xQueueRegistry[ ux ] );
 4198              		.loc 1 2854 36
 4199 0060 FB68     		ldr	r3, [r7, #12]
 4200 0062 DB00     		lsls	r3, r3, #3
 4201 0064 0D4A     		ldr	r2, .L318+12
 4202 0066 1344     		add	r3, r3, r2
 4203 0068 BB60     		str	r3, [r7, #8]
 4204              	.L314:
2843:Lib/FreeRTOS/Source/queue.c ****             {
 4205              		.loc 1 2843 93 discriminator 2
 4206 006a FB68     		ldr	r3, [r7, #12]
 4207 006c 0133     		adds	r3, r3, #1
 4208 006e FB60     		str	r3, [r7, #12]
 4209              	.L312:
2843:Lib/FreeRTOS/Source/queue.c ****             {
 4210              		.loc 1 2843 46 discriminator 1
 4211 0070 FB68     		ldr	r3, [r7, #12]
 4212 0072 072B     		cmp	r3, #7
 4213 0074 DDD9     		bls	.L315
 4214              	.L311:
2855:Lib/FreeRTOS/Source/queue.c ****                 }
ARM GAS  /tmp/cchrzcnP.s 			page 124


2856:Lib/FreeRTOS/Source/queue.c ****                 else
2857:Lib/FreeRTOS/Source/queue.c ****                 {
2858:Lib/FreeRTOS/Source/queue.c ****                     mtCOVERAGE_TEST_MARKER();
2859:Lib/FreeRTOS/Source/queue.c ****                 }
2860:Lib/FreeRTOS/Source/queue.c ****             }
2861:Lib/FreeRTOS/Source/queue.c ****         }
2862:Lib/FreeRTOS/Source/queue.c **** 
2863:Lib/FreeRTOS/Source/queue.c ****         if( pxEntryToWrite != NULL )
 4215              		.loc 1 2863 11
 4216 0076 BB68     		ldr	r3, [r7, #8]
 4217 0078 002B     		cmp	r3, #0
 4218 007a 05D0     		beq	.L317
2864:Lib/FreeRTOS/Source/queue.c ****         {
2865:Lib/FreeRTOS/Source/queue.c ****             /* Store the information on this queue. */
2866:Lib/FreeRTOS/Source/queue.c ****             pxEntryToWrite->pcQueueName = pcQueueName;
 4219              		.loc 1 2866 41
 4220 007c BB68     		ldr	r3, [r7, #8]
 4221 007e 3A68     		ldr	r2, [r7]
 4222 0080 1A60     		str	r2, [r3]
2867:Lib/FreeRTOS/Source/queue.c ****             pxEntryToWrite->xHandle = xQueue;
 4223              		.loc 1 2867 37
 4224 0082 BB68     		ldr	r3, [r7, #8]
 4225 0084 7A68     		ldr	r2, [r7, #4]
 4226 0086 5A60     		str	r2, [r3, #4]
 4227              	.L317:
2868:Lib/FreeRTOS/Source/queue.c **** 
2869:Lib/FreeRTOS/Source/queue.c ****             traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2870:Lib/FreeRTOS/Source/queue.c ****         }
2871:Lib/FreeRTOS/Source/queue.c ****     }
 4228              		.loc 1 2871 5
 4229 0088 00BF     		nop
 4230 008a 1037     		adds	r7, r7, #16
 4231              		.cfi_def_cfa_offset 8
 4232 008c BD46     		mov	sp, r7
 4233              		.cfi_def_cfa_register 13
 4234              		@ sp needed
 4235 008e 80BD     		pop	{r7, pc}
 4236              	.L319:
 4237              		.align	2
 4238              	.L318:
 4239 0090 00000000 		.word	.LC0
 4240 0094 00000000 		.word	__func__.2
 4241 0098 04000000 		.word	.LC1
 4242 009c 00000000 		.word	xQueueRegistry
 4243              		.cfi_endproc
 4244              	.LFE36:
 4246              		.section	.text.pcQueueGetName,"ax",%progbits
 4247              		.align	1
 4248              		.global	pcQueueGetName
 4249              		.syntax unified
 4250              		.thumb
 4251              		.thumb_func
 4253              	pcQueueGetName:
 4254              	.LFB37:
2872:Lib/FreeRTOS/Source/queue.c **** 
2873:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2874:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
ARM GAS  /tmp/cchrzcnP.s 			page 125


2875:Lib/FreeRTOS/Source/queue.c **** 
2876:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2877:Lib/FreeRTOS/Source/queue.c **** 
2878:Lib/FreeRTOS/Source/queue.c ****     const char * pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are all
2879:Lib/FreeRTOS/Source/queue.c ****     {
 4255              		.loc 1 2879 5
 4256              		.cfi_startproc
 4257              		@ args = 0, pretend = 0, frame = 16
 4258              		@ frame_needed = 1, uses_anonymous_args = 0
 4259 0000 80B5     		push	{r7, lr}
 4260              		.cfi_def_cfa_offset 8
 4261              		.cfi_offset 7, -8
 4262              		.cfi_offset 14, -4
 4263 0002 84B0     		sub	sp, sp, #16
 4264              		.cfi_def_cfa_offset 24
 4265 0004 00AF     		add	r7, sp, #0
 4266              		.cfi_def_cfa_register 7
 4267 0006 7860     		str	r0, [r7, #4]
2880:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2881:Lib/FreeRTOS/Source/queue.c ****         const char * pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings a
 4268              		.loc 1 2881 22
 4269 0008 0023     		movs	r3, #0
 4270 000a BB60     		str	r3, [r7, #8]
2882:Lib/FreeRTOS/Source/queue.c **** 
2883:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 4271              		.loc 1 2883 9
 4272 000c 7B68     		ldr	r3, [r7, #4]
 4273 000e 002B     		cmp	r3, #0
 4274 0010 08D1     		bne	.L321
 4275              		.loc 1 2883 9 is_stmt 0 discriminator 1
 4276 0012 FFF7FEFF 		bl	ulSetInterruptMask
 4277 0016 114B     		ldr	r3, .L327
 4278 0018 114A     		ldr	r2, .L327+4
 4279 001a 40F64331 		movw	r1, #2883
 4280 001e 1148     		ldr	r0, .L327+8
 4281 0020 FFF7FEFF 		bl	__assert_func
 4282              	.L321:
2884:Lib/FreeRTOS/Source/queue.c **** 
2885:Lib/FreeRTOS/Source/queue.c ****         /* Note there is nothing here to protect against another task adding or
2886:Lib/FreeRTOS/Source/queue.c ****          * removing entries from the registry while it is being searched. */
2887:Lib/FreeRTOS/Source/queue.c **** 
2888:Lib/FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4283              		.loc 1 2888 17 is_stmt 1
 4284 0024 0023     		movs	r3, #0
 4285 0026 FB60     		str	r3, [r7, #12]
 4286              		.loc 1 2888 9
 4287 0028 10E0     		b	.L322
 4288              	.L325:
2889:Lib/FreeRTOS/Source/queue.c ****         {
2890:Lib/FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 4289              		.loc 1 2890 37
 4290 002a 0F4A     		ldr	r2, .L327+12
 4291 002c FB68     		ldr	r3, [r7, #12]
 4292 002e DB00     		lsls	r3, r3, #3
 4293 0030 1344     		add	r3, r3, r2
 4294 0032 5B68     		ldr	r3, [r3, #4]
 4295              		.loc 1 2890 15
ARM GAS  /tmp/cchrzcnP.s 			page 126


 4296 0034 7A68     		ldr	r2, [r7, #4]
 4297 0036 9A42     		cmp	r2, r3
 4298 0038 05D1     		bne	.L323
2891:Lib/FreeRTOS/Source/queue.c ****             {
2892:Lib/FreeRTOS/Source/queue.c ****                 pcReturn = xQueueRegistry[ ux ].pcQueueName;
 4299              		.loc 1 2892 26
 4300 003a 0B4A     		ldr	r2, .L327+12
 4301 003c FB68     		ldr	r3, [r7, #12]
 4302 003e 52F83330 		ldr	r3, [r2, r3, lsl #3]
 4303 0042 BB60     		str	r3, [r7, #8]
2893:Lib/FreeRTOS/Source/queue.c ****                 break;
 4304              		.loc 1 2893 17
 4305 0044 05E0     		b	.L324
 4306              	.L323:
2888:Lib/FreeRTOS/Source/queue.c ****         {
 4307              		.loc 1 2888 89 discriminator 2
 4308 0046 FB68     		ldr	r3, [r7, #12]
 4309 0048 0133     		adds	r3, r3, #1
 4310 004a FB60     		str	r3, [r7, #12]
 4311              	.L322:
2888:Lib/FreeRTOS/Source/queue.c ****         {
 4312              		.loc 1 2888 42 discriminator 1
 4313 004c FB68     		ldr	r3, [r7, #12]
 4314 004e 072B     		cmp	r3, #7
 4315 0050 EBD9     		bls	.L325
 4316              	.L324:
2894:Lib/FreeRTOS/Source/queue.c ****             }
2895:Lib/FreeRTOS/Source/queue.c ****             else
2896:Lib/FreeRTOS/Source/queue.c ****             {
2897:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2898:Lib/FreeRTOS/Source/queue.c ****             }
2899:Lib/FreeRTOS/Source/queue.c ****         }
2900:Lib/FreeRTOS/Source/queue.c **** 
2901:Lib/FreeRTOS/Source/queue.c ****         return pcReturn;
 4317              		.loc 1 2901 16
 4318 0052 BB68     		ldr	r3, [r7, #8]
2902:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
 4319              		.loc 1 2902 5
 4320 0054 1846     		mov	r0, r3
 4321 0056 1037     		adds	r7, r7, #16
 4322              		.cfi_def_cfa_offset 8
 4323 0058 BD46     		mov	sp, r7
 4324              		.cfi_def_cfa_register 13
 4325              		@ sp needed
 4326 005a 80BD     		pop	{r7, pc}
 4327              	.L328:
 4328              		.align	2
 4329              	.L327:
 4330 005c 00000000 		.word	.LC0
 4331 0060 00000000 		.word	__func__.1
 4332 0064 04000000 		.word	.LC1
 4333 0068 00000000 		.word	xQueueRegistry
 4334              		.cfi_endproc
 4335              	.LFE37:
 4337              		.section	.text.vQueueUnregisterQueue,"ax",%progbits
 4338              		.align	1
 4339              		.global	vQueueUnregisterQueue
ARM GAS  /tmp/cchrzcnP.s 			page 127


 4340              		.syntax unified
 4341              		.thumb
 4342              		.thumb_func
 4344              	vQueueUnregisterQueue:
 4345              	.LFB38:
2903:Lib/FreeRTOS/Source/queue.c **** 
2904:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2905:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2906:Lib/FreeRTOS/Source/queue.c **** 
2907:Lib/FreeRTOS/Source/queue.c **** #if ( configQUEUE_REGISTRY_SIZE > 0 )
2908:Lib/FreeRTOS/Source/queue.c **** 
2909:Lib/FreeRTOS/Source/queue.c ****     void vQueueUnregisterQueue( QueueHandle_t xQueue )
2910:Lib/FreeRTOS/Source/queue.c ****     {
 4346              		.loc 1 2910 5
 4347              		.cfi_startproc
 4348              		@ args = 0, pretend = 0, frame = 16
 4349              		@ frame_needed = 1, uses_anonymous_args = 0
 4350 0000 80B5     		push	{r7, lr}
 4351              		.cfi_def_cfa_offset 8
 4352              		.cfi_offset 7, -8
 4353              		.cfi_offset 14, -4
 4354 0002 84B0     		sub	sp, sp, #16
 4355              		.cfi_def_cfa_offset 24
 4356 0004 00AF     		add	r7, sp, #0
 4357              		.cfi_def_cfa_register 7
 4358 0006 7860     		str	r0, [r7, #4]
2911:Lib/FreeRTOS/Source/queue.c ****         UBaseType_t ux;
2912:Lib/FreeRTOS/Source/queue.c **** 
2913:Lib/FreeRTOS/Source/queue.c ****         configASSERT( xQueue );
 4359              		.loc 1 2913 9
 4360 0008 7B68     		ldr	r3, [r7, #4]
 4361 000a 002B     		cmp	r3, #0
 4362 000c 08D1     		bne	.L330
 4363              		.loc 1 2913 9 is_stmt 0 discriminator 1
 4364 000e FFF7FEFF 		bl	ulSetInterruptMask
 4365 0012 144B     		ldr	r3, .L335
 4366 0014 144A     		ldr	r2, .L335+4
 4367 0016 40F66131 		movw	r1, #2913
 4368 001a 1448     		ldr	r0, .L335+8
 4369 001c FFF7FEFF 		bl	__assert_func
 4370              	.L330:
2914:Lib/FreeRTOS/Source/queue.c **** 
2915:Lib/FreeRTOS/Source/queue.c ****         /* See if the handle of the queue being unregistered in actually in the
2916:Lib/FreeRTOS/Source/queue.c ****          * registry. */
2917:Lib/FreeRTOS/Source/queue.c ****         for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 4371              		.loc 1 2917 17 is_stmt 1
 4372 0020 0023     		movs	r3, #0
 4373 0022 FB60     		str	r3, [r7, #12]
 4374              		.loc 1 2917 9
 4375 0024 16E0     		b	.L331
 4376              	.L334:
2918:Lib/FreeRTOS/Source/queue.c ****         {
2919:Lib/FreeRTOS/Source/queue.c ****             if( xQueueRegistry[ ux ].xHandle == xQueue )
 4377              		.loc 1 2919 37
 4378 0026 124A     		ldr	r2, .L335+12
 4379 0028 FB68     		ldr	r3, [r7, #12]
 4380 002a DB00     		lsls	r3, r3, #3
ARM GAS  /tmp/cchrzcnP.s 			page 128


 4381 002c 1344     		add	r3, r3, r2
 4382 002e 5B68     		ldr	r3, [r3, #4]
 4383              		.loc 1 2919 15
 4384 0030 7A68     		ldr	r2, [r7, #4]
 4385 0032 9A42     		cmp	r2, r3
 4386 0034 0BD1     		bne	.L332
2920:Lib/FreeRTOS/Source/queue.c ****             {
2921:Lib/FreeRTOS/Source/queue.c ****                 /* Set the name to NULL to show that this slot if free again. */
2922:Lib/FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].pcQueueName = NULL;
 4387              		.loc 1 2922 50
 4388 0036 0E4A     		ldr	r2, .L335+12
 4389 0038 FB68     		ldr	r3, [r7, #12]
 4390 003a 0021     		movs	r1, #0
 4391 003c 42F83310 		str	r1, [r2, r3, lsl #3]
2923:Lib/FreeRTOS/Source/queue.c **** 
2924:Lib/FreeRTOS/Source/queue.c ****                 /* Set the handle to NULL to ensure the same queue handle cannot
2925:Lib/FreeRTOS/Source/queue.c ****                  * appear in the registry twice if it is added, removed, then
2926:Lib/FreeRTOS/Source/queue.c ****                  * added again. */
2927:Lib/FreeRTOS/Source/queue.c ****                 xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 4392              		.loc 1 2927 46
 4393 0040 0B4A     		ldr	r2, .L335+12
 4394 0042 FB68     		ldr	r3, [r7, #12]
 4395 0044 DB00     		lsls	r3, r3, #3
 4396 0046 1344     		add	r3, r3, r2
 4397 0048 0022     		movs	r2, #0
 4398 004a 5A60     		str	r2, [r3, #4]
2928:Lib/FreeRTOS/Source/queue.c ****                 break;
 4399              		.loc 1 2928 17
 4400 004c 06E0     		b	.L333
 4401              	.L332:
2917:Lib/FreeRTOS/Source/queue.c ****         {
 4402              		.loc 1 2917 89 discriminator 2
 4403 004e FB68     		ldr	r3, [r7, #12]
 4404 0050 0133     		adds	r3, r3, #1
 4405 0052 FB60     		str	r3, [r7, #12]
 4406              	.L331:
2917:Lib/FreeRTOS/Source/queue.c ****         {
 4407              		.loc 1 2917 42 discriminator 1
 4408 0054 FB68     		ldr	r3, [r7, #12]
 4409 0056 072B     		cmp	r3, #7
 4410 0058 E5D9     		bls	.L334
2929:Lib/FreeRTOS/Source/queue.c ****             }
2930:Lib/FreeRTOS/Source/queue.c ****             else
2931:Lib/FreeRTOS/Source/queue.c ****             {
2932:Lib/FreeRTOS/Source/queue.c ****                 mtCOVERAGE_TEST_MARKER();
2933:Lib/FreeRTOS/Source/queue.c ****             }
2934:Lib/FreeRTOS/Source/queue.c ****         }
2935:Lib/FreeRTOS/Source/queue.c ****     } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 4411              		.loc 1 2935 5
 4412 005a 00BF     		nop
 4413              	.L333:
 4414 005c 00BF     		nop
 4415 005e 1037     		adds	r7, r7, #16
 4416              		.cfi_def_cfa_offset 8
 4417 0060 BD46     		mov	sp, r7
 4418              		.cfi_def_cfa_register 13
 4419              		@ sp needed
ARM GAS  /tmp/cchrzcnP.s 			page 129


 4420 0062 80BD     		pop	{r7, pc}
 4421              	.L336:
 4422              		.align	2
 4423              	.L335:
 4424 0064 00000000 		.word	.LC0
 4425 0068 00000000 		.word	__func__.0
 4426 006c 04000000 		.word	.LC1
 4427 0070 00000000 		.word	xQueueRegistry
 4428              		.cfi_endproc
 4429              	.LFE38:
 4431              		.section	.text.vQueueWaitForMessageRestricted,"ax",%progbits
 4432              		.align	1
 4433              		.global	vQueueWaitForMessageRestricted
 4434              		.syntax unified
 4435              		.thumb
 4436              		.thumb_func
 4438              	vQueueWaitForMessageRestricted:
 4439              	.LFB39:
2936:Lib/FreeRTOS/Source/queue.c **** 
2937:Lib/FreeRTOS/Source/queue.c **** #endif /* configQUEUE_REGISTRY_SIZE */
2938:Lib/FreeRTOS/Source/queue.c **** /*-----------------------------------------------------------*/
2939:Lib/FreeRTOS/Source/queue.c **** 
2940:Lib/FreeRTOS/Source/queue.c **** #if ( configUSE_TIMERS == 1 )
2941:Lib/FreeRTOS/Source/queue.c **** 
2942:Lib/FreeRTOS/Source/queue.c ****     void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
2943:Lib/FreeRTOS/Source/queue.c ****                                          TickType_t xTicksToWait,
2944:Lib/FreeRTOS/Source/queue.c ****                                          const BaseType_t xWaitIndefinitely )
2945:Lib/FreeRTOS/Source/queue.c ****     {
 4440              		.loc 1 2945 5
 4441              		.cfi_startproc
 4442              		@ args = 0, pretend = 0, frame = 24
 4443              		@ frame_needed = 1, uses_anonymous_args = 0
 4444 0000 80B5     		push	{r7, lr}
 4445              		.cfi_def_cfa_offset 8
 4446              		.cfi_offset 7, -8
 4447              		.cfi_offset 14, -4
 4448 0002 86B0     		sub	sp, sp, #24
 4449              		.cfi_def_cfa_offset 32
 4450 0004 00AF     		add	r7, sp, #0
 4451              		.cfi_def_cfa_register 7
 4452 0006 F860     		str	r0, [r7, #12]
 4453 0008 B960     		str	r1, [r7, #8]
 4454 000a 7A60     		str	r2, [r7, #4]
2946:Lib/FreeRTOS/Source/queue.c ****         Queue_t * const pxQueue = xQueue;
 4455              		.loc 1 2946 25
 4456 000c FB68     		ldr	r3, [r7, #12]
 4457 000e 7B61     		str	r3, [r7, #20]
2947:Lib/FreeRTOS/Source/queue.c **** 
2948:Lib/FreeRTOS/Source/queue.c ****         /* This function should not be called by application code hence the
2949:Lib/FreeRTOS/Source/queue.c ****          * 'Restricted' in its name.  It is not part of the public API.  It is
2950:Lib/FreeRTOS/Source/queue.c ****          * designed for use by kernel code, and has special calling requirements.
2951:Lib/FreeRTOS/Source/queue.c ****          * It can result in vListInsert() being called on a list that can only
2952:Lib/FreeRTOS/Source/queue.c ****          * possibly ever have one item in it, so the list will be fast, but even
2953:Lib/FreeRTOS/Source/queue.c ****          * so it should be called with the scheduler locked and not from a critical
2954:Lib/FreeRTOS/Source/queue.c ****          * section. */
2955:Lib/FreeRTOS/Source/queue.c **** 
2956:Lib/FreeRTOS/Source/queue.c ****         /* Only do anything if there are no messages in the queue.  This function
ARM GAS  /tmp/cchrzcnP.s 			page 130


2957:Lib/FreeRTOS/Source/queue.c ****          *  will not actually cause the task to block, just place it on a blocked
2958:Lib/FreeRTOS/Source/queue.c ****          *  list.  It will not block until the scheduler is unlocked - at which
2959:Lib/FreeRTOS/Source/queue.c ****          *  time a yield will be performed.  If an item is added to the queue while
2960:Lib/FreeRTOS/Source/queue.c ****          *  the queue is locked, and the calling task blocks on the queue, then the
2961:Lib/FreeRTOS/Source/queue.c ****          *  calling task will be immediately unblocked when the queue is unlocked. */
2962:Lib/FreeRTOS/Source/queue.c ****         prvLockQueue( pxQueue );
 4458              		.loc 1 2962 9
 4459 0010 FFF7FEFF 		bl	vPortEnterCritical
 4460              		.loc 1 2962 9 is_stmt 0 discriminator 1
 4461 0014 7B69     		ldr	r3, [r7, #20]
 4462 0016 93F84430 		ldrb	r3, [r3, #68]
 4463 001a 5BB2     		sxtb	r3, r3
 4464 001c B3F1FF3F 		cmp	r3, #-1
 4465 0020 03D1     		bne	.L338
 4466 0022 7B69     		ldr	r3, [r7, #20]
 4467 0024 0022     		movs	r2, #0
 4468 0026 83F84420 		strb	r2, [r3, #68]
 4469              	.L338:
 4470              		.loc 1 2962 9 discriminator 3
 4471 002a 7B69     		ldr	r3, [r7, #20]
 4472 002c 93F84530 		ldrb	r3, [r3, #69]
 4473 0030 5BB2     		sxtb	r3, r3
 4474 0032 B3F1FF3F 		cmp	r3, #-1
 4475 0036 03D1     		bne	.L339
 4476              		.loc 1 2962 9 discriminator 4
 4477 0038 7B69     		ldr	r3, [r7, #20]
 4478 003a 0022     		movs	r2, #0
 4479 003c 83F84520 		strb	r2, [r3, #69]
 4480              	.L339:
 4481              		.loc 1 2962 9 discriminator 6
 4482 0040 FFF7FEFF 		bl	vPortExitCritical
2963:Lib/FreeRTOS/Source/queue.c **** 
2964:Lib/FreeRTOS/Source/queue.c ****         if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 4483              		.loc 1 2964 20 is_stmt 1
 4484 0044 7B69     		ldr	r3, [r7, #20]
 4485 0046 9B6B     		ldr	r3, [r3, #56]
 4486              		.loc 1 2964 11
 4487 0048 002B     		cmp	r3, #0
 4488 004a 06D1     		bne	.L340
2965:Lib/FreeRTOS/Source/queue.c ****         {
2966:Lib/FreeRTOS/Source/queue.c ****             /* There is nothing in the queue, block for the specified period. */
2967:Lib/FreeRTOS/Source/queue.c ****             vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xW
 4489              		.loc 1 2967 13
 4490 004c 7B69     		ldr	r3, [r7, #20]
 4491 004e 2433     		adds	r3, r3, #36
 4492 0050 7A68     		ldr	r2, [r7, #4]
 4493 0052 B968     		ldr	r1, [r7, #8]
 4494 0054 1846     		mov	r0, r3
 4495 0056 FFF7FEFF 		bl	vTaskPlaceOnEventListRestricted
 4496              	.L340:
2968:Lib/FreeRTOS/Source/queue.c ****         }
2969:Lib/FreeRTOS/Source/queue.c ****         else
2970:Lib/FreeRTOS/Source/queue.c ****         {
2971:Lib/FreeRTOS/Source/queue.c ****             mtCOVERAGE_TEST_MARKER();
2972:Lib/FreeRTOS/Source/queue.c ****         }
2973:Lib/FreeRTOS/Source/queue.c **** 
2974:Lib/FreeRTOS/Source/queue.c ****         prvUnlockQueue( pxQueue );
ARM GAS  /tmp/cchrzcnP.s 			page 131


 4497              		.loc 1 2974 9
 4498 005a 7869     		ldr	r0, [r7, #20]
 4499 005c FFF7FEFF 		bl	prvUnlockQueue
2975:Lib/FreeRTOS/Source/queue.c ****     }
 4500              		.loc 1 2975 5
 4501 0060 00BF     		nop
 4502 0062 1837     		adds	r7, r7, #24
 4503              		.cfi_def_cfa_offset 8
 4504 0064 BD46     		mov	sp, r7
 4505              		.cfi_def_cfa_register 13
 4506              		@ sp needed
 4507 0066 80BD     		pop	{r7, pc}
 4508              		.cfi_endproc
 4509              	.LFE39:
 4511              		.section	.rodata.__func__.24,"a"
 4512              		.align	2
 4515              	__func__.24:
 4516 0000 78517565 		.ascii	"xQueueGenericReset\000"
 4516      75654765 
 4516      6E657269 
 4516      63526573 
 4516      657400
 4517              		.section	.rodata.__func__.23,"a"
 4518              		.align	2
 4521              	__func__.23:
 4522 0000 78517565 		.ascii	"xQueueGenericCreateStatic\000"
 4522      75654765 
 4522      6E657269 
 4522      63437265 
 4522      61746553 
 4523              		.section	.rodata.__func__.22,"a"
 4524              		.align	2
 4527              	__func__.22:
 4528 0000 78517565 		.ascii	"xQueueGenericGetStaticBuffers\000"
 4528      75654765 
 4528      6E657269 
 4528      63476574 
 4528      53746174 
 4529              		.section	.rodata.__func__.21,"a"
 4530              		.align	2
 4533              	__func__.21:
 4534 0000 78517565 		.ascii	"xQueueGetMutexHolder\000"
 4534      75654765 
 4534      744D7574 
 4534      6578486F 
 4534      6C646572 
 4535              		.section	.rodata.__func__.20,"a"
 4536              		.align	2
 4539              	__func__.20:
 4540 0000 78517565 		.ascii	"xQueueGetMutexHolderFromISR\000"
 4540      75654765 
 4540      744D7574 
 4540      6578486F 
 4540      6C646572 
 4541              		.section	.rodata.__func__.19,"a"
 4542              		.align	2
 4545              	__func__.19:
ARM GAS  /tmp/cchrzcnP.s 			page 132


 4546 0000 78517565 		.ascii	"xQueueGiveMutexRecursive\000"
 4546      75654769 
 4546      76654D75 
 4546      74657852 
 4546      65637572 
 4547              		.section	.rodata.__func__.18,"a"
 4548              		.align	2
 4551              	__func__.18:
 4552 0000 78517565 		.ascii	"xQueueTakeMutexRecursive\000"
 4552      75655461 
 4552      6B654D75 
 4552      74657852 
 4552      65637572 
 4553              		.section	.rodata.__func__.17,"a"
 4554              		.align	2
 4557              	__func__.17:
 4558 0000 78517565 		.ascii	"xQueueCreateCountingSemaphoreStatic\000"
 4558      75654372 
 4558      65617465 
 4558      436F756E 
 4558      74696E67 
 4559              		.section	.rodata.__func__.16,"a"
 4560              		.align	2
 4563              	__func__.16:
 4564 0000 78517565 		.ascii	"xQueueGenericSend\000"
 4564      75654765 
 4564      6E657269 
 4564      6353656E 
 4564      6400
 4565              		.section	.rodata.__func__.15,"a"
 4566              		.align	2
 4569              	__func__.15:
 4570 0000 78517565 		.ascii	"xQueueGenericSendFromISR\000"
 4570      75654765 
 4570      6E657269 
 4570      6353656E 
 4570      6446726F 
 4571              		.section	.rodata.__func__.14,"a"
 4572              		.align	2
 4575              	__func__.14:
 4576 0000 78517565 		.ascii	"xQueueGiveFromISR\000"
 4576      75654769 
 4576      76654672 
 4576      6F6D4953 
 4576      5200
 4577              		.section	.rodata.__func__.13,"a"
 4578              		.align	2
 4581              	__func__.13:
 4582 0000 78517565 		.ascii	"xQueueReceive\000"
 4582      75655265 
 4582      63656976 
 4582      6500
 4583              		.section	.rodata.__func__.12,"a"
 4584              		.align	2
 4587              	__func__.12:
 4588 0000 78517565 		.ascii	"xQueueSemaphoreTake\000"
 4588      75655365 
ARM GAS  /tmp/cchrzcnP.s 			page 133


 4588      6D617068 
 4588      6F726554 
 4588      616B6500 
 4589              		.section	.rodata.__func__.11,"a"
 4590              		.align	2
 4593              	__func__.11:
 4594 0000 78517565 		.ascii	"xQueuePeek\000"
 4594      75655065 
 4594      656B00
 4595              		.section	.rodata.__func__.10,"a"
 4596              		.align	2
 4599              	__func__.10:
 4600 0000 78517565 		.ascii	"xQueueReceiveFromISR\000"
 4600      75655265 
 4600      63656976 
 4600      6546726F 
 4600      6D495352 
 4601              		.section	.rodata.__func__.9,"a"
 4602              		.align	2
 4605              	__func__.9:
 4606 0000 78517565 		.ascii	"xQueuePeekFromISR\000"
 4606      75655065 
 4606      656B4672 
 4606      6F6D4953 
 4606      5200
 4607              		.section	.rodata.__func__.8,"a"
 4608              		.align	2
 4611              	__func__.8:
 4612 0000 75785175 		.ascii	"uxQueueMessagesWaiting\000"
 4612      6575654D 
 4612      65737361 
 4612      67657357 
 4612      61697469 
 4613              		.section	.rodata.__func__.7,"a"
 4614              		.align	2
 4617              	__func__.7:
 4618 0000 75785175 		.ascii	"uxQueueSpacesAvailable\000"
 4618      65756553 
 4618      70616365 
 4618      73417661 
 4618      696C6162 
 4619              		.section	.rodata.__func__.6,"a"
 4620              		.align	2
 4623              	__func__.6:
 4624 0000 75785175 		.ascii	"uxQueueMessagesWaitingFromISR\000"
 4624      6575654D 
 4624      65737361 
 4624      67657357 
 4624      61697469 
 4625              		.section	.rodata.__func__.5,"a"
 4626              		.align	2
 4629              	__func__.5:
 4630 0000 76517565 		.ascii	"vQueueDelete\000"
 4630      75654465 
 4630      6C657465 
 4630      00
 4631              		.section	.rodata.__func__.4,"a"
ARM GAS  /tmp/cchrzcnP.s 			page 134


 4632              		.align	2
 4635              	__func__.4:
 4636 0000 78517565 		.ascii	"xQueueIsQueueEmptyFromISR\000"
 4636      75654973 
 4636      51756575 
 4636      65456D70 
 4636      74794672 
 4637              		.section	.rodata.__func__.3,"a"
 4638              		.align	2
 4641              	__func__.3:
 4642 0000 78517565 		.ascii	"xQueueIsQueueFullFromISR\000"
 4642      75654973 
 4642      51756575 
 4642      6546756C 
 4642      6C46726F 
 4643              		.section	.rodata.__func__.2,"a"
 4644              		.align	2
 4647              	__func__.2:
 4648 0000 76517565 		.ascii	"vQueueAddToRegistry\000"
 4648      75654164 
 4648      64546F52 
 4648      65676973 
 4648      74727900 
 4649              		.section	.rodata.__func__.1,"a"
 4650              		.align	2
 4653              	__func__.1:
 4654 0000 70635175 		.ascii	"pcQueueGetName\000"
 4654      65756547 
 4654      65744E61 
 4654      6D6500
 4655              		.section	.rodata.__func__.0,"a"
 4656              		.align	2
 4659              	__func__.0:
 4660 0000 76517565 		.ascii	"vQueueUnregisterQueue\000"
 4660      7565556E 
 4660      72656769 
 4660      73746572 
 4660      51756575 
 4661              		.text
 4662              	.Letext0:
 4663              		.file 2 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4664              		.file 3 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4665              		.file 4 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-t
 4666              		.file 5 "Lib/FreeRTOS/Source/portable/GCC/ARM_CM55_NTZ/non_secure/portmacrocommon.h"
 4667              		.file 6 "Lib/FreeRTOS/Source/include/FreeRTOS.h"
 4668              		.file 7 "Lib/FreeRTOS/Source/include/list.h"
 4669              		.file 8 "Lib/FreeRTOS/Source/include/task.h"
 4670              		.file 9 "Lib/FreeRTOS/Source/include/queue.h"
 4671              		.file 10 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
 4672              		.file 11 "/home/tanjiajun2002/renesas/rzv/e2studio_v2025-01_fsp_v3.1.0/toolchains/gcc_arm/arm-gnu-
ARM GAS  /tmp/cchrzcnP.s 			page 135


DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
     /tmp/cchrzcnP.s:30     .bss.xQueueRegistry:00000000 xQueueRegistry
     /tmp/cchrzcnP.s:27     .bss.xQueueRegistry:00000000 $d
     /tmp/cchrzcnP.s:33     .rodata:00000000 $d
     /tmp/cchrzcnP.s:40     .text.xQueueGenericReset:00000000 $t
     /tmp/cchrzcnP.s:46     .text.xQueueGenericReset:00000000 xQueueGenericReset
     /tmp/cchrzcnP.s:230    .text.xQueueGenericReset:00000108 $d
     /tmp/cchrzcnP.s:4515   .rodata.__func__.24:00000000 __func__.24
     /tmp/cchrzcnP.s:237    .text.xQueueGenericCreateStatic:00000000 $t
     /tmp/cchrzcnP.s:243    .text.xQueueGenericCreateStatic:00000000 xQueueGenericCreateStatic
     /tmp/cchrzcnP.s:460    .text.prvInitialiseNewQueue:00000000 prvInitialiseNewQueue
     /tmp/cchrzcnP.s:360    .text.xQueueGenericCreateStatic:000000a8 $d
     /tmp/cchrzcnP.s:4521   .rodata.__func__.23:00000000 __func__.23
     /tmp/cchrzcnP.s:367    .text.xQueueGenericGetStaticBuffers:00000000 $t
     /tmp/cchrzcnP.s:373    .text.xQueueGenericGetStaticBuffers:00000000 xQueueGenericGetStaticBuffers
     /tmp/cchrzcnP.s:448    .text.xQueueGenericGetStaticBuffers:00000064 $d
     /tmp/cchrzcnP.s:4527   .rodata.__func__.22:00000000 __func__.22
     /tmp/cchrzcnP.s:455    .text.prvInitialiseNewQueue:00000000 $t
     /tmp/cchrzcnP.s:521    .text.prvInitialiseMutex:00000000 $t
     /tmp/cchrzcnP.s:526    .text.prvInitialiseMutex:00000000 prvInitialiseMutex
     /tmp/cchrzcnP.s:1060   .text.xQueueGenericSend:00000000 xQueueGenericSend
     /tmp/cchrzcnP.s:576    .text.xQueueCreateMutexStatic:00000000 $t
     /tmp/cchrzcnP.s:582    .text.xQueueCreateMutexStatic:00000000 xQueueCreateMutexStatic
     /tmp/cchrzcnP.s:631    .text.xQueueGetMutexHolder:00000000 $t
     /tmp/cchrzcnP.s:637    .text.xQueueGetMutexHolder:00000000 xQueueGetMutexHolder
     /tmp/cchrzcnP.s:700    .text.xQueueGetMutexHolder:0000004c $d
     /tmp/cchrzcnP.s:4533   .rodata.__func__.21:00000000 __func__.21
     /tmp/cchrzcnP.s:707    .text.xQueueGetMutexHolderFromISR:00000000 $t
     /tmp/cchrzcnP.s:713    .text.xQueueGetMutexHolderFromISR:00000000 xQueueGetMutexHolderFromISR
     /tmp/cchrzcnP.s:769    .text.xQueueGetMutexHolderFromISR:00000040 $d
     /tmp/cchrzcnP.s:4539   .rodata.__func__.20:00000000 __func__.20
     /tmp/cchrzcnP.s:776    .text.xQueueGiveMutexRecursive:00000000 $t
     /tmp/cchrzcnP.s:782    .text.xQueueGiveMutexRecursive:00000000 xQueueGiveMutexRecursive
     /tmp/cchrzcnP.s:864    .text.xQueueGiveMutexRecursive:00000064 $d
     /tmp/cchrzcnP.s:4545   .rodata.__func__.19:00000000 __func__.19
     /tmp/cchrzcnP.s:871    .text.xQueueTakeMutexRecursive:00000000 $t
     /tmp/cchrzcnP.s:877    .text.xQueueTakeMutexRecursive:00000000 xQueueTakeMutexRecursive
     /tmp/cchrzcnP.s:2077   .text.xQueueSemaphoreTake:00000000 xQueueSemaphoreTake
     /tmp/cchrzcnP.s:960    .text.xQueueTakeMutexRecursive:00000068 $d
     /tmp/cchrzcnP.s:4551   .rodata.__func__.18:00000000 __func__.18
     /tmp/cchrzcnP.s:967    .text.xQueueCreateCountingSemaphoreStatic:00000000 $t
     /tmp/cchrzcnP.s:973    .text.xQueueCreateCountingSemaphoreStatic:00000000 xQueueCreateCountingSemaphoreStatic
     /tmp/cchrzcnP.s:1047   .text.xQueueCreateCountingSemaphoreStatic:00000060 $d
     /tmp/cchrzcnP.s:4557   .rodata.__func__.17:00000000 __func__.17
     /tmp/cchrzcnP.s:1054   .text.xQueueGenericSend:00000000 $t
     /tmp/cchrzcnP.s:3492   .text.prvCopyDataToQueue:00000000 prvCopyDataToQueue
     /tmp/cchrzcnP.s:3996   .text.prvIsQueueFull:00000000 prvIsQueueFull
     /tmp/cchrzcnP.s:3738   .text.prvUnlockQueue:00000000 prvUnlockQueue
     /tmp/cchrzcnP.s:1357   .text.xQueueGenericSend:000001c4 $d
     /tmp/cchrzcnP.s:4563   .rodata.__func__.16:00000000 __func__.16
     /tmp/cchrzcnP.s:1364   .text.xQueueGenericSendFromISR:00000000 $t
     /tmp/cchrzcnP.s:1370   .text.xQueueGenericSendFromISR:00000000 xQueueGenericSendFromISR
     /tmp/cchrzcnP.s:1583   .text.xQueueGenericSendFromISR:00000134 $d
     /tmp/cchrzcnP.s:4569   .rodata.__func__.15:00000000 __func__.15
     /tmp/cchrzcnP.s:1590   .text.xQueueGiveFromISR:00000000 $t
     /tmp/cchrzcnP.s:1596   .text.xQueueGiveFromISR:00000000 xQueueGiveFromISR
ARM GAS  /tmp/cchrzcnP.s 			page 136


     /tmp/cchrzcnP.s:1786   .text.xQueueGiveFromISR:00000118 $d
     /tmp/cchrzcnP.s:4575   .rodata.__func__.14:00000000 __func__.14
     /tmp/cchrzcnP.s:1793   .text.xQueueReceive:00000000 $t
     /tmp/cchrzcnP.s:1799   .text.xQueueReceive:00000000 xQueueReceive
     /tmp/cchrzcnP.s:3662   .text.prvCopyDataFromQueue:00000000 prvCopyDataFromQueue
     /tmp/cchrzcnP.s:3872   .text.prvIsQueueEmpty:00000000 prvIsQueueEmpty
     /tmp/cchrzcnP.s:2064   .text.xQueueReceive:00000198 $d
     /tmp/cchrzcnP.s:4581   .rodata.__func__.13:00000000 __func__.13
     /tmp/cchrzcnP.s:2071   .text.xQueueSemaphoreTake:00000000 $t
     /tmp/cchrzcnP.s:3436   .text.prvGetDisinheritPriorityAfterTimeout:00000000 prvGetDisinheritPriorityAfterTimeout
     /tmp/cchrzcnP.s:2374   .text.xQueueSemaphoreTake:000001d4 $d
     /tmp/cchrzcnP.s:4587   .rodata.__func__.12:00000000 __func__.12
     /tmp/cchrzcnP.s:2381   .text.xQueuePeek:00000000 $t
     /tmp/cchrzcnP.s:2387   .text.xQueuePeek:00000000 xQueuePeek
     /tmp/cchrzcnP.s:2654   .text.xQueuePeek:0000019c $d
     /tmp/cchrzcnP.s:4593   .rodata.__func__.11:00000000 __func__.11
     /tmp/cchrzcnP.s:2661   .text.xQueueReceiveFromISR:00000000 $t
     /tmp/cchrzcnP.s:2667   .text.xQueueReceiveFromISR:00000000 xQueueReceiveFromISR
     /tmp/cchrzcnP.s:2845   .text.xQueueReceiveFromISR:00000104 $d
     /tmp/cchrzcnP.s:4599   .rodata.__func__.10:00000000 __func__.10
     /tmp/cchrzcnP.s:2852   .text.xQueuePeekFromISR:00000000 $t
     /tmp/cchrzcnP.s:2858   .text.xQueuePeekFromISR:00000000 xQueuePeekFromISR
     /tmp/cchrzcnP.s:2980   .text.xQueuePeekFromISR:000000ac $d
     /tmp/cchrzcnP.s:4605   .rodata.__func__.9:00000000 __func__.9
     /tmp/cchrzcnP.s:2987   .text.uxQueueMessagesWaiting:00000000 $t
     /tmp/cchrzcnP.s:2993   .text.uxQueueMessagesWaiting:00000000 uxQueueMessagesWaiting
     /tmp/cchrzcnP.s:3041   .text.uxQueueMessagesWaiting:00000038 $d
     /tmp/cchrzcnP.s:4611   .rodata.__func__.8:00000000 __func__.8
     /tmp/cchrzcnP.s:3048   .text.uxQueueSpacesAvailable:00000000 $t
     /tmp/cchrzcnP.s:3054   .text.uxQueueSpacesAvailable:00000000 uxQueueSpacesAvailable
     /tmp/cchrzcnP.s:3110   .text.uxQueueSpacesAvailable:00000044 $d
     /tmp/cchrzcnP.s:4617   .rodata.__func__.7:00000000 __func__.7
     /tmp/cchrzcnP.s:3117   .text.uxQueueMessagesWaitingFromISR:00000000 $t
     /tmp/cchrzcnP.s:3123   .text.uxQueueMessagesWaitingFromISR:00000000 uxQueueMessagesWaitingFromISR
     /tmp/cchrzcnP.s:3170   .text.uxQueueMessagesWaitingFromISR:00000034 $d
     /tmp/cchrzcnP.s:4623   .rodata.__func__.6:00000000 __func__.6
     /tmp/cchrzcnP.s:3177   .text.vQueueDelete:00000000 $t
     /tmp/cchrzcnP.s:3183   .text.vQueueDelete:00000000 vQueueDelete
     /tmp/cchrzcnP.s:4344   .text.vQueueUnregisterQueue:00000000 vQueueUnregisterQueue
     /tmp/cchrzcnP.s:3227   .text.vQueueDelete:00000034 $d
     /tmp/cchrzcnP.s:4629   .rodata.__func__.5:00000000 __func__.5
     /tmp/cchrzcnP.s:3234   .text.uxQueueGetQueueNumber:00000000 $t
     /tmp/cchrzcnP.s:3240   .text.uxQueueGetQueueNumber:00000000 uxQueueGetQueueNumber
     /tmp/cchrzcnP.s:3273   .text.vQueueSetQueueNumber:00000000 $t
     /tmp/cchrzcnP.s:3279   .text.vQueueSetQueueNumber:00000000 vQueueSetQueueNumber
     /tmp/cchrzcnP.s:3314   .text.ucQueueGetQueueType:00000000 $t
     /tmp/cchrzcnP.s:3320   .text.ucQueueGetQueueType:00000000 ucQueueGetQueueType
     /tmp/cchrzcnP.s:3353   .text.uxQueueGetQueueItemSize:00000000 $t
     /tmp/cchrzcnP.s:3359   .text.uxQueueGetQueueItemSize:00000000 uxQueueGetQueueItemSize
     /tmp/cchrzcnP.s:3392   .text.uxQueueGetQueueLength:00000000 $t
     /tmp/cchrzcnP.s:3398   .text.uxQueueGetQueueLength:00000000 uxQueueGetQueueLength
     /tmp/cchrzcnP.s:3431   .text.prvGetDisinheritPriorityAfterTimeout:00000000 $t
     /tmp/cchrzcnP.s:3487   .text.prvCopyDataToQueue:00000000 $t
     /tmp/cchrzcnP.s:3657   .text.prvCopyDataFromQueue:00000000 $t
     /tmp/cchrzcnP.s:3733   .text.prvUnlockQueue:00000000 $t
     /tmp/cchrzcnP.s:3867   .text.prvIsQueueEmpty:00000000 $t
     /tmp/cchrzcnP.s:3920   .text.xQueueIsQueueEmptyFromISR:00000000 $t
ARM GAS  /tmp/cchrzcnP.s 			page 137


     /tmp/cchrzcnP.s:3926   .text.xQueueIsQueueEmptyFromISR:00000000 xQueueIsQueueEmptyFromISR
     /tmp/cchrzcnP.s:3984   .text.xQueueIsQueueEmptyFromISR:00000040 $d
     /tmp/cchrzcnP.s:4635   .rodata.__func__.4:00000000 __func__.4
     /tmp/cchrzcnP.s:3991   .text.prvIsQueueFull:00000000 $t
     /tmp/cchrzcnP.s:4047   .text.xQueueIsQueueFullFromISR:00000000 $t
     /tmp/cchrzcnP.s:4053   .text.xQueueIsQueueFullFromISR:00000000 xQueueIsQueueFullFromISR
     /tmp/cchrzcnP.s:4114   .text.xQueueIsQueueFullFromISR:00000044 $d
     /tmp/cchrzcnP.s:4641   .rodata.__func__.3:00000000 __func__.3
     /tmp/cchrzcnP.s:4121   .text.vQueueAddToRegistry:00000000 $t
     /tmp/cchrzcnP.s:4127   .text.vQueueAddToRegistry:00000000 vQueueAddToRegistry
     /tmp/cchrzcnP.s:4239   .text.vQueueAddToRegistry:00000090 $d
     /tmp/cchrzcnP.s:4647   .rodata.__func__.2:00000000 __func__.2
     /tmp/cchrzcnP.s:4247   .text.pcQueueGetName:00000000 $t
     /tmp/cchrzcnP.s:4253   .text.pcQueueGetName:00000000 pcQueueGetName
     /tmp/cchrzcnP.s:4330   .text.pcQueueGetName:0000005c $d
     /tmp/cchrzcnP.s:4653   .rodata.__func__.1:00000000 __func__.1
     /tmp/cchrzcnP.s:4338   .text.vQueueUnregisterQueue:00000000 $t
     /tmp/cchrzcnP.s:4424   .text.vQueueUnregisterQueue:00000064 $d
     /tmp/cchrzcnP.s:4659   .rodata.__func__.0:00000000 __func__.0
     /tmp/cchrzcnP.s:4432   .text.vQueueWaitForMessageRestricted:00000000 $t
     /tmp/cchrzcnP.s:4438   .text.vQueueWaitForMessageRestricted:00000000 vQueueWaitForMessageRestricted
     /tmp/cchrzcnP.s:4512   .rodata.__func__.24:00000000 $d
     /tmp/cchrzcnP.s:4518   .rodata.__func__.23:00000000 $d
     /tmp/cchrzcnP.s:4524   .rodata.__func__.22:00000000 $d
     /tmp/cchrzcnP.s:4530   .rodata.__func__.21:00000000 $d
     /tmp/cchrzcnP.s:4536   .rodata.__func__.20:00000000 $d
     /tmp/cchrzcnP.s:4542   .rodata.__func__.19:00000000 $d
     /tmp/cchrzcnP.s:4548   .rodata.__func__.18:00000000 $d
     /tmp/cchrzcnP.s:4554   .rodata.__func__.17:00000000 $d
     /tmp/cchrzcnP.s:4560   .rodata.__func__.16:00000000 $d
     /tmp/cchrzcnP.s:4566   .rodata.__func__.15:00000000 $d
     /tmp/cchrzcnP.s:4572   .rodata.__func__.14:00000000 $d
     /tmp/cchrzcnP.s:4578   .rodata.__func__.13:00000000 $d
     /tmp/cchrzcnP.s:4584   .rodata.__func__.12:00000000 $d
     /tmp/cchrzcnP.s:4590   .rodata.__func__.11:00000000 $d
     /tmp/cchrzcnP.s:4596   .rodata.__func__.10:00000000 $d
     /tmp/cchrzcnP.s:4602   .rodata.__func__.9:00000000 $d
     /tmp/cchrzcnP.s:4608   .rodata.__func__.8:00000000 $d
     /tmp/cchrzcnP.s:4614   .rodata.__func__.7:00000000 $d
     /tmp/cchrzcnP.s:4620   .rodata.__func__.6:00000000 $d
     /tmp/cchrzcnP.s:4626   .rodata.__func__.5:00000000 $d
     /tmp/cchrzcnP.s:4632   .rodata.__func__.4:00000000 $d
     /tmp/cchrzcnP.s:4638   .rodata.__func__.3:00000000 $d
     /tmp/cchrzcnP.s:4644   .rodata.__func__.2:00000000 $d
     /tmp/cchrzcnP.s:4650   .rodata.__func__.1:00000000 $d
     /tmp/cchrzcnP.s:4656   .rodata.__func__.0:00000000 $d
                           .group:00000000 wm4.0.2a10773746a5c5ebb5552f50e466f80b
                           .group:00000000 wm4.ieeefp.h.77.bd5feb87d9990dd328793ced294f6a87
                           .group:00000000 wm4._newlib_version.h.4.411db44ea2338a62eca2f0777f81481b
                           .group:00000000 wm4.newlib.h.27.4b972ceed5d01f491020c20f1e546cab
                           .group:00000000 wm4.features.h.22.9dfb1293666eb4caf24cccb81c86a551
                           .group:00000000 wm4.config.h.224.10ee1ad185d877c6e334e6581faab44d
                           .group:00000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.stddef.h.185.882514a1a6169ceba9142f401cbe27c6
                           .group:00000000 wm4.stddef.h.39.794fa375de48dda278c4aebb5c74aa5b
                           .group:00000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
ARM GAS  /tmp/cchrzcnP.s 			page 138


                           .group:00000000 wm4.cdefs.h.49.70fc7af612f78ddcace70fdd90b5623b
                           .group:00000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:00000000 wm4.stddef.h.158.6f8e08a347b1cff664332fa350bfceb3
                           .group:00000000 wm4._types.h.127.3bdfe3ff8ea2d0985b03d9cbe93480e3
                           .group:00000000 wm4.reent.h.18.25503cdc8b7e55dd0d6ea7b3e5af7a03
                           .group:00000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:00000000 wm4.reent.h.78.6b87466b04591b1f1cb88c14fdf2ba9e
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:00000000 wm4.string.h.8.c4b8571ce60dff2817f43fec8b86aecd
                           .group:00000000 wm4.stddef.h.158.eec8bf00b5213f43d095cb984c5f22e3
                           .group:00000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:00000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:00000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:00000000 wm4.FreeRTOS.h.59.647b1b0da38e4e98108aae13c8abe9ee
                           .group:00000000 wm4.assert.h.11.db24e541f16414db224bf986d21017e2
                           .group:00000000 wm4.FreeRTOSConfig.h.59.2629c72cff9e6dbe880a2dc225eae516
                           .group:00000000 wm4.FreeRTOS.h.80.7742fabaf5accf3762dc12f7f259a8a0
                           .group:00000000 wm4.projdefs.h.30.55a824156f299c075c33148a9fdadb99
                           .group:00000000 wm4.portmacro.h.30.cbb4b2da41f551c2a9904f0d03a1ce3e
                           .group:00000000 wm4.portmacrocommon.h.30.d5cb67896ab50a95311be7e023da5c4f
                           .group:00000000 wm4.portmacro.h.68.4051ecf710d074fb55b16d91dfebeeaa
                           .group:00000000 wm4.portable.h.61.d557c57974d490f056246a26cdcddd6c
                           .group:00000000 wm4.mpu_wrappers.h.30.ccc5f1a6903f941a88c268f5f62af3fe
                           .group:00000000 wm4.portable.h.189.522b8bd52a171d3fd1432ef06d0caa63
                           .group:00000000 wm4.FreeRTOS.h.102.fb871f3e464d99c5a57b3115545a02ad
                           .group:00000000 wm4.list.h.59.bce6419520cd4f5f98779a1530bf2118
                           .group:00000000 wm4.task.h.56.84290139c73b47f5b9aac361361a2a31
                           .group:00000000 wm4.queue.h.68.219f47fba8b59640449b84d04c5bd6d8

UNDEFINED SYMBOLS
ulSetInterruptMask
__assert_func
vPortEnterCritical
xTaskRemoveFromEventList
vPortYield
vListInitialise
vPortExitCritical
xTaskGetCurrentTaskHandle
xTaskGetSchedulerState
vTaskInternalSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vPortValidateInterruptPriority
uxTaskGetNumberOfTasks
vClearInterruptMask
pvTaskIncrementMutexHeldCount
xTaskPriorityInherit
vTaskPriorityDisinheritAfterTimeout
xTaskPriorityDisinherit
memcpy
vTaskMissedYield
vTaskPlaceOnEventListRestricted
